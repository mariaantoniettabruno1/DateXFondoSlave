var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
(function(Vue) {
  "use strict";
  function _interopNamespace(e) {
    if (e && e.__esModule)
      return e;
    var n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
    if (e) {
      Object.keys(e).forEach(function(k) {
        if (k !== "default") {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: function() {
              return e[k];
            }
          });
        }
      });
    }
    n["default"] = e;
    return Object.freeze(n);
  }
  var Vue__namespace = /* @__PURE__ */ _interopNamespace(Vue);
  var index$1 = "";
  var isVue2 = false;
  /*!
    * pinia v2.0.23
    * (c) 2022 Eduardo San Martin Morote
    * @license MIT
    */
  let activePinia;
  const setActivePinia = (pinia) => activePinia = pinia;
  const piniaSymbol = Symbol();
  function isPlainObject$2(o) {
    return o && typeof o === "object" && Object.prototype.toString.call(o) === "[object Object]" && typeof o.toJSON !== "function";
  }
  var MutationType;
  (function(MutationType2) {
    MutationType2["direct"] = "direct";
    MutationType2["patchObject"] = "patch object";
    MutationType2["patchFunction"] = "patch function";
  })(MutationType || (MutationType = {}));
  function createPinia() {
    const scope = Vue.effectScope(true);
    const state = scope.run(() => Vue.ref({}));
    let _p = [];
    let toBeInstalled = [];
    const pinia = Vue.markRaw({
      install(app) {
        setActivePinia(pinia);
        {
          pinia._a = app;
          app.provide(piniaSymbol, pinia);
          app.config.globalProperties.$pinia = pinia;
          toBeInstalled.forEach((plugin) => _p.push(plugin));
          toBeInstalled = [];
        }
      },
      use(plugin) {
        if (!this._a && !isVue2) {
          toBeInstalled.push(plugin);
        } else {
          _p.push(plugin);
        }
        return this;
      },
      _p,
      _a: null,
      _e: scope,
      _s: /* @__PURE__ */ new Map(),
      state
    });
    return pinia;
  }
  const noop$1 = () => {
  };
  function addSubscription(subscriptions, callback, detached, onCleanup = noop$1) {
    subscriptions.push(callback);
    const removeSubscription = () => {
      const idx = subscriptions.indexOf(callback);
      if (idx > -1) {
        subscriptions.splice(idx, 1);
        onCleanup();
      }
    };
    if (!detached && Vue.getCurrentInstance()) {
      Vue.onUnmounted(removeSubscription);
    }
    return removeSubscription;
  }
  function triggerSubscriptions(subscriptions, ...args) {
    subscriptions.slice().forEach((callback) => {
      callback(...args);
    });
  }
  function mergeReactiveObjects(target, patchToApply) {
    if (target instanceof Map && patchToApply instanceof Map) {
      patchToApply.forEach((value, key) => target.set(key, value));
    }
    if (target instanceof Set && patchToApply instanceof Set) {
      patchToApply.forEach(target.add, target);
    }
    for (const key in patchToApply) {
      if (!patchToApply.hasOwnProperty(key))
        continue;
      const subPatch = patchToApply[key];
      const targetValue = target[key];
      if (isPlainObject$2(targetValue) && isPlainObject$2(subPatch) && target.hasOwnProperty(key) && !Vue.isRef(subPatch) && !Vue.isReactive(subPatch)) {
        target[key] = mergeReactiveObjects(targetValue, subPatch);
      } else {
        target[key] = subPatch;
      }
    }
    return target;
  }
  const skipHydrateSymbol = Symbol();
  function shouldHydrate(obj) {
    return !isPlainObject$2(obj) || !obj.hasOwnProperty(skipHydrateSymbol);
  }
  const { assign } = Object;
  function isComputed(o) {
    return !!(Vue.isRef(o) && o.effect);
  }
  function createOptionsStore(id, options2, pinia, hot) {
    const { state, actions, getters } = options2;
    const initialState = pinia.state.value[id];
    let store;
    function setup() {
      if (!initialState && true) {
        {
          pinia.state.value[id] = state ? state() : {};
        }
      }
      const localState = Vue.toRefs(pinia.state.value[id]);
      return assign(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {
        computedGetters[name] = Vue.markRaw(Vue.computed(() => {
          setActivePinia(pinia);
          const store2 = pinia._s.get(id);
          return getters[name].call(store2, store2);
        }));
        return computedGetters;
      }, {}));
    }
    store = createSetupStore(id, setup, options2, pinia, hot, true);
    store.$reset = function $reset() {
      const newState = state ? state() : {};
      this.$patch(($state) => {
        assign($state, newState);
      });
    };
    return store;
  }
  function createSetupStore($id, setup, options2 = {}, pinia, hot, isOptionsStore) {
    let scope;
    const optionsForPlugin = assign({ actions: {} }, options2);
    const $subscribeOptions = {
      deep: true
    };
    let isListening;
    let isSyncListening;
    let subscriptions = Vue.markRaw([]);
    let actionSubscriptions = Vue.markRaw([]);
    let debuggerEvents;
    const initialState = pinia.state.value[$id];
    if (!isOptionsStore && !initialState && true) {
      {
        pinia.state.value[$id] = {};
      }
    }
    Vue.ref({});
    let activeListener;
    function $patch(partialStateOrMutator) {
      let subscriptionMutation;
      isListening = isSyncListening = false;
      if (typeof partialStateOrMutator === "function") {
        partialStateOrMutator(pinia.state.value[$id]);
        subscriptionMutation = {
          type: MutationType.patchFunction,
          storeId: $id,
          events: debuggerEvents
        };
      } else {
        mergeReactiveObjects(pinia.state.value[$id], partialStateOrMutator);
        subscriptionMutation = {
          type: MutationType.patchObject,
          payload: partialStateOrMutator,
          storeId: $id,
          events: debuggerEvents
        };
      }
      const myListenerId = activeListener = Symbol();
      Vue.nextTick().then(() => {
        if (activeListener === myListenerId) {
          isListening = true;
        }
      });
      isSyncListening = true;
      triggerSubscriptions(subscriptions, subscriptionMutation, pinia.state.value[$id]);
    }
    const $reset = noop$1;
    function $dispose() {
      scope.stop();
      subscriptions = [];
      actionSubscriptions = [];
      pinia._s.delete($id);
    }
    function wrapAction(name, action) {
      return function() {
        setActivePinia(pinia);
        const args = Array.from(arguments);
        const afterCallbackList = [];
        const onErrorCallbackList = [];
        function after(callback) {
          afterCallbackList.push(callback);
        }
        function onError(callback) {
          onErrorCallbackList.push(callback);
        }
        triggerSubscriptions(actionSubscriptions, {
          args,
          name,
          store,
          after,
          onError
        });
        let ret;
        try {
          ret = action.apply(this && this.$id === $id ? this : store, args);
        } catch (error) {
          triggerSubscriptions(onErrorCallbackList, error);
          throw error;
        }
        if (ret instanceof Promise) {
          return ret.then((value) => {
            triggerSubscriptions(afterCallbackList, value);
            return value;
          }).catch((error) => {
            triggerSubscriptions(onErrorCallbackList, error);
            return Promise.reject(error);
          });
        }
        triggerSubscriptions(afterCallbackList, ret);
        return ret;
      };
    }
    const partialStore = {
      _p: pinia,
      $id,
      $onAction: addSubscription.bind(null, actionSubscriptions),
      $patch,
      $reset,
      $subscribe(callback, options3 = {}) {
        const removeSubscription = addSubscription(subscriptions, callback, options3.detached, () => stopWatcher());
        const stopWatcher = scope.run(() => Vue.watch(() => pinia.state.value[$id], (state) => {
          if (options3.flush === "sync" ? isSyncListening : isListening) {
            callback({
              storeId: $id,
              type: MutationType.direct,
              events: debuggerEvents
            }, state);
          }
        }, assign({}, $subscribeOptions, options3)));
        return removeSubscription;
      },
      $dispose
    };
    const store = Vue.reactive(partialStore);
    pinia._s.set($id, store);
    const setupStore = pinia._e.run(() => {
      scope = Vue.effectScope();
      return scope.run(() => setup());
    });
    for (const key in setupStore) {
      const prop = setupStore[key];
      if (Vue.isRef(prop) && !isComputed(prop) || Vue.isReactive(prop)) {
        if (!isOptionsStore) {
          if (initialState && shouldHydrate(prop)) {
            if (Vue.isRef(prop)) {
              prop.value = initialState[key];
            } else {
              mergeReactiveObjects(prop, initialState[key]);
            }
          }
          {
            pinia.state.value[$id][key] = prop;
          }
        }
      } else if (typeof prop === "function") {
        const actionValue = wrapAction(key, prop);
        {
          setupStore[key] = actionValue;
        }
        optionsForPlugin.actions[key] = prop;
      } else
        ;
    }
    {
      assign(store, setupStore);
      assign(Vue.toRaw(store), setupStore);
    }
    Object.defineProperty(store, "$state", {
      get: () => pinia.state.value[$id],
      set: (state) => {
        $patch(($state) => {
          assign($state, state);
        });
      }
    });
    pinia._p.forEach((extender) => {
      {
        assign(store, scope.run(() => extender({
          store,
          app: pinia._a,
          pinia,
          options: optionsForPlugin
        })));
      }
    });
    if (initialState && isOptionsStore && options2.hydrate) {
      options2.hydrate(store.$state, initialState);
    }
    isListening = true;
    isSyncListening = true;
    return store;
  }
  function defineStore(idOrOptions, setup, setupOptions) {
    let id;
    let options2;
    const isSetupStore = typeof setup === "function";
    if (typeof idOrOptions === "string") {
      id = idOrOptions;
      options2 = isSetupStore ? setupOptions : setup;
    } else {
      options2 = idOrOptions;
      id = idOrOptions.id;
    }
    function useStore(pinia, hot) {
      const currentInstance = Vue.getCurrentInstance();
      pinia = pinia || currentInstance && Vue.inject(piniaSymbol);
      if (pinia)
        setActivePinia(pinia);
      pinia = activePinia;
      if (!pinia._s.has(id)) {
        if (isSetupStore) {
          createSetupStore(id, setup, options2, pinia);
        } else {
          createOptionsStore(id, options2, pinia);
        }
      }
      const store = pinia._s.get(id);
      return store;
    }
    useStore.$id = id;
    return useStore;
  }
  function storeToRefs(store) {
    {
      store = Vue.toRaw(store);
      const refs = {};
      for (const key in store) {
        const value = store[key];
        if (Vue.isRef(value) || Vue.isReactive(value)) {
          refs[key] = Vue.toRef(store, key);
        }
      }
      return refs;
    }
  }
  var Label_vue_vue_type_style_index_0_lang$1 = "";
  var _export_sfc = (sfc, props) => {
    const target = sfc.__vccOpts || sfc;
    for (const [key, val] of props) {
      target[key] = val;
    }
    return target;
  };
  const _sfc_main$37 = {
    name: "ZionLabel",
    props: ["text", "type"]
  };
  function _sfc_render$1b(_ctx, _cache, $props, $setup, $data, $options) {
    return Vue.openBlock(), Vue.createElementBlock("span", {
      class: Vue.normalizeClass(["znpb-label", { [`znpb-label--${$props.type}`]: $props.type }])
    }, Vue.toDisplayString($props.text), 3);
  }
  var ZionLabel = /* @__PURE__ */ _export_sfc(_sfc_main$37, [["render", _sfc_render$1b]]);
  var AccordionMenu_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$36 = {
    name: "LayoutMenu",
    components: {
      ZionLabel
    },
    inject: {
      parentAccordion: {
        default: null
      },
      showChanges: {
        default: true
      }
    },
    props: {
      child_options: {
        type: Object,
        required: false
      },
      title: {
        type: String,
        required: true
      },
      modelValue: {
        required: false
      },
      homeButtonText: {
        type: String
      },
      add_to_parent_breadcrumbs: {
        type: Boolean,
        required: false,
        default: false
      },
      label: {
        type: Object,
        required: false
      }
    },
    setup(props, { slots }) {
      const hasHeaderSlot = Vue.computed(() => !!slots.header);
      const hasTitleSlot = Vue.computed(() => !!slots.title);
      const InputWrapper = Vue.inject("inputWrapper");
      const hasChanges = Vue.computed(() => {
        return InputWrapper.hasChanges.value;
      });
      return {
        hasHeaderSlot,
        hasTitleSlot,
        hasChanges
      };
    },
    data() {
      return {
        showBreadcrumbs: this.parentAccordion === null,
        expanded: false
      };
    },
    computed: {
      valueModel() {
        return this.modelValue || {};
      },
      optionsValue: {
        get() {
          return this.modelValue || {};
        },
        set(newValue) {
          this.$emit("update:modelValue", newValue);
        }
      }
    },
    mounted() {
      this.$el.parentNode.classList.add("znpb-option-layout__menu-container");
    },
    beforeUnmount() {
      if (this.breadCrumbConfig) {
        this.parentAccordion.removeBreadcrumb(this.breadCrumbConfig);
      }
    },
    methods: {
      onAccordionExpanded() {
        if (this.parentAccordion !== null) {
          this.breadCrumbConfig = {
            title: this.title,
            previousCallback: this.$refs.accordion.closeAccordion
          };
          this.parentAccordion.addBreadcrumb(this.breadCrumbConfig);
        }
        this.expanded = true;
      },
      onAccordionCollapsed() {
        if (this.parentAccordion !== null && this.parentAccordion) {
          this.parentAccordion.removeBreadcrumb(this.breadCrumbConfig);
        }
        this.expanded = false;
      }
    }
  };
  function _sfc_render$1a(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Icon = Vue.resolveComponent("Icon");
    const _component_ZionLabel = Vue.resolveComponent("ZionLabel");
    const _component_ChangesBullet = Vue.resolveComponent("ChangesBullet");
    const _component_OptionsForm = Vue.resolveComponent("OptionsForm");
    const _component_HorizontalAccordion = Vue.resolveComponent("HorizontalAccordion");
    return Vue.openBlock(), Vue.createBlock(_component_HorizontalAccordion, {
      ref: "accordion",
      class: "znpb-option-layout__menu",
      title: $props.title,
      icon: _ctx.$attrs.icon,
      "show-back-button": true,
      "show-home-button": true,
      "home-button-text": $props.homeButtonText || "Options",
      "has-breadcrumbs": $data.showBreadcrumbs,
      onExpand: $options.onAccordionExpanded,
      onCollapse: $options.onAccordionCollapsed
    }, Vue.createSlots({
      actions: Vue.withCtx(() => [
        Vue.renderSlot(_ctx.$slots, "actions")
      ]),
      default: Vue.withCtx(() => [
        $data.expanded ? (Vue.openBlock(), Vue.createBlock(_component_OptionsForm, {
          key: 0,
          modelValue: $options.optionsValue,
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $options.optionsValue = $event),
          class: "znpb-option-layout__menu-options-form",
          schema: $props.child_options,
          "show-changes": $options.showChanges
        }, null, 8, ["modelValue", "schema", "show-changes"])) : Vue.createCommentVNode("", true)
      ]),
      _: 2
    }, [
      $setup.hasHeaderSlot ? {
        name: "header",
        fn: Vue.withCtx(() => [
          Vue.renderSlot(_ctx.$slots, "header")
        ]),
        key: "0"
      } : void 0,
      $setup.hasTitleSlot ? {
        name: "title",
        fn: Vue.withCtx(() => [
          Vue.renderSlot(_ctx.$slots, "title")
        ]),
        key: "1"
      } : {
        name: "title",
        fn: Vue.withCtx(() => [
          _ctx.$attrs.icon ? (Vue.openBlock(), Vue.createBlock(_component_Icon, {
            key: 0,
            icon: _ctx.$attrs.icon
          }, null, 8, ["icon"])) : Vue.createCommentVNode("", true),
          Vue.createElementVNode("span", { innerHTML: $props.title }, null, 8, ["innerHTML"]),
          $props.label ? (Vue.openBlock(), Vue.createBlock(_component_ZionLabel, {
            key: 1,
            text: $props.label.text,
            type: $props.label.type
          }, null, 8, ["text", "type"])) : Vue.createCommentVNode("", true),
          $options.showChanges && $setup.hasChanges ? (Vue.openBlock(), Vue.createBlock(_component_ChangesBullet, {
            key: 2,
            onRemoveStyles: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", null))
          })) : Vue.createCommentVNode("", true)
        ]),
        key: "2"
      }
    ]), 1032, ["title", "icon", "home-button-text", "has-breadcrumbs", "onExpand", "onCollapse"]);
  }
  var AccordionMenu$1 = /* @__PURE__ */ _export_sfc(_sfc_main$36, [["render", _sfc_render$1a]]);
  var AccordionMenu$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    "default": AccordionMenu$1
  }, Symbol.toStringTag, { value: "Module" }));
  var AccordionMenu = {
    id: "accordion_menu",
    component: AccordionMenu$1,
    config: {
      barebone: true
    }
  };
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function commonjsRequire(path) {
    throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
  }
  var axios$2 = { exports: {} };
  var bind$2 = function bind2(fn, thisArg) {
    return function wrap() {
      var args = new Array(arguments.length);
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }
      return fn.apply(thisArg, args);
    };
  };
  var bind$1 = bind$2;
  var toString$1 = Object.prototype.toString;
  var kindOf = function(cache2) {
    return function(thing) {
      var str = toString$1.call(thing);
      return cache2[str] || (cache2[str] = str.slice(8, -1).toLowerCase());
    };
  }(/* @__PURE__ */ Object.create(null));
  function kindOfTest(type) {
    type = type.toLowerCase();
    return function isKindOf(thing) {
      return kindOf(thing) === type;
    };
  }
  function isArray$2(val) {
    return Array.isArray(val);
  }
  function isUndefined(val) {
    return typeof val === "undefined";
  }
  function isBuffer$2(val) {
    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
  }
  var isArrayBuffer = kindOfTest("ArrayBuffer");
  function isArrayBufferView(val) {
    var result;
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
      result = ArrayBuffer.isView(val);
    } else {
      result = val && val.buffer && isArrayBuffer(val.buffer);
    }
    return result;
  }
  function isString(val) {
    return typeof val === "string";
  }
  function isNumber(val) {
    return typeof val === "number";
  }
  function isObject$1(val) {
    return val !== null && typeof val === "object";
  }
  function isPlainObject$1(val) {
    if (kindOf(val) !== "object") {
      return false;
    }
    var prototype2 = Object.getPrototypeOf(val);
    return prototype2 === null || prototype2 === Object.prototype;
  }
  var isDate = kindOfTest("Date");
  var isFile = kindOfTest("File");
  var isBlob = kindOfTest("Blob");
  var isFileList = kindOfTest("FileList");
  function isFunction$1(val) {
    return toString$1.call(val) === "[object Function]";
  }
  function isStream(val) {
    return isObject$1(val) && isFunction$1(val.pipe);
  }
  function isFormData(thing) {
    var pattern = "[object FormData]";
    return thing && (typeof FormData === "function" && thing instanceof FormData || toString$1.call(thing) === pattern || isFunction$1(thing.toString) && thing.toString() === pattern);
  }
  var isURLSearchParams = kindOfTest("URLSearchParams");
  function trim(str) {
    return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
  }
  function isStandardBrowserEnv() {
    if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
      return false;
    }
    return typeof window !== "undefined" && typeof document !== "undefined";
  }
  function forEach$1(obj, fn) {
    if (obj === null || typeof obj === "undefined") {
      return;
    }
    if (typeof obj !== "object") {
      obj = [obj];
    }
    if (isArray$2(obj)) {
      for (var i = 0, l = obj.length; i < l; i++) {
        fn.call(null, obj[i], i, obj);
      }
    } else {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          fn.call(null, obj[key], key, obj);
        }
      }
    }
  }
  function merge$2() {
    var result = {};
    function assignValue2(val, key) {
      if (isPlainObject$1(result[key]) && isPlainObject$1(val)) {
        result[key] = merge$2(result[key], val);
      } else if (isPlainObject$1(val)) {
        result[key] = merge$2({}, val);
      } else if (isArray$2(val)) {
        result[key] = val.slice();
      } else {
        result[key] = val;
      }
    }
    for (var i = 0, l = arguments.length; i < l; i++) {
      forEach$1(arguments[i], assignValue2);
    }
    return result;
  }
  function extend(a, b, thisArg) {
    forEach$1(b, function assignValue2(val, key) {
      if (thisArg && typeof val === "function") {
        a[key] = bind$1(val, thisArg);
      } else {
        a[key] = val;
      }
    });
    return a;
  }
  function stripBOM(content) {
    if (content.charCodeAt(0) === 65279) {
      content = content.slice(1);
    }
    return content;
  }
  function inherits$1(constructor, superConstructor, props, descriptors2) {
    constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
    constructor.prototype.constructor = constructor;
    props && Object.assign(constructor.prototype, props);
  }
  function toFlatObject(sourceObj, destObj, filter2) {
    var props;
    var i;
    var prop;
    var merged = {};
    destObj = destObj || {};
    do {
      props = Object.getOwnPropertyNames(sourceObj);
      i = props.length;
      while (i-- > 0) {
        prop = props[i];
        if (!merged[prop]) {
          destObj[prop] = sourceObj[prop];
          merged[prop] = true;
        }
      }
      sourceObj = Object.getPrototypeOf(sourceObj);
    } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
    return destObj;
  }
  function endsWith(str, searchString, position) {
    str = String(str);
    if (position === void 0 || position > str.length) {
      position = str.length;
    }
    position -= searchString.length;
    var lastIndex = str.indexOf(searchString, position);
    return lastIndex !== -1 && lastIndex === position;
  }
  function toArray(thing) {
    if (!thing)
      return null;
    var i = thing.length;
    if (isUndefined(i))
      return null;
    var arr = new Array(i);
    while (i-- > 0) {
      arr[i] = thing[i];
    }
    return arr;
  }
  var isTypedArray$2 = function(TypedArray) {
    return function(thing) {
      return TypedArray && thing instanceof TypedArray;
    };
  }(typeof Uint8Array !== "undefined" && Object.getPrototypeOf(Uint8Array));
  var utils$h = {
    isArray: isArray$2,
    isArrayBuffer,
    isBuffer: isBuffer$2,
    isFormData,
    isArrayBufferView,
    isString,
    isNumber,
    isObject: isObject$1,
    isPlainObject: isPlainObject$1,
    isUndefined,
    isDate,
    isFile,
    isBlob,
    isFunction: isFunction$1,
    isStream,
    isURLSearchParams,
    isStandardBrowserEnv,
    forEach: forEach$1,
    merge: merge$2,
    extend,
    trim,
    stripBOM,
    inherits: inherits$1,
    toFlatObject,
    kindOf,
    kindOfTest,
    endsWith,
    toArray,
    isTypedArray: isTypedArray$2,
    isFileList
  };
  var utils$g = utils$h;
  function encode(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
  }
  var buildURL$2 = function buildURL2(url, params, paramsSerializer) {
    if (!params) {
      return url;
    }
    var serializedParams;
    if (paramsSerializer) {
      serializedParams = paramsSerializer(params);
    } else if (utils$g.isURLSearchParams(params)) {
      serializedParams = params.toString();
    } else {
      var parts = [];
      utils$g.forEach(params, function serialize2(val, key) {
        if (val === null || typeof val === "undefined") {
          return;
        }
        if (utils$g.isArray(val)) {
          key = key + "[]";
        } else {
          val = [val];
        }
        utils$g.forEach(val, function parseValue(v) {
          if (utils$g.isDate(v)) {
            v = v.toISOString();
          } else if (utils$g.isObject(v)) {
            v = JSON.stringify(v);
          }
          parts.push(encode(key) + "=" + encode(v));
        });
      });
      serializedParams = parts.join("&");
    }
    if (serializedParams) {
      var hashmarkIndex = url.indexOf("#");
      if (hashmarkIndex !== -1) {
        url = url.slice(0, hashmarkIndex);
      }
      url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
    }
    return url;
  };
  var utils$f = utils$h;
  function InterceptorManager$1() {
    this.handlers = [];
  }
  InterceptorManager$1.prototype.use = function use(fulfilled, rejected, options2) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options2 ? options2.synchronous : false,
      runWhen: options2 ? options2.runWhen : null
    });
    return this.handlers.length - 1;
  };
  InterceptorManager$1.prototype.eject = function eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  };
  InterceptorManager$1.prototype.forEach = function forEach2(fn) {
    utils$f.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  };
  var InterceptorManager_1 = InterceptorManager$1;
  var utils$e = utils$h;
  var normalizeHeaderName$1 = function normalizeHeaderName2(headers, normalizedName) {
    utils$e.forEach(headers, function processHeader(value, name) {
      if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
        headers[normalizedName] = value;
        delete headers[name];
      }
    });
  };
  var utils$d = utils$h;
  function AxiosError$5(message, code, config, request, response) {
    Error.call(this);
    this.message = message;
    this.name = "AxiosError";
    code && (this.code = code);
    config && (this.config = config);
    request && (this.request = request);
    response && (this.response = response);
  }
  utils$d.inherits(AxiosError$5, Error, {
    toJSON: function toJSON() {
      return {
        message: this.message,
        name: this.name,
        description: this.description,
        number: this.number,
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        config: this.config,
        code: this.code,
        status: this.response && this.response.status ? this.response.status : null
      };
    }
  });
  var prototype = AxiosError$5.prototype;
  var descriptors = {};
  [
    "ERR_BAD_OPTION_VALUE",
    "ERR_BAD_OPTION",
    "ECONNABORTED",
    "ETIMEDOUT",
    "ERR_NETWORK",
    "ERR_FR_TOO_MANY_REDIRECTS",
    "ERR_DEPRECATED",
    "ERR_BAD_RESPONSE",
    "ERR_BAD_REQUEST",
    "ERR_CANCELED"
  ].forEach(function(code) {
    descriptors[code] = { value: code };
  });
  Object.defineProperties(AxiosError$5, descriptors);
  Object.defineProperty(prototype, "isAxiosError", { value: true });
  AxiosError$5.from = function(error, code, config, request, response, customProps) {
    var axiosError = Object.create(prototype);
    utils$d.toFlatObject(error, axiosError, function filter2(obj) {
      return obj !== Error.prototype;
    });
    AxiosError$5.call(axiosError, error.message, code, config, request, response);
    axiosError.name = error.name;
    customProps && Object.assign(axiosError, customProps);
    return axiosError;
  };
  var AxiosError_1 = AxiosError$5;
  var transitional = {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  };
  var utils$c = utils$h;
  function toFormData$1(obj, formData) {
    formData = formData || new FormData();
    var stack = [];
    function convertValue(value) {
      if (value === null)
        return "";
      if (utils$c.isDate(value)) {
        return value.toISOString();
      }
      if (utils$c.isArrayBuffer(value) || utils$c.isTypedArray(value)) {
        return typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
      }
      return value;
    }
    function build(data2, parentKey) {
      if (utils$c.isPlainObject(data2) || utils$c.isArray(data2)) {
        if (stack.indexOf(data2) !== -1) {
          throw Error("Circular reference detected in " + parentKey);
        }
        stack.push(data2);
        utils$c.forEach(data2, function each(value, key) {
          if (utils$c.isUndefined(value))
            return;
          var fullKey = parentKey ? parentKey + "." + key : key;
          var arr;
          if (value && !parentKey && typeof value === "object") {
            if (utils$c.endsWith(key, "{}")) {
              value = JSON.stringify(value);
            } else if (utils$c.endsWith(key, "[]") && (arr = utils$c.toArray(value))) {
              arr.forEach(function(el) {
                !utils$c.isUndefined(el) && formData.append(fullKey, convertValue(el));
              });
              return;
            }
          }
          build(value, fullKey);
        });
        stack.pop();
      } else {
        formData.append(parentKey, convertValue(data2));
      }
    }
    build(obj);
    return formData;
  }
  var toFormData_1 = toFormData$1;
  var AxiosError$4 = AxiosError_1;
  var settle$1 = function settle2(resolve, reject, response) {
    var validateStatus = response.config.validateStatus;
    if (!response.status || !validateStatus || validateStatus(response.status)) {
      resolve(response);
    } else {
      reject(new AxiosError$4(
        "Request failed with status code " + response.status,
        [AxiosError$4.ERR_BAD_REQUEST, AxiosError$4.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
        response.config,
        response.request,
        response
      ));
    }
  };
  var utils$b = utils$h;
  var cookies$1 = utils$b.isStandardBrowserEnv() ? function standardBrowserEnv() {
    return {
      write: function write2(name, value, expires, path, domain, secure) {
        var cookie = [];
        cookie.push(name + "=" + encodeURIComponent(value));
        if (utils$b.isNumber(expires)) {
          cookie.push("expires=" + new Date(expires).toGMTString());
        }
        if (utils$b.isString(path)) {
          cookie.push("path=" + path);
        }
        if (utils$b.isString(domain)) {
          cookie.push("domain=" + domain);
        }
        if (secure === true) {
          cookie.push("secure");
        }
        document.cookie = cookie.join("; ");
      },
      read: function read2(name) {
        var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
        return match ? decodeURIComponent(match[3]) : null;
      },
      remove: function remove(name) {
        this.write(name, "", Date.now() - 864e5);
      }
    };
  }() : function nonStandardBrowserEnv() {
    return {
      write: function write2() {
      },
      read: function read2() {
        return null;
      },
      remove: function remove() {
      }
    };
  }();
  var isAbsoluteURL$1 = function isAbsoluteURL2(url) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
  };
  var combineURLs$1 = function combineURLs2(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
  };
  var isAbsoluteURL = isAbsoluteURL$1;
  var combineURLs = combineURLs$1;
  var buildFullPath$2 = function buildFullPath2(baseURL, requestedURL) {
    if (baseURL && !isAbsoluteURL(requestedURL)) {
      return combineURLs(baseURL, requestedURL);
    }
    return requestedURL;
  };
  var utils$a = utils$h;
  var ignoreDuplicateOf = [
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ];
  var parseHeaders$1 = function parseHeaders2(headers) {
    var parsed = {};
    var key;
    var val;
    var i;
    if (!headers) {
      return parsed;
    }
    utils$a.forEach(headers.split("\n"), function parser(line) {
      i = line.indexOf(":");
      key = utils$a.trim(line.substr(0, i)).toLowerCase();
      val = utils$a.trim(line.substr(i + 1));
      if (key) {
        if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
          return;
        }
        if (key === "set-cookie") {
          parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
        }
      }
    });
    return parsed;
  };
  var utils$9 = utils$h;
  var isURLSameOrigin$1 = utils$9.isStandardBrowserEnv() ? function standardBrowserEnv() {
    var msie = /(msie|trident)/i.test(navigator.userAgent);
    var urlParsingNode = document.createElement("a");
    var originURL;
    function resolveURL(url) {
      var href = url;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin2(requestURL) {
      var parsed = utils$9.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }() : function nonStandardBrowserEnv() {
    return function isURLSameOrigin2() {
      return true;
    };
  }();
  var AxiosError$3 = AxiosError_1;
  var utils$8 = utils$h;
  function CanceledError$3(message) {
    AxiosError$3.call(this, message == null ? "canceled" : message, AxiosError$3.ERR_CANCELED);
    this.name = "CanceledError";
  }
  utils$8.inherits(CanceledError$3, AxiosError$3, {
    __CANCEL__: true
  });
  var CanceledError_1 = CanceledError$3;
  var parseProtocol$1 = function parseProtocol2(url) {
    var match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
    return match && match[1] || "";
  };
  var utils$7 = utils$h;
  var settle = settle$1;
  var cookies = cookies$1;
  var buildURL$1 = buildURL$2;
  var buildFullPath$1 = buildFullPath$2;
  var parseHeaders = parseHeaders$1;
  var isURLSameOrigin = isURLSameOrigin$1;
  var transitionalDefaults$1 = transitional;
  var AxiosError$2 = AxiosError_1;
  var CanceledError$2 = CanceledError_1;
  var parseProtocol = parseProtocol$1;
  var xhr = function xhrAdapter(config) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
      var requestData = config.data;
      var requestHeaders = config.headers;
      var responseType = config.responseType;
      var onCanceled;
      function done() {
        if (config.cancelToken) {
          config.cancelToken.unsubscribe(onCanceled);
        }
        if (config.signal) {
          config.signal.removeEventListener("abort", onCanceled);
        }
      }
      if (utils$7.isFormData(requestData) && utils$7.isStandardBrowserEnv()) {
        delete requestHeaders["Content-Type"];
      }
      var request = new XMLHttpRequest();
      if (config.auth) {
        var username = config.auth.username || "";
        var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
        requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
      }
      var fullPath = buildFullPath$1(config.baseURL, config.url);
      request.open(config.method.toUpperCase(), buildURL$1(fullPath, config.params, config.paramsSerializer), true);
      request.timeout = config.timeout;
      function onloadend() {
        if (!request) {
          return;
        }
        var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null;
        var responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
        var response = {
          data: responseData,
          status: request.status,
          statusText: request.statusText,
          headers: responseHeaders,
          config,
          request
        };
        settle(function _resolve(value) {
          resolve(value);
          done();
        }, function _reject(err) {
          reject(err);
          done();
        }, response);
        request = null;
      }
      if ("onloadend" in request) {
        request.onloadend = onloadend;
      } else {
        request.onreadystatechange = function handleLoad() {
          if (!request || request.readyState !== 4) {
            return;
          }
          if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
            return;
          }
          setTimeout(onloadend);
        };
      }
      request.onabort = function handleAbort() {
        if (!request) {
          return;
        }
        reject(new AxiosError$2("Request aborted", AxiosError$2.ECONNABORTED, config, request));
        request = null;
      };
      request.onerror = function handleError() {
        reject(new AxiosError$2("Network Error", AxiosError$2.ERR_NETWORK, config, request, request));
        request = null;
      };
      request.ontimeout = function handleTimeout() {
        var timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
        var transitional2 = config.transitional || transitionalDefaults$1;
        if (config.timeoutErrorMessage) {
          timeoutErrorMessage = config.timeoutErrorMessage;
        }
        reject(new AxiosError$2(
          timeoutErrorMessage,
          transitional2.clarifyTimeoutError ? AxiosError$2.ETIMEDOUT : AxiosError$2.ECONNABORTED,
          config,
          request
        ));
        request = null;
      };
      if (utils$7.isStandardBrowserEnv()) {
        var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
        if (xsrfValue) {
          requestHeaders[config.xsrfHeaderName] = xsrfValue;
        }
      }
      if ("setRequestHeader" in request) {
        utils$7.forEach(requestHeaders, function setRequestHeader(val, key) {
          if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
            delete requestHeaders[key];
          } else {
            request.setRequestHeader(key, val);
          }
        });
      }
      if (!utils$7.isUndefined(config.withCredentials)) {
        request.withCredentials = !!config.withCredentials;
      }
      if (responseType && responseType !== "json") {
        request.responseType = config.responseType;
      }
      if (typeof config.onDownloadProgress === "function") {
        request.addEventListener("progress", config.onDownloadProgress);
      }
      if (typeof config.onUploadProgress === "function" && request.upload) {
        request.upload.addEventListener("progress", config.onUploadProgress);
      }
      if (config.cancelToken || config.signal) {
        onCanceled = function(cancel) {
          if (!request) {
            return;
          }
          reject(!cancel || cancel && cancel.type ? new CanceledError$2() : cancel);
          request.abort();
          request = null;
        };
        config.cancelToken && config.cancelToken.subscribe(onCanceled);
        if (config.signal) {
          config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
        }
      }
      if (!requestData) {
        requestData = null;
      }
      var protocol = parseProtocol(fullPath);
      if (protocol && ["http", "https", "file"].indexOf(protocol) === -1) {
        reject(new AxiosError$2("Unsupported protocol " + protocol + ":", AxiosError$2.ERR_BAD_REQUEST, config));
        return;
      }
      request.send(requestData);
    });
  };
  var _null = null;
  var utils$6 = utils$h;
  var normalizeHeaderName = normalizeHeaderName$1;
  var AxiosError$1 = AxiosError_1;
  var transitionalDefaults = transitional;
  var toFormData = toFormData_1;
  var DEFAULT_CONTENT_TYPE = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  function setContentTypeIfUnset(headers, value) {
    if (!utils$6.isUndefined(headers) && utils$6.isUndefined(headers["Content-Type"])) {
      headers["Content-Type"] = value;
    }
  }
  function getDefaultAdapter() {
    var adapter;
    if (typeof XMLHttpRequest !== "undefined") {
      adapter = xhr;
    } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
      adapter = xhr;
    }
    return adapter;
  }
  function stringifySafely(rawValue, parser, encoder) {
    if (utils$6.isString(rawValue)) {
      try {
        (parser || JSON.parse)(rawValue);
        return utils$6.trim(rawValue);
      } catch (e) {
        if (e.name !== "SyntaxError") {
          throw e;
        }
      }
    }
    return (encoder || JSON.stringify)(rawValue);
  }
  var defaults$3 = {
    transitional: transitionalDefaults,
    adapter: getDefaultAdapter(),
    transformRequest: [function transformRequest(data2, headers) {
      normalizeHeaderName(headers, "Accept");
      normalizeHeaderName(headers, "Content-Type");
      if (utils$6.isFormData(data2) || utils$6.isArrayBuffer(data2) || utils$6.isBuffer(data2) || utils$6.isStream(data2) || utils$6.isFile(data2) || utils$6.isBlob(data2)) {
        return data2;
      }
      if (utils$6.isArrayBufferView(data2)) {
        return data2.buffer;
      }
      if (utils$6.isURLSearchParams(data2)) {
        setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
        return data2.toString();
      }
      var isObjectPayload = utils$6.isObject(data2);
      var contentType = headers && headers["Content-Type"];
      var isFileList2;
      if ((isFileList2 = utils$6.isFileList(data2)) || isObjectPayload && contentType === "multipart/form-data") {
        var _FormData = this.env && this.env.FormData;
        return toFormData(isFileList2 ? { "files[]": data2 } : data2, _FormData && new _FormData());
      } else if (isObjectPayload || contentType === "application/json") {
        setContentTypeIfUnset(headers, "application/json");
        return stringifySafely(data2);
      }
      return data2;
    }],
    transformResponse: [function transformResponse(data2) {
      var transitional2 = this.transitional || defaults$3.transitional;
      var silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      var forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
      var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
      if (strictJSONParsing || forcedJSONParsing && utils$6.isString(data2) && data2.length) {
        try {
          return JSON.parse(data2);
        } catch (e) {
          if (strictJSONParsing) {
            if (e.name === "SyntaxError") {
              throw AxiosError$1.from(e, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response);
            }
            throw e;
          }
        }
      }
      return data2;
    }],
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
      FormData: _null
    },
    validateStatus: function validateStatus(status) {
      return status >= 200 && status < 300;
    },
    headers: {
      common: {
        "Accept": "application/json, text/plain, */*"
      }
    }
  };
  utils$6.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
    defaults$3.headers[method] = {};
  });
  utils$6.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
    defaults$3.headers[method] = utils$6.merge(DEFAULT_CONTENT_TYPE);
  });
  var defaults_1 = defaults$3;
  var utils$5 = utils$h;
  var defaults$2 = defaults_1;
  var transformData$1 = function transformData2(data2, headers, fns) {
    var context = this || defaults$2;
    utils$5.forEach(fns, function transform(fn) {
      data2 = fn.call(context, data2, headers);
    });
    return data2;
  };
  var isCancel$1 = function isCancel2(value) {
    return !!(value && value.__CANCEL__);
  };
  var utils$4 = utils$h;
  var transformData = transformData$1;
  var isCancel = isCancel$1;
  var defaults$1 = defaults_1;
  var CanceledError$1 = CanceledError_1;
  function throwIfCancellationRequested(config) {
    if (config.cancelToken) {
      config.cancelToken.throwIfRequested();
    }
    if (config.signal && config.signal.aborted) {
      throw new CanceledError$1();
    }
  }
  var dispatchRequest$1 = function dispatchRequest2(config) {
    throwIfCancellationRequested(config);
    config.headers = config.headers || {};
    config.data = transformData.call(
      config,
      config.data,
      config.headers,
      config.transformRequest
    );
    config.headers = utils$4.merge(
      config.headers.common || {},
      config.headers[config.method] || {},
      config.headers
    );
    utils$4.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      function cleanHeaderConfig(method) {
        delete config.headers[method];
      }
    );
    var adapter = config.adapter || defaults$1.adapter;
    return adapter(config).then(function onAdapterResolution(response) {
      throwIfCancellationRequested(config);
      response.data = transformData.call(
        config,
        response.data,
        response.headers,
        config.transformResponse
      );
      return response;
    }, function onAdapterRejection(reason) {
      if (!isCancel(reason)) {
        throwIfCancellationRequested(config);
        if (reason && reason.response) {
          reason.response.data = transformData.call(
            config,
            reason.response.data,
            reason.response.headers,
            config.transformResponse
          );
        }
      }
      return Promise.reject(reason);
    });
  };
  var utils$3 = utils$h;
  var mergeConfig$2 = function mergeConfig2(config1, config2) {
    config2 = config2 || {};
    var config = {};
    function getMergedValue(target, source) {
      if (utils$3.isPlainObject(target) && utils$3.isPlainObject(source)) {
        return utils$3.merge(target, source);
      } else if (utils$3.isPlainObject(source)) {
        return utils$3.merge({}, source);
      } else if (utils$3.isArray(source)) {
        return source.slice();
      }
      return source;
    }
    function mergeDeepProperties(prop) {
      if (!utils$3.isUndefined(config2[prop])) {
        return getMergedValue(config1[prop], config2[prop]);
      } else if (!utils$3.isUndefined(config1[prop])) {
        return getMergedValue(void 0, config1[prop]);
      }
    }
    function valueFromConfig2(prop) {
      if (!utils$3.isUndefined(config2[prop])) {
        return getMergedValue(void 0, config2[prop]);
      }
    }
    function defaultToConfig2(prop) {
      if (!utils$3.isUndefined(config2[prop])) {
        return getMergedValue(void 0, config2[prop]);
      } else if (!utils$3.isUndefined(config1[prop])) {
        return getMergedValue(void 0, config1[prop]);
      }
    }
    function mergeDirectKeys(prop) {
      if (prop in config2) {
        return getMergedValue(config1[prop], config2[prop]);
      } else if (prop in config1) {
        return getMergedValue(void 0, config1[prop]);
      }
    }
    var mergeMap = {
      "url": valueFromConfig2,
      "method": valueFromConfig2,
      "data": valueFromConfig2,
      "baseURL": defaultToConfig2,
      "transformRequest": defaultToConfig2,
      "transformResponse": defaultToConfig2,
      "paramsSerializer": defaultToConfig2,
      "timeout": defaultToConfig2,
      "timeoutMessage": defaultToConfig2,
      "withCredentials": defaultToConfig2,
      "adapter": defaultToConfig2,
      "responseType": defaultToConfig2,
      "xsrfCookieName": defaultToConfig2,
      "xsrfHeaderName": defaultToConfig2,
      "onUploadProgress": defaultToConfig2,
      "onDownloadProgress": defaultToConfig2,
      "decompress": defaultToConfig2,
      "maxContentLength": defaultToConfig2,
      "maxBodyLength": defaultToConfig2,
      "beforeRedirect": defaultToConfig2,
      "transport": defaultToConfig2,
      "httpAgent": defaultToConfig2,
      "httpsAgent": defaultToConfig2,
      "cancelToken": defaultToConfig2,
      "socketPath": defaultToConfig2,
      "responseEncoding": defaultToConfig2,
      "validateStatus": mergeDirectKeys
    };
    utils$3.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
      var merge2 = mergeMap[prop] || mergeDeepProperties;
      var configValue = merge2(prop);
      utils$3.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
    });
    return config;
  };
  var data = {
    "version": "0.27.2"
  };
  var VERSION = data.version;
  var AxiosError = AxiosError_1;
  var validators$1 = {};
  ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i) {
    validators$1[type] = function validator2(thing) {
      return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
    };
  });
  var deprecatedWarnings = {};
  validators$1.transitional = function transitional2(validator2, version, message) {
    function formatMessage(opt, desc) {
      return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
    }
    return function(value, opt, opts) {
      if (validator2 === false) {
        throw new AxiosError(
          formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
          AxiosError.ERR_DEPRECATED
        );
      }
      if (version && !deprecatedWarnings[opt]) {
        deprecatedWarnings[opt] = true;
        console.warn(
          formatMessage(
            opt,
            " has been deprecated since v" + version + " and will be removed in the near future"
          )
        );
      }
      return validator2 ? validator2(value, opt, opts) : true;
    };
  };
  function assertOptions(options2, schema, allowUnknown) {
    if (typeof options2 !== "object") {
      throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
    }
    var keys2 = Object.keys(options2);
    var i = keys2.length;
    while (i-- > 0) {
      var opt = keys2[i];
      var validator2 = schema[opt];
      if (validator2) {
        var value = options2[opt];
        var result = value === void 0 || validator2(value, opt, options2);
        if (result !== true) {
          throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
        }
        continue;
      }
      if (allowUnknown !== true) {
        throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
      }
    }
  }
  var validator$1 = {
    assertOptions,
    validators: validators$1
  };
  var utils$2 = utils$h;
  var buildURL = buildURL$2;
  var InterceptorManager = InterceptorManager_1;
  var dispatchRequest = dispatchRequest$1;
  var mergeConfig$1 = mergeConfig$2;
  var buildFullPath = buildFullPath$2;
  var validator = validator$1;
  var validators = validator.validators;
  function Axios$1(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager(),
      response: new InterceptorManager()
    };
  }
  Axios$1.prototype.request = function request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig$1(this.defaults, config);
    if (config.method) {
      config.method = config.method.toLowerCase();
    } else if (this.defaults.method) {
      config.method = this.defaults.method.toLowerCase();
    } else {
      config.method = "get";
    }
    var transitional2 = config.transitional;
    if (transitional2 !== void 0) {
      validator.assertOptions(transitional2, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }
    var requestInterceptorChain = [];
    var synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    var responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    var promise;
    if (!synchronousRequestInterceptors) {
      var chain = [dispatchRequest, void 0];
      Array.prototype.unshift.apply(chain, requestInterceptorChain);
      chain = chain.concat(responseInterceptorChain);
      promise = Promise.resolve(config);
      while (chain.length) {
        promise = promise.then(chain.shift(), chain.shift());
      }
      return promise;
    }
    var newConfig = config;
    while (requestInterceptorChain.length) {
      var onFulfilled = requestInterceptorChain.shift();
      var onRejected = requestInterceptorChain.shift();
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected(error);
        break;
      }
    }
    try {
      promise = dispatchRequest(newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    while (responseInterceptorChain.length) {
      promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
    }
    return promise;
  };
  Axios$1.prototype.getUri = function getUri(config) {
    config = mergeConfig$1(this.defaults, config);
    var fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  };
  utils$2.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
    Axios$1.prototype[method] = function(url, config) {
      return this.request(mergeConfig$1(config || {}, {
        method,
        url,
        data: (config || {}).data
      }));
    };
  });
  utils$2.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
    function generateHTTPMethod(isForm) {
      return function httpMethod(url, data2, config) {
        return this.request(mergeConfig$1(config || {}, {
          method,
          headers: isForm ? {
            "Content-Type": "multipart/form-data"
          } : {},
          url,
          data: data2
        }));
      };
    }
    Axios$1.prototype[method] = generateHTTPMethod();
    Axios$1.prototype[method + "Form"] = generateHTTPMethod(true);
  });
  var Axios_1 = Axios$1;
  var CanceledError = CanceledError_1;
  function CancelToken(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    var resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    var token = this;
    this.promise.then(function(cancel) {
      if (!token._listeners)
        return;
      var i;
      var l = token._listeners.length;
      for (i = 0; i < l; i++) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = function(onfulfilled) {
      var _resolve;
      var promise = new Promise(function(resolve) {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError(message);
      resolvePromise(token.reason);
    });
  }
  CancelToken.prototype.throwIfRequested = function throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  };
  CancelToken.prototype.subscribe = function subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  };
  CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    var index2 = this._listeners.indexOf(listener);
    if (index2 !== -1) {
      this._listeners.splice(index2, 1);
    }
  };
  CancelToken.source = function source() {
    var cancel;
    var token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  };
  var CancelToken_1 = CancelToken;
  var spread = function spread2(callback) {
    return function wrap(arr) {
      return callback.apply(null, arr);
    };
  };
  var utils$1 = utils$h;
  var isAxiosError = function isAxiosError2(payload) {
    return utils$1.isObject(payload) && payload.isAxiosError === true;
  };
  var utils = utils$h;
  var bind = bind$2;
  var Axios = Axios_1;
  var mergeConfig = mergeConfig$2;
  var defaults = defaults_1;
  function createInstance(defaultConfig) {
    var context = new Axios(defaultConfig);
    var instance2 = bind(Axios.prototype.request, context);
    utils.extend(instance2, Axios.prototype, context);
    utils.extend(instance2, context);
    instance2.create = function create(instanceConfig) {
      return createInstance(mergeConfig(defaultConfig, instanceConfig));
    };
    return instance2;
  }
  var axios$1 = createInstance(defaults);
  axios$1.Axios = Axios;
  axios$1.CanceledError = CanceledError_1;
  axios$1.CancelToken = CancelToken_1;
  axios$1.isCancel = isCancel$1;
  axios$1.VERSION = data.version;
  axios$1.toFormData = toFormData_1;
  axios$1.AxiosError = AxiosError_1;
  axios$1.Cancel = axios$1.CanceledError;
  axios$1.all = function all(promises) {
    return Promise.all(promises);
  };
  axios$1.spread = spread;
  axios$1.isAxiosError = isAxiosError;
  axios$2.exports = axios$1;
  axios$2.exports.default = axios$1;
  var axios = axios$2.exports;
  function createWPService() {
    return axios.create({
      baseURL: `${window.ZnRestConfig.rest_root}wp/v2`,
      headers: {
        "X-WP-Nonce": window.ZnRestConfig.nonce,
        Accept: "application/json",
        "Content-Type": "application/json"
      }
    });
  }
  function getService() {
    return axios.create({
      baseURL: `${window.ZnRestConfig.rest_root}zionbuilder/v1/`,
      headers: {
        "X-WP-Nonce": window.ZnRestConfig.nonce,
        Accept: "application/json",
        "Content-Type": "application/json"
      }
    });
  }
  function bulkActions(payload) {
    const bulkActionData = {
      actions: payload,
      post_id: window.ZnPbInitialData ? window.ZnPbInitialData.page_id : null
    };
    return getService().post("bulk-actions", bulkActionData);
  }
  function getImageIds(payload) {
    return getService().post("media", payload);
  }
  function getFontsDataSet() {
    return getService().get("data-sets");
  }
  function getOptionsForm(payload) {
    return getService().post("elements/get_element_options_form", {
      element_data: payload
    });
  }
  function getGoogleFonts() {
    return getService().get("google-fonts");
  }
  function addLibraryItem(libraryID, data2) {
    return getService().post(`library/${libraryID}`, data2);
  }
  function exportLibraryItem(libraryID, itemID) {
    return getService().get(`library/${libraryID}/${itemID}/export`, {
      responseType: "arraybuffer"
    });
  }
  function deleteLibraryItem(libraryID, itemID) {
    return getService().delete(`library/${libraryID}/${itemID}`);
  }
  function getLibraryItemBuilderConfig(libraryID, itemID) {
    return getService().get(`library/${libraryID}/${itemID}/get-builder-config`);
  }
  function importLibraryItem(libraryID, file) {
    return getService().post(`library/${libraryID}/import`, file, {
      headers: {
        "Content-Type": "multipart/form-data"
      }
    });
  }
  function exportTemplate(data2) {
    return getService().post(`library/export`, data2, {
      responseType: "arraybuffer"
    });
  }
  function saveLibraryItemThumbnail(libraryID, itemID, data2) {
    return getService().post(`library/${libraryID}/${itemID}/save-thumbnail`, data2);
  }
  function saveOptions(options2) {
    return getService().post("options", options2);
  }
  function getSavedOptions() {
    return getService().get("options");
  }
  function lockPage(id) {
    return getService().get(`pages/${id}/lock`);
  }
  function savePage(pageData) {
    return getService().post("save-page", pageData);
  }
  function regenerateCache(itemData) {
    return getService().post("assets/regenerate", itemData);
  }
  function getCacheList() {
    return getService().get("assets");
  }
  function finishRegeneration() {
    return getService().get("assets/finish");
  }
  function errorInterceptor(errors, service = getService()) {
    service.interceptors.response.use(
      function(response) {
        if (typeof response.data !== "object") {
          errors.add({
            title: "Server error",
            message: "There was a server error. Please refresh the page and try again",
            type: "error"
          });
          console.warn(response);
        }
        return response;
      },
      function(error) {
        let message = "There was a problem performing the action. Please try again or refresh the page.";
        if (typeof error.response.data.message !== "undefined") {
          message = error.response.data.message;
        }
        errors.add({
          title: "Error",
          message,
          type: "error"
        });
        return Promise.reject(error);
      }
    );
  }
  function getUsersById(ids) {
    return createWPService().get(`users`, {
      params: {
        include: ids
      }
    });
  }
  function uploadFile(data2) {
    return getService().post("upload", data2, {
      headers: {
        "Content-Type": "multipart/form-data"
      }
    });
  }
  function saveUserData(userData) {
    return getService().post(`user-data`, userData);
  }
  function saveBreakpoints(breakpoints) {
    return getService().post("breakpoints", breakpoints);
  }
  var FileSaver_min = { exports: {} };
  (function(module2, exports2) {
    (function(a, b) {
      b();
    })(commonjsGlobal, function() {
      function b(a2, b2) {
        return "undefined" == typeof b2 ? b2 = { autoBom: false } : "object" != typeof b2 && (console.warn("Deprecated: Expected third argument to be a object"), b2 = { autoBom: !b2 }), b2.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a2.type) ? new Blob(["\uFEFF", a2], { type: a2.type }) : a2;
      }
      function c(a2, b2, c2) {
        var d2 = new XMLHttpRequest();
        d2.open("GET", a2), d2.responseType = "blob", d2.onload = function() {
          g(d2.response, b2, c2);
        }, d2.onerror = function() {
          console.error("could not download file");
        }, d2.send();
      }
      function d(a2) {
        var b2 = new XMLHttpRequest();
        b2.open("HEAD", a2, false);
        try {
          b2.send();
        } catch (a3) {
        }
        return 200 <= b2.status && 299 >= b2.status;
      }
      function e(a2) {
        try {
          a2.dispatchEvent(new MouseEvent("click"));
        } catch (c2) {
          var b2 = document.createEvent("MouseEvents");
          b2.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null), a2.dispatchEvent(b2);
        }
      }
      var f = "object" == typeof window && window.window === window ? window : "object" == typeof self && self.self === self ? self : "object" == typeof commonjsGlobal && commonjsGlobal.global === commonjsGlobal ? commonjsGlobal : void 0, a = f.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), g = f.saveAs || ("object" != typeof window || window !== f ? function() {
      } : "download" in HTMLAnchorElement.prototype && !a ? function(b2, g2, h) {
        var i = f.URL || f.webkitURL, j = document.createElement("a");
        g2 = g2 || b2.name || "download", j.download = g2, j.rel = "noopener", "string" == typeof b2 ? (j.href = b2, j.origin === location.origin ? e(j) : d(j.href) ? c(b2, g2, h) : e(j, j.target = "_blank")) : (j.href = i.createObjectURL(b2), setTimeout(function() {
          i.revokeObjectURL(j.href);
        }, 4e4), setTimeout(function() {
          e(j);
        }, 0));
      } : "msSaveOrOpenBlob" in navigator ? function(f2, g2, h) {
        if (g2 = g2 || f2.name || "download", "string" != typeof f2)
          navigator.msSaveOrOpenBlob(b(f2, h), g2);
        else if (d(f2))
          c(f2, g2, h);
        else {
          var i = document.createElement("a");
          i.href = f2, i.target = "_blank", setTimeout(function() {
            e(i);
          });
        }
      } : function(b2, d2, e2, g2) {
        if (g2 = g2 || open("", "_blank"), g2 && (g2.document.title = g2.document.body.innerText = "downloading..."), "string" == typeof b2)
          return c(b2, d2, e2);
        var h = "application/octet-stream" === b2.type, i = /constructor/i.test(f.HTMLElement) || f.safari, j = /CriOS\/[\d]+/.test(navigator.userAgent);
        if ((j || h && i || a) && "undefined" != typeof FileReader) {
          var k = new FileReader();
          k.onloadend = function() {
            var a2 = k.result;
            a2 = j ? a2 : a2.replace(/^data:[^;]*;/, "data:attachment/file;"), g2 ? g2.location.href = a2 : location = a2, g2 = null;
          }, k.readAsDataURL(b2);
        } else {
          var l = f.URL || f.webkitURL, m = l.createObjectURL(b2);
          g2 ? g2.location = m : location.href = m, g2 = null, setTimeout(function() {
            l.revokeObjectURL(m);
          }, 4e4);
        }
      });
      f.saveAs = g.saveAs = g, module2.exports = g;
    });
  })(FileSaver_min);
  class LibraryItem$1 {
    constructor(item, librarySource) {
      __publicField(this, "id", "");
      __publicField(this, "name", "");
      __publicField(this, "category", []);
      __publicField(this, "thumbnail", "");
      __publicField(this, "data", "");
      __publicField(this, "tags", []);
      __publicField(this, "urls", {});
      __publicField(this, "type", "");
      __publicField(this, "source", "");
      __publicField(this, "url", "");
      __publicField(this, "pro", false);
      __publicField(this, "loadingThumbnail", false);
      __publicField(this, "loading", false);
      __publicField(this, "librarySource");
      Object.assign(this, item);
      this.librarySource = librarySource;
    }
    delete() {
      this.loading = true;
      return this.librarySource.removeItem(this).finally(() => {
        this.loading = false;
      });
    }
    export() {
      this.loading = true;
      return exportLibraryItem(this.librarySource.id, this.id).then((response) => {
        const blob = new Blob([response.data], { type: "application/zip" });
        FileSaver_min.exports.saveAs(blob, `${this.name}.zip`);
      }).finally(() => {
        this.loading = false;
      });
    }
    saveThumbnailData(data2) {
      saveLibraryItemThumbnail(this.librarySource.id, this.id, data2).finally(() => {
        this.librarySource.deleteCache();
      });
    }
    getBuilderData() {
      return getLibraryItemBuilderConfig(this.librarySource.id, this.id);
    }
    toJSON() {
      return {
        id: this.id,
        name: this.name,
        category: this.category,
        thumbnail: this.thumbnail,
        data: this.data,
        tags: this.tags,
        urls: this.urls,
        type: this.type,
        pro: this.pro,
        url: this.url
      };
    }
  }
  var ls = {
    set: function(variable, value, ttl_ms) {
      var data2 = { value, expires_at: new Date().getTime() + ttl_ms / 1 };
      localStorage.setItem(variable.toString(), JSON.stringify(data2));
    },
    get: function(variable) {
      var data2 = JSON.parse(localStorage.getItem(variable.toString()));
      if (data2 !== null) {
        if (data2.expires_at !== null && data2.expires_at < new Date().getTime()) {
          localStorage.removeItem(variable.toString());
        } else {
          return data2.value;
        }
      }
      return null;
    }
  };
  var localstorageTtl = ls;
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  var freeGlobal$1 = freeGlobal;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal$1 || freeSelf || Function("return this")();
  var root$1 = root;
  var Symbol$1 = root$1.Symbol;
  var Symbol$2 = Symbol$1;
  var objectProto$f = Object.prototype;
  var hasOwnProperty$c = objectProto$f.hasOwnProperty;
  var nativeObjectToString$1 = objectProto$f.toString;
  var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;
  function getRawTag(value) {
    var isOwn = hasOwnProperty$c.call(value, symToStringTag$1), tag = value[symToStringTag$1];
    try {
      value[symToStringTag$1] = void 0;
      var unmasked = true;
    } catch (e) {
    }
    var result = nativeObjectToString$1.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag$1] = tag;
      } else {
        delete value[symToStringTag$1];
      }
    }
    return result;
  }
  var objectProto$e = Object.prototype;
  var nativeObjectToString = objectProto$e.toString;
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }
  var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
  var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
  function baseGetTag(value) {
    if (value == null) {
      return value === void 0 ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }
  function isObjectLike(value) {
    return value != null && typeof value == "object";
  }
  var symbolTag$3 = "[object Symbol]";
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag$3;
  }
  function arrayMap(array, iteratee) {
    var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
    while (++index2 < length) {
      result[index2] = iteratee(array[index2], index2, array);
    }
    return result;
  }
  var isArray = Array.isArray;
  var isArray$1 = isArray;
  var INFINITY$3 = 1 / 0;
  var symbolProto$2 = Symbol$2 ? Symbol$2.prototype : void 0, symbolToString = symbolProto$2 ? symbolProto$2.toString : void 0;
  function baseToString(value) {
    if (typeof value == "string") {
      return value;
    }
    if (isArray$1(value)) {
      return arrayMap(value, baseToString) + "";
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY$3 ? "-0" : result;
  }
  var reWhitespace = /\s/;
  function trimmedEndIndex(string) {
    var index2 = string.length;
    while (index2-- && reWhitespace.test(string.charAt(index2))) {
    }
    return index2;
  }
  var reTrimStart = /^\s+/;
  function baseTrim(string) {
    return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
  }
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == "object" || type == "function");
  }
  var NAN = 0 / 0;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  function toNumber(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject(value)) {
      var other = typeof value.valueOf == "function" ? value.valueOf() : value;
      value = isObject(other) ? other + "" : other;
    }
    if (typeof value != "string") {
      return value === 0 ? value : +value;
    }
    value = baseTrim(value);
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }
  var INFINITY$2 = 1 / 0, MAX_INTEGER = 17976931348623157e292;
  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }
    value = toNumber(value);
    if (value === INFINITY$2 || value === -INFINITY$2) {
      var sign = value < 0 ? -1 : 1;
      return sign * MAX_INTEGER;
    }
    return value === value ? value : 0;
  }
  function toInteger(value) {
    var result = toFinite(value), remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
  }
  function identity$1(value) {
    return value;
  }
  var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
  function isFunction(value) {
    if (!isObject(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
  }
  var coreJsData = root$1["__core-js_shared__"];
  var coreJsData$1 = coreJsData;
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  var funcProto$2 = Function.prototype;
  var funcToString$2 = funcProto$2.toString;
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString$2.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  }
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var funcProto$1 = Function.prototype, objectProto$d = Object.prototype;
  var funcToString$1 = funcProto$1.toString;
  var hasOwnProperty$b = objectProto$d.hasOwnProperty;
  var reIsNative = RegExp(
    "^" + funcToString$1.call(hasOwnProperty$b).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  function getValue(object, key) {
    return object == null ? void 0 : object[key];
  }
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : void 0;
  }
  var WeakMap = getNative(root$1, "WeakMap");
  var WeakMap$1 = WeakMap;
  var objectCreate = Object.create;
  var baseCreate = function() {
    function object() {
    }
    return function(proto) {
      if (!isObject(proto)) {
        return {};
      }
      if (objectCreate) {
        return objectCreate(proto);
      }
      object.prototype = proto;
      var result = new object();
      object.prototype = void 0;
      return result;
    };
  }();
  var baseCreate$1 = baseCreate;
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args[0]);
      case 2:
        return func.call(thisArg, args[0], args[1]);
      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }
  function noop() {
  }
  function copyArray(source, array) {
    var index2 = -1, length = source.length;
    array || (array = Array(length));
    while (++index2 < length) {
      array[index2] = source[index2];
    }
    return array;
  }
  var HOT_COUNT = 800, HOT_SPAN = 16;
  var nativeNow = Date.now;
  function shortOut(func) {
    var count = 0, lastCalled = 0;
    return function() {
      var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
      lastCalled = stamp;
      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count = 0;
      }
      return func.apply(void 0, arguments);
    };
  }
  function constant(value) {
    return function() {
      return value;
    };
  }
  var defineProperty = function() {
    try {
      var func = getNative(Object, "defineProperty");
      func({}, "", {});
      return func;
    } catch (e) {
    }
  }();
  var defineProperty$1 = defineProperty;
  var baseSetToString = !defineProperty$1 ? identity$1 : function(func, string) {
    return defineProperty$1(func, "toString", {
      "configurable": true,
      "enumerable": false,
      "value": constant(string),
      "writable": true
    });
  };
  var baseSetToString$1 = baseSetToString;
  var setToString = shortOut(baseSetToString$1);
  var setToString$1 = setToString;
  function arrayEach(array, iteratee) {
    var index2 = -1, length = array == null ? 0 : array.length;
    while (++index2 < length) {
      if (iteratee(array[index2], index2, array) === false) {
        break;
      }
    }
    return array;
  }
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
    while (fromRight ? index2-- : ++index2 < length) {
      if (predicate(array[index2], index2, array)) {
        return index2;
      }
    }
    return -1;
  }
  function baseIsNaN(value) {
    return value !== value;
  }
  function strictIndexOf(array, value, fromIndex) {
    var index2 = fromIndex - 1, length = array.length;
    while (++index2 < length) {
      if (array[index2] === value) {
        return index2;
      }
    }
    return -1;
  }
  function baseIndexOf(array, value, fromIndex) {
    return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
  }
  function arrayIncludes(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && baseIndexOf(array, value, 0) > -1;
  }
  var MAX_SAFE_INTEGER$1 = 9007199254740991;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER$1 : length;
    return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  function baseAssignValue(object, key, value) {
    if (key == "__proto__" && defineProperty$1) {
      defineProperty$1(object, key, {
        "configurable": true,
        "enumerable": true,
        "value": value,
        "writable": true
      });
    } else {
      object[key] = value;
    }
  }
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  var objectProto$c = Object.prototype;
  var hasOwnProperty$a = objectProto$c.hasOwnProperty;
  function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty$a.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
      baseAssignValue(object, key, value);
    }
  }
  function copyObject(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});
    var index2 = -1, length = props.length;
    while (++index2 < length) {
      var key = props[index2];
      var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
      if (newValue === void 0) {
        newValue = source[key];
      }
      if (isNew) {
        baseAssignValue(object, key, newValue);
      } else {
        assignValue(object, key, newValue);
      }
    }
    return object;
  }
  var nativeMax$2 = Math.max;
  function overRest(func, start2, transform) {
    start2 = nativeMax$2(start2 === void 0 ? func.length - 1 : start2, 0);
    return function() {
      var args = arguments, index2 = -1, length = nativeMax$2(args.length - start2, 0), array = Array(length);
      while (++index2 < length) {
        array[index2] = args[start2 + index2];
      }
      index2 = -1;
      var otherArgs = Array(start2 + 1);
      while (++index2 < start2) {
        otherArgs[index2] = args[index2];
      }
      otherArgs[start2] = transform(array);
      return apply(func, this, otherArgs);
    };
  }
  function baseRest(func, start2) {
    return setToString$1(overRest(func, start2, identity$1), func + "");
  }
  var MAX_SAFE_INTEGER = 9007199254740991;
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }
  function isIterateeCall(value, index2, object) {
    if (!isObject(object)) {
      return false;
    }
    var type = typeof index2;
    if (type == "number" ? isArrayLike(object) && isIndex(index2, object.length) : type == "string" && index2 in object) {
      return eq(object[index2], value);
    }
    return false;
  }
  function createAssigner(assigner) {
    return baseRest(function(object, sources) {
      var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
      customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        customizer = length < 3 ? void 0 : customizer;
        length = 1;
      }
      object = Object(object);
      while (++index2 < length) {
        var source = sources[index2];
        if (source) {
          assigner(object, source, index2, customizer);
        }
      }
      return object;
    });
  }
  var objectProto$b = Object.prototype;
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$b;
    return value === proto;
  }
  function baseTimes(n, iteratee) {
    var index2 = -1, result = Array(n);
    while (++index2 < n) {
      result[index2] = iteratee(index2);
    }
    return result;
  }
  var argsTag$3 = "[object Arguments]";
  function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag$3;
  }
  var objectProto$a = Object.prototype;
  var hasOwnProperty$9 = objectProto$a.hasOwnProperty;
  var propertyIsEnumerable$1 = objectProto$a.propertyIsEnumerable;
  var isArguments = baseIsArguments(function() {
    return arguments;
  }()) ? baseIsArguments : function(value) {
    return isObjectLike(value) && hasOwnProperty$9.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
  };
  var isArguments$1 = isArguments;
  function stubFalse() {
    return false;
  }
  var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
  var Buffer$2 = moduleExports$2 ? root$1.Buffer : void 0;
  var nativeIsBuffer = Buffer$2 ? Buffer$2.isBuffer : void 0;
  var isBuffer = nativeIsBuffer || stubFalse;
  var isBuffer$1 = isBuffer;
  var argsTag$2 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$3 = "[object Boolean]", dateTag$3 = "[object Date]", errorTag$2 = "[object Error]", funcTag$1 = "[object Function]", mapTag$5 = "[object Map]", numberTag$3 = "[object Number]", objectTag$4 = "[object Object]", regexpTag$3 = "[object RegExp]", setTag$5 = "[object Set]", stringTag$3 = "[object String]", weakMapTag$2 = "[object WeakMap]";
  var arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
  var typedArrayTags = {};
  typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
  typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$3] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$2] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$5] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$4] = typedArrayTags[regexpTag$3] = typedArrayTags[setTag$5] = typedArrayTags[stringTag$3] = typedArrayTags[weakMapTag$2] = false;
  function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }
  var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
  var freeProcess = moduleExports$1 && freeGlobal$1.process;
  var nodeUtil = function() {
    try {
      var types = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
      if (types) {
        return types;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e) {
    }
  }();
  var nodeUtil$1 = nodeUtil;
  var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray;
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  var isTypedArray$1 = isTypedArray;
  var objectProto$9 = Object.prototype;
  var hasOwnProperty$8 = objectProto$9.hasOwnProperty;
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray$1(value), isArg = !isArr && isArguments$1(value), isBuff = !isArr && !isArg && isBuffer$1(value), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
    for (var key in value) {
      if ((inherited || hasOwnProperty$8.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  var nativeKeys = overArg(Object.keys, Object);
  var nativeKeys$1 = nativeKeys;
  var objectProto$8 = Object.prototype;
  var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys$1(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty$7.call(object, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  }
  function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }
  function nativeKeysIn(object) {
    var result = [];
    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }
    return result;
  }
  var objectProto$7 = Object.prototype;
  var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
  function baseKeysIn(object) {
    if (!isObject(object)) {
      return nativeKeysIn(object);
    }
    var isProto = isPrototype(object), result = [];
    for (var key in object) {
      if (!(key == "constructor" && (isProto || !hasOwnProperty$6.call(object, key)))) {
        result.push(key);
      }
    }
    return result;
  }
  function keysIn(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
  }
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
  function isKey(value, object) {
    if (isArray$1(value)) {
      return false;
    }
    var type = typeof value;
    if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
      return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
  }
  var nativeCreate = getNative(Object, "create");
  var nativeCreate$1 = nativeCreate;
  function hashClear() {
    this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
    this.size = 0;
  }
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }
  var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
  var objectProto$6 = Object.prototype;
  var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
  function hashGet(key) {
    var data2 = this.__data__;
    if (nativeCreate$1) {
      var result = data2[key];
      return result === HASH_UNDEFINED$2 ? void 0 : result;
    }
    return hasOwnProperty$5.call(data2, key) ? data2[key] : void 0;
  }
  var objectProto$5 = Object.prototype;
  var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
  function hashHas(key) {
    var data2 = this.__data__;
    return nativeCreate$1 ? data2[key] !== void 0 : hasOwnProperty$4.call(data2, key);
  }
  var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
  function hashSet(key, value) {
    var data2 = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data2[key] = nativeCreate$1 && value === void 0 ? HASH_UNDEFINED$1 : value;
    return this;
  }
  function Hash(entries) {
    var index2 = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  var arrayProto$1 = Array.prototype;
  var splice$1 = arrayProto$1.splice;
  function listCacheDelete(key) {
    var data2 = this.__data__, index2 = assocIndexOf(data2, key);
    if (index2 < 0) {
      return false;
    }
    var lastIndex = data2.length - 1;
    if (index2 == lastIndex) {
      data2.pop();
    } else {
      splice$1.call(data2, index2, 1);
    }
    --this.size;
    return true;
  }
  function listCacheGet(key) {
    var data2 = this.__data__, index2 = assocIndexOf(data2, key);
    return index2 < 0 ? void 0 : data2[index2][1];
  }
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  function listCacheSet(key, value) {
    var data2 = this.__data__, index2 = assocIndexOf(data2, key);
    if (index2 < 0) {
      ++this.size;
      data2.push([key, value]);
    } else {
      data2[index2][1] = value;
    }
    return this;
  }
  function ListCache(entries) {
    var index2 = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  var Map$1 = getNative(root$1, "Map");
  var Map$2 = Map$1;
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      "hash": new Hash(),
      "map": new (Map$2 || ListCache)(),
      "string": new Hash()
    };
  }
  function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  function getMapData(map, key) {
    var data2 = map.__data__;
    return isKeyable(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
  }
  function mapCacheDelete(key) {
    var result = getMapData(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
  }
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  function mapCacheSet(key, value) {
    var data2 = getMapData(this, key), size = data2.size;
    data2.set(key, value);
    this.size += data2.size == size ? 0 : 1;
    return this;
  }
  function MapCache(entries) {
    var index2 = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  var FUNC_ERROR_TEXT$1 = "Expected a function";
  function memoize(func, resolver) {
    if (typeof func != "function" || resolver != null && typeof resolver != "function") {
      throw new TypeError(FUNC_ERROR_TEXT$1);
    }
    var memoized = function() {
      var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
      if (cache2.has(key)) {
        return cache2.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache2.set(key, result) || cache2;
      return result;
    };
    memoized.cache = new (memoize.Cache || MapCache)();
    return memoized;
  }
  memoize.Cache = MapCache;
  var MAX_MEMOIZE_SIZE = 500;
  function memoizeCapped(func) {
    var result = memoize(func, function(key) {
      if (cache2.size === MAX_MEMOIZE_SIZE) {
        cache2.clear();
      }
      return key;
    });
    var cache2 = result.cache;
    return result;
  }
  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = memoizeCapped(function(string) {
    var result = [];
    if (string.charCodeAt(0) === 46) {
      result.push("");
    }
    string.replace(rePropName, function(match, number, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
    });
    return result;
  });
  var stringToPath$1 = stringToPath;
  function toString(value) {
    return value == null ? "" : baseToString(value);
  }
  function castPath(value, object) {
    if (isArray$1(value)) {
      return value;
    }
    return isKey(value, object) ? [value] : stringToPath$1(toString(value));
  }
  var INFINITY$1 = 1 / 0;
  function toKey(value) {
    if (typeof value == "string" || isSymbol(value)) {
      return value;
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
  }
  function baseGet(object, path) {
    path = castPath(path, object);
    var index2 = 0, length = path.length;
    while (object != null && index2 < length) {
      object = object[toKey(path[index2++])];
    }
    return index2 && index2 == length ? object : void 0;
  }
  function get(object, path, defaultValue) {
    var result = object == null ? void 0 : baseGet(object, path);
    return result === void 0 ? defaultValue : result;
  }
  function arrayPush(array, values) {
    var index2 = -1, length = values.length, offset2 = array.length;
    while (++index2 < length) {
      array[offset2 + index2] = values[index2];
    }
    return array;
  }
  var spreadableSymbol = Symbol$2 ? Symbol$2.isConcatSpreadable : void 0;
  function isFlattenable(value) {
    return isArray$1(value) || isArguments$1(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
  }
  function baseFlatten(array, depth, predicate, isStrict, result) {
    var index2 = -1, length = array.length;
    predicate || (predicate = isFlattenable);
    result || (result = []);
    while (++index2 < length) {
      var value = array[index2];
      if (depth > 0 && predicate(value)) {
        if (depth > 1) {
          baseFlatten(value, depth - 1, predicate, isStrict, result);
        } else {
          arrayPush(result, value);
        }
      } else if (!isStrict) {
        result[result.length] = value;
      }
    }
    return result;
  }
  function flatten(array) {
    var length = array == null ? 0 : array.length;
    return length ? baseFlatten(array, 1) : [];
  }
  function flatRest(func) {
    return setToString$1(overRest(func, void 0, flatten), func + "");
  }
  var getPrototype = overArg(Object.getPrototypeOf, Object);
  var getPrototype$1 = getPrototype;
  var objectTag$3 = "[object Object]";
  var funcProto = Function.prototype, objectProto$4 = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
  var objectCtorString = funcToString.call(Object);
  function isPlainObject(value) {
    if (!isObjectLike(value) || baseGetTag(value) != objectTag$3) {
      return false;
    }
    var proto = getPrototype$1(value);
    if (proto === null) {
      return true;
    }
    var Ctor = hasOwnProperty$3.call(proto, "constructor") && proto.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
  }
  function baseSlice(array, start2, end2) {
    var index2 = -1, length = array.length;
    if (start2 < 0) {
      start2 = -start2 > length ? 0 : length + start2;
    }
    end2 = end2 > length ? length : end2;
    if (end2 < 0) {
      end2 += length;
    }
    length = start2 > end2 ? 0 : end2 - start2 >>> 0;
    start2 >>>= 0;
    var result = Array(length);
    while (++index2 < length) {
      result[index2] = array[index2 + start2];
    }
    return result;
  }
  function castSlice(array, start2, end2) {
    var length = array.length;
    end2 = end2 === void 0 ? length : end2;
    return !start2 && end2 >= length ? array : baseSlice(array, start2, end2);
  }
  var rsAstralRange$2 = "\\ud800-\\udfff", rsComboMarksRange$3 = "\\u0300-\\u036f", reComboHalfMarksRange$3 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$3 = "\\u20d0-\\u20ff", rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3, rsVarRange$2 = "\\ufe0e\\ufe0f";
  var rsZWJ$2 = "\\u200d";
  var reHasUnicode = RegExp("[" + rsZWJ$2 + rsAstralRange$2 + rsComboRange$3 + rsVarRange$2 + "]");
  function hasUnicode(string) {
    return reHasUnicode.test(string);
  }
  function asciiToArray(string) {
    return string.split("");
  }
  var rsAstralRange$1 = "\\ud800-\\udfff", rsComboMarksRange$2 = "\\u0300-\\u036f", reComboHalfMarksRange$2 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$2 = "\\u20d0-\\u20ff", rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2, rsVarRange$1 = "\\ufe0e\\ufe0f";
  var rsAstral = "[" + rsAstralRange$1 + "]", rsCombo$2 = "[" + rsComboRange$2 + "]", rsFitz$1 = "\\ud83c[\\udffb-\\udfff]", rsModifier$1 = "(?:" + rsCombo$2 + "|" + rsFitz$1 + ")", rsNonAstral$1 = "[^" + rsAstralRange$1 + "]", rsRegional$1 = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair$1 = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ$1 = "\\u200d";
  var reOptMod$1 = rsModifier$1 + "?", rsOptVar$1 = "[" + rsVarRange$1 + "]?", rsOptJoin$1 = "(?:" + rsZWJ$1 + "(?:" + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join("|") + ")" + rsOptVar$1 + reOptMod$1 + ")*", rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1, rsSymbol = "(?:" + [rsNonAstral$1 + rsCombo$2 + "?", rsCombo$2, rsRegional$1, rsSurrPair$1, rsAstral].join("|") + ")";
  var reUnicode = RegExp(rsFitz$1 + "(?=" + rsFitz$1 + ")|" + rsSymbol + rsSeq$1, "g");
  function unicodeToArray(string) {
    return string.match(reUnicode) || [];
  }
  function stringToArray(string) {
    return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
  }
  function createCaseFirst(methodName) {
    return function(string) {
      string = toString(string);
      var strSymbols = hasUnicode(string) ? stringToArray(string) : void 0;
      var chr = strSymbols ? strSymbols[0] : string.charAt(0);
      var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
      return chr[methodName]() + trailing;
    };
  }
  var upperFirst = createCaseFirst("toUpperCase");
  var upperFirst$1 = upperFirst;
  function capitalize(string) {
    return upperFirst$1(toString(string).toLowerCase());
  }
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index2 = -1, length = array == null ? 0 : array.length;
    if (initAccum && length) {
      accumulator = array[++index2];
    }
    while (++index2 < length) {
      accumulator = iteratee(accumulator, array[index2], index2, array);
    }
    return accumulator;
  }
  function basePropertyOf(object) {
    return function(key) {
      return object == null ? void 0 : object[key];
    };
  }
  var deburredLetters = {
    "\xC0": "A",
    "\xC1": "A",
    "\xC2": "A",
    "\xC3": "A",
    "\xC4": "A",
    "\xC5": "A",
    "\xE0": "a",
    "\xE1": "a",
    "\xE2": "a",
    "\xE3": "a",
    "\xE4": "a",
    "\xE5": "a",
    "\xC7": "C",
    "\xE7": "c",
    "\xD0": "D",
    "\xF0": "d",
    "\xC8": "E",
    "\xC9": "E",
    "\xCA": "E",
    "\xCB": "E",
    "\xE8": "e",
    "\xE9": "e",
    "\xEA": "e",
    "\xEB": "e",
    "\xCC": "I",
    "\xCD": "I",
    "\xCE": "I",
    "\xCF": "I",
    "\xEC": "i",
    "\xED": "i",
    "\xEE": "i",
    "\xEF": "i",
    "\xD1": "N",
    "\xF1": "n",
    "\xD2": "O",
    "\xD3": "O",
    "\xD4": "O",
    "\xD5": "O",
    "\xD6": "O",
    "\xD8": "O",
    "\xF2": "o",
    "\xF3": "o",
    "\xF4": "o",
    "\xF5": "o",
    "\xF6": "o",
    "\xF8": "o",
    "\xD9": "U",
    "\xDA": "U",
    "\xDB": "U",
    "\xDC": "U",
    "\xF9": "u",
    "\xFA": "u",
    "\xFB": "u",
    "\xFC": "u",
    "\xDD": "Y",
    "\xFD": "y",
    "\xFF": "y",
    "\xC6": "Ae",
    "\xE6": "ae",
    "\xDE": "Th",
    "\xFE": "th",
    "\xDF": "ss",
    "\u0100": "A",
    "\u0102": "A",
    "\u0104": "A",
    "\u0101": "a",
    "\u0103": "a",
    "\u0105": "a",
    "\u0106": "C",
    "\u0108": "C",
    "\u010A": "C",
    "\u010C": "C",
    "\u0107": "c",
    "\u0109": "c",
    "\u010B": "c",
    "\u010D": "c",
    "\u010E": "D",
    "\u0110": "D",
    "\u010F": "d",
    "\u0111": "d",
    "\u0112": "E",
    "\u0114": "E",
    "\u0116": "E",
    "\u0118": "E",
    "\u011A": "E",
    "\u0113": "e",
    "\u0115": "e",
    "\u0117": "e",
    "\u0119": "e",
    "\u011B": "e",
    "\u011C": "G",
    "\u011E": "G",
    "\u0120": "G",
    "\u0122": "G",
    "\u011D": "g",
    "\u011F": "g",
    "\u0121": "g",
    "\u0123": "g",
    "\u0124": "H",
    "\u0126": "H",
    "\u0125": "h",
    "\u0127": "h",
    "\u0128": "I",
    "\u012A": "I",
    "\u012C": "I",
    "\u012E": "I",
    "\u0130": "I",
    "\u0129": "i",
    "\u012B": "i",
    "\u012D": "i",
    "\u012F": "i",
    "\u0131": "i",
    "\u0134": "J",
    "\u0135": "j",
    "\u0136": "K",
    "\u0137": "k",
    "\u0138": "k",
    "\u0139": "L",
    "\u013B": "L",
    "\u013D": "L",
    "\u013F": "L",
    "\u0141": "L",
    "\u013A": "l",
    "\u013C": "l",
    "\u013E": "l",
    "\u0140": "l",
    "\u0142": "l",
    "\u0143": "N",
    "\u0145": "N",
    "\u0147": "N",
    "\u014A": "N",
    "\u0144": "n",
    "\u0146": "n",
    "\u0148": "n",
    "\u014B": "n",
    "\u014C": "O",
    "\u014E": "O",
    "\u0150": "O",
    "\u014D": "o",
    "\u014F": "o",
    "\u0151": "o",
    "\u0154": "R",
    "\u0156": "R",
    "\u0158": "R",
    "\u0155": "r",
    "\u0157": "r",
    "\u0159": "r",
    "\u015A": "S",
    "\u015C": "S",
    "\u015E": "S",
    "\u0160": "S",
    "\u015B": "s",
    "\u015D": "s",
    "\u015F": "s",
    "\u0161": "s",
    "\u0162": "T",
    "\u0164": "T",
    "\u0166": "T",
    "\u0163": "t",
    "\u0165": "t",
    "\u0167": "t",
    "\u0168": "U",
    "\u016A": "U",
    "\u016C": "U",
    "\u016E": "U",
    "\u0170": "U",
    "\u0172": "U",
    "\u0169": "u",
    "\u016B": "u",
    "\u016D": "u",
    "\u016F": "u",
    "\u0171": "u",
    "\u0173": "u",
    "\u0174": "W",
    "\u0175": "w",
    "\u0176": "Y",
    "\u0177": "y",
    "\u0178": "Y",
    "\u0179": "Z",
    "\u017B": "Z",
    "\u017D": "Z",
    "\u017A": "z",
    "\u017C": "z",
    "\u017E": "z",
    "\u0132": "IJ",
    "\u0133": "ij",
    "\u0152": "Oe",
    "\u0153": "oe",
    "\u0149": "'n",
    "\u017F": "s"
  };
  var deburrLetter = basePropertyOf(deburredLetters);
  var deburrLetter$1 = deburrLetter;
  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
  var rsComboMarksRange$1 = "\\u0300-\\u036f", reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$1 = "\\u20d0-\\u20ff", rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;
  var rsCombo$1 = "[" + rsComboRange$1 + "]";
  var reComboMark = RegExp(rsCombo$1, "g");
  function deburr(string) {
    string = toString(string);
    return string && string.replace(reLatin, deburrLetter$1).replace(reComboMark, "");
  }
  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
  function asciiWords(string) {
    return string.match(reAsciiWord) || [];
  }
  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
  function hasUnicodeWord(string) {
    return reHasUnicodeWord.test(string);
  }
  var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
  var rsApos$1 = "['\u2019]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
  var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos$1 + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos$1 + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
  var reUnicodeWord = RegExp([
    rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
    rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
    rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
    rsUpper + "+" + rsOptContrUpper,
    rsOrdUpper,
    rsOrdLower,
    rsDigits,
    rsEmoji
  ].join("|"), "g");
  function unicodeWords(string) {
    return string.match(reUnicodeWord) || [];
  }
  function words(string, pattern, guard) {
    string = toString(string);
    pattern = guard ? void 0 : pattern;
    if (pattern === void 0) {
      return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
    }
    return string.match(pattern) || [];
  }
  var rsApos = "['\u2019]";
  var reApos = RegExp(rsApos, "g");
  function createCompounder(callback) {
    return function(string) {
      return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
    };
  }
  var camelCase = createCompounder(function(result, word, index2) {
    word = word.toLowerCase();
    return result + (index2 ? capitalize(word) : word);
  });
  var camelCase$1 = camelCase;
  function baseClamp(number, lower, upper) {
    if (number === number) {
      if (upper !== void 0) {
        number = number <= upper ? number : upper;
      }
      if (lower !== void 0) {
        number = number >= lower ? number : lower;
      }
    }
    return number;
  }
  function clamp(number, lower, upper) {
    if (upper === void 0) {
      upper = lower;
      lower = void 0;
    }
    if (upper !== void 0) {
      upper = toNumber(upper);
      upper = upper === upper ? upper : 0;
    }
    if (lower !== void 0) {
      lower = toNumber(lower);
      lower = lower === lower ? lower : 0;
    }
    return baseClamp(toNumber(number), lower, upper);
  }
  function stackClear() {
    this.__data__ = new ListCache();
    this.size = 0;
  }
  function stackDelete(key) {
    var data2 = this.__data__, result = data2["delete"](key);
    this.size = data2.size;
    return result;
  }
  function stackGet(key) {
    return this.__data__.get(key);
  }
  function stackHas(key) {
    return this.__data__.has(key);
  }
  var LARGE_ARRAY_SIZE$1 = 200;
  function stackSet(key, value) {
    var data2 = this.__data__;
    if (data2 instanceof ListCache) {
      var pairs = data2.__data__;
      if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE$1 - 1) {
        pairs.push([key, value]);
        this.size = ++data2.size;
        return this;
      }
      data2 = this.__data__ = new MapCache(pairs);
    }
    data2.set(key, value);
    this.size = data2.size;
    return this;
  }
  function Stack(entries) {
    var data2 = this.__data__ = new ListCache(entries);
    this.size = data2.size;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  function baseAssign(object, source) {
    return object && copyObject(source, keys(source), object);
  }
  function baseAssignIn(object, source) {
    return object && copyObject(source, keysIn(source), object);
  }
  var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer$1 = moduleExports ? root$1.Buffer : void 0, allocUnsafe = Buffer$1 ? Buffer$1.allocUnsafe : void 0;
  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
    buffer.copy(result);
    return result;
  }
  function arrayFilter(array, predicate) {
    var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
    while (++index2 < length) {
      var value = array[index2];
      if (predicate(value, index2, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }
  function stubArray() {
    return [];
  }
  var objectProto$3 = Object.prototype;
  var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;
  var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
  var getSymbols = !nativeGetSymbols$1 ? stubArray : function(object) {
    if (object == null) {
      return [];
    }
    object = Object(object);
    return arrayFilter(nativeGetSymbols$1(object), function(symbol) {
      return propertyIsEnumerable.call(object, symbol);
    });
  };
  var getSymbols$1 = getSymbols;
  function copySymbols(source, object) {
    return copyObject(source, getSymbols$1(source), object);
  }
  var nativeGetSymbols = Object.getOwnPropertySymbols;
  var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
    var result = [];
    while (object) {
      arrayPush(result, getSymbols$1(object));
      object = getPrototype$1(object);
    }
    return result;
  };
  var getSymbolsIn$1 = getSymbolsIn;
  function copySymbolsIn(source, object) {
    return copyObject(source, getSymbolsIn$1(source), object);
  }
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray$1(object) ? result : arrayPush(result, symbolsFunc(object));
  }
  function getAllKeys(object) {
    return baseGetAllKeys(object, keys, getSymbols$1);
  }
  function getAllKeysIn(object) {
    return baseGetAllKeys(object, keysIn, getSymbolsIn$1);
  }
  var DataView = getNative(root$1, "DataView");
  var DataView$1 = DataView;
  var Promise$1 = getNative(root$1, "Promise");
  var Promise$2 = Promise$1;
  var Set$1 = getNative(root$1, "Set");
  var Set$2 = Set$1;
  var mapTag$4 = "[object Map]", objectTag$2 = "[object Object]", promiseTag = "[object Promise]", setTag$4 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
  var dataViewTag$3 = "[object DataView]";
  var dataViewCtorString = toSource(DataView$1), mapCtorString = toSource(Map$2), promiseCtorString = toSource(Promise$2), setCtorString = toSource(Set$2), weakMapCtorString = toSource(WeakMap$1);
  var getTag = baseGetTag;
  if (DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag$3 || Map$2 && getTag(new Map$2()) != mapTag$4 || Promise$2 && getTag(Promise$2.resolve()) != promiseTag || Set$2 && getTag(new Set$2()) != setTag$4 || WeakMap$1 && getTag(new WeakMap$1()) != weakMapTag$1) {
    getTag = function(value) {
      var result = baseGetTag(value), Ctor = result == objectTag$2 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag$3;
          case mapCtorString:
            return mapTag$4;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag$4;
          case weakMapCtorString:
            return weakMapTag$1;
        }
      }
      return result;
    };
  }
  var getTag$1 = getTag;
  var objectProto$2 = Object.prototype;
  var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
  function initCloneArray(array) {
    var length = array.length, result = new array.constructor(length);
    if (length && typeof array[0] == "string" && hasOwnProperty$2.call(array, "index")) {
      result.index = array.index;
      result.input = array.input;
    }
    return result;
  }
  var Uint8Array$1 = root$1.Uint8Array;
  var Uint8Array$2 = Uint8Array$1;
  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array$2(result).set(new Uint8Array$2(arrayBuffer));
    return result;
  }
  function cloneDataView(dataView, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
  }
  var reFlags = /\w*$/;
  function cloneRegExp(regexp) {
    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result.lastIndex = regexp.lastIndex;
    return result;
  }
  var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : void 0;
  function cloneSymbol(symbol) {
    return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
  }
  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }
  var boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", mapTag$3 = "[object Map]", numberTag$2 = "[object Number]", regexpTag$2 = "[object RegExp]", setTag$3 = "[object Set]", stringTag$2 = "[object String]", symbolTag$2 = "[object Symbol]";
  var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
  function initCloneByTag(object, tag, isDeep) {
    var Ctor = object.constructor;
    switch (tag) {
      case arrayBufferTag$2:
        return cloneArrayBuffer(object);
      case boolTag$2:
      case dateTag$2:
        return new Ctor(+object);
      case dataViewTag$2:
        return cloneDataView(object, isDeep);
      case float32Tag$1:
      case float64Tag$1:
      case int8Tag$1:
      case int16Tag$1:
      case int32Tag$1:
      case uint8Tag$1:
      case uint8ClampedTag$1:
      case uint16Tag$1:
      case uint32Tag$1:
        return cloneTypedArray(object, isDeep);
      case mapTag$3:
        return new Ctor();
      case numberTag$2:
      case stringTag$2:
        return new Ctor(object);
      case regexpTag$2:
        return cloneRegExp(object);
      case setTag$3:
        return new Ctor();
      case symbolTag$2:
        return cloneSymbol(object);
    }
  }
  function initCloneObject(object) {
    return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate$1(getPrototype$1(object)) : {};
  }
  var mapTag$2 = "[object Map]";
  function baseIsMap(value) {
    return isObjectLike(value) && getTag$1(value) == mapTag$2;
  }
  var nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap;
  var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
  var isMap$1 = isMap;
  var setTag$2 = "[object Set]";
  function baseIsSet(value) {
    return isObjectLike(value) && getTag$1(value) == setTag$2;
  }
  var nodeIsSet = nodeUtil$1 && nodeUtil$1.isSet;
  var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
  var isSet$1 = isSet;
  var CLONE_DEEP_FLAG$2 = 1, CLONE_FLAT_FLAG$1 = 2, CLONE_SYMBOLS_FLAG$2 = 4;
  var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag$1 = "[object Map]", numberTag$1 = "[object Number]", objectTag$1 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$1 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]", weakMapTag = "[object WeakMap]";
  var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var cloneableTags = {};
  cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$1] = cloneableTags[dataViewTag$1] = cloneableTags[boolTag$1] = cloneableTags[dateTag$1] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag$1] = cloneableTags[numberTag$1] = cloneableTags[objectTag$1] = cloneableTags[regexpTag$1] = cloneableTags[setTag$1] = cloneableTags[stringTag$1] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag$1] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
  function baseClone(value, bitmask, customizer, key, object, stack) {
    var result, isDeep = bitmask & CLONE_DEEP_FLAG$2, isFlat = bitmask & CLONE_FLAT_FLAG$1, isFull = bitmask & CLONE_SYMBOLS_FLAG$2;
    if (customizer) {
      result = object ? customizer(value, key, object, stack) : customizer(value);
    }
    if (result !== void 0) {
      return result;
    }
    if (!isObject(value)) {
      return value;
    }
    var isArr = isArray$1(value);
    if (isArr) {
      result = initCloneArray(value);
      if (!isDeep) {
        return copyArray(value, result);
      }
    } else {
      var tag = getTag$1(value), isFunc = tag == funcTag || tag == genTag;
      if (isBuffer$1(value)) {
        return cloneBuffer(value, isDeep);
      }
      if (tag == objectTag$1 || tag == argsTag$1 || isFunc && !object) {
        result = isFlat || isFunc ? {} : initCloneObject(value);
        if (!isDeep) {
          return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
        }
      } else {
        if (!cloneableTags[tag]) {
          return object ? value : {};
        }
        result = initCloneByTag(value, tag, isDeep);
      }
    }
    stack || (stack = new Stack());
    var stacked = stack.get(value);
    if (stacked) {
      return stacked;
    }
    stack.set(value, result);
    if (isSet$1(value)) {
      value.forEach(function(subValue) {
        result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
      });
    } else if (isMap$1(value)) {
      value.forEach(function(subValue, key2) {
        result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
      });
    }
    var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
    var props = isArr ? void 0 : keysFunc(value);
    arrayEach(props || value, function(subValue, key2) {
      if (props) {
        key2 = subValue;
        subValue = value[key2];
      }
      assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
    });
    return result;
  }
  var CLONE_DEEP_FLAG$1 = 1, CLONE_SYMBOLS_FLAG$1 = 4;
  function cloneDeep(value) {
    return baseClone(value, CLONE_DEEP_FLAG$1 | CLONE_SYMBOLS_FLAG$1);
  }
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  function SetCache(values) {
    var index2 = -1, length = values == null ? 0 : values.length;
    this.__data__ = new MapCache();
    while (++index2 < length) {
      this.add(values[index2]);
    }
  }
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  function arraySome(array, predicate) {
    var index2 = -1, length = array == null ? 0 : array.length;
    while (++index2 < length) {
      if (predicate(array[index2], index2, array)) {
        return true;
      }
    }
    return false;
  }
  function cacheHas(cache2, key) {
    return cache2.has(key);
  }
  var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    var arrStacked = stack.get(array);
    var othStacked = stack.get(other);
    if (arrStacked && othStacked) {
      return arrStacked == other && othStacked == array;
    }
    var index2 = -1, result = true, seen2 = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
    stack.set(array, other);
    stack.set(other, array);
    while (++index2 < arrLength) {
      var arrValue = array[index2], othValue = other[index2];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
      }
      if (compared !== void 0) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      if (seen2) {
        if (!arraySome(other, function(othValue2, othIndex) {
          if (!cacheHas(seen2, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
            return seen2.push(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
        result = false;
        break;
      }
    }
    stack["delete"](array);
    stack["delete"](other);
    return result;
  }
  function mapToArray(map) {
    var index2 = -1, result = Array(map.size);
    map.forEach(function(value, key) {
      result[++index2] = [key, value];
    });
    return result;
  }
  function setToArray(set2) {
    var index2 = -1, result = Array(set2.size);
    set2.forEach(function(value) {
      result[++index2] = value;
    });
    return result;
  }
  var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
  var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
  var symbolProto = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag:
        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
          return false;
        }
        object = object.buffer;
        other = other.buffer;
      case arrayBufferTag:
        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$2(object), new Uint8Array$2(other))) {
          return false;
        }
        return true;
      case boolTag:
      case dateTag:
      case numberTag:
        return eq(+object, +other);
      case errorTag:
        return object.name == other.name && object.message == other.message;
      case regexpTag:
      case stringTag:
        return object == other + "";
      case mapTag:
        var convert = mapToArray;
      case setTag:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
        convert || (convert = setToArray);
        if (object.size != other.size && !isPartial) {
          return false;
        }
        var stacked = stack.get(object);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= COMPARE_UNORDERED_FLAG$2;
        stack.set(object, other);
        var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
        stack["delete"](object);
        return result;
      case symbolTag:
        if (symbolValueOf) {
          return symbolValueOf.call(object) == symbolValueOf.call(other);
        }
    }
    return false;
  }
  var COMPARE_PARTIAL_FLAG$3 = 1;
  var objectProto$1 = Object.prototype;
  var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index2 = objLength;
    while (index2--) {
      var key = objProps[index2];
      if (!(isPartial ? key in other : hasOwnProperty$1.call(other, key))) {
        return false;
      }
    }
    var objStacked = stack.get(object);
    var othStacked = stack.get(other);
    if (objStacked && othStacked) {
      return objStacked == other && othStacked == object;
    }
    var result = true;
    stack.set(object, other);
    stack.set(other, object);
    var skipCtor = isPartial;
    while (++index2 < objLength) {
      key = objProps[index2];
      var objValue = object[key], othValue = other[key];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
      }
      if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key == "constructor");
    }
    if (result && !skipCtor) {
      var objCtor = object.constructor, othCtor = other.constructor;
      if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack["delete"](object);
    stack["delete"](other);
    return result;
  }
  var COMPARE_PARTIAL_FLAG$2 = 1;
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray$1(object), othIsArr = isArray$1(other), objTag = objIsArr ? arrayTag : getTag$1(object), othTag = othIsArr ? arrayTag : getTag$1(other);
    objTag = objTag == argsTag ? objectTag : objTag;
    othTag = othTag == argsTag ? objectTag : othTag;
    var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
    if (isSameTag && isBuffer$1(object)) {
      if (!isBuffer$1(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack || (stack = new Stack());
      return objIsArr || isTypedArray$1(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
      var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
        stack || (stack = new Stack());
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack || (stack = new Stack());
    return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
  }
  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
  }
  var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
  function baseIsMatch(object, source, matchData, customizer) {
    var index2 = matchData.length, length = index2, noCustomizer = !customizer;
    if (object == null) {
      return !length;
    }
    object = Object(object);
    while (index2--) {
      var data2 = matchData[index2];
      if (noCustomizer && data2[2] ? data2[1] !== object[data2[0]] : !(data2[0] in object)) {
        return false;
      }
    }
    while (++index2 < length) {
      data2 = matchData[index2];
      var key = data2[0], objValue = object[key], srcValue = data2[1];
      if (noCustomizer && data2[2]) {
        if (objValue === void 0 && !(key in object)) {
          return false;
        }
      } else {
        var stack = new Stack();
        if (customizer) {
          var result = customizer(objValue, srcValue, key, object, source, stack);
        }
        if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {
          return false;
        }
      }
    }
    return true;
  }
  function isStrictComparable(value) {
    return value === value && !isObject(value);
  }
  function getMatchData(object) {
    var result = keys(object), length = result.length;
    while (length--) {
      var key = result[length], value = object[key];
      result[length] = [key, value, isStrictComparable(value)];
    }
    return result;
  }
  function matchesStrictComparable(key, srcValue) {
    return function(object) {
      if (object == null) {
        return false;
      }
      return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
    };
  }
  function baseMatches(source) {
    var matchData = getMatchData(source);
    if (matchData.length == 1 && matchData[0][2]) {
      return matchesStrictComparable(matchData[0][0], matchData[0][1]);
    }
    return function(object) {
      return object === source || baseIsMatch(object, source, matchData);
    };
  }
  function baseHasIn(object, key) {
    return object != null && key in Object(object);
  }
  function hasPath(object, path, hasFunc) {
    path = castPath(path, object);
    var index2 = -1, length = path.length, result = false;
    while (++index2 < length) {
      var key = toKey(path[index2]);
      if (!(result = object != null && hasFunc(object, key))) {
        break;
      }
      object = object[key];
    }
    if (result || ++index2 != length) {
      return result;
    }
    length = object == null ? 0 : object.length;
    return !!length && isLength(length) && isIndex(key, length) && (isArray$1(object) || isArguments$1(object));
  }
  function hasIn(object, path) {
    return object != null && hasPath(object, path, baseHasIn);
  }
  var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  function baseMatchesProperty(path, srcValue) {
    if (isKey(path) && isStrictComparable(srcValue)) {
      return matchesStrictComparable(toKey(path), srcValue);
    }
    return function(object) {
      var objValue = get(object, path);
      return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
    };
  }
  function baseProperty(key) {
    return function(object) {
      return object == null ? void 0 : object[key];
    };
  }
  function basePropertyDeep(path) {
    return function(object) {
      return baseGet(object, path);
    };
  }
  function property(path) {
    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
  }
  function baseIteratee(value) {
    if (typeof value == "function") {
      return value;
    }
    if (value == null) {
      return identity$1;
    }
    if (typeof value == "object") {
      return isArray$1(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
    }
    return property(value);
  }
  function createBaseFor(fromRight) {
    return function(object, iteratee, keysFunc) {
      var index2 = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
      while (length--) {
        var key = props[fromRight ? length : ++index2];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object;
    };
  }
  var baseFor = createBaseFor();
  var baseFor$1 = baseFor;
  function baseForOwn(object, iteratee) {
    return object && baseFor$1(object, iteratee, keys);
  }
  function createBaseEach(eachFunc, fromRight) {
    return function(collection, iteratee) {
      if (collection == null) {
        return collection;
      }
      if (!isArrayLike(collection)) {
        return eachFunc(collection, iteratee);
      }
      var length = collection.length, index2 = fromRight ? length : -1, iterable = Object(collection);
      while (fromRight ? index2-- : ++index2 < length) {
        if (iteratee(iterable[index2], index2, iterable) === false) {
          break;
        }
      }
      return collection;
    };
  }
  var baseEach = createBaseEach(baseForOwn);
  var baseEach$1 = baseEach;
  var now = function() {
    return root$1.Date.now();
  };
  var now$1 = now;
  var FUNC_ERROR_TEXT = "Expected a function";
  var nativeMax$1 = Math.max, nativeMin = Math.min;
  function debounce$1(func, wait, options2) {
    var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    wait = toNumber(wait) || 0;
    if (isObject(options2)) {
      leading = !!options2.leading;
      maxing = "maxWait" in options2;
      maxWait = maxing ? nativeMax$1(toNumber(options2.maxWait) || 0, wait) : maxWait;
      trailing = "trailing" in options2 ? !!options2.trailing : trailing;
    }
    function invokeFunc(time) {
      var args = lastArgs, thisArg = lastThis;
      lastArgs = lastThis = void 0;
      lastInvokeTime = time;
      result = func.apply(thisArg, args);
      return result;
    }
    function leadingEdge(time) {
      lastInvokeTime = time;
      timerId = setTimeout(timerExpired, wait);
      return leading ? invokeFunc(time) : result;
    }
    function remainingWait(time) {
      var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
      return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
    }
    function shouldInvoke(time) {
      var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
      return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
    }
    function timerExpired() {
      var time = now$1();
      if (shouldInvoke(time)) {
        return trailingEdge(time);
      }
      timerId = setTimeout(timerExpired, remainingWait(time));
    }
    function trailingEdge(time) {
      timerId = void 0;
      if (trailing && lastArgs) {
        return invokeFunc(time);
      }
      lastArgs = lastThis = void 0;
      return result;
    }
    function cancel() {
      if (timerId !== void 0) {
        clearTimeout(timerId);
      }
      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = void 0;
    }
    function flush() {
      return timerId === void 0 ? result : trailingEdge(now$1());
    }
    function debounced() {
      var time = now$1(), isInvoking = shouldInvoke(time);
      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time;
      if (isInvoking) {
        if (timerId === void 0) {
          return leadingEdge(lastCallTime);
        }
        if (maxing) {
          clearTimeout(timerId);
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (timerId === void 0) {
        timerId = setTimeout(timerExpired, wait);
      }
      return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }
  function assignMergeValue(object, key, value) {
    if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
      baseAssignValue(object, key, value);
    }
  }
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }
  function safeGet(object, key) {
    if (key === "constructor" && typeof object[key] === "function") {
      return;
    }
    if (key == "__proto__") {
      return;
    }
    return object[key];
  }
  function toPlainObject(value) {
    return copyObject(value, keysIn(value));
  }
  function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
    var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
    if (stacked) {
      assignMergeValue(object, key, stacked);
      return;
    }
    var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
    var isCommon = newValue === void 0;
    if (isCommon) {
      var isArr = isArray$1(srcValue), isBuff = !isArr && isBuffer$1(srcValue), isTyped = !isArr && !isBuff && isTypedArray$1(srcValue);
      newValue = srcValue;
      if (isArr || isBuff || isTyped) {
        if (isArray$1(objValue)) {
          newValue = objValue;
        } else if (isArrayLikeObject(objValue)) {
          newValue = copyArray(objValue);
        } else if (isBuff) {
          isCommon = false;
          newValue = cloneBuffer(srcValue, true);
        } else if (isTyped) {
          isCommon = false;
          newValue = cloneTypedArray(srcValue, true);
        } else {
          newValue = [];
        }
      } else if (isPlainObject(srcValue) || isArguments$1(srcValue)) {
        newValue = objValue;
        if (isArguments$1(objValue)) {
          newValue = toPlainObject(objValue);
        } else if (!isObject(objValue) || isFunction(objValue)) {
          newValue = initCloneObject(srcValue);
        }
      } else {
        isCommon = false;
      }
    }
    if (isCommon) {
      stack.set(srcValue, newValue);
      mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
      stack["delete"](srcValue);
    }
    assignMergeValue(object, key, newValue);
  }
  function baseMerge(object, source, srcIndex, customizer, stack) {
    if (object === source) {
      return;
    }
    baseFor$1(source, function(srcValue, key) {
      stack || (stack = new Stack());
      if (isObject(srcValue)) {
        baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
      } else {
        var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
        if (newValue === void 0) {
          newValue = srcValue;
        }
        assignMergeValue(object, key, newValue);
      }
    }, keysIn);
  }
  var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
    baseMerge(object, source, srcIndex, customizer);
  });
  var mergeWith$1 = mergeWith;
  function arrayIncludesWith(array, value, comparator) {
    var index2 = -1, length = array == null ? 0 : array.length;
    while (++index2 < length) {
      if (comparator(value, array[index2])) {
        return true;
      }
    }
    return false;
  }
  function last(array) {
    var length = array == null ? 0 : array.length;
    return length ? array[length - 1] : void 0;
  }
  function castFunction(value) {
    return typeof value == "function" ? value : identity$1;
  }
  function forEach(collection, iteratee) {
    var func = isArray$1(collection) ? arrayEach : baseEach$1;
    return func(collection, castFunction(iteratee));
  }
  var htmlEscapes = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;"
  };
  var escapeHtmlChar = basePropertyOf(htmlEscapes);
  var escapeHtmlChar$1 = escapeHtmlChar;
  var reUnescapedHtml = /[&<>"']/g, reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
  function escape$1(string) {
    string = toString(string);
    return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar$1) : string;
  }
  function baseFilter(collection, predicate) {
    var result = [];
    baseEach$1(collection, function(value, index2, collection2) {
      if (predicate(value, index2, collection2)) {
        result.push(value);
      }
    });
    return result;
  }
  function filter(collection, predicate) {
    var func = isArray$1(collection) ? arrayFilter : baseFilter;
    return func(collection, baseIteratee(predicate));
  }
  function createFind(findIndexFunc) {
    return function(collection, predicate, fromIndex) {
      var iterable = Object(collection);
      if (!isArrayLike(collection)) {
        var iteratee = baseIteratee(predicate);
        collection = keys(collection);
        predicate = function(key) {
          return iteratee(iterable[key], key, iterable);
        };
      }
      var index2 = findIndexFunc(collection, predicate, fromIndex);
      return index2 > -1 ? iterable[iteratee ? collection[index2] : index2] : void 0;
    };
  }
  var nativeMax = Math.max;
  function findIndex(array, predicate, fromIndex) {
    var length = array == null ? 0 : array.length;
    if (!length) {
      return -1;
    }
    var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
    if (index2 < 0) {
      index2 = nativeMax(length + index2, 0);
    }
    return baseFindIndex(array, baseIteratee(predicate), index2);
  }
  var find = createFind(findIndex);
  var find$1 = find;
  function baseMap(collection, iteratee) {
    var index2 = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
    baseEach$1(collection, function(value, key, collection2) {
      result[++index2] = iteratee(value, key, collection2);
    });
    return result;
  }
  function parent$1(object, path) {
    return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
  }
  function isEqual$1(value, other) {
    return baseIsEqual(value, other);
  }
  var kebabCase = createCompounder(function(result, word, index2) {
    return result + (index2 ? "-" : "") + word.toLowerCase();
  });
  var kebabCase$1 = kebabCase;
  var merge = createAssigner(function(object, source, srcIndex) {
    baseMerge(object, source, srcIndex);
  });
  var merge$1 = merge;
  function baseUnset(object, path) {
    path = castPath(path, object);
    object = parent$1(object, path);
    return object == null || delete object[toKey(last(path))];
  }
  function customOmitClone(value) {
    return isPlainObject(value) ? void 0 : value;
  }
  var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
  var omit = flatRest(function(object, paths) {
    var result = {};
    if (object == null) {
      return result;
    }
    var isDeep = false;
    paths = arrayMap(paths, function(path) {
      path = castPath(path, object);
      isDeep || (isDeep = path.length > 1);
      return path;
    });
    copyObject(object, getAllKeysIn(object), result);
    if (isDeep) {
      result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
    }
    var length = paths.length;
    while (length--) {
      baseUnset(result, paths[length]);
    }
    return result;
  });
  var omit$1 = omit;
  function baseSet(object, path, value, customizer) {
    if (!isObject(object)) {
      return object;
    }
    path = castPath(path, object);
    var index2 = -1, length = path.length, lastIndex = length - 1, nested = object;
    while (nested != null && ++index2 < length) {
      var key = toKey(path[index2]), newValue = value;
      if (key === "__proto__" || key === "constructor" || key === "prototype") {
        return object;
      }
      if (index2 != lastIndex) {
        var objValue = nested[key];
        newValue = customizer ? customizer(objValue, key, nested) : void 0;
        if (newValue === void 0) {
          newValue = isObject(objValue) ? objValue : isIndex(path[index2 + 1]) ? [] : {};
        }
      }
      assignValue(nested, key, newValue);
      nested = nested[key];
    }
    return object;
  }
  function baseSortBy(array, comparer) {
    var length = array.length;
    array.sort(comparer);
    while (length--) {
      array[length] = array[length].value;
    }
    return array;
  }
  function compareAscending(value, other) {
    if (value !== other) {
      var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
      var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
      if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
        return 1;
      }
      if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
        return -1;
      }
    }
    return 0;
  }
  function compareMultiple(object, other, orders) {
    var index2 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
    while (++index2 < length) {
      var result = compareAscending(objCriteria[index2], othCriteria[index2]);
      if (result) {
        if (index2 >= ordersLength) {
          return result;
        }
        var order2 = orders[index2];
        return result * (order2 == "desc" ? -1 : 1);
      }
    }
    return object.index - other.index;
  }
  function baseOrderBy(collection, iteratees, orders) {
    if (iteratees.length) {
      iteratees = arrayMap(iteratees, function(iteratee) {
        if (isArray$1(iteratee)) {
          return function(value) {
            return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
          };
        }
        return iteratee;
      });
    } else {
      iteratees = [identity$1];
    }
    var index2 = -1;
    iteratees = arrayMap(iteratees, baseUnary(baseIteratee));
    var result = baseMap(collection, function(value, key, collection2) {
      var criteria = arrayMap(iteratees, function(iteratee) {
        return iteratee(value);
      });
      return { "criteria": criteria, "index": ++index2, "value": value };
    });
    return baseSortBy(result, function(object, other) {
      return compareMultiple(object, other, orders);
    });
  }
  function orderBy(collection, iteratees, orders, guard) {
    if (collection == null) {
      return [];
    }
    if (!isArray$1(iteratees)) {
      iteratees = iteratees == null ? [] : [iteratees];
    }
    orders = guard ? void 0 : orders;
    if (!isArray$1(orders)) {
      orders = orders == null ? [] : [orders];
    }
    return baseOrderBy(collection, iteratees, orders);
  }
  function baseIndexOfWith(array, value, fromIndex, comparator) {
    var index2 = fromIndex - 1, length = array.length;
    while (++index2 < length) {
      if (comparator(array[index2], value)) {
        return index2;
      }
    }
    return -1;
  }
  var arrayProto = Array.prototype;
  var splice = arrayProto.splice;
  function basePullAll(array, values, iteratee, comparator) {
    var indexOf = comparator ? baseIndexOfWith : baseIndexOf, index2 = -1, length = values.length, seen2 = array;
    if (array === values) {
      values = copyArray(values);
    }
    if (iteratee) {
      seen2 = arrayMap(array, baseUnary(iteratee));
    }
    while (++index2 < length) {
      var fromIndex = 0, value = values[index2], computed = iteratee ? iteratee(value) : value;
      while ((fromIndex = indexOf(seen2, computed, fromIndex, comparator)) > -1) {
        if (seen2 !== array) {
          splice.call(seen2, fromIndex, 1);
        }
        splice.call(array, fromIndex, 1);
      }
    }
    return array;
  }
  function pullAll(array, values) {
    return array && array.length && values && values.length ? basePullAll(array, values) : array;
  }
  var pull = baseRest(pullAll);
  var pull$1 = pull;
  function set(object, path, value) {
    return object == null ? object : baseSet(object, path, value);
  }
  var startCase = createCompounder(function(result, word, index2) {
    return result + (index2 ? " " : "") + upperFirst$1(word);
  });
  var startCase$1 = startCase;
  var INFINITY = 1 / 0;
  var createSet = !(Set$2 && 1 / setToArray(new Set$2([, -0]))[1] == INFINITY) ? noop : function(values) {
    return new Set$2(values);
  };
  var createSet$1 = createSet;
  var LARGE_ARRAY_SIZE = 200;
  function baseUniq(array, iteratee, comparator) {
    var index2 = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen2 = result;
    if (comparator) {
      isCommon = false;
      includes = arrayIncludesWith;
    } else if (length >= LARGE_ARRAY_SIZE) {
      var set2 = iteratee ? null : createSet$1(array);
      if (set2) {
        return setToArray(set2);
      }
      isCommon = false;
      includes = cacheHas;
      seen2 = new SetCache();
    } else {
      seen2 = iteratee ? [] : result;
    }
    outer:
      while (++index2 < length) {
        var value = array[index2], computed = iteratee ? iteratee(value) : value;
        value = comparator || value !== 0 ? value : 0;
        if (isCommon && computed === computed) {
          var seenIndex = seen2.length;
          while (seenIndex--) {
            if (seen2[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen2.push(computed);
          }
          result.push(value);
        } else if (!includes(seen2, computed, comparator)) {
          if (seen2 !== result) {
            seen2.push(computed);
          }
          result.push(value);
        }
      }
    return result;
  }
  var unionBy = baseRest(function(arrays) {
    var iteratee = last(arrays);
    if (isArrayLikeObject(iteratee)) {
      iteratee = void 0;
    }
    return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), baseIteratee(iteratee));
  });
  var unionBy$1 = unionBy;
  function uniq(array) {
    return array && array.length ? baseUniq(array) : [];
  }
  function unset(object, path) {
    return object == null ? true : baseUnset(object, path);
  }
  function baseUpdate(object, path, updater, customizer) {
    return baseSet(object, path, updater(baseGet(object, path)), customizer);
  }
  function update(object, path, updater) {
    return object == null ? object : baseUpdate(object, path, castFunction(updater));
  }
  const useBuilderOptionsStore = defineStore("builderOptions", () => {
    const isLoading = Vue.ref(false);
    let fetched = false;
    const options2 = Vue.ref({
      allowed_post_types: ["post", "page"],
      google_fonts: [],
      custom_fonts: [],
      typekit_token: "",
      typekit_fonts: [],
      local_colors: [],
      global_colors: [],
      local_gradients: [],
      global_gradients: [],
      user_roles_permissions: {},
      users_permissions: {},
      custom_code: ""
    });
    if (!fetched) {
      fetchOptions();
    }
    function fetchOptions(force = false) {
      if (fetched && !force) {
        return Promise.resolve(options2.value);
      }
      return getSavedOptions().then((response) => {
        const data2 = response.data;
        if (Array.isArray(data2.user_roles_permissions)) {
          data2.user_roles_permissions = {};
        }
        if (Array.isArray(data2.users_permissions)) {
          data2.users_permissions = {};
        }
        options2.value = __spreadValues(__spreadValues({}, options2.value), data2);
      }).finally(() => {
        fetched = true;
      });
    }
    function getOptionValue(optionId, defaultValue = null) {
      return get(options2.value, optionId, defaultValue);
    }
    function updateOptionValue2(path, newValue, saveOptions2 = true) {
      update(options2.value, path, () => newValue);
      if (saveOptions2) {
        saveOptionsToDB();
      }
    }
    function deleteOptionValue(path, saveOptions2 = true) {
      const clonedValues = cloneDeep(options2.value);
      unset(clonedValues, path);
      options2.value = clonedValues;
      if (saveOptions2) {
        saveOptionsToDB();
      }
    }
    function saveOptionsToDB() {
      return __async(this, null, function* () {
        isLoading.value = true;
        try {
          return yield saveOptions(options2.value);
        } finally {
          isLoading.value = false;
        }
      });
    }
    const debouncedSaveOptions = debounce$1(saveOptionsToDB, 700);
    function updateGoogleFont(fontFamily, newValue) {
      const savedFont = options2.value.google_fonts.find((fontItem) => fontItem.font_family === fontFamily);
      if (savedFont) {
        const fontIndex = options2.value.google_fonts.indexOf(savedFont);
        options2.value.google_fonts.splice(fontIndex, 1, newValue);
      }
      saveOptionsToDB();
    }
    function removeGoogleFont(fontFamily) {
      const savedFont = options2.value.google_fonts.find((fontItem) => fontItem.font_family === fontFamily);
      if (savedFont) {
        const fontIndex = options2.value.google_fonts.indexOf(savedFont);
        options2.value.google_fonts.splice(fontIndex, 1);
      } else {
        console.warn("Font for deletion was not found");
      }
      saveOptionsToDB();
    }
    function addGoogleFont(fontFamily) {
      options2.value.google_fonts.push({
        font_family: fontFamily,
        font_variants: ["regular"],
        font_subset: ["latin"]
      });
      saveOptionsToDB();
    }
    function addLocalColor(color) {
      options2.value.local_colors.push(color);
      saveOptionsToDB();
    }
    function deleteLocalColor(color) {
      const colorIndex = options2.value.local_colors.indexOf(color);
      if (colorIndex !== -1) {
        options2.value.local_colors.splice(colorIndex, 1);
      }
      saveOptionsToDB();
    }
    function editLocalColor(color, newColor, saveToDB = true) {
      const colorIndex = options2.value.local_colors.indexOf(color);
      if (colorIndex !== -1) {
        options2.value.local_colors.splice(colorIndex, 1, newColor);
      }
      if (saveToDB) {
        saveOptionsToDB();
      }
    }
    function addGlobalColor(color) {
      options2.value.global_colors.push(color);
      saveOptionsToDB();
    }
    function deleteGlobalColor(color) {
      const colorIndex = options2.value.global_colors.indexOf(color);
      if (colorIndex !== -1) {
        options2.value.global_colors.splice(colorIndex, 1);
      }
      saveOptionsToDB();
    }
    function editGlobalColor(index2, newColor, saveToDB = true) {
      const colorToChange = __spreadValues({}, options2.value.global_colors[index2]);
      colorToChange["color"] = newColor;
      options2.value.global_colors.splice(index2, 1, colorToChange);
      if (saveToDB) {
        saveOptionsToDB();
      }
    }
    function addCustomFont(font) {
      options2.value.custom_fonts.push(font);
      saveOptionsToDB();
    }
    function updateCustomFont(fontFamily, newValue) {
      const savedFont = options2.value.custom_fonts.find((fontItem) => fontItem.font_family === fontFamily);
      if (savedFont) {
        const fontIndex = options2.value.custom_fonts.indexOf(savedFont);
        options2.value.custom_fonts.splice(fontIndex, 1, newValue);
      }
      saveOptionsToDB();
    }
    function deleteCustomFont(fontFamily) {
      const savedFont = options2.value.custom_fonts.find((fontItem) => fontItem.font_family === fontFamily);
      if (savedFont) {
        const fontIndex = options2.value.custom_fonts.indexOf(savedFont);
        options2.value.custom_fonts.splice(fontIndex, 1);
      } else {
        console.warn("Font for deletion was not found");
      }
      saveOptionsToDB();
    }
    function addLocalGradient(gradient) {
      options2.value.local_gradients.push(gradient);
      saveOptionsToDB();
    }
    function deleteLocalGradient(gradient) {
      const gradientIndex = options2.value.local_gradients.indexOf(gradient);
      if (gradientIndex !== -1) {
        options2.value.local_gradients.splice(gradientIndex, 1);
      }
      saveOptionsToDB();
    }
    function editLocalGradient(gradientId, newgradient) {
      const editedGradient = options2.value.local_gradients.find((gradient) => gradient.id === gradientId);
      if (editedGradient) {
        editedGradient.config = newgradient;
      }
    }
    function addGlobalGradient(gradient) {
      options2.value.global_gradients.push(gradient);
      saveOptionsToDB();
    }
    function deleteGlobalGradient(gradient) {
      const gradientIndex = options2.value.global_gradients.indexOf(gradient);
      if (gradientIndex !== -1) {
        options2.value.global_gradients.splice(gradientIndex, 1);
      }
      saveOptionsToDB();
    }
    function editGlobalGradient(gradientId, newgradient) {
      const editedGradient = options2.value.global_gradients.find((gradient) => gradient.id === gradientId);
      if (editedGradient) {
        editedGradient.config = newgradient;
      }
    }
    function addTypeKitToken(token) {
      options2.value.typekit_token = token;
    }
    function addFontProject(fontId) {
      const fontIndex = options2.value.typekit_fonts.indexOf(fontId);
      if (fontIndex === -1) {
        options2.value.typekit_fonts.push(fontId);
      }
      saveOptionsToDB();
    }
    function removeFontProject(fontId) {
      const fontIndex = options2.value.typekit_fonts.indexOf(fontId);
      if (fontIndex !== -1) {
        options2.value.typekit_fonts.splice(fontIndex, 1);
      }
      saveOptionsToDB();
    }
    function addUserPermissions(user) {
      options2.value.users_permissions[user.id] = {};
      saveOptionsToDB();
    }
    function editUserPermission(userID, newValues) {
      options2.value.users_permissions[userID] = newValues;
      saveOptionsToDB();
    }
    function deleteUserPermission(userID) {
      delete options2.value.users_permissions[userID];
      saveOptionsToDB();
    }
    function getUserPermissions(userID) {
      return options2.value.users_permissions[userID];
    }
    function getRolePermissions(roleID) {
      return options2.value.user_roles_permissions[roleID] || {
        allowed_access: false,
        permissions: {
          only_content: false,
          features: [],
          post_types: []
        }
      };
    }
    function editRolePermission(roleID, newValues) {
      options2.value.user_roles_permissions[roleID] = newValues;
      saveOptionsToDB();
    }
    return {
      isLoading,
      fetched,
      options: options2,
      fetchOptions,
      getOptionValue,
      updateOptionValue: updateOptionValue2,
      deleteOptionValue,
      saveOptionsToDB,
      editRolePermission,
      getRolePermissions,
      getUserPermissions,
      editUserPermission,
      deleteUserPermission,
      addUserPermissions,
      removeFontProject,
      addFontProject,
      addTypeKitToken,
      editGlobalGradient,
      deleteGlobalGradient,
      addGlobalGradient,
      editLocalGradient,
      deleteLocalGradient,
      addLocalGradient,
      deleteCustomFont,
      updateCustomFont,
      addCustomFont,
      editGlobalColor,
      removeGoogleFont,
      updateGoogleFont,
      addGoogleFont,
      addLocalColor,
      deleteLocalColor,
      editLocalColor,
      addGlobalColor,
      deleteGlobalColor,
      debouncedSaveOptions
    };
  });
  const useGoogleFontsStore = defineStore("googleFonts", {
    state: () => {
      return {
        isLoading: false,
        fetched: false,
        fonts: []
      };
    },
    getters: {
      getFontData: (state) => {
        return (family) => state.fonts.find((font) => font["family"] == family);
      }
    },
    actions: {
      fetchGoogleFonts(force = false) {
        if (this.fetched && !force) {
          return Promise.resolve(this.fonts);
        }
        return getGoogleFonts().then((response) => {
          this.fonts = response.data;
        });
      }
    }
  });
  class Notification {
    constructor(data2) {
      __publicField(this, "title", "");
      __publicField(this, "message", "");
      __publicField(this, "type", "info");
      __publicField(this, "delayClose", 5e3);
      Object.assign(this, data2);
    }
    remove() {
      const notificationsStore = useNotificationsStore();
      notificationsStore.remove(this);
    }
  }
  const useNotificationsStore = defineStore("notifications", {
    state: () => {
      return {
        notifications: []
      };
    },
    actions: {
      add(data2) {
        this.notifications.push(new Notification(data2));
      },
      remove(notification) {
        const index2 = this.notifications.indexOf(notification);
        this.notifications.splice(index2, 1);
      }
    }
  });
  const useUsersStore = defineStore("usersStore", () => {
    const loadedUsers = Vue.ref([]);
    function fetchUsersData(userIDs) {
      return getUsersById(userIDs).then((response) => {
        if (Array.isArray(response.data)) {
          response.data.forEach((user) => loadedUsers.value.push(user));
        }
      });
    }
    function getUserInfo(userID) {
      return loadedUsers.value.find((user) => user.id === userID);
    }
    function addUser(user) {
      loadedUsers.value.push(user);
    }
    return {
      loadedUsers,
      fetchUsersData,
      addUser,
      getUserInfo
    };
  });
  const useDataSetsStore = defineStore("dataSets", () => {
    let loaded2 = false;
    const dataSets = Vue.ref({
      fonts_list: {
        google_fonts: [],
        custom_fonts: [],
        typekit_fonts: []
      },
      user_roles: [],
      post_types: [],
      taxonomies: [],
      icons: [],
      image_sizes: []
    });
    if (!loaded2) {
      getFontsDataSet().then((response) => {
        dataSets.value = response.data;
        loaded2 = true;
      });
    }
    const fontsListForOption = Vue.computed(() => {
      let option = [
        {
          id: "Arial",
          name: "Arial"
        },
        {
          id: "Times New Roman",
          name: "Times New Roman"
        },
        {
          id: "Verdana",
          name: "Verdana"
        },
        {
          id: "Trebuchet",
          name: "Trebuchet"
        },
        {
          id: "Georgia",
          name: "Georgia"
        },
        {
          id: "Segoe UI",
          name: "Segoe UI"
        }
      ];
      const fontsProviders = dataSets.value.fonts_list;
      Object.keys(fontsProviders).forEach((fontProviderId) => {
        const fontsList = fontsProviders[fontProviderId];
        option = [...fontsList, ...option];
      });
      return option;
    });
    const addIconsSet = (iconSet) => {
      dataSets.value.icons.push(iconSet);
    };
    const deleteIconSet = (icons) => {
      const iconsPackage = dataSets.value.icons.find((iconSet) => {
        return iconSet.id === icons;
      });
      if (iconsPackage !== void 0) {
        const iconsPackageIndex = dataSets.value.icons.indexOf(iconsPackage);
        dataSets.value.icons.splice(iconsPackageIndex, 1);
      }
    };
    return {
      dataSets,
      fontsListForOption,
      addIconsSet,
      deleteIconSet
    };
  });
  const useAssetsStore = defineStore("assets", {
    state: () => {
      return {
        isLoading: false,
        currentIndex: 0,
        filesCount: 0
      };
    },
    actions: {
      regenerateCache() {
        return __async(this, null, function* () {
          this.isLoading = true;
          try {
            const { data: cacheFiles } = yield getCacheList();
            this.filesCount = cacheFiles.length;
            if (this.filesCount > 0) {
              for (const fileData of cacheFiles) {
                try {
                  this.currentIndex++;
                  yield regenerateCache(fileData);
                } catch (error) {
                  console.error(error);
                }
              }
            }
          } catch (error) {
            console.error(error);
          }
          this.isLoading = false;
          this.filesCount = 0;
          this.currentIndex = 0;
        });
      },
      finish() {
        return finishRegeneration();
      }
    }
  });
  class LibrarySource {
    constructor(librarySource) {
      __publicField(this, "name", "");
      __publicField(this, "id", "");
      __publicField(this, "url", "");
      __publicField(this, "request_headers", []);
      __publicField(this, "use_cache", false);
      __publicField(this, "items", []);
      __publicField(this, "categories", []);
      __publicField(this, "loading", false);
      __publicField(this, "loaded", false);
      __publicField(this, "type", "remote");
      Object.assign(this, librarySource);
    }
    getData(useCache = true) {
      if (this.loaded && useCache) {
        return;
      } else if (useCache && this.use_cache && localstorageTtl.get(`znpbLibraryCache_${this.id}`)) {
        const savedData = localstorageTtl.get(`znpbLibraryCache_${this.id}`);
        if (savedData) {
          const { items: items2, categories } = savedData;
          this.categories = categories;
          this.setItems(items2);
          this.loaded = true;
        }
      } else {
        this.loading = true;
        fetch(this.url, {
          headers: this.request_headers
        }).then((response) => {
          return response.json().then((data2) => {
            if (!response.ok) {
              const { add } = useNotificationsStore();
              if (data2 == null ? void 0 : data2.message) {
                add({
                  message: data2.message,
                  type: "error",
                  delayClose: 5e3
                });
              }
              return;
            }
            const { categories = {}, items: items2 = [] } = data2;
            this.categories = Object.values(categories);
            this.setItems(items2);
            this.loaded = true;
            if (this.use_cache) {
              this.saveToCache(Object.values(categories), items2);
            }
          });
        }).finally(() => {
          this.loading = false;
        });
      }
    }
    setItems(items2) {
      this.items = items2.map((item) => new LibraryItem$1(item, this));
    }
    removeItem(item) {
      const index2 = this.items.indexOf(item);
      this.items.splice(index2, 1);
      this.deleteCache();
    }
    addItem(item) {
      this.items.push(new LibraryItem$1(item, this));
      this.deleteCache();
    }
    saveToCache(categories, items2) {
      localstorageTtl.set(
        `znpbLibraryCache_${this.id}`,
        {
          categories,
          items: items2
        },
        6048e5
      );
    }
    deleteCache() {
      localStorage.removeItem(`znpbLibraryCache_${this.id}`.toString());
    }
  }
  class LocalLibrary extends LibrarySource {
    importItem(templateData) {
      this.loading = true;
      return importLibraryItem(this.id, templateData).then((response) => {
        this.addItem(response.data);
        return Promise.resolve(response);
      }).finally(() => {
        this.loading = false;
      });
    }
    removeItem(item) {
      return deleteLibraryItem(this.id, item.id).then((response) => {
        super.removeItem(item);
        return Promise.resolve(response);
      });
    }
    createItem(item) {
      this.loading = true;
      return addLibraryItem(this.id, item).then((response) => {
        if (response.data) {
          this.addItem(response.data);
        }
        return Promise.resolve(response);
      }).finally(() => {
        this.loading = false;
      });
    }
  }
  const activeElement = Vue.ref(null);
  const librarySources = Vue.ref({});
  const useLibrary = () => {
    function getElementForInsert() {
      const { element, config } = activeElement.value;
      const { placement = "inside" } = config;
      if (placement === "inside" && (element.isWrapper || element.element_type === "contentRoot")) {
        return {
          element
        };
      } else {
        const index2 = element.getIndexInParent() + 1;
        return {
          element: element.parent,
          index: index2
        };
      }
    }
    function insertElement(newElement) {
      const { element, index: index2 = -1 } = getElementForInsert();
      newElement = Array.isArray(newElement) ? newElement : [newElement];
      element.addChildren(newElement, index2);
    }
    function addSources2(sources) {
      Object.keys(sources).forEach((sourceID) => {
        addSource(sources[sourceID]);
      });
    }
    function getSourceType(sourceType) {
      const { applyFilters: applyFilters2 } = window.zb.hooks;
      const sourceTypes = applyFilters2("zionbuilder/library/sourceTypes", {
        local: LocalLibrary
      });
      return typeof sourceTypes[sourceType] !== "undefined" ? sourceTypes[sourceType] : LibrarySource;
    }
    function addSource(source) {
      const sourceType = getSourceType(source.type);
      librarySources.value[source.id] = new sourceType(source);
    }
    function getSource(sourceID) {
      return librarySources.value[sourceID];
    }
    return {
      activeElement,
      insertElement,
      addSources: addSources2,
      addSource,
      getSource,
      librarySources
    };
  };
  const units = [
    "auto",
    "fit-content",
    "inherit",
    "initial",
    "max-content",
    "min-content",
    "unset",
    "normal",
    "left",
    "right",
    "top",
    "bottom",
    "center"
  ];
  const registeredLocations = {};
  const useInjections = () => {
    const registerComponent = (location2, component) => {
      if (!location2 && !component) {
        console.warn("You need to specify a location and a component in order to register an injection component.", {
          location: location2,
          component
        });
        return false;
      }
      if (!Array.isArray(registeredLocations[location2])) {
        registeredLocations[location2] = [];
      }
      registeredLocations[location2].push(component);
    };
    const getComponentsForLocation = (location2) => {
      if (!location2) {
        console.warn("You need to specify a location and a component in order to get injection components.", {
          location: location2
        });
        return false;
      }
      if (!Array.isArray(registeredLocations[location2])) {
        return [];
      }
      return registeredLocations[location2];
    };
    return {
      registerComponent,
      getComponentsForLocation,
      registeredLocations
    };
  };
  var ListScroll_vue_vue_type_style_index_0_lang = "";
  const __default__$1a = {
    name: "ListScroll"
  };
  const _sfc_main$35 = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$1a), {
    props: {
      loading: { type: Boolean, default: true }
    },
    emits: ["scroll-end"],
    setup(__props, { emit }) {
      const listScrollRef = Vue.ref(null);
      function onScroll(event2) {
        if (listScrollRef.value.scrollHeight - Math.round(listScrollRef.value.scrollTop) === listScrollRef.value.clientHeight) {
          emit("scroll-end");
        }
      }
      return (_ctx, _cache) => {
        const _component_Loader = Vue.resolveComponent("Loader");
        return Vue.openBlock(), Vue.createElementBlock("div", {
          class: Vue.normalizeClass(["znpb-scroll-list-wrapper", { "znpb-scroll-list-wrapper--loading": __props.loading }])
        }, [
          Vue.createElementVNode("div", {
            ref_key: "listScrollRef",
            ref: listScrollRef,
            class: "znpb-fancy-scrollbar znpb-scroll-list-container",
            onWheelPassive: onScroll
          }, [
            Vue.renderSlot(_ctx.$slots, "default")
          ], 544),
          Vue.createVNode(Vue.Transition, { name: "fadeFromBottom" }, {
            default: Vue.withCtx(() => [
              __props.loading ? (Vue.openBlock(), Vue.createBlock(_component_Loader, { key: 0 })) : Vue.createCommentVNode("", true)
            ]),
            _: 1
          })
        ], 2);
      };
    }
  }));
  const SvgIcons = [
    {
      paths: [
        "M11 0C4.9 0 0 4.9 0 11s4.9 11 11 11c1 0 1.8-.9 1.8-1.8 0-.5-.1-.9-.5-1.2-.2-.4-.5-.7-.5-1.2 0-1 .9-1.8 1.8-1.8h2.2c3.4 0 6.1-2.7 6.1-6.1C22 4.4 17.1 0 11 0zM4.3 11c-1 0-1.8-.9-1.8-1.8s.9-1.8 1.8-1.8 1.8.9 1.8 1.8S5.3 11 4.3 11zm3.6-4.9c-1 0-1.8-.9-1.8-1.8S7 2.4 7.9 2.4s1.8.9 1.8 1.8-.8 1.9-1.8 1.9zm6.2 0c-1 0-1.8-.9-1.8-1.8s.9-1.8 1.8-1.8 1.8.9 1.8 1.8-.9 1.8-1.8 1.8zm3.6 4.9c-1 0-1.8-.9-1.8-1.8s.9-1.8 1.8-1.8 1.8.9 1.8 1.8-.8 1.8-1.8 1.8z"
      ],
      tags: ["background"],
      viewBox: ["0 0 22 22"]
    },
    {
      paths: [
        "M20 0h2v22h-2z",
        "M0 2v2h2V2h2V0H0zM0 12h2v4H0zM0 6h2v4H0zM6 20h4v2H6zM2 18H0v4h4v-2H2zM18 20h2v2h-2zM6 0h4v2H6zM18 0h2v2h-2zM12 20h4v2h-4zM12 0h4v2h-4z"
      ],
      tags: ["borders"],
      viewBox: ["0 0 22 22"]
    },
    {
      paths: ["M20 2v8H2V2h18m2-2H0v12h22V0zM8 16v4H2v-4h6m2-2H0v8h10v-8zM20 16v4h-6v-4h6m2-2H12v8h10v-8z"],
      tags: ["display"],
      viewBox: ["0 0 22 22"]
    },
    {
      paths: [
        "M0 0l7.5 13v9l2.9-2 2.1-1.5 2-1.4V13L22 0H0zm9.5 18.2v-5.7L8.1 10 3.5 2h15.1L14 10l-1.4 2.5v3.6l-3.1 2.1z"
      ],
      tags: ["filters"],
      viewBox: ["0 0 22 22"]
    },
    {
      paths: [
        "M20 2v18H2V2h18m2-2H0v22h22V0z",
        "M14 7l-1.4 1.3 1.8 1.8H7.7l1.8-1.8L8 7l-4 4 1.3 1.3L8 15l1.4-1.3L7.7 12h6.7l-1.8 1.8L14 15l2.7-2.7L18 11l-4-4z"
      ],
      tags: ["size-spacing"],
      viewBox: ["0 0 22 22"]
    },
    {
      paths: ["M0 0v14h14V0H0zm12 12H2V2h10v10z", "M16 4v2h4v14H6v-4H4v6h18V4z"],
      tags: ["transform"],
      viewBox: ["0 0 22 22"]
    },
    {
      paths: [],
      circle: ['cx="6" cy="16" r="6"', 'cx="11" cy="11" r="6"', 'cx="16" cy="6" r="6"'],
      tags: ["transitions"],
      viewBox: ["0 0 22 22"]
    },
    {
      paths: [
        "M18.3 7.6c-1.4 0-2.6.3-3.6.9v2c.9-.8 2-1.2 3.1-1.2 1.3 0 2 .7 2 2.1l-2.9.4c-2.2.3-3.2 1.4-3.2 3.3 0 .8.3 1.6.8 2.1s1.3.8 2.2.8c1.3 0 2.3-.6 3-1.8v1.5H22v-6.5c0-2.3-1.3-3.6-3.7-3.6zm.9 7.9c-.4.4-1 .7-1.7.7-.5 0-.9-.2-1.2-.4-.3-.3-.5-.6-.5-1 0-.6.2-.9.5-1.2.3-.3.8-.4 1.5-.5l2-.3v.8c0 .9-.2 1.4-.6 1.9zM5.1 4L0 17.7h2.5l1.2-3.5h5.4l1.3 3.5h2.5L7.7 4H5.1zm-.8 8.4l1.8-5.5c0-.2.2-.5.2-.8 0 .4.1.7.2.8l1.9 5.5H4.3z"
      ],
      tags: ["typography"],
      viewBox: ["0 0 22 22"]
    },
    {
      paths: [
        "M28 6H7.7l2.2-2.2L7.1 1 0 8.1l7.1 7 2.8-2.8L7.6 10H28zM0 18.1h20.3l-2.2-2.2 2.8-2.8 7.1 7-7.1 7.1-2.8-2.8 2.3-2.3H0z"
      ],
      tags: ["reverse"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: [
        "M25 25l5.5-2.8 5.5-2.7L47 14 25 3 3 14l11 5.5L3 25l11 5.5L3 36l22 11v-5.5L13.9 36l5.5-2.8L25 36v-5.5L13.9 25l5.5-2.8L25 25zM13.9 14L25 8.5 36.1 14 25 19.5 13.9 14z",
        "M39.1 25h-5.3v6.2h-6.2v5.2h6.2v6.2h5.3v-6.2h6.1v-5.2h-6.1z"
      ],
      tags: ["dynamic"]
    },
    {
      paths: [
        "M38.8 30.9l-1.1-1.1c-.1-.1-.2-.3-.2-.5v-1.1c0-.2-.2-.4-.4-.4h-.5c-.2 0-.3.1-.3.3l-.4 1.3c0 .2-.2.3-.3.3h-.3c-.1 0-.3-.1-.3-.2l-.5-1.1c-.1-.3-.4-.4-.7-.4h-1.1c-.1 0-.3 0-.4.1l-2.1 1.5c-.2.1-.3.2-.5.3l-3.5 1.4c-.3.1-.4.4-.4.7v.9c0 .2.1.4.2.5l1.1 1.1c.3.3.6.4 1 .4h1.2l1.9-.5c.8-.2 1.7 0 2.3.6l1.2 1.2c.3.3.6.4 1 .4H37c.4 0 .7-.1 1-.4l.8-.8c.3-.3.4-.6.4-1v-2.2c0-.7-.2-1-.4-1.3zM25 3C12.9 3 3 12.8 3 25s9.9 22 22 22 22-9.8 22-22S37.1 3 25 3zm0 39.7c-8.8 0-16.1-6.5-17.5-14.9h5.6c.4 0 .7-.1 1-.4l1.7-1.7c.3-.3.9-.2 1.1.2l2 4c.2.5.7.8 1.3.8h.5c.8 0 1.4-.6 1.4-1.4v-.8c0-.4-.1-.7-.4-1l-.5-.5c-.3-.3-.3-.7 0-1l.5-.5c.3-.3.6-.4 1-.4.5 0 1-.3 1.2-.7l1.5-2.6c.2-.3.6-.3.7 0 .1.2.4.4.6.4h.3c.4 0 .7-.3.7-.7v-6.9c0-.5-.3-1-.8-1.3l-1-.5c-.5-.2-.5-.9-.1-1.2l4.4-3.4c7.1 2.3 12.3 9 12.3 16.9.2 9.7-7.7 17.6-17.5 17.6z"
      ],
      tags: ["globe"]
    },
    {
      paths: [
        "M3 2C1.3 2 0 3.3 0 5s1.3 3 3 3 3-1.3 3-3-1.3-3-3-3zm0 18c-1.7 0-3 1.3-3 3s1.3 3 3 3 3-1.3 3-3-1.3-3-3-3zm0-9c-1.7 0-3 1.3-3 3s1.3 3 3 3 3-1.3 3-3-1.3-3-3-3z"
      ],
      tags: ["ite-move"],
      viewBox: ["0 0 6 28"]
    },
    {
      paths: [
        "M9.1 2.2L.2 25.8h4.3l1.9-5.5h9.2l1.9 5.5h4.3l-9-23.7H9.1zM7.5 17L11 7.2l3.4 9.8H7.5zm29.8 4.4v-7.9c0-1.9-.7-3.3-1.9-4.4-1.2-1-2.9-1.6-4.9-1.6-1.4 0-2.6.2-3.7.7-1.1.5-2 1.1-2.6 2-.6.8-1 1.7-1 2.7h4c0-.7.3-1.3.9-1.7.6-.4 1.3-.7 2.2-.7 1 0 1.8.3 2.3.8.5.5.8 1.3.8 2.2v1.2H31c-2.6 0-4.6.5-6 1.5-1.4 1-2.1 2.4-2.1 4.3 0 1.5.6 2.7 1.7 3.7s2.6 1.5 4.3 1.5c1.8 0 3.4-.7 4.6-2 .1.8.3 1.3.5 1.6h4V25c-.4-.7-.7-2-.7-3.6zm-3.9-.8c-.3.6-.9 1.1-1.6 1.5s-1.4.6-2.2.6c-.8 0-1.5-.2-2-.7-.5-.4-.8-1.1-.8-1.8 0-.9.4-1.7 1.1-2.2.7-.5 1.8-.8 3.3-.8h2.1v3.4z"
      ],
      tags: ["ite-font"],
      viewBox: ["0 0 38 28"]
    },
    {
      paths: [
        "M1.1 26V2h8.4c2.9 0 5.1.6 6.6 1.7s2.3 2.8 2.3 4.9c0 1.2-.3 2.2-.9 3.1-.6.9-1.4 1.6-2.5 2 1.2.3 2.2.9 2.9 1.9.7.9 1.1 2.1 1.1 3.4 0 2.3-.7 4.1-2.2 5.2-1.5 1.2-3.6 1.8-6.3 1.8H1.1zM6 12.1h3.7c2.5 0 3.7-1 3.7-3 0-1.1-.3-1.9-.9-2.3s-1.6-.8-3-.8H6v6.1zm0 3.4V22h4.2c1.2 0 2.1-.3 2.7-.8.7-.6 1-1.3 1-2.3 0-2.2-1.1-3.3-3.4-3.3H6z"
      ],
      tags: ["ite-weight"],
      viewBox: ["0 0 20 28"]
    },
    {
      paths: ["M3.9 23.2L6.8 4.7 4 4l.3-1.9 9.3-.1-.3 2-3 .7-3 18.5 2.9.7-.4 2.1H.5l.3-2.1 3.1-.7z"],
      tags: ["ite-italic"],
      viewBox: ["0 0 14 28"]
    },
    {
      paths: [
        "M5.5 21.8c-1.6-1.4-2.4-3.5-2.4-6V0h4.1v15.8c0 1.6.4 2.8 1.2 3.6.8.8 2 1.3 3.5 1.3 3.2 0 4.7-1.7 4.7-5V0h4.1v15.8c0 2.5-.8 4.5-2.4 6-1.5 1.5-3.6 2.2-6.3 2.2-2.7 0-4.9-.7-6.5-2.2zM0 26v2h24v-2H0z"
      ],
      tags: ["ite-underline"],
      viewBox: ["0 0 24 28"]
    },
    {
      paths: [
        "M9.1 2.1v.1L.2 25.8h4.3l1.9-5.5h9.2l1.9 5.5h4.3l-9-23.7H9.1zM7.5 17L11 7.3l3.4 9.8H7.5zM35.8 2.1h-3.7v.1l-8.9 23.6h4.3l1.9-5.5h9.2l1.9 5.5h4.3l-9-23.7zM30.5 17L34 7.3l3.4 9.8h-6.9z"
      ],
      tags: ["ite-uppercase"],
      viewBox: ["0 0 45 28"]
    },
    {
      paths: [
        "M15 4c-1.7-1.4-3.6-2-5.6-2-2.9 0-5.8 1.3-7.5 3.8C-1.2 10-.4 15.9 3.8 19.2c1 .6 1.9 1.1 3 1.5-1.6 1.8-3.6 3.3-5.9 4.4-.2.1-.3.2-.4.4 0 .1 0 .3.1.4s.2.1.4.1c2.9-.2 6-1 8.8-2.5 2.5-1.3 4.8-3.1 6.5-5.4.3-.3.5-.6.6-.9C20 13.1 19.2 7.2 15 4zm-1.1 10.8c-.2.2-.3.4-.5.6l-.1.1-.1.2c-.6.9-1.5 1.6-2.3 2.4l-3.2-1c-.7-.2-1.3-.6-1.9-1-2.5-1.9-3-5.5-1.1-8 1.1-1.4 2.8-2.2 4.6-2.2 1.2 0 2.4.4 3.4 1.1 2.6 1.8 3.1 5.3 1.2 7.8zM34.2 4c-1.7-1.4-3.6-2-5.6-2-2.9 0-5.8 1.3-7.5 3.8C18 10 18.8 15.9 23 19.2c1 .6 1.9 1.1 3 1.5-1.6 1.8-3.6 3.3-5.9 4.4-.2.1-.3.2-.4.4 0 .1 0 .3.1.4s.2.1.4.1c2.9-.2 6-1 8.8-2.5 2.5-1.3 4.8-3.1 6.5-5.4.3-.3.5-.6.6-.9 3.1-4.1 2.3-10-1.9-13.2zm-1.1 10.8c-.2.2-.3.4-.5.6l-.1.1-.1.2c-.6.9-1.5 1.6-2.3 2.4l-3.2-1c-.7-.2-1.3-.6-1.9-1-2.5-1.9-3-5.5-1.1-8 1.1-1.4 2.8-2.2 4.6-2.2 1.2 0 2.4.4 3.4 1.1 2.6 1.8 3.1 5.3 1.2 7.8z"
      ],
      tags: ["ite-quote"],
      viewBox: ["0 0 38 28"]
    },
    {
      paths: ["M24 2v4H0V2h24zM0 26h24v-4H0v4zm6-14v4h12v-4H6z"],
      tags: ["ite-alignment"],
      viewBox: ["0 0 24 28"]
    },
    {
      paths: [
        "M25.8 2.2c-3.1-3.1-8.1-3.1-11.1 0-4.2 4.2-4.2 4.2-4.5 4.6-2.5 3.2-2.3 7.7.5 10.5.6.6 1.4 1.1 2.1 1.5.2.1.3.1.5.1.3 0 .6-.1.8-.3l.2-.2c.6-.6.8-1.4.9-2 0-.6-.3-1-.7-1.1-.4-.2-.7-.4-1-.8-.8-.8-1.2-1.7-1.2-2.8 0-1.1.4-2.1 1.2-2.8l4-4c1.5-1.5 4.1-1.5 5.6 0s1.5 4.1 0 5.6L20.6 13c-.3.3-.3.7-.3.9v.1c.1.4.2.8.2 1.3 0 .2 0 .5.1.6 0 .5.3.9.7 1.1.4.2.9 0 1.2-.3l3.4-3.4c2.9-2.9 2.8-8-.1-11.1z",
        "M17.4 10.6c-.6-.6-1.4-1.1-1.9-1.5-.4-.3-1-.2-1.4.2l-.2.2c-.6.6-.8 1.4-.9 2 0 .6.3 1 .7 1.1.3.2.7.4 1 .8.8.8 1.2 1.7 1.2 2.8 0 1.1-.4 2.1-1.2 2.8l-4 4c-1.5 1.5-4.1 1.5-5.6 0s-1.5-4.1 0-5.6L7.5 15c.4-.2.5-.8.4-1.1-.2-.6-.3-1.3-.3-1.9 0-.4-.3-.8-.7-1-.4-.2-.9-.1-1.2.2l-3.4 3.4c-3.1 3.1-3.1 8.1 0 11.1C3.9 27.2 5.9 28 7.9 28c2 0 4-.8 5.6-2.3 2.1-2.2 3.2-3.2 3.7-3.8l.8-.8c2.6-3.1 2.3-7.7-.6-10.5z"
      ],
      tags: ["ite-link"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: [
        "M11.7 9.1L0 40.3h5.7l2.7-8h12.3l2.9 8h5.7L17.6 9.1h-5.9zM9.8 28.2L14 15.7c.1-.5.4-1.2.5-1.9h.1c.1 1 .2 1.5.4 1.9l4.3 12.5H9.8zm31.7-10.8c-3.1 0-5.8.7-8.1 2.1V24c2.1-1.8 4.5-2.7 7.1-2.7 3 0 4.5 1.5 4.5 4.8l-6.7 1c-4.9.7-7.3 3.1-7.3 7.4 0 1.9.6 3.6 1.9 4.8 1.2 1.2 3 1.8 5.1 1.8 3 0 5.2-1.3 6.8-4h.1v3.5H50V25.8c0-5.5-2.9-8.4-8.5-8.4zm3.6 13.9c0 1.7-.5 3-1.5 4S41.3 37 39.8 37c-1.2 0-2-.4-2.7-1-.7-.6-1.1-1.4-1.1-2.3 0-1.3.4-2.1 1.1-2.7.7-.6 1.8-.8 3.3-1.1l4.6-.6v1.9l.1.1z"
      ],
      tags: ["type-font"]
    },
    {
      paths: [
        "M11.9 14.6c1.5 0 3 .5 4.3 1.4 3.2 2.4 3.8 6.9 1.4 10-.2.2-.4.5-.6.7l-.1.1-.1.2c-.8 1.1-1.9 2-2.9 3l-4-1.3c-.9-.2-1.7-.7-2.4-1.2-3.2-2.4-3.8-6.9-1.4-10.1 1.4-1.8 3.5-2.8 5.8-2.8m0-4.7c-3.7 0-7.3 1.7-9.5 4.8-3.9 5.2-2.9 12.7 2.4 16.8 1.2.8 2.4 1.4 3.8 1.9-2 2.3-4.5 4.2-7.5 5.6-.2.1-.4.2-.5.5 0 .1 0 .4.1.5.1.1.4.2.6.2C5 40 8.9 38.9 12.4 37c3.2-1.7 6-3.9 8.2-6.8.4-.4.6-.7.8-1.1 3.9-5.2 2.9-12.7-2.4-16.7-2.1-1.8-4.6-2.5-7.1-2.5zM38.1 14.6c1.5 0 3 .5 4.3 1.4 3.2 2.4 3.8 6.9 1.4 10-.2.2-.4.5-.6.7l-.1.1-.1.2c-.8 1.1-1.9 2-2.9 3l-4-1.3c-.8-.2-1.7-.7-2.4-1.2-3.2-2.4-3.8-6.9-1.4-10.1 1.4-1.8 3.5-2.8 5.8-2.8m0-4.7c-3.7 0-7.3 1.7-9.5 4.8-3.9 5.2-2.9 12.7 2.4 16.8 1.2.8 2.4 1.4 3.8 1.9-2 2.3-4.5 4.2-7.5 5.6-.2.1-.4.2-.5.5 0 .1 0 .4.1.5.1.1.4.2.6.2 3.7-.2 7.6-1.3 11.1-3.2 3.2-1.7 6-3.9 8.2-6.8.4-.4.6-.7.8-1.1 3.9-5.2 2.9-12.7-2.4-16.7-2.1-1.8-4.6-2.5-7.1-2.5z"
      ],
      tags: ["quote"]
    },
    {
      paths: ["M0 24h28v4H0zM0 0h28v4H0zM2 16h10v6H2zM16 16h10v6H16zM16 6h10v6H16zM2 6h10v6H2z"],
      tags: ["content-stretch"],
      viewBox: ["0 0 25 28"]
    },
    {
      paths: [
        "M17.7 22c-.9-2.9-3.5-5-6.7-5s-5.8 2.1-6.7 5H0v4h4.3c.9 2.9 3.5 5 6.7 5s5.8-2.1 6.7-5H32v-4H17.7zM11 27c-.9 0-1.7-.4-2.2-1-.5-.5-.8-1.2-.8-2s.3-1.5.8-2c.5-.6 1.3-1 2.2-1s1.7.4 2.2 1c.5.5.8 1.2.8 2s-.3 1.5-.8 2c-.5.6-1.3 1-2.2 1zM27.7 6c-.9-2.9-3.5-5-6.7-5s-5.8 2.1-6.7 5H0v4h14.3c.9 2.9 3.5 5 6.7 5s5.8-2.1 6.7-5H32V6h-4.3zm-4.5 4c-.5.6-1.3 1-2.2 1s-1.7-.4-2.2-1c-.5-.5-.8-1.2-.8-2s.3-1.5.8-2c.5-.6 1.3-1 2.2-1s1.7.4 2.2 1c.5.5.8 1.2.8 2s-.3 1.5-.8 2z"
      ],
      tags: ["sliders"],
      viewBox: ["0 0 32 32"]
    },
    {
      paths: [
        "M6.6 16.9c0 .8-.6 1.5-1.4 1.5-.8 0-1.5-.6-1.5-1.5 0-.8.6-1.4 1.5-1.4.8 0 1.5.6 1.4 1.4zm-1.4 4.4c-.8 0-1.5.7-1.5 1.5s.6 1.5 1.5 1.5c.8 0 1.4-.7 1.4-1.5.1-.8-.6-1.5-1.4-1.5zm0-17.6c-.8 0-1.5.6-1.5 1.4 0 .8.6 1.5 1.5 1.5.8 0 1.4-.6 1.4-1.5.1-.8-.6-1.4-1.4-1.4zM.8 16.2c-.5 0-.8.3-.8.8 0 .4.3.8.8.8s.8-.4.8-.8c-.1-.5-.4-.8-.8-.8zm4.4-6.6c-.8 0-1.5.6-1.5 1.5 0 .8.6 1.5 1.5 1.5.8 0 1.4-.6 1.4-1.5S6 9.6 5.2 9.6zM17 1.5c.4 0 .8-.4.8-.8-.1-.4-.5-.7-.8-.7-.4 0-.8.3-.8.8 0 .3.3.7.8.7zm-6.5 5c1.2.4 2.3-.7 1.9-1.9-.2-.4-.5-.8-.9-.9-1.2-.4-2.3.7-1.9 1.9.2.4.6.8.9.9zm.5 20c-.4 0-.8.3-.8.8s.5.7.8.7c.4 0 .8-.3.8-.8 0-.4-.3-.7-.8-.7zm16.3-14.7c.4 0 .8-.3.8-.8s-.3-.8-.8-.8-.8.3-.8.8.3.8.8.8zM17 6.6c.8 0 1.5-.6 1.5-1.5 0-.8-.6-1.4-1.5-1.4-.8 0-1.5.6-1.5 1.4 0 .9.6 1.5 1.5 1.5zm-6-5.1c.4 0 .8-.4.8-.8S11.5 0 11 0c-.4 0-.8.3-.8.8.1.3.5.7.8.7zM.8 10.3c-.5 0-.8.3-.8.7s.3.8.8.8.8-.3.8-.8c-.1-.4-.4-.7-.8-.7zm22 5.2c-.8 0-1.4.6-1.4 1.4 0 .8.6 1.5 1.4 1.5.8 0 1.5-.6 1.5-1.5 0-.8-.6-1.4-1.5-1.4zM17 8.8c-1.2 0-2.2 1-2.2 2.2s1 2.2 2.2 2.2 2.2-1 2.2-2.2-1-2.2-2.2-2.2zm5.8.8c-.8 0-1.4.6-1.4 1.5 0 .8.6 1.5 1.4 1.5.8 0 1.5-.6 1.5-1.5s-.6-1.5-1.5-1.5zm0 11.7c-.8 0-1.4.7-1.4 1.5s.6 1.5 1.4 1.5c.8 0 1.5-.7 1.5-1.5s-.6-1.5-1.5-1.5zm-11.8.1c-.8 0-1.5.6-1.5 1.5 0 .8.6 1.5 1.5 1.5.8 0 1.5-.6 1.5-1.5s-.6-1.5-1.5-1.5zm16.3-5.2c-.4 0-.8.3-.8.8 0 .4.3.8.8.8s.7-.5.7-.8c0-.5-.3-.8-.7-.8zM22.8 3.7c-.8 0-1.4.6-1.4 1.4 0 .8.6 1.5 1.4 1.5.8 0 1.5-.6 1.5-1.5 0-.8-.6-1.4-1.5-1.4zM11 14.8c-1.2 0-2.2 1-2.2 2.2s1 2.2 2.2 2.2 2.2-1 2.2-2.2-.9-2.2-2.2-2.2zm0-6c-1.2 0-2.2 1-2.2 2.2s1 2.2 2.2 2.2 2.2-1 2.2-2.2-.9-2.2-2.2-2.2zm6 17.7c-.4 0-.8.3-.8.8s.3.7.8.7c.4 0 .8-.3.8-.8-.1-.4-.5-.7-.8-.7zm0-11.7c-1.2 0-2.2 1-2.2 2.2 0 1.2 1 2.2 2.2 2.2s2.2-1 2.2-2.2c0-1.3-1-2.2-2.2-2.2zm0 6.5c-.8 0-1.5.7-1.5 1.5s.7 1.5 1.5 1.5 1.5-.7 1.5-1.5c-.1-.8-.7-1.5-1.5-1.5z"
      ],
      viewBox: ["0 0 28 28"],
      tags: ["blur"]
    },
    {
      paths: [
        "M6.7 13l2.8-6.5h3.9l-4.8 9.6v5.4H4.8v-5.4L0 6.5h3.9L6.7 13z",
        "M24 7.2h4L22 0l-6 7.2h4v13.6h-4l6 7.2 6-7.2h-4z"
      ],
      viewBox: ["0 0 28 28"],
      tags: ["vertical"]
    },
    {
      paths: [
        "M14 5l2.5-5h4.1l-4.2 7.4 4.3 7.6h-4.2L14 9.9 11.5 15H7.3l4.3-7.6L7.4 0h4.1L14 5z",
        "M20.8 24v4l7.2-6-7.2-6v4H7.2v-4L0 22l7.2 6v-4z"
      ],
      viewBox: ["0 0 28 28"],
      tags: ["horizontal"]
    },
    {
      paths: ["M12 6h16v16H12z", "M0 10h8v8H0z"],
      viewBox: ["0 0 28 28"],
      tags: ["spread"]
    },
    {
      paths: ["M5 0v32h22V0H5zm18 28H9v-6h14v6zm0-10H9v-4h14v4zm0-8H9V4h14v6z"],
      tags: ["structure"],
      viewBox: ["0 0 32 32"]
    },
    {
      paths: ["M3 0v32h26V0H3zm22 28H7V4h18v24zm-11-4c0-1.1.9-2 2-2s2 .9 2 2-.9 2-2 2-2-.9-2-2z"],
      tags: ["tablet"],
      viewBox: ["0 0 32 32"]
    },
    {
      paths: [
        "M4 14c0-2.2 1.8-4 4-4h2.2l4-4H8c-4.4 0-8 3.6-8 8 0 1.7.6 3.3 1.5 4.7l2.9-2.9c-.2-.6-.4-1.2-.4-1.8zM23.8 7l1.5-1.5-2.8-2.8L2.7 22.5l2.8 2.8L8.8 22H20c4.4 0 8-3.6 8-8 0-3-1.7-5.6-4.2-7zM20 18h-7.2l7.9-7.9c1.8.4 3.2 2 3.2 3.9.1 2.2-1.7 4-3.9 4z"
      ],
      tags: ["unlink"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: [
        "M25 3C12.8 3 3 12.8 3 25s9.8 22 22 22 22-9.8 22-22S37.2 3 25 3zm0 38c-8.8 0-16-7.2-16-16S16.2 9 25 9s16 7.2 16 16-7.2 16-16 16z",
        "M22 14.5h6v12h-6zM22 29.5h6v6h-6z"
      ],
      tags: ["warning"]
    },
    {
      paths: ["M10.2 13.3l-4.3 4.3 14.9 14.8 4.2 4.3 19.1-19.1-4.3-4.3L25 28.2z"],
      tags: ["select"]
    },
    {
      paths: ["M28 14l-2.8 2.8-7.1 7.1-2.8-2.8 5-5.1H0v-4h20.3l-5-5.1 2.8-2.8 7.1 7.1L28 14z"],
      tags: ["long-arrow-right"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: ["M20 0v18H7.7l3.1-3.2L8 12l-5.2 5.2L0 20l2.8 2.8L8 28l2.8-2.8L7.7 22H24V0z"],
      tags: ["line-break"],
      viewBox: ["0 0 24 28"]
    },
    {
      paths: ["M32 7.5l-2.8-2.9-17.1 17.1-9.3-9.2L0 15.3l12.1 12.1z"],
      tags: ["check"],
      viewBox: ["0 0 32 32"]
    },
    {
      paths: ["M25.3 5.5l-2.8-2.8-8.5 8.5-8.5-8.5-2.8 2.8 8.5 8.5-8.5 8.5 2.8 2.8 8.5-8.5 8.5 8.5 2.8-2.8-8.5-8.5z"],
      tags: ["close"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: ["M22 2H8v4h14v14h4V2z", "M2 26h18V8H2v18zm4-14h10v10H6V12z"],
      tags: ["copy"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: ["M2 8h18v18H2V8zm20-6H8v4h14v14h4V2h-4z"],
      tags: ["paste"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: ["M25 6h-8V2h-6v4H3v4h3v16h16V10h3V6zm-7 16h-8V10h8v12z"],
      tags: ["delete"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: ["M17.5 2L6 13.5l-4 4V26h8.5l4-4L26 10.5 17.5 2zM8.8 22H6v-2.8L17.5 7.7l2.8 2.8L8.8 22z"],
      tags: ["edit"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: [
        "M18.7 10.7c.6-.2 1.6-1 1.6-2.3 0-1.7-1.4-2.8-3.2-2.4-6.7 1.6-8.8 4.3-8.8 8.6 0 .6.2 2.3.2 3.1 0 3.2-1.3 4.4-3.7 4.6C3 22.5 2 23.5 2 25c0 1.6 1.1 2.5 2.8 2.7 2.5.2 3.7 1.4 3.7 4.6 0 .7-.2 2.4-.2 3.1 0 4.3 2 7 8.8 8.6 1.8.4 3.2-.7 3.2-2.4 0-1.3-.9-2-1.6-2.3-3.4-1.2-4-2.5-4-4.9 0-.9.2-2.4.2-3.3 0-3.3-1.7-5.1-4.6-6 3-1.1 4.6-2.8 4.6-6 0-1-.2-2.5-.2-3.3 0-2.6.6-3.8 4-5.1zM45.1 22.3c-2.5-.2-3.7-1.4-3.7-4.6 0-.7.2-2.4.2-3.1 0-4.3-2-7-8.8-8.6-1.8-.4-3.2.7-3.2 2.4 0 1.3.9 2 1.6 2.3 3.4 1.2 4 2.5 4 4.9 0 .9-.2 2.4-.2 3.3 0 3.3 1.7 5.1 4.6 6-3 1.1-4.6 2.8-4.6 6 0 1 .2 2.5.2 3.3 0 2.5-.6 3.7-4 4.9-.6.2-1.6 1-1.6 2.3 0 1.7 1.4 2.8 3.2 2.4 6.7-1.6 8.8-4.3 8.8-8.6 0-.6-.2-2.3-.2-3.1 0-3.2 1.3-4.4 3.7-4.6 1.8-.2 2.8-1.2 2.8-2.7 0-1.4-1.1-2.3-2.8-2.5z"
      ],
      tags: ["braces"]
    },
    {
      paths: [
        "M34.3 12.3L30 16.5l5.5 5.5h-21l5.5-5.5-4.3-4.2L3 25l4.2 4.2 8.5 8.5 4.3-4.2-5.5-5.5h21L30 33.5l4.3 4.2 8.5-8.5L47 25z"
      ],
      tags: ["enlarge"]
    },
    {
      paths: ["M0 4v6h4V4h6V0H0zM24 0h-6v4h6v6h4V0zM24 24h-6v4h10V18h-4zM4 18H0v10h10v-4H4z"],
      tags: ["maximize"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: ["M10 6V0H6v6H0v4h10zM22 10h6V6h-6V0h-4v10zM22 22h6v-4H18v10h4zM6 28h4V18H0v4h6z"],
      tags: ["shrink"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: ["M26 22v4H2v-4h24zm-12-2l2.8-2.8 7.1-7.1-2.8-2.8-5.1 5V2h-4v10.3l-5.1-5-2.8 2.8 7.1 7.1L14 20z"],
      tags: ["export"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: [
        "M26.9 1.3C26.1.1 24.4-.4 23.2.5c-.4 0-.4.4-.4.4l-13.2 19c-6.2 8.7-4.1 20.3 4.6 26.5s20.3 4.1 26.5-4.6c4.6-6.6 4.6-15.3 0-22L26.9 1.3z"
      ],
      tags: ["style"]
    },
    {
      paths: [
        "M35.4 12.8C32 6.2 25.3 2 18 2S4 6.2.6 12.8c-.4.7-.4 1.6 0 2.3C4 21.8 10.7 26 18 26c7.3 0 14-4.2 17.4-10.8.4-.8.4-1.6 0-2.4zM18 21.9c-5.4 0-10.5-3-13.3-7.9C7.5 9.1 12.6 6.1 18 6.1s10.5 3 13.3 7.9c-2.8 4.9-7.9 7.9-13.3 7.9zm5.8-6.2c-.9 3.2-4.2 5-7.4 4.1-3.2-.9-5-4.2-4.1-7.4.4.3.9.4 1.4.4 1.7 0 3-1.3 3-3 0-.5-.1-1-.4-1.4.5-.3 1.1-.4 1.7-.4.6 0 1.1.1 1.7.2 3.1 1 5 4.3 4.1 7.5z"
      ],
      tags: ["eye"],
      viewBox: ["0 0 36 28"]
    },
    {
      paths: [
        "M4.1 20.1C2.7 18.7 1.5 17 .6 15.2c-.4-.7-.4-1.6 0-2.3C4 6.2 10.7 2 18 2c1.3 0 2.6.1 3.8.4l-3.7 3.7H18c-5.4 0-10.5 3-13.3 7.9.7 1.2 1.5 2.2 2.4 3.1l-3 3zm31.3-4.9C32 21.8 25.3 26 18 26c-2.6 0-5.2-.6-7.6-1.6L6.9 28 4 25.2 29.1.1 32 2.9l-2.7 2.7c2.5 1.8 4.7 4.3 6.2 7.2.3.8.3 1.6-.1 2.4zM31.3 14c-1.3-2.2-3-4-5.1-5.4l-2.8 2.8c.6 1.3.8 2.7.4 4.2-.9 3.2-4.2 5-7.4 4.1l-.9-.3-1.8 1.8c1.4.4 2.8.7 4.3.7 5.4 0 10.5-3 13.3-7.9z"
      ],
      tags: ["hidden"]
    },
    {
      paths: [
        "M25 29.9c-2.7 0-4.9-2.2-4.9-4.9s2.2-4.9 4.9-4.9 4.9 2.2 4.9 4.9-2.2 4.9-4.9 4.9z",
        "M25 40.6c-5.1 0-10.1-1.4-14.5-4C6.3 34.1 2.7 30.5.3 26.2c-.4-.7-.4-1.7 0-2.4 2.4-4.3 5.9-7.9 10.2-10.4 4.4-2.6 9.4-4 14.5-4s10.1 1.4 14.5 4c4.2 2.5 7.8 6.1 10.2 10.4.4.7.4 1.7 0 2.4-2.4 4.3-5.9 7.9-10.2 10.4-4.4 2.7-9.4 4-14.5 4zM5.3 25C9.6 31.7 17 35.7 25 35.7s15.4-4 19.7-10.7C40.4 18.3 33 14.3 25 14.3S9.6 18.3 5.3 25z"
      ],
      tags: ["visibility"]
    },
    {
      paths: [
        'M49.7 23.8c-1.7-3-3.9-5.7-6.6-7.9l-3.5 3.5c2 1.6 3.7 3.5 5.1 5.6C40.4 31.7 33 35.7 25 35.7c-.6 0-1.1 0-1.7-.1L19 40c2 .4 4 .6 6 .6 5.1 0 10.1-1.4 14.5-4 4.2-2.5 7.8-6.1 10.2-10.4.4-.7.4-1.7 0-2.4zM25 29.9c2.7 0 4.9-2.2 4.9-4.9 0-.4-.1-.9-.2-1.3L44.4 9c1-1 1-2.5 0-3.5s-2.5-1-3.5 0l-5.7 5.7C32 10 28.5 9.4 25 9.4c-5.1 0-10.1 1.4-14.5 4C6.3 15.9 2.7 19.5.3 23.8c-.4.7-.4 1.7 0 2.4 2.4 4.2 5.7 7.7 9.8 10.2l-4.5 4.5c-1 1-1 2.5 0 3.5s2.5 1 3.5 0l14.7-14.7c.3.1.8.2 1.2.2zM5.3 25C9.6 18.3 17 14.2 25 14.2c2.2 0 4.3.3 6.4.9l-5.1 5.1c-.4-.1-.8-.2-1.3-.2-2.7 0-4.9 2.2-4.9 4.9 0 .4.1.9.2 1.3l-6.6 6.6C10.3 31 7.4 28.3 5.3 25z"'
      ],
      tags: ["visibility-hidden"]
    },
    {
      paths: [
        "M19.8 18.6l-4.9 4.9-2.8-2.8 3.7-3.7V8.6h4v10zM16 0C11.4 0 7.2 2 4.2 5.2L1.6 2.6 0 12.6 10.1 11l-3-3c2.2-2.5 5.4-4 8.9-4 6.6 0 12 5.4 12 12s-5.4 12-12 12c-3.5 0-6.7-1.5-8.9-4l-3 2.7c3 3.2 7.2 5.3 11.9 5.3 8.8 0 16-7.2 16-16S24.8 0 16 0z"
      ],
      tags: ["history"],
      viewBox: ["0 0 32 32"]
    },
    {
      paths: [
        "M5 25c0 11 9 20 20 20 7.6 0 14.2-4.2 17.6-10.6l-5.5-3.3c-2.2 4.4-6.8 7.4-12.1 7.4-7.5 0-13.6-6.1-13.6-13.6S17.5 11.4 25 11.4c4 0 7.5 1.8 9.9 4.5l-4.2 2.6 12.1 4L45 9.9l-4.3 2.6C37 8 31.4 5 25 5 14 5 5 14 5 25z"
      ],
      tags: ["redo"]
    },
    {
      paths: [
        "M25 5c-6.4 0-12 3-15.6 7.5L5 9.9l2.2 12.6 12.1-4-4.3-2.6c2.4-2.7 5.9-4.5 9.9-4.5 7.5 0 13.6 6.1 13.6 13.6s-6 13.6-13.5 13.6c-5.3 0-9.8-3-12.1-7.4l-5.5 3.3C10.7 40.8 17.4 45 25 45c11 0 20-9 20-20S36 5 25 5z"
      ],
      tags: ["undo"]
    },
    {
      paths: [
        "M16 0C7.2 0 0 7.2 0 16s7.2 16 16 16 16-7.2 16-16S24.8 0 16 0zm0 28C9.4 28 4 22.6 4 16S9.4 4 16 4s12 5.4 12 12-5.4 12-12 12zm2-17c0 1.1-.9 2-2 2s-2-.9-2-2 .9-2 2-2 2 .9 2 2zm-4 4h4v8h-4v-8z"
      ],
      tags: ["info"],
      viewBox: ["0 0 32 32"]
    },
    {
      paths: [
        "M90 20c38.6 0 70 31.4 70 70s-31.4 70-70 70-70-31.4-70-70 31.4-70 70-70m0-20C40.3 0 0 40.3 0 90s40.3 90 90 90 90-40.3 90-90S139.7 0 90 0z",
        "M90 65z",
        "M90 55c-5.5 0-10 4.5-10 10s4.5 10 10 10 10-4.5 10-10-4.5-10-10-10z",
        "M90 115V95v20z",
        "M90 85c-5.5 0-10 4.5-10 10v20c0 5.5 4.5 10 10 10s10-4.5 10-10V95c0-5.5-4.5-10-10-10z"
      ],
      viewBox: ["0 0 180 180"],
      tags: ["infopanel"]
    },
    {
      paths: [
        "M33.9 6.1c0 1.6-.6 3.2-1.7 4.4-1.2 1.1-2.7 1.7-4.3 1.7-1.6 0-3.1-.6-4.2-1.7-1.2-1.2-1.8-2.7-1.7-4.4 0-1.6.6-3.2 1.7-4.3C24.8.6 26.3 0 27.9 0s3.2.7 4.3 1.8c1.1 1.2 1.7 2.7 1.7 4.3zm-1 41.3l-4.2 1.9c-1.2.4-2.4.6-3.7.6-1.8.1-3.7-.6-5-1.8-1.1-1.3-1.8-3-1.7-4.8 0-.8 0-1.6.1-2.3.1-.8.3-1.7.4-2.7l2.2-9.5c.2-.9.4-1.7.5-2.6.1-.7.2-1.5.2-2.2.1-.9-.1-1.7-.6-2.4-.6-.6-1.5-.8-2.3-.7-.6 0-1.2.1-1.7.3-.6.2-1-2.3-1-2.3s2.9-1.2 4.2-1.7c1.2-.5 2.4-.8 3.7-.8 1.8-.1 3.6.5 4.9 1.8 1.2 1.4 1.8 3.1 1.7 4.9 0 .7 0 1.4-.1 2.1-.1 1-.2 1.9-.5 2.9l-2.1 9.4c-.2.7-.3 1.6-.5 2.6-.2.9-.2 1.7-.2 2.2-.1.9.2 1.8.7 2.6.7.5 1.5.7 2.3.6.6 0 1.2-.1 1.8-.3.7-.3.9 2.2.9 2.2z"
      ],
      tags: ["infobig"]
    },
    {
      paths: [
        "M19 4.6L30 11l-11 6.4L8 11l11-6.4M19 0L0 11l19 11 19-11L19 0zm15 18.7l-15 8.7-15-8.7L0 21l15.3 8.8L19 32l3.7-2.1L38 21l-4-2.3z"
      ],
      tags: ["lib"],
      viewBox: ["0 0 38 32"]
    },
    {
      paths: [
        "M20 6H8c-4.4 0-8 3.6-8 8s3.6 8 8 8h12c4.4 0 8-3.6 8-8s-3.6-8-8-8zm0 12H8c-2.2 0-4-1.8-4-4s1.8-4 4-4h12c2.2 0 4 1.8 4 4s-1.8 4-4 4z",
        "M10 12h8v4h-8z"
      ],
      tags: ["link"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: ["M8 21h34v8H8z"],
      tags: ["minus"]
    },
    {
      paths: ["M22 4v24H10V4h12m4-4H6v32h20V0zM16 22c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"],
      tags: ["mobile"],
      viewBox: ["0 0 32 32"]
    },
    {
      paths: ["M25 6v12H7V6h18m4-4H3v20h26V2zM32 26H0v4h32v-4z"],
      tags: ["laptop"],
      viewBox: ["0 0 32 32"]
    },
    {
      paths: ["M28 4v16H4V4h24m4-4H0v24h32V0zM24 28H8v4h16v-4z"],
      tags: ["desktop"],
      viewBox: ["0 0 32 32"]
    },
    {
      paths: ["M24 4v13H4V4h20m4-4H0v21h28V0zM21 24H7v4h14v-4z"],
      tags: ["desktop-sm"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: ["M28 0H18v4h6v6h4zM0 28h10v-4H4v-6H0zM16 12v4h-4v-4h4m4-4H8v12h12V8z"],
      tags: ["drag"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: [
        "M47.6 2.4C46.1.9 44 0 41.7 0c-2.3 0-4.4.9-5.9 2.4l-5.9 5.9-3-2.9L24 8.3l2.9 2.9L0 37.5V50h12.5l26.3-26.9 2.9 2.9 2.9-2.9-2.9-3 5.9-5.9c1.5-1.5 2.4-3.6 2.4-5.9s-.9-4.4-2.4-5.9zM18.9 37.5H6l23.9-23.3 6 6-17 17.3z"
      ],
      tags: ["picker"]
    },
    {
      paths: ["M42 21H29V8h-8v13H8v8h13v13h8V29h13z"],
      tags: ["plus"]
    },
    {
      paths: [
        "M47.9 0H12.1c-.4 0-.8.2-1 .5L1 15.5c-.3.4-.3 1 .1 1.4l28 34.6c.5.6 1.4.6 1.9 0l28-34.6c.3-.4.4-1 .1-1.4L48.9.5c-.2-.3-.6-.5-1-.5zm-2 4.9l6.4 9.7h-6.9l-5.3-9.7h5.8zm-20.5 0h9.2l5.3 9.7H20.1l5.3-9.7zm-11.3 0h5.8l-5.3 9.7H7.7l6.4-9.7zM9.7 19.5h5.2l6.9 16.2L9.7 19.5zm10.5 0h19.7L30 44.2l-9.8-24.7zm17.9 16.2L45 19.5h5.2L38.1 35.7z"
      ],
      tags: ["quality"],
      viewBox: ["0 0 58 52"]
    },
    {
      paths: [
        "M14 0C6.3 0 0 6.3 0 14s6.3 14 14 14 14-6.3 14-14S21.7 0 14 0zm0 24C8.5 24 4 19.5 4 14S8.5 4 14 4s10 4.5 10 10-4.5 10-10 10zm1.7-4.7c0 1.1-.9 2-2 2s-2-.9-2-2 .9-2 2-2 2 .9 2 2zm3.3-8.2c0 3.3-3.6 3.3-3.6 4.6v.2c0 .4-.3.7-.7.7h-2.1c-.4 0-.7-.3-.7-.7v-.3c0-1.8 1.3-2.5 2.3-3 .9-.5 1.4-.8 1.4-1.5 0-.8-1.1-1.4-2-1.4-1.1 0-1.6.5-2.4 1.4-.2.3-.7.3-.9.1l-1.2-.9c-.1-.3-.2-.7 0-1 1.2-1.7 2.6-2.6 4.9-2.6 2.4 0 5 1.9 5 4.4z"
      ],
      tags: ["question-mark"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: [
        "M245.9-211.5l-52.2 52.2c-44.9-44.9-106.9-72.6-175.4-72.6-132.8 0-241.2 104.3-247.7 235.5-.3 6.8 5.2 12.5 12 12.5h28c6.4 0 11.6-5 12-11.3 5.8-103.1 91.1-184.7 195.7-184.7 54.2 0 103.2 21.9 138.6 57.4l-54.1 54.1c-7.6 7.6-2.2 20.5 8.5 20.5h143c6.6 0 12-5.4 12-12v-143c.1-10.8-12.9-16.1-20.4-8.6zm8.2 227.6h-28c-6.4 0-11.6 5-12 11.3-5.8 103.1-91.1 184.7-195.7 184.7-54.2 0-103.2-21.9-138.6-57.4l54.1-54.1c7.6-7.6 2.2-20.5-8.5-20.5h-143c-6.6 0-12 5.4-12 12v143c0 10.7 12.9 16 20.5 8.5l52.2-52.2C-112 236.3-50 264 18.5 264c132.8 0 241.2-104.3 247.7-235.5.2-6.8-5.3-12.4-12.1-12.4zM26.8 1.2l-2.9 2.9C21.4 1.6 17.9 0 14 0 6.5 0 .4 5.9 0 13.3c0 .4.3.7.7.7h1.6c.4 0 .7-.3.7-.6.3-5.9 5.1-10.5 11-10.5 3.1 0 5.8 1.2 7.8 3.2l-3.1 3.1c-.4.4-.1 1.2.5 1.2h8.1c.4 0 .7-.3.7-.7V1.6c0-.6-.7-.9-1.2-.4zM27.3 14h-1.6c-.4 0-.7.3-.7.6-.3 5.8-5.1 10.4-11 10.4-3.1 0-5.8-1.2-7.8-3.2l3.1-3.1c.4-.4.1-1.2-.5-1.2H.7c-.4 0-.7.3-.7.7v8.1c0 .6.7.9 1.2.5l2.9-2.9c2.5 2.5 6 4.1 9.9 4.1 7.5 0 13.6-5.9 14-13.3 0-.4-.3-.7-.7-.7z"
      ],
      tags: ["refresh"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: ["M14 14l-2.8-2.8-8.4-8.4L0 5.6 8.4 14 0 22.4l2.8 2.8 8.4-8.4L14 14z"],
      tags: ["right-arrow"],
      viewBox: ["0 0 14 28"]
    },
    {
      paths: ["M0 12h24v4H0zM10 0h14v4H10zM10 24h14v4H10z"],
      tags: ["align--right"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: ["M0 12h24v4H0zM0 0h14v4H0zM0 24h14v4H0z"],
      tags: ["align--left"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: ["M0 0h24v4H0zM0 24h24v4H0zM0 12h24v4H0z"],
      tags: ["align--justify"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: ["M0 0h24v4H0zM0 24h24v4H0zM5 12h14v4H5z"],
      tags: ["align--center"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: ["M0 0v28h28V0H0zm24 24H4V4h20v20zm-3.8-10L9.8 20V8l10.4 6z"],
      tags: ["video"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: [
        "M0 0v28h28V0H0zm24 4v13.5l-4.2-4.2c-.4-.4-.9-.4-1.3 0l-7.9 7.9-3-3c-.4-.4-.9-.4-1.3 0L4 20.5V4h20zM8 11.5c0-1.5 1.2-2.7 2.7-2.7s2.7 1.2 2.7 2.7c0 1.5-1.2 2.7-2.7 2.7S8 13 8 11.5z"
      ],
      tags: ["picture"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: ["M0 0v28h28V0H0zm4 24V4h20L4 24z"],
      tags: ["gradient"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: [
        "M16.6 10.1c-1.5-2.2-3.3-4.6-4.4-8.4C11.9.7 11 0 10 0 9 0 8.1.6 7.8 1.7 6.7 5.4 5 7.9 3.4 10.1 1.6 12.6.1 14.8.1 18c0 5.5 4.4 10 9.8 10s9.8-4.5 9.8-10c.1-3.2-1.4-5.4-3.1-7.9zm-6.6 14c-3.3 0-5.9-2.7-5.9-6 0-2 1-3.4 2.6-5.7 1-1.5 2.3-3.3 3.4-5.5 1.1 2.3 2.3 4.1 3.4 5.5 1.6 2.3 2.6 3.7 2.6 5.7-.2 3.3-2.8 6-6.1 6z"
      ],
      tags: ["drop"],
      viewBox: ["0 0 20 28"]
    },
    {
      paths: [
        "M6 14c0 1.7-1.3 3-3 3s-3-1.3-3-3 1.3-3 3-3 3 1.3 3 3zm8-3c-1.7 0-3 1.3-3 3s1.3 3 3 3 3-1.3 3-3-1.3-3-3-3zm11 0c-1.7 0-3 1.3-3 3s1.3 3 3 3 3-1.3 3-3-1.3-3-3-3z"
      ],
      tags: ["more"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: ["M0 0v32h32V0H0zm4 4h10v10H4V4zm24 24H4V18h24v10zm0-14H18V4h10v10z"],
      tags: ["layout"],
      viewBox: ["0 0 32 32"]
    },
    {
      paths: ["M31.3 2.8L28.5 0l-9.8 9.8V0h-4v19.4L3.5 8.2.7 11.1l14 13.9v7h4V15.4z"],
      tags: ["treeview"],
      viewBox: ["0 0 32 32"]
    },
    {
      paths: [
        "M11 4c3.9 0 7 3.1 7 7 0 1.4-.4 2.8-1.2 4l-.8 1-1 .8c-1.2.8-2.5 1.2-4 1.2-3.9 0-7-3.1-7-7s3.1-7 7-7m0-4C4.9 0 0 4.9 0 11s4.9 11 11 11c2.3 0 4.5-.7 6.2-1.9l7.9 7.9 2.8-2.8-7.9-7.9c1.2-1.8 1.9-3.9 1.9-6.2C22 4.9 17.1 0 11 0z"
      ],
      tags: ["search"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: [
        "M13 40.8V9h11.6c3.5 0 6.3.6 8.2 2 1.8 1.4 2.9 3.1 2.9 5.5 0 1.7-.6 3.3-1.8 4.6-1.2 1.4-2.7 2.2-4.5 2.7v.2c2.3.2 4.1 1.1 5.4 2.5 1.4 1.4 2.1 3.2 2.1 5.1 0 3-1 5.2-3.1 7-2.1 1.8-5 2.5-8.5 2.5L13 40.8zm7.2-26.5v7.5h3.2c1.4 0 2.7-.3 3.5-1.1.8-.8 1.3-1.8 1.3-3 0-2.4-1.8-3.5-5.2-3.5l-2.8.1zm0 12.9v8.4h3.9c1.7 0 3-.4 3.9-1.1.9-.8 1.4-1.8 1.4-3.2.1-1.1-.5-2.3-1.4-3-1-.7-2.2-1.1-3.9-1.1h-3.9z"
      ],
      tags: ["bold"]
    },
    {
      paths: [
        "M39 8h-1c-.5 0-1 .5-1 1v.8C35.6 8.7 33.9 8 32 8c-4.4 0-8 3.6-8 8v2c0 4.4 3.6 7.9 8 7.9 1.9 0 3.6-.7 5-1.8v.9c0 .5.4 1 1 1h1c.5 0 1-.5 1-1V9c0-.5-.4-1-1-1zm-2 10c0 2.8-2.3 5-5 5s-5-2.3-5-5v-2c0-2.8 2.3-5 5-5s5 2.3 5 5v2zM13.2 2.7c-.1-.5-.5-.7-.9-.7H9.6c-.4 0-.8.2-1 .7L0 24.7c-.2.5.1 1.1.6 1.3H2c.4 0 .8-.2 1-.7L5.5 19h10.9l2.5 6.4c.1.4.5.7 1 .7H21c.5 0 1-.5 1-1 0-.2 0-.2-.1-.4l-8.7-22zM6.7 16L11 5l4.3 11H6.7z"
      ],
      tags: ["capitalize"],
      viewBox: ["0 0 40 28"]
    },
    {
      paths: [
        "M20 1v1c0 .6-.4 1-1 1h-4.2L9.3 25H13c.6 0 1 .4 1 1v1c0 .6-.4 1-1 1H1c-.6 0-1-.4-1-1v-1c0-.6.4-1 1-1h4.2l5.5-22H7c-.6 0-1-.4-1-1V1c0-.6.4-1 1-1h12c.6 0 1 .4 1 1z"
      ],
      tags: ["italic"],
      viewBox: ["0 0 20 28"]
    },
    {
      paths: [
        "M33 8h-1c-.5 0-1 .5-1 1v.8C29.6 8.7 27.9 8 26 8c-4.4 0-8 3.6-8 8v2c0 4.3 3.6 8 8 8 1.9 0 3.6-.7 5-1.8v.8c0 .5.4 1 1 1h1c.5 0 1-.5 1-1V9c0-.5-.4-1-1-1zm-2 10c0 2.8-2.3 5-5 5s-5-2.3-5-5v-2c0-2.8 2.3-5 5-5s5 2.3 5 5v2zM15 8h-1c-.5 0-1 .5-1 1v.8C11.6 8.7 9.9 8 8 8c-4.4 0-8 3.6-8 8v2c0 4.3 3.6 8 8 8 1.9 0 3.6-.7 5-1.8v.8c0 .5.4 1 1 1h1c.5 0 1-.5 1-1V9c0-.5-.4-1-1-1zm-2 10c0 2.8-2.3 5-5 5s-5-2.3-5-5v-2c0-2.8 2.3-5 5-5s5 2.3 5 5v2z"
      ],
      tags: ["lowercase"],
      viewBox: ["0 0 34 28"]
    },
    {
      paths: ["M0 12.2h10.2v30.5h5.9V12.2h10.2v-5H0v5zm27.7 3.9v4.5h8.2v22.1h6v-22H50v-4.5H27.7z"],
      tags: ["smallcaps"]
    },
    {
      paths: [
        "M31 13H1c-.6 0-1 .4-1 1v1c0 .6.4 1 1 1h30c.6 0 1-.4 1-1v-1c0-.6-.4-1-1-1zM9.4 11h7.1l-2.9-1.4c-1.4-.7-2-2.4-1.3-3.8.3-.6.7-1 1.3-1.3.6-.3 1.2-.5 1.9-.5h3.9c.9 0 1.7.4 2.3 1.1l.9 1.3c.3.4 1 .5 1.4.2l1.6-1.2c.4-.3.5-1 .2-1.4l-.9-1.3C23.6 1 21.5 0 19.4 0h-3.9c-1.3 0-2.5.3-3.7.9-2.5 1.2-4 3.9-3.8 6.7.1 1.3.7 2.4 1.4 3.4zM25.2 18h-5.7l.9.4c1.4.7 2 2.4 1.3 3.8-.3.6-.7 1-1.3 1.3-.6.3-1.2.4-1.9.4h-3.9c-.9 0-1.7-.4-2.3-1.1l-.9-1.3c-.3-.4-1-.5-1.4-.2l-1.6 1.2c-.4.3-.5 1-.2 1.4l.9 1.3c1.3 1.7 3.3 2.7 5.5 2.7h3.9c1.3 0 2.5-.3 3.7-.9 2.5-1.3 4-3.9 3.8-6.8-.1-.7-.4-1.5-.8-2.2z"
      ],
      tags: ["strikethrough"],
      viewBox: ["0 0 32 28"]
    },
    {
      paths: [
        "M2.5 2.6h1.8V14c0 4.8 3.9 8.8 8.8 8.8s8.8-3.9 8.8-8.8V2.6h1.8c.5 0 .9-.4.9-.9V.9C24.4.4 24 0 23.5 0h-7c-.5 0-.9.4-.9.9v.9c0 .5.4.9.9.9h1.8V14c0 2.9-2.4 5.3-5.3 5.3S7.8 16.9 7.8 14V2.6h1.8c.5 0 .9-.4.9-.9V.9c-.1-.5-.5-.9-1-.9h-7c-.5 0-.9.4-.9.9v.9c0 .4.4.8.9.8zm21.9 22.8H1.6c-.5 0-.9.4-.9.9v.9c0 .5.4.9.9.9h22.8c.5 0 .9-.4.9-.9v-.9c0-.5-.4-.9-.9-.9z"
      ],
      tags: ["underline"],
      viewBox: ["0 0 26 28"]
    },
    {
      paths: [
        "M13.3 2.7c-.1-.5-.5-.7-.9-.7H9.7c-.5 0-.8.2-1 .7l-8.6 22c-.2.5.1 1.1.6 1.3H2c.5 0 .8-.2.9-.7L5.4 19h11.1l2.5 6.4c.1.4.5.7 1 .7h1c.5 0 1-.5 1-1 0-.2 0-.2-.1-.4l-8.6-22zM6.7 16L11 5.2 15.3 16H6.7zM36.3 2.7c-.2-.5-.5-.7-1-.7h-2.7c-.5 0-.8.2-1 .7l-8.6 22c-.2.5.1 1.1.6 1.3h1.5c.4 0 .8-.2 1-.7l2.5-6.4h11l2.5 6.4c.2.4.5.7 1 .7h.9c.5 0 1-.5 1-1 0-.2 0-.2-.1-.4L36.3 2.7zM29.7 16L34 5.1 38.3 16h-8.6z"
      ],
      tags: ["uppercase"],
      viewBox: ["0 0 45 28"]
    },
    {
      paths: ["M24 4v20H4V4h20m4-4H0v28h28V0z"],
      tags: ["all-sides"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: ["M28 0H0v20h4V4h20v16h4V0z", "M28 24H0v4h28v-4z"],
      tags: ["border-bottom"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: ["M28 0H8v4h16v20H8v4h20V0z", "M4 0H0v28h4V0z"],
      tags: ["border-left"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: ["M20 0H0v28h20v-4H4V4h16V0z", "M28 0h-4v28h4V0z"],
      tags: ["border-right"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: ["M28 8h-4v16H4V8H0v20h28V8z", "M28 0H0v4h28V0z"],
      tags: ["border-top"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: [
        "M38.3 0H12.5C5.8-.2.2 5 0 11.7v25.8C-.2 44.2 5 49.8 11.7 50h25.8c6.7.2 12.3-5 12.5-11.7V12.5C50.2 5.8 45 .2 38.3 0zm3.4 12.5v25c.2 2.1-1.2 3.9-3.3 4.2H12.5c-2.1.2-3.9-1.2-4.2-3.3V12.5c-.2-2.1 1.2-3.9 3.3-4.2h25.9c2.1-.2 3.9 1.2 4.2 3.3v.9z"
      ],
      tags: ["all-corners"]
    },
    {
      paths: ["M0 10h4V4h20v20h-6v4h10V0H0z", "M14 28v-4C8.5 24 4 19.5 4 14H0c0 7.7 6.3 14 14 14z"],
      tags: ["b-l-corner"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: ["M10 28v-4H4V4h20v6h4V0H0v28z", "M28 14h-4c0 5.5-4.5 10-10 10v4c7.7 0 14-6.3 14-14z"],
      tags: ["b-r-corner"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: ["M18 0v4h6v20H4v-6H0v10h28V0z", "M0 14h4C4 8.5 8.5 4 14 4V0C6.3 0 0 6.3 0 14z"],
      tags: ["t-l-corner"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: ["M28 18h-4v6H4V4h6V0H0v28h28z", "M14 0v4c5.5 0 10 4.5 10 10h4c0-7.7-6.3-14-14-14z"],
      tags: ["t-r-corner"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: [
        "M10.8 21.7V28H7.1V10h7c1.4 0 2.5.2 3.6.7 1 .5 1.8 1.2 2.4 2.1.6.9.8 1.9.8 3.1 0 1.8-.6 3.2-1.8 4.2-1.2 1-2.9 1.5-5 1.5h-3.3zm0-3h3.3c1 0 1.7-.2 2.2-.7.5-.5.8-1.1.8-2 0-.9-.3-1.6-.8-2.1s-1.2-.8-2.2-.8h-3.4v5.6z",
        "M28 0v4H0V0z"
      ],
      tags: ["padding-top"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: [
        "M3.7 16.7V23H0V5h7c1.4 0 2.5.2 3.6.7s1.8 1.2 2.4 2.1c.6.9.8 1.9.8 3.1 0 1.8-.6 3.2-1.8 4.2-1.2 1-2.9 1.5-5 1.5H3.7zm0-3H7c1 0 1.7-.2 2.2-.7.5-.5.8-1.1.8-2 0-.9-.3-1.6-.8-2.1C8.7 8.3 8 8 7.1 8H3.7v5.7z",
        "M24 0h4v28h-4z"
      ],
      tags: ["padding-right"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: [
        "M10.8 11.7V18H7.1V0h7c1.4 0 2.5.2 3.6.7s1.8 1.2 2.4 2.1c.6.9.8 1.9.8 3.1 0 1.8-.6 3.2-1.8 4.2-1.2 1-2.9 1.5-5 1.5h-3.3zm0-3h3.3c1 0 1.7-.2 2.2-.7.5-.5.8-1.1.8-2 0-.9-.3-1.6-.8-2.1-.5-.6-1.2-.9-2.1-.9h-3.4v5.7z",
        "M28 24v4H0v-4z"
      ],
      tags: ["padding-bottom"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: [
        "M17.9 16.7V23h-3.7V5h7c1.4 0 2.5.2 3.6.7s1.8 1.2 2.4 2.1c.5 1 .8 2 .8 3.2 0 1.8-.6 3.2-1.8 4.2-1.2 1-2.9 1.5-5 1.5h-3.3zm0-3h3.3c1 0 1.7-.2 2.2-.7.5-.5.8-1.1.8-2 0-.9-.3-1.6-.8-2.1-.4-.6-1.2-.9-2.1-.9h-3.4v5.7z",
        "M0 0h4v28H0z"
      ],
      tags: ["padding-left"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: [
        "M9.6 10.9L14 23.3l4.4-12.4H23V28h-3.5v-4.7l.4-8.1L15.2 28h-2.4L8.2 15.3l.4 8.1V28H5V10.9h4.6z",
        "M28 0v4H0V0z"
      ],
      tags: ["margin-top"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: [
        "M4.6 5.4L9 17.9l4.4-12.4H18v17.1h-3.5v-4.7l.4-8.1-4.6 12.7H7.8L3.2 9.8l.4 8.1v4.7H0V5.4h4.6z",
        "M24 0h4v28h-4z"
      ],
      tags: ["margin-right"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: [
        "M9.6 0L14 12.4 18.4 0H23v17.1h-3.5v-4.7l.4-8.1L15.3 17h-2.4L8.2 4.4l.4 8.1v4.7H5V0h4.6z",
        "M28 24v4H0v-4z"
      ],
      tags: ["margin-bottom"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: [
        "M14.6 5.4L19 17.9l4.4-12.4H28v17.1h-3.5v-4.7l.4-8.1-4.6 12.7h-2.4L13.2 9.8l.4 8.1v4.7H10V5.4h4.6z",
        "M0 0h4v28H0z"
      ],
      tags: ["margin-left"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: ["M2 4h10v8H2zM16 4h10v8H16z", "M26 12H0v4h2v8h10v-8h4v8h10v-8h2v-4z"],
      tags: ["align-baseline"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: ["M4 16h8v10H4zM4 2h8v10H4z", "M12 2v26h4v-2h8V16h-8v-4h8V2h-8V0h-4z"],
      tags: ["align-baseline-reversed"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: ["M28 12h-2V6H16v6h-4V4H2v8H0v4h2v8h10v-8h4v6h10v-6h2z"],
      tags: ["align-center"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: ["M2 4h10v18H2zM16 10h10v12H16zM0 24h28v4H0z"],
      tags: ["align-end"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: ["M2 6h10v18H2zM16 6h10v12H16zM0 0h28v4H0z"],
      tags: ["align-start"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: ["M2 6h10v16H2zM16 6h10v16H16zM0 24h28v4H0zM0 0h28v4H0z"],
      tags: ["align-stretch"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: ["M6 26V16h16v10H6zm0-14V2h16v10H6zm18 16V0h4v28h-4zM0 28V0h4v28H0z"],
      tags: ["align-stretch-reversed"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: ["M0 12h28v4H0zM2 0h10v10H2zM2 18h10v10H2zM16 0h10v10H16zM16 18h10v10H16z"],
      tags: ["content-center"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: ["M0 24h28v4H0zM2 0h10v10H2zM2 12h10v10H2zM16 0h10v10H16zM16 12h10v10H16z"],
      tags: ["content-end"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: ["M0 24h28v4H0zM0 0h28v4H0zM2 8h10v4H2zM2 16h10v4H2zM16 8h10v4H16zM16 16h10v4H16z"],
      tags: ["content-space-around"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: ["M0 24h28v4H0zM0 0h28v4H0zM2 6h10v4H2zM2 18h10v4H2zM16 6h10v4H16zM16 18h10v4H16z"],
      tags: ["content-space-btw"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: ["M0 0h28v4H0zM2 6h10v10H2zM2 18h10v10H2zM16 6h10v10H16zM16 18h10v10H16z"],
      tags: ["content-start"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: ["M0 6h10v16H0zM18 6h10v16H18zM12 0h4v28h-4z"],
      tags: ["justify-center"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: ["M0 6h10v16H0zM12 6h10v16H12zM24 0h4v28h-4z"],
      tags: ["justify-end"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: ["M8 6h4v16H8zM16 6h4v16h-4zM24 0h4v28h-4zM0 0h4v28H0z"],
      tags: ["justify-sp-around"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: ["M6 8h16v4H6zM6 16h16v4H6zM0 24h28v4H0zM0 0h28v4H0z"],
      tags: ["justify-sp-around-reverse"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: ["M6 6h4v16H6zM18 6h4v16h-4zM24 0h4v28h-4zM0 0h4v28H0z"],
      tags: ["justify-sp-btw"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: ["M6 6h16v4H6zM6 18h16v4H6zM0 24h28v4H0zM0 0h28v4H0z"],
      tags: ["justify-sp-btw-reverse"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: ["M6 6h10v16H6zM18 6h10v16H18zM0 0h4v28H0z"],
      tags: ["justify-start"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: ["M2 8h10v12H2z", "M16 8V0h-4v28h4v-8h10V8z"],
      tags: ["self-baseline"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: ["M26 8H16V0h-4v8H2v12h10v8h4v-8h10z"],
      tags: ["self-center"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: ["M24 0h4v28h-4zM0 8h22v12H0z"],
      tags: ["self-end"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: ["M0 0h4v28H0zM6 8h22v12H6z"],
      tags: ["self-start"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: ["M24 0h4v28h-4zM0 0h4v28H0zM6 8h16v12H6z"],
      tags: ["self-stretch"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: [
        "M43.1 8.5c-2.4-2.2-5.5-3.4-8.6-3.4-3.4 0-6.8 1.4-9.2 4l-.2.1-.2-.2-.5-.5c-2.4-2.2-5.5-3.4-8.6-3.4C12.3 5 8.9 6.5 6.5 9 1.7 14 1.9 22 7 26.9l18 18 18-18 .5-.5c4.9-5.1 4.7-13.1-.4-17.9z",
        "M15.4 11.1h.3c1.6 0 3.2.6 4.5 1.8l.4.4.2.2 3.5 3.5 4.1-2.7.3-.2.6-.4.5-.5c1.2-1.3 2.9-2 4.8-2 1.7 0 3.3.7 4.5 1.8 1.3 1.2 2 2.8 2 4.6s-.6 3.4-1.8 4.7l-.4.4L25 36.4 11.2 22.7l-.1-.1-.1-.1c-2.7-2.5-2.8-6.7-.3-9.4 1.3-1.3 3-2 4.7-2m0-6c-3.4 0-6.6 1.5-8.9 4C1.7 14.1 1.9 22 7 27l18 18 18-18 .5-.5c4.8-5.1 4.6-13.1-.5-17.9-2.4-2.2-5.5-3.4-8.6-3.4-3.4 0-6.8 1.4-9.2 4H25l-.2-.2-.5-.5c-2.4-2.2-5.5-3.4-8.6-3.4h-.3z"
      ],
      tags: ["heart"]
    },
    {
      paths: [
        "M15 4h20v15.347c4.73 2.247 8 7.068 8 12.653H27v12a2 2 0 1 1-4 0V32H7c0-5.585 3.27-10.406 8-12.653V4Z",
        "M43 32c0-1.39-.203-2.733-.58-4A14.037 14.037 0 0 0 35 19.347V4H15v15.347A14.038 14.038 0 0 0 7.58 28 14.003 14.003 0 0 0 7 32h16v12a2 2 0 1 0 4 0V32h16Zm-26.284-9.04L19 21.875V8h12v13.875l2.284 1.085A10.038 10.038 0 0 1 38.168 28H11.832a10.038 10.038 0 0 1 4.884-5.04Z"
      ],
      tags: ["pin"]
    },
    {
      paths: ["M2 6V2h24v4H2zm12 2l-2.8 2.8-7.1 7.1 2.8 2.8 5.1-5V26h4V15.7l5.1 5 2.8-2.8-7.1-7.1L14 8z"],
      tags: ["import"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: [
        "M24.6 18l3.4 3.4 4.4-4.4v25.2h4.8V17l4.4 4.4L45 18l-6.8-6.8-3.4-3.4L24.6 18zM5 32l3.4-3.4 4.4 4.4V7.8h4.8V33l4.4-4.4 3.4 3.4-6.8 6.8-3.4 3.4L5 32z"
      ],
      tags: ["reverse-y"]
    },
    {
      paths: [
        "M32 24.6L28.6 28l4.4 4.4H7.8v4.8H33l-4.4 4.4L32 45l6.8-6.8 3.4-3.4L32 24.6zM18 5l3.4 3.4-4.4 4.4h25.2v4.8H17l4.4 4.4-3.4 3.4-6.8-6.8-3.4-3.4L18 5z"
      ],
      tags: ["reverse-x"]
    },
    {
      paths: [
        "M37 9H11c-1.1 0-2 .9-2 2v26c0 1.1.9 2 2 2h26c1.1 0 2-.9 2-2V11c0-1.1-.9-2-2-2zM11.6 37c-.3 0-.6-.3-.6-.6V11.6c0-.3.3-.6.6-.6h24.8c.3 0 .6.3.6.6v24.8c0 .3-.3.6-.6.6H11.6z",
        "M38 5H10c-.6 0-1 .4-1 1s.4 1 1 1h28c.6 0 1-.4 1-1s-.4-1-1-1zm0 36H10c-.6 0-1 .4-1 1s.4 1 1 1h28c.6 0 1-.4 1-1s-.4-1-1-1z",
        "M29 16H15c-.6 0-1-.4-1-1s.4-1 1-1h14c.6 0 1 .4 1 1s-.4 1-1 1z"
      ],
      tags: ["element-accordion"],
      viewBox: ["0 0 48 48"]
    },
    {
      paths: [
        "M39 21H21C19.3 21 18 22.3 18 24V34C18 35.7 19.3 37 21 37H29C29.3 37 29.6 37.1 29.8 37.4L33 41.7L36.2 37.4C36.4 37.2 36.7 37 37 37H39C40.7 37 42 35.7 42 34V24C42 22.3 40.7 21 39 21ZM40 34C40 34.6 39.6 35 39 35H37C36.1 35 35.2 35.4 34.6 36.2L33 38.3L31.4 36.2C30.8 35.4 29.9 35 29 35H21C20.4 35 20 34.6 20 34V24C20 23.4 20.4 23 21 23H39C39.6 23 40 23.4 40 24V34Z",
        "M9 11C7.3 11 6 12.3 6 14V24C6 25.7 7.3 27 9 27H16V25H9C8.4 25 8 24.6 8 24V14C8 13.4 8.4 13 9 13H27C27.6 13 28 13.4 28 14V19H30V14C30 12.3 28.7 11 27 11H9Z"
      ],
      tags: ["element-comments"],
      viewBox: ["0 0 48 48"]
    },
    {
      paths: [
        "M33 13H7c-1.1 0-2 .9-2 2v26c0 1.1.9 2 2 2h26c1.1 0 2-.9 2-2V15c0-1.1-.9-2-2-2zm-.6 28H7.6c-.3 0-.6-.3-.6-.6V15.6c0-.3.3-.6.6-.6h24.8c.3 0 .6.3.6.6v24.8c0 .3-.3.6-.6.6z",
        "M31.1 27.9l-3.5-3.5-9.8 9.7-4.5-4.5-1.4 1.4-3 3.1 1.4 1.4 3-3 4.5 4.4 9.8-9.7 2.1 2.1 1.4-1.4zM14.9 21c.6 0 1 .4 1 1s-.4 1-1 1-1-.4-1-1 .5-1 1-1m0-2c-1.7 0-3 1.3-3 3s1.3 3 3 3 3-1.3 3-3-1.3-3-3-3z",
        "M37 9H11c-1.1 0-2 .9-2 2v2h2v-1.4c0-.3.3-.6.6-.6h24.8c.3 0 .6.3.6.6v24.8c0 .3-.3.6-.6.6H35v2h2c1.1 0 2-.9 2-2V11c0-1.1-.9-2-2-2z",
        "M41 5H15c-1.1 0-2 .9-2 2v2h2V7.6c0-.3.3-.6.6-.6h24.8c.3 0 .6.3.6.6v24.8c0 .3-.3.6-.6.6H39v2h2c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2z"
      ],
      tags: ["element-gallery"],
      viewBox: ["0 0 48 48"]
    },
    {
      paths: [
        "M17.4 9.8c-.5.3-1 .6-1.3 1.1-.3.5-.5 1-.5 1.6 0 1 .3 1.8 1 2.4.7.6 1.6.9 2.8.9 1.2 0 2.1-.3 2.8-.9s1-1.4 1-2.4c0-.6-.2-1.2-.5-1.6-.3-.5-.8-.8-1.3-1.1.4-.2.7-.5 1-.8h-6c.2.3.6.6 1 .8zm.9 1.4c.3-.3.7-.4 1.1-.4.5 0 .9.1 1.2.4.3.3.4.7.4 1.2s-.1.9-.4 1.2c-.3.3-.7.4-1.2.4s-.9-.1-1.2-.4-.4-.7-.4-1.2.2-.9.5-1.2zM30.1 9.3c-.1.3-.3.5-.6.7s-.6.3-.9.3c-.5 0-.9-.2-1.2-.6-.2-.2-.3-.4-.4-.7h-2.3c.1.8.4 1.4.8 2 .6.7 1.4 1 2.4 1 .8 0 1.5-.3 2.1-.9-.2 1.8-1.2 2.7-3.2 2.8h-.5v1.9h.6c1.7-.1 3.1-.7 4-1.7.9-1.1 1.4-2.6 1.4-4.5V9H30v.3z",
        "M17.7 26.9h-.5v1.9h.6c1.7-.1 3.1-.7 4-1.7.9-1.1 1.4-2.6 1.4-4.5v-.8c0-.9-.2-1.7-.5-2.4s-.8-1.2-1.4-1.6c-.6-.4-1.3-.6-2-.6s-1.4.2-2 .5c-.6.3-1 .8-1.4 1.5-.3.6-.5 1.3-.5 2.1 0 1.2.3 2.1.9 2.8.6.7 1.4 1 2.4 1 .8 0 1.5-.3 2.1-.9-.1 1.7-1.1 2.6-3.1 2.7zm2.6-3.9c-.3.2-.6.3-.9.3-.5 0-.9-.2-1.2-.6-.3-.4-.4-.9-.4-1.5s.1-1.1.4-1.6c.3-.4.7-.6 1.1-.6.5 0 .9.2 1.2.6.3.4.4 1 .4 1.8v.9c-.1.3-.3.5-.6.7zM28.6 28.8c1.3 0 2.2-.4 2.9-1.3s1-2 1-3.6v-2.1c0-1.5-.4-2.7-1-3.5-.7-.8-1.6-1.2-2.8-1.2s-2.2.4-2.8 1.2c-.7.8-1 2-1 3.6V24c0 1.5.4 2.7 1 3.5s1.5 1.3 2.7 1.3zM27 21.5c0-.9.1-1.5.4-1.9.3-.4.6-.6 1.2-.6.5 0 .9.2 1.2.6s.4 1.1.4 2.1v2.7c0 .9-.1 1.6-.4 2s-.7.6-1.2.6c-.6 0-1-.2-1.2-.7-.3-.5-.4-1.1-.4-2.1v-2.7z",
        "M23.2 35.6v-.8c0-.9-.2-1.7-.5-2.4s-.8-1.2-1.4-1.6c-.6-.4-1.3-.6-2-.6s-1.4.2-2 .5c-.6.3-1 .8-1.4 1.5-.3.6-.5 1.3-.5 2.1 0 1.2.3 2.1.9 2.8.6.7 1.4 1 2.4 1 .8 0 1.5-.3 2.1-.9-.1.8-.3 1.4-.8 1.9h2.4c.5-1 .8-2.2.8-3.5zm-2.3-.3c-.1.3-.3.5-.6.7-.3.2-.6.3-.9.3-.5 0-.9-.2-1.2-.6-.3-.4-.4-.9-.4-1.5s.1-1.1.4-1.6c.3-.4.7-.6 1.1-.6.5 0 .9.2 1.2.6.3.4.4 1 .4 1.8v.9zM30.3 30.3H30L25.3 32v1.8L28 33v6h2.3z"
      ],
      tags: ["element-counter-free"],
      viewBox: ["0 0 48 48"]
    },
    {
      paths: [
        "M36.3 25.9H30l2 2.1c-1.5 2.3-3.9 3.9-6.6 4.3V18.2c1.6-.6 2.9-2.2 2.9-4-.1-2.3-2-4.2-4.3-4.2s-4.2 1.9-4.2 4.2c0 1.9 1.2 3.4 2.9 4v14.1c-2.7-.4-5.1-1.9-6.6-4.3l2.1-2.1h-6.4v6.3L14 30c2 2.9 5.2 4.7 8.6 5.1v1.6c0 .8.6 1.4 1.4 1.4s1.4-.6 1.4-1.4v-1.5c3.5-.4 6.6-2.2 8.6-5.1l2.2 2.2v-6.4z"
      ],
      tags: ["element-anchor-point"],
      viewBox: ["0 0 48 48"]
    },
    {
      circle: ['cx="24" cy="30.5" r="1.5"', 'cx="19" cy="30.5" r="1.5"', 'cx="29" cy="30.5" r="1.5"'],
      paths: ["M11 13h2v2h-2z", "M9 13h2v22H9zM11 33h2v2h-2zM37 13h2v22h-2zM35 13h2v2h-2zM35 33h2v2h-2z"],
      tags: ["element-shortcode"],
      viewBox: ["0 0 48 48"]
    },
    {
      paths: [
        "M34.3 23.1c-.3 0-.7 0-1 .1-.4-4.3-4-7.6-8.4-7.6-.5 0-.9.4-.9.9v15c0 .5.4.9.9.9h9.4c2.6 0 4.7-2.1 4.7-4.7 0-2.5-2.1-4.6-4.7-4.6zM21.2 17.4c-.5 0-.9.4-.9.9v13.1c0 .5.4.9.9.9s.9-.4.9-.9v-13c0-.5-.4-1-.9-1zM17.4 21.2c-.5 0-.9.4-.9.9v9.4c0 .5.4.9.9.9s.9-.4.9-.9v-9.4c.1-.5-.3-.9-.9-.9zM13.7 21.2c-.5 0-.9.4-.9.9v9.4c0 .5.4.9.9.9s.9-.4.9-.9v-9.4c0-.5-.4-.9-.9-.9zM9.9 24c-.5 0-.9.4-.9.9v5.6c0 .5.4.9.9.9s.9-.4.9-.9v-5.6c.1-.5-.3-.9-.9-.9z"
      ],
      tags: ["element-soundcloud"],
      viewBox: ["0 0 48 48"]
    },
    {
      paths: [
        "M41.6 28c.2.9.2 2-.2 3.2-1 3.1-3.4 8.8-4.3 10.9 3.5-1.6 5.9-5 5.9-9.1 0-1.8-.5-3.5-1.4-5zM24.3 29h-.5c-.5 1.1-.8 2.6-.8 4 0 4.1 2.5 7.6 6.1 9.1l-3.8-12.5s-.5-.6-1-.6zM30.6 42.7c.8.2 1.5.3 2.4.3.8 0 1.7-.1 2.4-.3l-2.2-6.2-2.6 6.2z",
        "M37.9 29.7c-1.7-1.1-1.3-3.1 0-3.9.6-.3 1.1-.4 1.6-.3-1.7-1.5-4-2.5-6.5-2.5-3.9 0-7.2 2-8.9 5.1h5.1v.9h-.1c-.1 0-.3.2-.4.3-.1.1-.2.7-.2.7l2.1 8.7 1.9-4.3-.9-2.9c-.3-.9-.6-1.7-.8-2-.2-.2-.4-.5-.6-.5H30v-.9h6v.9h-1c-.2 0-.3.2-.4.3-.1.1-.2.4-.2.6 0 .2.1.7.1.7l2.3 8s2.4-4.6 2.4-5.6c.1-1-.3-2.6-1.3-3.3z",
        "M11.6 37c-.3 0-.6-.3-.6-.6V19h26v2.7c.7.2 1.4.6 2 .9V11c0-1.1-.9-2-2-2H11c-1.1 0-2 .9-2 2v26c0 1.1.9 2 2 2h11.6c-.4-.6-.7-1.3-.9-2H11.6zM11 11.6c0-.3.3-.6.6-.6h24.8c.3 0 .6.3.6.6V17H11v-5.4z"
      ],
      tags: ["element-wp"],
      viewBox: ["0 0 48 48"]
    },
    {
      paths: [
        "M35 19v15.4c0 .3-.3.6-.6.6H13.6c-.3 0-.6-.3-.6-.6V19h-2v16c0 1.1.9 2 2 2h22c1.1 0 2-.9 2-2V19h-2zM37 11H11c-1.1 0-2 .9-2 2v4c0 1.1.9 2 2 2h26c1.1 0 2-.9 2-2v-4c0-1.1-.9-2-2-2zm-.6 6H11.6c-.3 0-.6-.3-.6-.6v-2.8c0-.3.3-.6.6-.6h24.8c.3 0 .6.3.6.6v2.8c0 .3-.3.6-.6.6z",
        "M27.5 26h-7c-.8 0-1.5-.7-1.5-1.5s.7-1.5 1.5-1.5h7c.8 0 1.5.7 1.5 1.5s-.7 1.5-1.5 1.5z",
        "M40 25c-.6 0-1 .4-1 1v5c0 .6.4 1 1 1s1-.4 1-1v-5c0-.6-.4-1-1-1z",
        "M19.5 40c0-.6-.4-1-1-1h-5c-.6 0-1 .4-1 1s.4 1 1 1h5c.6 0 1-.4 1-1z"
      ],
      circle: ['cx="40" cy="22" r="1"', ' cx="22.5" cy="40" r="1" fill="currentColor"'],
      tags: ["element-archive"],
      viewBox: ["0 0 48 48"]
    },
    {
      paths: [
        "M14.8 16c.1-.1.3-.2.4-.4.2-.1.3-.2.5-.4.3-.2.5-.4.7-.5s.4-.4.6-.6c.2-.2.3-.5.4-.8.1-.3.2-.6.2-1 0-.3-.1-.6-.2-.9-.1-.3-.3-.5-.5-.7-.2-.2-.5-.3-.8-.4-.3-.1-.7-.2-1.1-.2-.8 0-1.6.2-2.3.7v1.5c.6-.5 1.2-.8 1.9-.8.4 0 .7.1.9.3.2.2.3.4.3.8 0 .2 0 .3-.1.5-.1.1-.1.3-.3.4l-.4.4c-.2.1-.4.3-.6.5-.2.2-.4.3-.7.5-.2.2-.5.4-.7.7-.2.3-.4.5-.5.8-.1.3-.2.7-.2 1.1v.6h5.2v-1.4h-3.3c0-.1 0-.2.1-.3.3-.1.4-.3.5-.4zM23.6 15.2v-4.9H22c-.2.4-.4.8-.7 1.2-.3.4-.5.9-.8 1.3l-.9 1.2c-.3.4-.6.8-.9 1.1v1.3h3.4V18h1.6v-1.6h.9v-1.3h-1zm-1.5 0h-1.8c.2-.2.3-.4.5-.6.2-.2.3-.4.5-.7.2-.2.3-.5.5-.7.1-.2.3-.5.4-.7v2.7z",
        "M29.5 24.3h-21c-.8 0-1.5-.7-1.5-1.5s.7-1.5 1.5-1.5h21c.8 0 1.5.7 1.5 1.5s-.7 1.5-1.5 1.5z",
        "M39.5 24.3h-31c-.8 0-1.5-.7-1.5-1.5s.7-1.5 1.5-1.5h31c.8 0 1.5.7 1.5 1.5s-.7 1.5-1.5 1.5z",
        "M39.5 31.3h-31c-.8 0-1.5-.7-1.5-1.5s.7-1.5 1.5-1.5h31c.8 0 1.5.7 1.5 1.5s-.7 1.5-1.5 1.5z",
        "M33.5 31.3h-25c-.8 0-1.5-.7-1.5-1.5s.7-1.5 1.5-1.5h25c.8 0 1.5.7 1.5 1.5s-.7 1.5-1.5 1.5z",
        "M39.5 38.3h-31c-.8 0-1.5-.7-1.5-1.5s.7-1.5 1.5-1.5h31c.8 0 1.5.7 1.5 1.5s-.7 1.5-1.5 1.5z",
        "M21.5 38.3h-13c-.8 0-1.5-.7-1.5-1.5s.7-1.5 1.5-1.5h13c.8 0 1.5.7 1.5 1.5s-.7 1.5-1.5 1.5z"
      ],
      tags: ["element-bar-counter"],
      viewBox: ["0 0 48 48"]
    },
    {
      paths: [
        "M10 18h28v12H10z",
        "M17 23h14v2H17z",
        "M31 37.4v-4.2s0-1.2-.7-1.2-.8 1.1-.8 1.1l-.1 1c0 .1-.1.4-.4.4-.2 0-.4-.2-.4-.4l-.1-2.1c0-.4-.3-1-.8-1-.6 0-.8.7-.8 1l-.2 2.2s0 .4-.3.4c-.2 0-.4-.2-.4-.4l-.1-2.3c0-.5-.2-1.2-.8-1.2-.6 0-.8.8-.8 1.2l-.1 2.4c0 .2-.1.4-.4.4-.2 0-.4-.1-.4-.4l-.1-2-.1-4.7c0-.5-.2-1.2-.8-1.2-.7 0-.8.7-.9 1.1l-.6 10.4-1-2.4-.9-1s-.5-.6-1.1-.8c-.3-.1-.7-.1-.9.2-.2.3.2 1 .2 1l.6 1.1c.5.9 1.2 2.3 1.6 3.7 1.1 3 2.8 5 2.8 5H28.4c2.6-3.4 2.6-7.3 2.6-7.3z"
      ],
      tags: ["element-button"],
      viewBox: ["0 0 48 48"]
    },
    {
      paths: [
        "M28 9H2c-1.1 0-2 .9-2 2v26c0 1.1.9 2 2 2h26c1.1 0 2-.9 2-2V11c0-1.1-.9-2-2-2zM2.6 37c-.3 0-.6-.3-.6-.6V11.6c0-.3.3-.6.6-.6h24.8c.3 0 .6.3.6.6v24.8c0 .3-.3.6-.6.6H2.6z",
        "M48 9H36c-1.1 0-2 .9-2 2v26c0 1.1.9 2 2 2h12v-2H36.6c-.3 0-.6-.3-.6-.6V11.6c0-.3.3-.6.6-.6H48V9z"
      ],
      tags: ["element-carousel"],
      viewBox: ["0 0 48 48"]
    },
    {
      paths: [
        "M46 9H36c-1.1 0-2 .9-2 2v26c0 1.1.9 2 2 2h10c1.1 0 2-.9 2-2V11c0-1.1-.9-2-2-2zm-.6 28h-8.8c-.3 0-.6-.3-.6-.6V11.6c0-.3.3-.6.6-.6h8.8c.3 0 .6.3.6.6v24.8c0 .3-.3.6-.6.6z",
        "M29 9H19c-1.1 0-2 .9-2 2v26c0 1.1.9 2 2 2h10c1.1 0 2-.9 2-2V11c0-1.1-.9-2-2-2zm-.6 28h-8.8c-.3 0-.6-.3-.6-.6V11.6c0-.3.3-.6.6-.6h8.8c.3 0 .6.3.6.6v24.8c0 .3-.3.6-.6.6z",
        "M12 9H2c-1.1 0-2 .9-2 2v26c0 1.1.9 2 2 2h10c1.1 0 2-.9 2-2V11c0-1.1-.9-2-2-2zm-.6 28H2.6c-.3 0-.6-.3-.6-.6V11.6c0-.3.3-.6.6-.6h8.8c.3 0 .6.3.6.6v24.8c0 .3-.3.6-.6.6z"
      ],
      tags: ["element-column"],
      viewBox: ["0 0 48 48"]
    },
    {
      paths: [
        "M20.3 26.3h3v1.3h-4.7V27c0-.4.1-.7.2-1s.3-.5.5-.8.4-.4.6-.6.4-.3.6-.5c.2-.1.4-.3.5-.4l.4-.4c.1-.1.2-.3.2-.4s.1-.3.1-.4c0-.3-.1-.5-.3-.7s-.4-.2-.8-.2c-.6 0-1.2.2-1.7.7V21c.6-.4 1.3-.6 2.1-.6.4 0 .7 0 1 .1s.5.2.7.4.3.4.4.6.2.5.2.8c0 .3 0 .6-.1.9s-.2.5-.4.7l-.6.6c-.2.2-.4.3-.7.5-.2.1-.3.2-.5.3s-.3.2-.4.3l-.3.3c-.1.1 0 .3 0 .4zM28.6 20.6V25h.8v1.2h-.8v1.4h-1.4v-1.4h-3.1V25c.3-.3.6-.6.8-1s.6-.7.8-1.1.5-.8.8-1.1.4-.8.6-1.1h1.5zM25.5 25h1.7v-2.4c-.1.2-.2.4-.4.6s-.3.4-.4.6-.3.4-.4.6-.4.4-.5.6z",
        "M11 24c0-7.2 5.8-13 13-13 3.1 0 5.9 1.1 8.1 2.9l1.4-1.4c-.1-.1-.2-.1-.3-.2C30.7 10.2 27.5 9 24 9 15.7 9 9 15.7 9 24s6.7 15 15 15v-2c-7.2 0-13-5.8-13-13z"
      ],
      tags: ["element-circle-counter"],
      viewBox: ["0 0 48 48"]
    },
    {
      paths: [
        "M11.64 16.98c-.85 0-1.5.28-1.96.85-.45.57-.68 1.4-.68 2.49v1.44c.01 1.05.24 1.85.69 2.42.45.56 1.1.84 1.96.84.86 0 1.52-.29 1.97-.86.45-.57.67-1.4.67-2.48v-1.44c-.01-1.05-.24-1.85-.69-2.41s-1.11-.85-1.96-.85zm1.09 4.97c-.01.61-.09 1.07-.26 1.37-.17.3-.44.45-.82.45-.38 0-.66-.16-.83-.46-.17-.31-.26-.78-.26-1.42v-1.9c.01-.6.1-1.04.28-1.32.17-.28.44-.42.81-.42.38 0 .65.15.83.44.18.3.27.77.27 1.42v1.84zm7.17-4.13c-.45-.56-1.1-.84-1.96-.84s-1.5.28-1.96.85c-.45.57-.68 1.39-.68 2.49v1.44c.01 1.05.24 1.85.69 2.42.45.56 1.1.84 1.96.84.86 0 1.52-.29 1.97-.86.45-.57.67-1.4.67-2.48v-1.44c0-1.05-.24-1.86-.69-2.42zm-.86 4.13c-.01.61-.09 1.07-.26 1.37-.17.3-.44.45-.82.45-.38 0-.66-.16-.83-.46-.17-.31-.26-.78-.26-1.42v-1.9c.01-.6.1-1.04.28-1.32.17-.28.44-.42.81-.42.38 0 .65.15.83.44.18.3.27.77.27 1.42v1.84zm5.47.65c.17.15.25.35.25.6 0 .24-.08.44-.25.59-.17.15-.38.23-.63.23s-.46-.08-.63-.23c-.17-.14-.25-.34-.25-.58 0-.25.08-.45.25-.6.17-.15.38-.23.63-.23.25-.01.46.07.63.22zm-1.26-3.2a.75.75 0 01-.25-.59c0-.25.08-.45.25-.6.17-.15.38-.23.63-.23s.46.08.63.23c.17.15.25.35.25.6 0 .24-.08.44-.25.59s-.38.23-.63.23c-.26 0-.47-.08-.63-.23zm8.34-1.58c-.45-.56-1.1-.84-1.96-.84s-1.5.28-1.96.85-.67 1.4-.67 2.49v1.44c.01 1.05.24 1.85.69 2.42s1.1.84 1.96.84c.86 0 1.52-.29 1.97-.86s.67-1.4.67-2.48v-1.44c-.01-1.05-.25-1.86-.7-2.42zm-.86 4.13c-.01.61-.09 1.07-.26 1.37-.17.3-.44.45-.82.45-.38 0-.66-.15-.83-.46s-.26-.78-.26-1.42v-1.9c.01-.6.1-1.04.28-1.32.17-.28.44-.42.81-.42.38 0 .65.15.83.44.18.3.27.77.27 1.42v1.84zM37.2 26h-1.55v-3.22l-1.85.58V22.1l3.24-1.16h.17V26zm-1.55-5.98c.86 0 1.52-.29 1.97-.86s.67-1.4.67-2.48V16h-1.55v.95c-.01.61-.09 1.07-.26 1.37-.17.3-.44.45-.82.45-.38 0-.66-.15-.83-.46s-.26-.78-.26-1.42V16H33v.76c.01 1.05.24 1.85.69 2.42s1.11.84 1.96.84z",
        "M44 30V13.98c0-2.2-1.78-3.98-3.98-3.98H7.99C5.79 10 4 11.79 4 13.99V30H0v8h4c.55 0 1-.45 1-1s-.45-1-1-1H2v-4h29c.55 0 1-.45 1-1s-.45-1-1-1H6v-2h36v2h-1c-.55 0-1 .45-1 1s.45 1 1 1h5v4H14c-.55 0-1 .45-1 1s.45 1 1 1h34v-8h-4zm-2-4H6V16h36v10zm0-12H6v-.01c0-1.1.89-1.99 1.99-1.99h32.03c1.09 0 1.98.89 1.98 1.98V14zM11 37c0 .55-.45 1-1 1H8c-.55 0-1-.45-1-1s.45-1 1-1h2c.55 0 1 .45 1 1zm24-5c-.55 0-1-.45-1-1s.45-1 1-1h2c.55 0 1 .45 1 1s-.45 1-1 1h-2z"
      ],
      tags: ["element-countdown"],
      viewBox: ["0 0 48 48"]
    },
    {
      paths: [
        "M24 5C13.51 5 5 13.51 5 24s8.51 19 19 19 19-8.51 19-19S34.49 5 24 5zm0 36c-9.37 0-17-7.63-17-17S14.63 7 24 7s17 7.63 17 17-7.63 17-17 17z",
        "M28.38 26.45c-1.08 0-2.05.5-2.72 1.26l-4.62-2.66a3.616 3.616 0 00.06-1.84l4.7-2.72c.64.67 1.58 1.11 2.6 1.11 1.99 0 3.6-1.6 3.6-3.59 0-1.99-1.64-3.65-3.62-3.65-1.99 0-3.59 1.61-3.59 3.59 0 .12 0 .26.03.38l-4.97 2.86c-.61-.5-1.4-.79-2.25-.79-1.99.01-3.6 1.61-3.6 3.6s1.61 3.59 3.59 3.59c.79 0 1.49-.26 2.1-.67l5.11 2.92v.18c-.06 2.02 1.58 3.62 3.56 3.62 1.99 0 3.59-1.61 3.59-3.59.02-1.99-1.59-3.6-3.57-3.6zm0-9.76c.7 0 1.26.56 1.26 1.26s-.56 1.26-1.26 1.26-1.26-.56-1.26-1.26.56-1.26 1.26-1.26zm-10.82 8.57c-.7 0-1.26-.56-1.26-1.26s.56-1.26 1.26-1.26 1.26.56 1.26 1.26-.55 1.26-1.26 1.26zm10.82 6.05c-.7 0-1.26-.56-1.26-1.26s.56-1.29 1.26-1.29 1.26.56 1.26 1.26-.56 1.29-1.26 1.29z"
      ],
      tags: ["element-social-share"],
      viewBox: ["0 0 48 48"]
    },
    {
      paths: [
        "M17 31c0 .55-.45 1-1 1h-2c-.55 0-1-.45-1-1s.45-1 1-1h2c.55 0 1 .45 1 1zm23-15H8c-4.42 0-8 3.58-8 8s3.58 8 8 8h2c.55 0 1-.45 1-1s-.45-1-1-1H8c-3.31 0-6-2.69-6-6s2.69-6 6-6h32c3.31 0 6 2.69 6 6s-2.69 6-6 6H20c-.55 0-1 .45-1 1s.45 1 1 1h20c4.42 0 8-3.58 8-8s-3.58-8-8-8z",
        "M21 25H7c-.55 0-1-.45-1-1s.45-1 1-1h14c.55 0 1 .45 1 1s-.45 1-1 1z",
        "M39.88 20.7a4.008 4.008 0 00-5.66 0 4.008 4.008 0 000 5.66 3.991 3.991 0 004.85.61l1.51 1.51L42 27.06l-1.51-1.51c.9-1.54.71-3.54-.61-4.85zm-1.42 4.24c-.78.78-2.05.78-2.83 0-.78-.78-.78-2.05 0-2.83s2.05-.78 2.83 0c.78.78.78 2.05 0 2.83z"
      ],
      tags: ["element-search-form"],
      viewBox: ["0 0 48 48"]
    },
    {
      paths: [
        "M18 22.5c-.8 0-1.5.7-1.5 1.5s.7 1.5 1.5 1.5 1.5-.7 1.5-1.5-.7-1.5-1.5-1.5zm6 0c-.8 0-1.5.7-1.5 1.5s.7 1.5 1.5 1.5 1.5-.7 1.5-1.5-.7-1.5-1.5-1.5zm6 0c-.8 0-1.5.7-1.5 1.5s.7 1.5 1.5 1.5 1.5-.7 1.5-1.5-.7-1.5-1.5-1.5zm-15.5-7l-7.1 7.1L6 24l1.4 1.4 7.1 7.1 1.4-1.4L8.8 24l7.1-7.1-1.4-1.4zm26.1 7.1l-7.1-7.1-1.4 1.4 7.1 7.1-7.1 7.1 1.4 1.4 7.1-7.1L42 24l-1.4-1.4z"
      ],
      tags: ["element-pagination"],
      viewBox: ["0 0 48 48"]
    },
    {
      paths: [
        "M38 43H14c-1.7 0-3-1.3-3-3V8c0-1.7 1.3-3 3-3h15.9C36 5 41 10 41 16.1V40c0 1.7-1.3 3-3 3zM14 7c-.6 0-1 .4-1 1v32c0 .6.4 1 1 1h24c.6 0 1-.4 1-1V16.1c0-5-4.1-9.1-9.1-9.1H14z",
        "M31 37H9c-1.1 0-2-.9-2-2v-9c0-1.1.9-2 2-2h22c1.1 0 2 .9 2 2v9c0 1.1-.9 2-2 2z",
        "M14.7 33.1h-1.1v-2h-2v2h-1.1v-4.9h1.1v2h2v-2h1.1v4.9zm4.6-4.1h-1.4v4h-1.1v-4h-1.4v-.9h3.9v.9zm6.2 4.1h-1.1v-2.9-1c-.1.3-.1.5-.1.6l-1.1 3.3h-.9l-1.2-3.3c0-.1-.1-.3-.2-.7v4h-1v-4.9h1.6l1 2.9c.1.2.1.5.2.7.1-.3.1-.5.2-.7l1-2.9h1.6v4.9zm4.1 0h-2.9v-4.9h1.1v4h1.8v.9z"
      ],
      tags: ["element-code"],
      viewBox: ["0 0 48 48"]
    },
    {
      paths: [
        "M37 9H11c-1.1 0-2 .9-2 2v26c0 1.1.9 2 2 2h26c1.1 0 2-.9 2-2V11c0-1.1-.9-2-2-2zm-.6 28H11.6c-.3 0-.6-.3-.6-.6V11.6c0-.3.3-.6.6-.6h24.8c.3 0 .6.3.6.6v24.8c0 .3-.3.6-.6.6z"
      ],
      tags: ["element-default"],
      viewBox: ["0 0 48 48"]
    },
    {
      paths: [
        "M38 23H10c-.6 0-1 .4-1 1s.4 1 1 1h28c.6 0 1-.4 1-1s-.4-1-1-1z",
        "M24 13.2c-.5 0-1 .2-1.4.6l-3.5 3.5c-.4.4-.4 1 0 1.4.2.2.5.3.7.3.3 0 .5-.1.7-.3l3.1-3.1c.1-.1.3-.2.4-.2s.3.1.4.2l3.1 3.1c.2.2.5.3.7.3.3 0 .5-.1.7-.3.4-.4.4-1 0-1.4l-3.5-3.5c-.4-.4-.9-.6-1.4-.6z",
        "M28.2 29c-.3 0-.5.1-.7.3l-3.1 3.1c-.1.1-.3.2-.4.2s-.3-.1-.4-.2l-3.1-3.1c-.2-.2-.5-.3-.7-.3-.3 0-.5.1-.7.3-.4.4-.4 1 0 1.4l3.5 3.5c.4.4.9.6 1.4.6s1-.2 1.4-.6l3.5-3.5c.4-.4.4-1 0-1.4-.1-.2-.4-.3-.7-.3z"
      ],
      tags: ["element-divider"],
      viewBox: ["0 0 48 48"]
    },
    {
      paths: [
        "M37 8H11c-1.1 0-2 .9-2 2v3c0 1.1.9 2 2 2h26c1.1 0 2-.9 2-2v-3c0-1.1-.9-2-2-2zm-.6 5H11.6c-.3 0-.6-.3-.6-.6v-1.8c0-.3.3-.6.6-.6h24.8c.3 0 .6.3.6.6v1.8c0 .3-.3.6-.6.6zM37 17H11c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h26c1.1 0 2-.9 2-2V19c0-1.1-.9-2-2-2zm-.6 14H11.6c-.3 0-.6-.3-.6-.6V19.6c0-.3.3-.6.6-.6h24.8c.3 0 .6.3.6.6v10.8c0 .3-.3.6-.6.6z",
        "M23 38c0 1.1-.9 2-2 2H11c-1.1 0-2-.9-2-2v-1c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2v1z"
      ],
      tags: ["element-form"],
      viewBox: ["0 0 48 48"]
    },
    {
      paths: [
        "M32 21.2c0-.2-.3-.4-.5-.4l-4.8-.7-2.2-4.4c-.1-.3-.4-.4-.6-.3h-.1l-.3.3-2.2 4.4-4.8.7c-.3 0-.5.3-.5.6 0 .1.1.3.2.4l3.5 3.4-.9 4.8c0 .3.2.6.5.6h.4l4.3-2.3 4.3 2.3h.6c.2-.1.3-.3.3-.5l-.9-4.9 3.5-3.4c.2-.2.2-.4.2-.6z"
      ],
      circle: ['cx="24" cy="24" r="14" fill="none" stroke="currentColor" stroke-width="2" stroke-linejoin="round"'],
      tags: ["element-icon"],
      viewBox: ["0 0 48 48"]
    },
    {
      paths: [
        "M38 36c0 1.1-.9 2-2 2H12c-1.1 0-2-.9-2-2V12c0-1.1.9-2 2-2h24c1.1 0 2 .9 2 2v24z",
        "M35.2 25.5L31.7 22l-9.8 9.7-4.5-4.5-1.4 1.4-3 3.1 1.4 1.4 3-3 4.5 4.4 9.8-9.7 2.1 2.1zM19 18.6c.6 0 1 .4 1 1s-.4 1-1 1-1-.4-1-1 .5-1 1-1m0-2c-1.7 0-3 1.3-3 3s1.3 3 3 3 3-1.3 3-3-1.3-3-3-3z"
      ],
      tags: ["element-image"],
      viewBox: ["0 0 48 48"]
    },
    {
      paths: [
        "M30 34c.5 0 1-.5 1-1s-.5-1-1-1H18c-.5 0-1 .5-1 1s.5 1 1 1h12zM33 36H15c-.5 0-1 .5-1 1s.5 1 1 1h18c.5 0 1-.5 1-1s-.5-1-1-1zM33 40H15c-.5 0-1 .5-1 1s.5 1 1 1h18c.5 0 1-.5 1-1s-.5-1-1-1zM34.4 6H13.6c-.9 0-1.6.7-1.6 1.6v20.8c0 .9.7 1.6 1.6 1.6h20.8c.9 0 1.6-.7 1.6-1.6V7.6c0-.9-.7-1.6-1.6-1.6zm0 21.9c0 .2-.2.5-.5.5H14.1c-.2 0-.5-.2-.5-.5V8.1c0-.2.2-.5.5-.5h19.8c.2 0 .5.2.5.5v19.8z",
        "M19.9 15.4c1.4 0 2.4-1 2.4-2.4s-1-2.4-2.4-2.4-2.4 1-2.4 2.4 1.1 2.4 2.4 2.4zm0-3.2c.5 0 .8.3.8.8s-.3.8-.8.8-.8-.3-.8-.8.4-.8.8-.8zM22.2 22.7l-3.6-3.6-1.1 1.1-2.4 2.5 1.1 1.1 2.4-2.4 3.6 3.5 7.9-7.7 1.7 1.7 1.1-1.2-2.8-2.8z"
      ],
      tags: ["element-image-box"],
      viewBox: ["0 0 48 48"]
    },
    {
      paths: [
        "M33 13H7c-1.1 0-2 .9-2 2v26c0 1.1.9 2 2 2h26c1.1 0 2-.9 2-2V15c0-1.1-.9-2-2-2zm-.6 28H7.6c-.3 0-.6-.3-.6-.6V15.6c0-.3.3-.6.6-.6h24.8c.3 0 .6.3.6.6v24.8c0 .3-.3.6-.6.6z",
        "M31.1 27.9l-3.5-3.5-9.8 9.7-4.5-4.5-1.4 1.4-3 3.1 1.4 1.4 3-3 4.5 4.4 9.8-9.7 2.1 2.1 1.4-1.4zM14.9 21c.6 0 1 .4 1 1s-.4 1-1 1-1-.4-1-1 .5-1 1-1m0-2c-1.7 0-3 1.3-3 3s1.3 3 3 3 3-1.3 3-3-1.3-3-3-3z",
        "M37 9H11c-1.1 0-2 .9-2 2v2h2v-1.4c0-.3.3-.6.6-.6h24.8c.3 0 .6.3.6.6v24.8c0 .3-.3.6-.6.6H35v2h2c1.1 0 2-.9 2-2V11c0-1.1-.9-2-2-2z",
        "M41 5H15c-1.1 0-2 .9-2 2v2h2V7.6c0-.3.3-.6.6-.6h24.8c.3 0 .6.3.6.6v24.8c0 .3-.3.6-.6.6H39v2h2c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2z"
      ],
      tags: ["element-image-gallery"],
      viewBox: ["0 0 48 48"]
    },
    {
      paths: [
        "M34.3 25.5l4.6 9.5c.2.4 0 .7-.4.7h-29c-.4 0-.6-.3-.4-.7l4.6-9.5c.1-.2.3-.3.4-.3h4c.1 0 .3.1.4.2.3.3.5.6.8.9.3.3.5.6.8.9h-4.7c-.2 0-.4.1-.4.3l-3.1 6.3h24.3l-3.1-6.3c-.1-.2-.3-.3-.4-.3H28c.3-.3.5-.6.8-.9.3-.3.5-.6.8-.9.1-.1.2-.2.4-.2h4c0 .1.2.2.3.3zm-3.5-6.4c0 5.2-4.3 6.2-6.3 11.1-.2.4-.7.4-.9 0-1.8-4.5-5.5-5.7-6.2-9.7-.7-3.9 2-7.8 6-8.2 4-.4 7.4 2.8 7.4 6.8zm-3.2 0c0-2-1.6-3.6-3.6-3.6s-3.6 1.6-3.6 3.6 1.6 3.6 3.6 3.6 3.6-1.7 3.6-3.6z"
      ],
      tags: ["element-map"],
      viewBox: ["0 0 48 48"]
    },
    {
      paths: ["M38 36c0 1.1-.9 2-2 2H12c-1.1 0-2-.9-2-2V12c0-1.1.9-2 2-2h24c1.1 0 2 .9 2 2v24z", "M30.2 24l-10.4-6v12z"],
      tags: ["element-media"],
      viewBox: ["0 0 48 48"]
    },
    {
      paths: [
        "M36.9 24h-6.4V13.3c0-1.2-1-2.1-2.1-2.1H11.1c-1.2 0-2.1 1-2.1 2.1v18.2c0 3 2.4 5.4 5.4 5.4h19.3c3 0 5.4-2.4 5.4-5.4v-5.4C39 25 38 24 36.9 24zM14.4 34.7c-1.8 0-3.2-1.4-3.2-3.2V13.3h17.1V31.5c0 1.2.4 2.4 1.1 3.2h-15zm22.5-3.2c0 1.8-1.4 3.2-3.2 3.2-1.8 0-3.2-1.4-3.2-3.2v-5.4h6.4v5.4z",
        "M25.1 16.5h-5.4c-.6 0-1.1.5-1.1 1.1s.5 1.1 1.1 1.1h5.4c.6 0 1.1-.5 1.1-1.1s-.5-1.1-1.1-1.1zM25.1 20.8h-5.4c-.6 0-1.1.5-1.1 1.1 0 .6.5 1.1 1.1 1.1h5.4c.6 0 1.1-.5 1.1-1.1-.1-.6-.5-1.1-1.1-1.1zM25.1 25.1H14.4c-.6 0-1.1.5-1.1 1.1 0 .6.5 1.1 1.1 1.1h10.7c.6 0 1.1-.5 1.1-1.1-.1-.6-.5-1.1-1.1-1.1zM25.1 29.4H14.4c-.6 0-1.1.5-1.1 1.1 0 .6.5 1.1 1.1 1.1h10.7c.6 0 1.1-.5 1.1-1.1-.1-.7-.5-1.1-1.1-1.1z"
      ],
      tags: ["element-newsletter"],
      viewBox: ["0 0 48 48"]
    },
    {
      paths: [
        "M34 5H14c-1.1 0-2 .9-2 2v34c0 1.1.9 2 2 2h20c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm-.6 36H14.6c-.3 0-.6-.3-.6-.6V7.6c0-.3.3-.6.6-.6h18.8c.3 0 .6.3.6.6v32.8c0 .3-.3.6-.6.6z",
        "M28 29h-8c-.6 0-1-.4-1-1s.4-1 1-1h8c.6 0 1 .4 1 1s-.4 1-1 1zM28 33h-8c-.6 0-1-.4-1-1s.4-1 1-1h8c.6 0 1 .4 1 1s-.4 1-1 1zM28 37h-8c-.6 0-1-.4-1-1s.4-1 1-1h8c.6 0 1 .4 1 1s-.4 1-1 1z",
        "M24.9 21.7c.8-.2 1.5-.6 1.8-1.4.7-1.6 0-2.7-1.6-3.5l-.8-.4-.8-.4c-1-.5-1.2-.9-.9-1.6.4-.8 2.1-.8 2.7-.3l.6.4.9-1.2-.6-.4c-.3-.2-.8-.4-1.3-.5V11h-1.5v1.3c-.9.1-1.7.6-2.1 1.5-.7 1.6 0 2.7 1.6 3.5l.8.4c.6.3.6.3.7.4 1 .5 1.3.9.9 1.6-.4.8-2.1.8-2.7.3l-.6-.5-.9 1.2.6.4c.4.3 1 .5 1.6.6V23h1.5v-1.3z"
      ],
      tags: ["element-pricing-table"],
      viewBox: ["0 0 48 48"]
    },
    {
      paths: [
        "M46 9H2c-1.1 0-2 .9-2 2v26c0 1.1.9 2 2 2h44c1.1 0 2-.9 2-2V11c0-1.1-.9-2-2-2zM2.6 37c-.3 0-.6-.3-.6-.6V11.6c0-.3.3-.6.6-.6h42.8c.3 0 .6.3.6.6v24.8c0 .3-.3.6-.6.6H2.6z",
        "M18 22.5c-.8 0-1.5.7-1.5 1.5s.7 1.5 1.5 1.5 1.5-.7 1.5-1.5-.7-1.5-1.5-1.5zM24 22.5c-.8 0-1.5.7-1.5 1.5s.7 1.5 1.5 1.5 1.5-.7 1.5-1.5-.7-1.5-1.5-1.5zM30 22.5c-.8 0-1.5.7-1.5 1.5s.7 1.5 1.5 1.5 1.5-.7 1.5-1.5-.7-1.5-1.5-1.5z"
      ],
      tags: ["element-section"],
      viewBox: ["0 0 48 48"]
    },
    {
      paths: [
        "M46 9H2C0.9 9 0 9.9 0 11V37C0 38.1 0.9 39 2 39H46C47.1 39 48 38.1 48 37V11C48 9.9 47.1 9 46 9ZM2.6 37C2.3 37 2 36.7 2 36.4V11.6C2 11.3 2.3 11 2.6 11H45.4C45.7 11 46 11.3 46 11.6V36.4C46 36.7 45.7 37 45.4 37H2.6Z",
        "M21 13C19.3431 13 18 14.3431 18 16V32C18 33.6569 19.3431 35 21 35H27C28.6569 35 30 33.6569 30 32V16C30 14.3431 28.6569 13 27 13H21ZM20 16C20 15.4477 20.4477 15 21 15H27C27.5523 15 28 15.4477 28 16V32C28 32.5523 27.5523 33 27 33H21C20.4477 33 20 32.5523 20 32V16ZM7 23C5.34315 23 4 24.3431 4 26V32C4 33.6569 5.34315 35 7 35H13C14.6569 35 16 33.6569 16 32V26C16 24.3431 14.6569 23 13 23H7ZM6 26C6 25.4477 6.44772 25 7 25H13C13.5523 25 14 25.4477 14 26V32C14 32.5523 13.5523 33 13 33H7C6.44772 33 6 32.5523 6 32V26ZM4 16C4 14.3431 5.34315 13 7 13H13C14.6569 13 16 14.3431 16 16V18C16 19.6569 14.6569 21 13 21H7C5.34315 21 4 19.6569 4 18V16ZM7 15C6.44772 15 6 15.4477 6 16V18C6 18.5523 6.44772 19 7 19H13C13.5523 19 14 18.5523 14 18V16C14 15.4477 13.5523 15 13 15H7ZM35 13C33.3431 13 32 14.3431 32 16V32C32 33.6569 33.3431 35 35 35H41C42.6569 35 44 33.6569 44 32V16C44 14.3431 42.6569 13 41 13H35ZM34 16C34 15.4477 34.4477 15 35 15H41C41.5523 15 42 15.4477 42 16V32C42 32.5523 41.5523 33 41 33H35C34.4477 33 34 32.5523 34 32V16Z"
      ],
      tags: ["element-container"],
      viewBox: ["0 0 48 48"]
    },
    {
      paths: [
        "M37 9H27c-1.1 0-2 .9-2 2v26c0 1.1.9 2 2 2h10c1.1 0 2-.9 2-2V11c0-1.1-.9-2-2-2zm-.6 28h-8.8c-.3 0-.6-.3-.6-.6V11.6c0-.3.3-.6.6-.6h8.8c.3 0 .6.3.6.6v24.8c0 .3-.3.6-.6.6z",
        "M20 9H9v2h10.4c.3 0 .6.3.6.6v24.8c0 .3-.3.6-.6.6H9v2h11c1.1 0 2-.9 2-2V11c0-1.1-.9-2-2-2z"
      ],
      tags: ["element-sidebar"],
      viewBox: ["0 0 48 48"]
    },
    {
      paths: [
        "M46 13H2c-1.1 0-2 .9-2 2v26c0 1.1.9 2 2 2h44c1.1 0 2-.9 2-2V15c0-1.1-.9-2-2-2zM2.6 41c-.3 0-.6-.3-.6-.6V15.6c0-.3.3-.6.6-.6h42.8c.3 0 .6.3.6.6v24.8c0 .3-.3.6-.6.6H2.6z",
        "M44 9H4c-.6 0-1 .4-1 1s.4 1 1 1h40c.6 0 1-.4 1-1s-.4-1-1-1zM7 7h34c.6 0 1-.4 1-1s-.4-1-1-1H7c-.6 0-1 .4-1 1s.4 1 1 1z"
      ],
      tags: ["element-slider"],
      viewBox: ["0 0 48 48"]
    },
    {
      paths: [
        "M33 28c-.1 0-.3 0-.4.1-.2.1-.3.1-.5.1-.8 0-1.6-.6-1.8-1.4l-2-7.4c-.9-3.4-3.9-5.7-7.4-5.7h-.7v-.6c-.2-.8-1-1.2-1.8-1-.8.2-1.2 1-1 1.8.1.2.2.4.3.5-1.4.7-2.6 1.7-3.4 3.1-1 1.8-1.3 3.8-.8 5.8l2 7.4c.1.5.1 1-.2 1.4-.3.4-.7.7-1.1.9-.8.2-1.3 1.1-1.1 1.9.2.7.8 1.2 1.5 1.2.1 0 .3 0 .4-.1l6.3-1.7c.6.9 1.6 1.5 2.7 1.5.3 0 .6 0 .8-.1 1.4-.4 2.3-1.6 2.4-2.9l6.2-1.7c.4-.1.8-.4 1-.7.2-.4.3-.8.2-1.2-.2-.7-.8-1.2-1.6-1.2zm-16.3 5.6c.2-.2.3-.4.4-.6.5-.9.6-1.9.4-2.9l-2-7.4c-.4-1.5-.2-3 .6-4.4.8-1.3 2-2.3 3.5-2.7.5-.1 1-.2 1.5-.2 2.6 0 4.9 1.7 5.5 4.2l2 7.4c.3 1.2 1.2 2.2 2.4 2.6l-14.3 4zM29.1 16.9c.3 0 .5-.1.7-.3l2-2c.4-.4.4-1 0-1.3-.4-.4-1-.4-1.3 0l-2 2c-.4.4-.4 1 0 1.3.1.2.3.3.6.3zM33.8 19.7H31c-.5 0-1 .4-1 1s.4 1 1 1h2.8c.5 0 1-.4 1-1s-.4-1-1-1zM30.5 18.1c.2.4.5.6.9.6.1 0 .3 0 .4-.1l2.6-1.1c.5-.2.7-.8.5-1.2-.2-.5-.8-.7-1.2-.5l-2.7 1c-.5.2-.7.8-.5 1.3z"
      ],
      tags: ["element-alert"],
      viewBox: ["0 0 48 48"]
    },
    {
      circle: ['cx="24" cy="23.3" r="5.7"'],
      paths: [
        "M24.4 32.6l1.7 6.4H34c0-4.4-3.6-8-8-8l-1.6 1.6zM23.7 32.6L22.1 31H22c-4.4 0-8 3.6-8 8h8.1l1.6-6.4z",
        "M25.7 12.9l1.4-1.4c.1-.1.1-.4-.1-.4-.6-.1-1.3-.2-1.9-.3L24.2 9c-.1-.2-.4-.2-.4 0l-.9 1.8c-.7.1-1.3.2-2 .3-.2 0-.2.3-.1.4l1.4 1.4c-.1.6-.2 1.3-.3 1.9 0 .2.2.4.4.3.6-.3 1.1-.6 1.7-.9.5.3 1.1.6 1.6.9 0 .1.1.1.2.1.2 0 .3-.2.3-.3-.2-.7-.3-1.3-.4-2zM20.8 13c-.5-.1-1-.1-1.5-.2-.2-.4-.4-.9-.6-1.3-.1-.2-.4-.2-.4 0-.2.4-.4.9-.7 1.3-.5.1-1 .1-1.5.2-.2 0-.2.3-.1.4l1 1c-.1.5-.2.9-.2 1.4 0 .2.2.4.4.3.4-.2.9-.4 1.3-.7l1.2.6c0 .1.1.1.2.1s.2-.1.3-.2v-.1c-.1-.5-.2-.9-.2-1.4l1-1c.1-.1 0-.4-.2-.4zM15.7 14.5c-.4-.1-.7-.1-1.1-.2-.2-.3-.3-.6-.5-1-.1-.2-.4-.2-.4 0-.2.3-.3.6-.5 1-.4.1-.7.1-1.1.2-.2 0-.2.3-.1.4.3.2.5.5.8.7-.1.3-.1.7-.2 1 0 .2.2.4.4.3.3-.2.6-.3.9-.5.3.1.6.3.8.4.1.1.2.1.3.1.1-.1.1-.1.1-.3-.1-.3-.1-.7-.2-1 .3-.2.5-.5.8-.7.2-.1.2-.4 0-.4zM31.8 13.1c-.5-.1-1-.1-1.5-.2-.2-.4-.4-.9-.7-1.3-.1-.2-.4-.2-.4 0-.2.4-.4.9-.6 1.3-.5.1-1 .1-1.5.2-.2 0-.2.3-.1.4l1 1c0 .5 0 .9-.1 1.4-.1.1 0 .3.2.3.1 0 .2 0 .3-.1l1.2-.6c.4.2.9.4 1.3.7.2.1.4-.1.4-.3-.1-.5-.2-.9-.2-1.4l1-1c0-.1-.1-.4-.3-.4zM35.8 14.6c-.4-.1-.7-.1-1.1-.2-.2-.3-.3-.6-.5-1-.1-.2-.4-.2-.4 0-.2.3-.3.6-.5 1-.4.1-.7.1-1.1.2-.2 0-.2.3-.1.4.3.2.5.5.8.7-.1.3-.1.6-.2.9-.1.1 0 .3.1.3.1.1.3.1.3 0 .3-.1.6-.3.8-.4.3.2.6.3.9.5.2.1.4-.1.4-.3-.1-.3-.1-.7-.2-1 .3-.2.5-.5.8-.7.3-.1.2-.4 0-.4z"
      ],
      tags: ["element-testimonial"],
      viewBox: ["0 0 48 48"]
    },
    {
      paths: [
        "M46 15H24.6c-.3 0-.6-.3-.6-.6V11c0-1.1-.9-2-2-2H12c-1.1 0-2 .9-2 2v3.4c0 .3-.3.6-.6.6H2c-1.1 0-2 .9-2 2v20c0 1.1.9 2 2 2h44c1.1 0 2-.9 2-2V17c0-1.1-.9-2-2-2zM2 36.4V17.6c0-.3.3-.6.6-.6H10c1.1 0 2-.9 2-2v-3.4c0-.3.3-.6.6-.6h8.8c.3 0 .6.3.6.6V15c0 1.1.9 2 2 2h21.4c.3 0 .6.3.6.6v18.8c0 .3-.3.6-.6.6H2.6c-.3 0-.6-.3-.6-.6z",
        "M7 11H1c-.6 0-1 .4-1 1s.4 1 1 1h6c.6 0 1-.4 1-1s-.4-1-1-1zM33 11h-6c-.6 0-1 .4-1 1s.4 1 1 1h6c.6 0 1-.4 1-1s-.4-1-1-1zM43 11h-6c-.6 0-1 .4-1 1s.4 1 1 1h6c.6 0 1-.4 1-1s-.4-1-1-1z"
      ],
      tags: ["element-tabs"],
      viewBox: ["0 0 48 48"]
    },
    {
      paths: [
        "M13.3 12h21.4l.2 7.8h-2.1l-.2-2.2c0-1-.4-2-1.1-2.7-.9-.6-2-.9-3.1-.8-.7-.1-1.5.1-2.1.5-.5.7-.7 1.5-.6 2.3v14.2c-.1.8.1 1.6.6 2.3.3.4 1.1.5 2.2.5H30V36H18v-2.1h1.8c.7 0 1.4-.1 2-.5.4-.7.6-1.5.5-2.3V16.9c.1-.8-.1-1.6-.6-2.3-.6-.4-1.4-.6-2.1-.5-1.1-.1-2.2.2-3.1.8-.7.7-1.1 1.7-1.1 2.7l-.2 2.2h-2.1l.2-7.8z"
      ],
      tags: ["element-heading"],
      viewBox: ["0 0 48 48"]
    },
    {
      paths: [
        "M34.6 12H13.2L13 19.8H15.1L15.3 17.6C15.3 16.6 15.7 15.6 16.4 14.9C17.3 14.3 18.4 14 19.5 14.1C20.2 14 21 14.2 21.6 14.6C22.1 15.3 22.3 16.1 22.2 16.9V24H25.6V16.9C25.5 16.1 25.7 15.3 26.2 14.6C26.8 14.2 27.6 14 28.3 14.1C29.4 14 30.5 14.3 31.4 14.9C32.1 15.6 32.5 16.6 32.5 17.6L32.7 19.8H34.8L34.6 12ZM21 36V33.7303C20.5834 33.8602 20.1417 33.9 19.7 33.9H17.9V36H21Z",
        "M23 27C23 26.4477 23.4477 26 24 26H34C34.5523 26 35 26.4477 35 27C35 27.5523 34.5523 28 34 28H24C23.4477 28 23 27.5523 23 27ZM23 31C23 30.4477 23.4477 30 24 30H38C38.5523 30 39 30.4477 39 31C39 31.5523 38.5523 32 38 32H24C23.4477 32 23 31.5523 23 31ZM24 34C23.4477 34 23 34.4477 23 35C23 35.5523 23.4477 36 24 36H38C38.5523 36 39 35.5523 39 35C39 34.4477 38.5523 34 38 34H24Z"
      ],
      tags: ["element-text"],
      viewBox: ["0 0 48 48"]
    },
    {
      paths: [
        "M22 37h-2c-.6 0-1-.4-1-1s.4-1 1-1h2c.6 0 1 .4 1 1s-.4 1-1 1zm12-26H14c-1.7 0-3 1.3-3 3v20c0 1.7 1.3 3 3 3h2c.6 0 1-.4 1-1s-.4-1-1-1h-2c-.6 0-1-.4-1-1V14c0-.6.4-1 1-1h20c.6 0 1 .4 1 1v20c0 .6-.4 1-1 1h-8c-.6 0-1 .4-1 1s.4 1 1 1h8c1.7 0 3-1.3 3-3V14c0-1.7-1.3-3-3-3z",
        "M23.3 29.5c0 .9-.8 1.7-1.7 1.7-.9 0-1.7-.8-1.7-1.7 0-.9.8-1.7 1.7-1.7.9 0 1.7.8 1.7 1.7zm3.3-1.7c-.9 0-1.7.8-1.7 1.7 0 .9.8 1.7 1.7 1.7s1.7-.8 1.7-1.7c0-.9-.8-1.7-1.7-1.7zm2.9-1.7h-8.9l-.2-1h7.3c.2 0 .4-.1.5-.3l1.7-4.4c.1-.3 0-.6-.3-.7H19.4l-.4-2.4c0-.3-.3-.4-.5-.4h-2c-.3 0-.5.2-.5.5s.2.5.5.5h1.6l1.5 8.9c0 .3.3.4.5.4h9.4c.3 0 .5-.2.5-.5s-.2-.6-.5-.6z"
      ],
      tags: ["element-woo-add-to-cart"],
      viewBox: ["0 0 48 48"]
    },
    {
      paths: [
        "M37.4 24l-2.1 2.1-3.9 3.9h-4.2l6-6-6-6h4.2l3.9 3.9 2.1 2.1zM27 21.9L23.1 18h-4.2l6 6-6 6h4.2l3.9-3.9 2.1-2.1-2.1-2.1zm-8.2 0L14.9 18h-4.2l6 6-6 6h4.2l3.9-3.9 2.1-2.1-2.1-2.1z"
      ],
      tags: ["element-woo-breadcrumbs"],
      viewBox: ["0 0 48 48"]
    },
    {
      paths: [
        "M28 17h20v2H28v-2zm0 6h20v-2H28v2zm0 4h16v-2H28v2zm0 4h14v-2H28v2z",
        "M7 30v-8H5v-4h4.2c.4 1.2 1.5 2 2.8 2s2.4-.8 2.8-2H19v4h-2v8H7zm14-18H3c-1.7 0-3 1.3-3 3v18c0 1.7 1.3 3 3 3h1c.6 0 1-.4 1-1s-.4-1-1-1H3c-.5 0-1-.4-1-1V15c0-.5.4-1 1-1h18c.5 0 1 .4 1 1v18c0 .5-.4 1-1 1h-7c-.6 0-1 .4-1 1s.4 1 1 1h7c1.7 0 3-1.3 3-3V15c0-1.7-1.3-3-3-3zM10 34H8c-.6 0-1 .4-1 1s.4 1 1 1h2c.6 0 1-.4 1-1s-.4-1-1-1z"
      ],
      tags: ["element-woo-description"],
      viewBox: ["0 0 48 48"]
    },
    {
      paths: [
        "M32 12.1v4.6h-2.3v9.1H18.3v-9.1H16v-4.6h4.8c.5 1.3 1.7 2.3 3.2 2.3s2.7-1 3.2-2.3H32zM36 4H12c-1.7 0-3 1.3-3 3v24c0 1.7 1.3 3 3 3h1c.6 0 1-.4 1-1s-.4-1-1-1h-1c-.6 0-1-.4-1-1V7c0-.6.4-1 1-1h24c.6 0 1 .4 1 1v24c0 .6-.4 1-1 1H23c-.6 0-1 .4-1 1s.4 1 1 1h13c1.7 0 3-1.3 3-3V7c0-1.7-1.3-3-3-3zM19 32h-2c-.6 0-1 .4-1 1s.4 1 1 1h2c.6 0 1-.4 1-1s-.4-1-1-1z",
        "M14.6 36h-3.2C10.1 36 9 37.1 9 38.4v3.2c0 1.3 1.1 2.4 2.4 2.4h3.2c1.3 0 2.4-1.1 2.4-2.4v-3.2c0-1.3-1.1-2.4-2.4-2.4zm.8 5.6c0 .4-.4.8-.8.8h-3.2c-.4 0-.8-.4-.8-.8v-3.2c0-.4.4-.8.8-.8h3.2c.4 0 .8.4.8.8v3.2zM25.6 36h-3.2c-1.3 0-2.4 1.1-2.4 2.4v3.2c0 1.3 1.1 2.4 2.4 2.4h3.2c1.3 0 2.4-1.1 2.4-2.4v-3.2c0-1.3-1.1-2.4-2.4-2.4zm.8 5.6c0 .4-.4.8-.8.8h-3.2c-.4 0-.8-.4-.8-.8v-3.2c0-.4.4-.8.8-.8h3.2c.4 0 .8.4.8.8v3.2zM36.6 36h-3.2c-1.3 0-2.4 1.1-2.4 2.4v3.2c0 1.3 1.1 2.4 2.4 2.4h3.2c1.3 0 2.4-1.1 2.4-2.4v-3.2c0-1.3-1.1-2.4-2.4-2.4zm.8 5.6c0 .4-.4.8-.8.8h-3.2c-.4 0-.8-.4-.8-.8v-3.2c0-.4.4-.8.8-.8h3.2c.4 0 .8.4.8.8v3.2z"
      ],
      tags: ["element-woo-product-images"],
      viewBox: ["0 0 48 48"]
    },
    {
      paths: [
        "M19.5 39.8c0-.2-.1-.4-.3-.5-.2-.2-.4-.3-.7-.3-.3 0-.5.1-.7.2-.2.1-.2.3-.2.5s.1.4.3.5c.2.1.4.2.7.2l.5.1.9.3c.3.1.5.3.6.6.2.2.2.5.2.8 0 .5-.2 1-.6 1.3-.4.3-1 .5-1.7.5s-1.3-.2-1.7-.5-.6-.8-.7-1.4h1.2c0 .3.1.5.3.7.2.1.5.2.8.2s.6-.1.7-.2c.2-.1.3-.3.3-.5s-.1-.3-.3-.5c-.2-.1-.4-.2-.7-.3l-.6-.2c-.5-.1-.9-.3-1.2-.6-.3-.3-.4-.6-.4-1s.1-.7.3-.9c.2-.3.5-.5.8-.6s.7-.2 1.1-.2c.4 0 .8.1 1.1.2.3.1.6.4.8.6.2.3.3.6.3.9h-1.1v.1zm2 4.1v-5.8h1.2v2.6h.1l2.1-2.6h1.5l-2.2 2.6 2.2 3.2H25l-1.6-2.4-.6.7v1.7h-1.3zm9.2-5.8h1.2v3.8c0 .4-.1.8-.3 1.1s-.5.6-.8.7c-.4.2-.8.3-1.3.3s-.9-.1-1.3-.3c-.4-.2-.6-.4-.8-.7s-.3-.7-.3-1.1v-3.8h1.2v3.7c0 .3.1.6.3.8.2.2.5.3.9.3s.6-.1.9-.3.3-.5.3-.8v-3.7z",
        "M32 12.1v4.6h-2.3v9.1H18.3v-9.1H16v-4.6h4.8c.5 1.3 1.7 2.3 3.2 2.3s2.7-1 3.2-2.3H32zM36 4H12c-1.7 0-3 1.3-3 3v24c0 1.7 1.3 3 3 3h1c.6 0 1-.4 1-1s-.4-1-1-1h-1c-.6 0-1-.4-1-1V7c0-.6.4-1 1-1h24c.6 0 1 .4 1 1v24c0 .6-.4 1-1 1H23c-.6 0-1 .4-1 1s.4 1 1 1h13c1.7 0 3-1.3 3-3V7c0-1.7-1.3-3-3-3zM19 32h-2c-.6 0-1 .4-1 1s.4 1 1 1h2c.6 0 1-.4 1-1s-.4-1-1-1z"
      ],
      tags: ["element-woo-product-meta"],
      viewBox: ["0 0 48 48"]
    },
    {
      paths: [
        "M20 34c0 .6-.4 1-1 1h-2c-.6 0-1-.4-1-1s.4-1 1-1h2c.6 0 1 .4 1 1zm17-21H11C4.9 13 0 17.9 0 24s4.9 11 11 11h2c.6 0 1-.4 1-1s-.4-1-1-1h-2c-5 0-9-4-9-9s4-9 9-9h26c5 0 9 4 9 9s-4 9-9 9H23c-.6 0-1 .4-1 1s.4 1 1 1h14c6.1 0 11-4.9 11-11s-4.9-11-11-11zm-19.5 8.2c.4 0 .7.1 1 .2.3.1.5.3.7.4l.7-1.5c-.3-.3-.7-.5-1.1-.6-.4-.1-.8-.2-1.3-.2-.9 0-1.7.3-2.4.8s-1.1 1.3-1.3 2.3h-.9l-.3.9h1.1v.8h-.8l-.3 1h1.2c.2 1 .7 1.8 1.3 2.3s1.4.8 2.4.8c.4 0 .9-.1 1.2-.2.4-.1.7-.3 1.1-.6l-.7-1.5c-.2.1-.4.2-.6.4-.3.1-.6.2-1 .2s-.8-.1-1.1-.3c-.3-.2-.5-.6-.7-1.1h1.7l.5-1h-2.3v-.4-.4h2.7l.4-.9h-3c.1-.5.4-.9.7-1.1.3-.2.7-.3 1.1-.3zm6.3 5.7h3.7v1.5h-6.2V27l3.1-2.9c.4-.4.7-.7.9-1s.3-.6.3-.9c0-.4-.1-.7-.4-.9-.3-.2-.6-.3-1-.3s-.7.1-1 .4c-.2.2-.4.6-.4 1H21c0-.6.1-1.1.4-1.5.3-.4.6-.7 1.1-1 .5-.2 1-.3 1.6-.3.6 0 1.2.1 1.6.3.5.2.8.5 1.1.9.3.4.4.8.4 1.3 0 .3-.1.7-.2 1-.1.3-.4.7-.7 1.1s-.7.8-1.3 1.3l-1.2 1.4zm11.3-5.1c-.2-.5-.5-1-.8-1.3-.3-.3-.7-.6-1.1-.7-.4-.1-.8-.2-1.3-.2-.7 0-1.2.1-1.7.4s-.9.6-1.1 1.1c-.3.5-.4 1-.4 1.6 0 .5.1 1 .4 1.4.2.4.5.8 1 1s.9.4 1.4.4c.5 0 .9-.1 1.3-.3.4-.2.7-.5.9-.9h.1c0 .9-.2 1.5-.4 2-.3.5-.7.7-1.3.7-.3 0-.6-.1-.8-.3-.2-.2-.4-.4-.4-.7h-1.8c.1.5.2.9.5 1.3s.6.7 1.1.9c.4.2 1 .3 1.5.3.7 0 1.3-.2 1.9-.6.5-.4.9-.9 1.2-1.6.3-.7.4-1.5.4-2.5-.3-.8-.4-1.5-.6-2zm-1.9 1.5c-.1.2-.3.4-.5.6-.2.1-.5.2-.8.2-.4 0-.8-.1-1-.4s-.4-.7-.4-1.1c0-.3.1-.5.2-.8.1-.2.3-.4.5-.5.2-.1.5-.2.8-.2.3 0 .5.1.8.2s.4.3.5.6c.1.2.2.5.2.8-.1.1-.2.3-.3.6z"
      ],
      tags: ["element-woo-product-price"],
      viewBox: ["0 0 48 48"]
    },
    {
      paths: [
        "M32 12.1v4.6h-2.3v9.1H18.3v-9.1H16v-4.6h4.8c.5 1.3 1.7 2.3 3.2 2.3s2.7-1 3.2-2.3H32zM36 4H12c-1.7 0-3 1.3-3 3v24c0 1.7 1.3 3 3 3h1c.6 0 1-.4 1-1s-.4-1-1-1h-1c-.6 0-1-.4-1-1V7c0-.6.4-1 1-1h24c.6 0 1 .4 1 1v24c0 .6-.4 1-1 1H23c-.6 0-1 .4-1 1s.4 1 1 1h13c1.7 0 3-1.3 3-3V7c0-1.7-1.3-3-3-3zM19 32h-2c-.6 0-1 .4-1 1s.4 1 1 1h2c.6 0 1-.4 1-1s-.4-1-1-1z",
        "M23 38.9l-2.6-.4-1.2-2.4c0-.1-.1-.1-.2-.1s-.2.1-.2.1l-1.2 2.4-2.6.4c-.1 0-.2.1-.2.2s0 .2.1.3l1.9 1.8-.4 2.6c0 .1 0 .2.1.2h.2l2.3-1.2 2.3 1.2h.3c.1-.1.1-.1.1-.2l-.4-2.6 1.9-1.8c.1-.1.1-.2.1-.3-.2-.2-.3-.2-.3-.2zM33.2 39c0-.1-.1-.2-.2-.2l-2.6-.4-1.2-2.4c0-.1-.1-.1-.2-.1s-.2.1-.2.1l-1.2 2.4-2.6.5c-.1 0-.2.1-.2.2s0 .2.1.3l1.9 1.8-.4 2.6c0 .1 0 .2.1.2h.2l2.3-1.2 2.3 1.2h.3c.1-.1.1-.1.1-.2l-.4-2.6 1.9-1.8V39z"
      ],
      tags: ["element-woo-product-rating"],
      viewBox: ["0 0 48 48"]
    },
    {
      paths: [
        "M36 4c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8zm4.5 5.9L35.4 15c-.3.3-.8.3-1.1 0l-2.7-2.5c-.3-.3-.3-.8-.1-1.1.3-.3.8-.3 1.1 0l2.1 2 4.6-4.6c.3-.3.8-.3 1.1 0 .4.3.4.8.1 1.1zm-3.5 12c.7-.1 1.4-.2 2-.4V36c0 1.7-1.3 3-3 3H23c-.6 0-1-.4-1-1s.4-1 1-1h13c.6 0 1-.4 1-1V21.9zM12 9c-1.7 0-3 1.3-3 3v24c0 1.7 1.3 3 3 3h1c.6 0 1-.4 1-1s-.4-1-1-1h-1c-.6 0-1-.4-1-1V12c0-.6.4-1 1-1h14c.1-.7.2-1.4.4-2H12zm7 28h-2c-.6 0-1 .4-1 1s.4 1 1 1h2c.6 0 1-.4 1-1s-.4-1-1-1zm8.4-19.9h-.2c-.5 1.3-1.7 2.3-3.2 2.3s-2.7-1-3.2-2.3H16v4.6h2.3v9.1h11.4v-9.1H32v-.6c-1.9-.8-3.5-2.2-4.6-4z"
      ],
      tags: ["element-woo-product-stock"],
      viewBox: ["0 0 48 48"]
    },
    {
      paths: [
        "M10.6 39.5c.4 0 .8-.2 1.1-.5l8.7-8.7 3.6 3.6c.6.6 1.6.6 2.2 0l9.8-9.8v3.5c0 .9.7 1.6 1.6 1.6.9 0 1.6-.7 1.6-1.6v-7.2c0-.9-.7-1.6-1.6-1.6h-7.2c-.9 0-1.6.7-1.6 1.6s.7 1.6 1.6 1.6h3.5L25 30.6 21.5 27c-.6-.6-1.6-.6-2.2 0l-9.8 9.8c-.6.6-.6 1.6 0 2.2.2.4.6.5 1.1.5zM18 8.5c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8zm.5 11.5v1c0 .1-.1.2-.3.2h-.6c-.1 0-.3-.1-.3-.2v-.8c-.6 0-1.1-.1-1.6-.3-.2-.1-.4-.3-.3-.6l.1-.4c0-.1.1-.3.3-.3.1-.1.3-.1.4 0 .4.2.9.3 1.4.3.7 0 1.1-.3 1.1-.7 0-.4-.4-.7-1.2-1-1.2-.4-2.1-1-2.1-2.1 0-1 .7-1.8 2-2.1v-1c0-.1.1-.3.3-.3h.6c.1 0 .3.1.3.3v.8c.5 0 .9.1 1.3.2.2.1.4.3.3.6l-.2.3c0 .1-.1.2-.2.3-.1.1-.3.1-.4 0-.3-.1-.7-.2-1.2-.2-.8 0-1 .3-1 .7 0 .4.4.6 1.4 1 1.4.5 1.9 1.1 1.9 2.2.1 1-.7 1.9-2 2.1z"
      ],
      tags: ["element-woo-product-upsells"],
      viewBox: ["0 0 48 48"]
    },
    {
      paths: [
        "M44 4.8v3.5h-1.7v6.8h-8.6V8.3H32V4.8h3.6c.4 1 1.3 1.7 2.4 1.7s2-.8 2.4-1.7H44zM45 0H31c-1.7 0-3 1.3-3 3v14c0 1.7 1.3 3 3 3h14c1.7 0 3-1.3 3-3V3c0-1.7-1.3-3-3-3zm1 17c0 .6-.5 1-1 1H31c-.6 0-1-.5-1-1V3c0-.6.5-1 1-1h14c.6 0 1 .5 1 1v14zM44 32.8v3.5h-1.7v6.8h-8.6v-6.8H32v-3.5h3.6c.4 1 1.3 1.7 2.4 1.7s2-.8 2.4-1.7H44zm1-4.8H31c-1.7 0-3 1.3-3 3v14c0 1.7 1.3 3 3 3h14c1.7 0 3-1.3 3-3V31c0-1.7-1.3-3-3-3zm1 17c0 .6-.5 1-1 1H31c-.6 0-1-.5-1-1V31c0-.6.5-1 1-1h14c.6 0 1 .5 1 1v14z",
        "M12.4 18.8H16v3.5h-1.7v6.8H5.7v-6.8H4v-3.5h3.6c.4 1 1.3 1.7 2.4 1.7s2-.7 2.4-1.7zM28 11.5l-8.3 4.3c.2.4.3.8.3 1.2v14c0 .5-.1 1-.3 1.4l8.3 4.3V39l-9.9-5.1c-.3 0-.7.1-1.1.1H3c-1.7 0-3-1.3-3-3V17c0-1.7 1.3-3 3-3h14c.5 0 .9.1 1.3.3l9.7-5v2.2zM18 17c0-.6-.5-1-1-1H3c-.6 0-1 .5-1 1v14c0 .6.5 1 1 1h14c.6 0 1-.5 1-1V17z"
      ],
      tags: ["element-woo-product-related"],
      viewBox: ["0 0 48 48"]
    },
    {
      paths: ["M11.8 12.7L33.2 25 11.8 37.3V12.7M6.8 4v42l36.4-21L6.8 4z"],
      tags: ["play-video"],
      viewBox: ["0 0 48 48"]
    },
    {
      paths: ["M9 8.5h8v33H9zM33 8.5h8v33h-8z"],
      tags: ["pause-video"],
      viewBox: ["0 0 48 48"]
    },
    {
      paths: [
        "M19.3 12.7v24.7l-7.9-4.5-1.2-.7H5V17.9h5.2l1.2-.7 7.9-4.5m5-8.7L8.9 12.9H0v24.2h8.9L24.3 46V4zM41.4 45.8l-3.5-3.5c9.5-9.5 9.5-25 0-34.5l3.5-3.5c11.5 11.4 11.5 30 0 41.5z",
        "M33.2 39l-3.5-3.5c5.8-5.8 5.8-15.1 0-20.9l3.5-3.5c7.7 7.6 7.7 20.2 0 27.9z"
      ],
      tags: ["sound-on"],
      viewBox: ["0 0 48 48"]
    },
    {
      paths: [
        "M19.3 12.7v24.7l-7.9-4.5-1.2-.7H5V17.9h5.2l1.2-.7 7.9-4.5m5-8.7L8.9 12.9H0v24.2h8.9L24.3 46V4zM50 18.6l-3.5-3.5-6.4 6.4-6.4-6.4-3.5 3.5 6.3 6.4-6.3 6.4 3.5 3.5 6.4-6.4 6.4 6.4 3.5-3.5-6.4-6.4z"
      ],
      tags: ["sound-off"],
      viewBox: ["0 0 48 48"]
    },
    {
      paths: ["M5 7v8h12V7H5zm10.5 6.5h-9v-5h9v5z"],
      tags: ["default-state"],
      viewBox: ["0 0 22 22"]
    },
    {
      paths: [
        "M17.5 14.4l2.5-1.6-3-1.1V7H5v8h8.8l1.1 3 1.6-2.5 1.7 1.7c.3.3.8.3 1.1 0 .3-.3.3-.8 0-1.1l-1.8-1.7zm-11-.9v-5h9v2.8L12 10l1.3 3.5H6.5z"
      ],
      tags: ["hover-state"],
      viewBox: ["0 0 22 22"]
    },
    {
      paths: [
        "M100.5 82.5L91 77l-9.5 5.5L91 88l9.5-5.5zM91 79.7l4.7 2.7-4.7 2.8-4.7-2.7 4.7-2.8zm9.5 7.8l-7.1 4.1L91 93l-2.4-1.4-7.1-4.1 2.4-1.4 7.1 4.1 7.1-4.1 2.4 1.4z",
        "M24 51h32v2H24v-2zm24 6H24v2h24v-2zm-24 8h27v-2H24v2zm76-33H82v6h18v-6zm46 1h-4v4h4v-4zm-8 1h-10v2h10v-2zm-24 51c0 12.7-10.3 23-23 23S68 97.7 68 85s10.3-23 23-23 23 10.3 23 23zm-2 0c0-11.6-9.4-21-21-21s-21 9.4-21 21 9.4 21 21 21 21-9.4 21-21zm53-35v28c0 2.2-1.8 4-4 4h-9v46.2s.1 0 .1.1c.9.9 1.7 1.7 2.7 2.6 2.6-2.5 2.1-2 2.7-2.6.4-.3.9-.4 1.3 0 .8 1 1.6 1.9 2.5 2.8.8.9-.5 2.1-1.3 1.3-.7-.7-1.3-1.5-1.9-2.2-.9.8-1.7 1.7-2.6 2.5-.4.4-.9.3-1.3 0-.8-.6-1.5-1.3-2.2-2V141c0 2.8-2.2 5-5 5h-27v9c0 1.6-1.3 3-3 3H55c-1.7 0-3-1.4-3-3v-9H35c-2.8 0-5-2.2-5-5v-30.3c-.7.7-1.4 1.4-2.2 2-.4.3-.9.4-1.3 0-.9-.8-1.7-1.7-2.6-2.5-.6.7-1.3 1.5-1.9 2.2-.8.9-2.1-.4-1.3-1.3s1.7-1.9 2.5-2.8c.3-.4.9-.3 1.3 0 .9.8 1.8 1.7 2.7 2.6.9-.8 1.8-1.7 2.7-2.6l.1-.1V73H19c-1.7 0-3-1.4-3-3V20c0-1.7 1.3-3 3-3h42c1.7 0 3 1.3 3 3v4h83c2.8 0 5 2.2 5 5v17h9c2.2 0 4 1.8 4 4zM18 44h44V20c0-.5-.5-1-1-1H19c-.5 0-1 .5-1 1v24zm43 27c.5 0 1-.5 1-1V46H18v24c0 .5.5 1 1 1h42zm57 52c0-.5-.5-1-1-1H55c-.5 0-1 .5-1 1v32c0 .5.5 1 1 1h62c.5 0 1-.5 1-1v-32zm32-41h-17c-2.2 0-4-1.8-4-4V50c0-2.2 1.8-4 4-4h17V29c0-1.7-1.3-3-3-3H64v44c0 1.6-1.3 3-3 3H32v36.1c.6.6 1.2 1.1 1.8 1.7 2.6-2.5 2.1-2 2.7-2.6.4-.3.9-.4 1.3 0 .8 1 1.6 1.9 2.5 2.8.8.9-.5 2.1-1.3 1.3-.7-.7-1.3-1.5-1.9-2.2-.9.8-1.7 1.7-2.6 2.5-.4.4-.9.3-1.3 0s-.8-.7-1.2-1V141c0 1.7 1.3 3 3 3h17v-21c0-1.7 1.3-3 3-3h62c1.7 0 3 1.3 3 3v21h27c1.7 0 3-1.3 3-3v-9.3c-.4.4-.8.7-1.2 1.1-.4.3-.9.4-1.3 0-.9-.8-1.7-1.7-2.6-2.5-.6.7-1.3 1.5-1.9 2.2-.8.9-2.1-.4-1.3-1.3s1.7-1.9 2.5-2.8c.3-.4.9-.3 1.3 0 .9.8 1.8 1.7 2.7 2.6.6-.5 1.2-1.1 1.8-1.7V82zm13-32c0-1.1-.9-2-2-2h-28c-1.1 0-2 .9-2 2v28c0 1.1.9 2 2 2h28c1.1 0 2-.9 2-2V50zm-8.3 11.4l-4.6-.4-1.8-4.3c-.1-.3-.4-.5-.8-.5s-.6.2-.8.5l-1.8 4.3-4.6.4c-.3 0-.6.3-.7.6-.1.3 0 .7.2.9l3.5 3.1-1 4.5c-.1.3.1.7.3.9.1.1.3.2.5.2s.3 0 .4-.1l4-2.4 4 2.4c.3.2.7.2.9 0 .3-.2.4-.5.3-.9l-1-4.5 3.5-3.1c.3-.2.4-.6.2-.9 0-.5-.3-.7-.7-.7zM56 154h30v-30H56v30zm34-23h24v-2H90v2zm16 4H90v2h16v-2zm-16 8h21v-2H90v2zm0 6h18v-2H90v2zm33.1-53.5l-2.1 2.1-2.1-2.1-1.4 1.4 2.1 2.1-2.1 2.1 1.4 1.4 2.1-2.1 2.1 2.1 1.4-1.4-2.1-2.1 2.1-2.1-1.4-1.4zm46.8-64.8c-2.2 0-4 1.8-4 4 0 .5-.4.9-.9.9s-.9-.4-.9-.9c0-2.2-1.8-4-4-4-.5 0-.9-.4-.9-.9s.4-.9.9-.9c2.2 0 4-1.8 4-4 0-.5.4-.9.9-.9s.9.4.9.9c0 2.2 1.8 4 4 4 .5 0 .9.4.9.9s-.3.9-.9.9zm-3.1-.9c-.7-.5-1.3-1.1-1.8-1.8-.5.7-1.1 1.3-1.8 1.8.7.5 1.3 1.1 1.8 1.8.5-.8 1.1-1.4 1.8-1.8zm-154.9 18c0 .5-.4.9-.9.9-2.2 0-4 1.8-4 4 0 .5-.4.9-.9.9s-.9-.4-.9-.9c0-2.2-1.8-4-4-4-.5 0-.9-.4-.9-.9s.4-.9.9-.9c2.2 0 4-1.8 4-4 0-.5.4-.9.9-.9s.9.4.9.9c0 2.2 1.8 4 4 4 .5 0 .9.4.9.9zm-4.1 0c-.7-.5-1.3-1.1-1.8-1.8-.5.7-1.1 1.3-1.8 1.8.8.4 1.4 1 1.8 1.7.5-.7 1.1-1.3 1.8-1.7zm168.4-8c0 1.6-1.3 2.9-2.9 2.9-1.6 0-2.9-1.3-2.9-2.9 0-1.6 1.3-2.9 2.9-2.9s2.9 1.3 2.9 2.9zm-1.9 0c0-.6-.5-1-1-1-.6 0-1 .5-1 1 0 .6.5 1 1 1s1-.4 1-1zm-9.3 0c-.6 0-1.2.5-1.2 1.2 0 .6.5 1.2 1.2 1.2.6 0 1.2-.5 1.2-1.2s-.5-1.2-1.2-1.2zm7.5-15.7c.6 0 1.2-.5 1.2-1.2 0-.6-.5-1.2-1.2-1.2s-1.2.5-1.2 1.2.6 1.2 1.2 1.2zM90.8 9.3c2.2 0 4 1.8 4 4s-1.8 4-4 4-4-1.8-4-4 1.8-4 4-4zm-1.4 4c0 .8.6 1.4 1.4 1.4.8 0 1.4-.6 1.4-1.4 0-.8-.6-1.4-1.4-1.4-.8 0-1.4.6-1.4 1.4zm-2.9-8.8c.9 0 1.6-.7 1.6-1.6 0-.9-.7-1.6-1.6-1.6s-1.6.7-1.6 1.6c0 .9.7 1.6 1.6 1.6z",
        "M68 85c0-10.3 6.7-18.9 16-21.9V49c0-1.7-1.3-3-3-3H64v24c0 1.6-1.3 3-3 3H36v26c0 1.6 1.3 3 3 3h36.5C70.9 97.8 68 91.7 68 85z"
      ],
      tags: ["library-illustration"],
      viewBox: ["0 0 182 158"]
    },
    {
      paths: [
        "M73,69.5A15.1,15.1,0,0,0,58.1,81.8a12.5,12.5,0,0,0,2.4,24.7H87.1a10.9,10.9,0,0,0,1-21.7A15.4,15.4,0,0,0,83.8,74,15.2,15.2,0,0,0,73,69.5Zm0,3.3a11.4,11.4,0,0,1,8.4,3.5,12,12,0,0,1,3.5,9.9A1.6,1.6,0,0,0,86.3,88h.8a7.6,7.6,0,1,1,0,15.2H60.5a9.2,9.2,0,0,1-.8-18.4,1.7,1.7,0,0,0,1.4-1.5,12.5,12.5,0,0,1,3.4-7A11.8,11.8,0,0,1,73,72.8Zm0,9.8a1.4,1.4,0,0,0-1.1.4l-6,5.4a1.6,1.6,0,0,0,2.2,2.4l3.3-2.9V98.3a1.6,1.6,0,1,0,3.2,0V87.9l3.3,2.9a1.6,1.6,0,1,0,2.2-2.4l-6-5.4A1.4,1.4,0,0,0,73,82.6Z",
        "M5,34.9a2.9,2.9,0,0,1,3,3,2.9,2.9,0,0,1-2.8,3H5a2.9,2.9,0,0,1-3-3,3.2,3.2,0,0,1,3-3m0-2a5.2,5.2,0,0,0-5,5,5,5,0,0,0,5,5,5,5,0,0,0,0-10Zm114.8,79a.9.9,0,0,1,1,.8v.2a1,1,0,0,1-2,0,.9.9,0,0,1,.8-1h.2m0-2a3,3,0,1,0,3,3h0a2.9,2.9,0,0,0-2.8-3Z"
      ],
      polygon: [
        "84.3 40.4 82.2 38.3 84.3 36.2 82.8 34.7 80.8 36.8 78.7 34.7 77.2 36.1 79.3 38.3 77.2 40.4 78.6 41.8 80.8 39.7 82.9 41.8 84.3 40.4"
      ],
      circle: [
        'cx="73.5" cy="88" r="60" fill="#f7fafa"',
        'cx="51.5" cy="154.9" r="3" fill="#06bee1"',
        'cx="111.3" cy="5" r="5" fill="#06bee1"'
      ],
      tags: ["import-big-icon"],
      viewBox: ["0 0 133.5 157.9"]
    },
    {
      paths: [
        "M119.7 32.2L64 0 8.8 32.2 35 46.7l29-15.9 25.1 14-64.7 38.9L64 106.3l29.5-16.1 10.3 6.5-39.7 22.9-49.3-28.2.7-45.4-7.2-4.4V96l55.8 32 53.4-31.3-24-14.4-29.4 15.6-25.2-14.4 64-38-38.8-22.9L35 38.3l-11.8-6.5L64.1 8.9 113 37.3v45.2l6.7 4.4z"
      ],
      tags: ["zion-icon-logo"],
      viewBox: ["0 0 128 128"]
    },
    {
      paths: [
        "M7 12h23v2H7zM7 23h23v2H7zM7 34h23v2H7zM36 18.1c2.8 0 5-2.2 5-5s-2.2-5-5-5-5 2.2-5 5c0 2.7 2.3 5 5 5zm0-9.4c2.4 0 4.3 1.9 4.3 4.3s-1.9 4.3-4.3 4.3-4.3-1.9-4.3-4.3c0-2.3 1.9-4.3 4.3-4.3z",
        "M34.6 13.5l-.3 1.6c0 .1.1.2.2.2h.1l1.4-.8 1.4.8h.2c.1 0 .1-.1.1-.2l-.3-1.6 1.2-1.1c.1-.1.1-.1.1-.2s-.1-.1-.2-.1l-1.6-.2-.7-1.5c0-.1-.1-.1-.2-.1l-.1.1-.7 1.5-1.7.1c-.1 0-.2.1-.2.2 0 0 0 .1.1.1l1.2 1.2zM36 19c-2.8 0-5 2.2-5 5s2.2 5 5 5 5-2.2 5-5c0-2.7-2.2-5-5-5zm0 9.4c-2.4 0-4.3-1.9-4.3-4.3s1.9-4.3 4.3-4.3 4.3 1.9 4.3 4.3c.1 2.3-1.9 4.3-4.3 4.3z",
        "M38.5 23l-1.6-.2-.7-1.5c0-.1-.1-.1-.2-.1l-.1.1-.7 1.5-1.7.2c-.1 0-.2.1-.2.2 0 0 0 .1.1.1l1.2 1.1-.3 1.6c0 .1.1.2.2.2h.1l1.4-.8 1.4.8h.2c.1 0 .1-.1.1-.2l-.3-1.6 1.2-1.1c.1-.1.1-.1.1-.2s-.1-.1-.2-.1zM36 30c-2.8 0-5 2.2-5 5s2.2 5 5 5 5-2.2 5-5-2.2-5-5-5zm0 9.3c-2.4 0-4.3-1.9-4.3-4.3s1.9-4.3 4.3-4.3 4.3 1.9 4.3 4.3c.1 2.3-1.9 4.3-4.3 4.3z",
        "M38.5 33.9l-1.6-.2-.7-1.5c0-.1-.1-.1-.2-.1l-.1.1-.7 1.5-1.6.2c-.1 0-.2.1-.2.2 0 0 0 .1.1.1l1.2 1.1-.4 1.7c0 .1.1.2.2.2h.1l1.4-.8 1.4.8h.2c.1 0 .1-.1.1-.2l-.3-1.6 1.2-1.1c.1-.1.1-.1.1-.2s-.1-.2-.2-.2z",
        ""
      ],
      tags: ["icon-list"],
      viewBox: ["0 0 48 48"]
    },
    {
      paths: [
        "M21.5 8.6L13.4.5c-.4-.3-.8-.5-1.3-.5H5.8C4.8 0 4 .8 4 1.8v6.3c0 .5.2.9.5 1.3l8.1 8.1c.3.3.8.5 1.3.5s.9-.2 1.3-.5l6.3-6.3c.3-.3.5-.8.5-1.3s-.2-.9-.5-1.3zM7.2 4.5c-.7 0-1.3-.6-1.3-1.3s.6-1.3 1.3-1.3 1.3.6 1.3 1.3-.6 1.3-1.3 1.3z",
        "M12.6 17.5L4.5 9.4c-.3-.3-.5-.8-.5-1.2-.2.2-.5.3-.8.3-.7 0-1.4-.6-1.4-1.3s.6-1.4 1.4-1.4c.3 0 .6.1.8.3V4H1.8C.8 4 0 4.8 0 5.8v6.3c0 .5.2.9.5 1.3l8.1 8.1c.4.3.8.5 1.3.5s.9-.2 1.3-.5l4-4c-.3.3-.8.5-1.3.5s-.9-.2-1.3-.5z"
      ],
      tags: ["tags-attributes"],
      viewBox: ["0 0 22 22"]
    },
    {
      paths: [
        "M7.4 11.2c1.8.5 3.2 2 3.7 3.6.5-.4 1.1-.9 1.7-1.4l-4-4c-.5.7-1 1.3-1.4 1.8zM19.4 0c-3.1.3-7.7 5.8-9.7 8.3l4.2 4.2c2.3-2 7.9-7 8-10.1.2-1.4-1-2.5-2.5-2.4zM2.2 14.1c-1.8 2.3-.3 4.4-2 6.3-.3.3-.2.8.2 1 2.9 1.2 6.6.4 8.3-1.4 1.6-1.7 2.1-4.6.1-6.5-1.8-1.9-5-1.4-6.6.6z"
      ],
      tags: ["brush"],
      viewBox: ["0 0 22 22"]
    },
    {
      paths: [
        "M8 4c0 2.2-1.8 4-4 4S0 6.2 0 4s1.8-4 4-4 4 1.8 4 4zM4 32c-2.2 0-4 1.8-4 4s1.8 4 4 4 4-1.8 4-4-1.8-4-4-4zm0-16c-2.2 0-4 1.8-4 4s1.8 4 4 4 4-1.8 4-4-1.8-4-4-4z"
      ],
      tags: ["three-dots"],
      viewBox: ["0 0 8 40"]
    },
    {
      paths: ["M40 18v8H4v-8h36m4-4H0v16h44V14z", "M44 34H0v10h4v-6h36v6h4V34z", "M44 0h-4v6H4V0H0v10h44V0z"],
      tags: ["templates-body"],
      viewBox: ["0 0 44 44"]
    },
    {
      paths: ["M40 32v8H4v-8h36m4-4H0v16h44V28z", "M44 0h-4v20H4V0H0v24h44V0z"],
      tags: ["templates-footer"],
      viewBox: ["0 0 44 44"]
    },
    {
      paths: ["M40 4v8H4V4h36m4-4H0v16h44V0z", "M42 24v-2 20z", "M44 20H0v24h4V24h36v20h4V20z"],
      tags: ["templates-header"],
      viewBox: ["0 0 44 44"]
    },
    {
      paths: [
        "M23 14.29c-.63-.19-1.3-.29-2-.29s-1.37.1-2 .29A7.018 7.018 0 0014.29 19H11c-1.1 0-2-.9-2-2v-3.29A7.018 7.018 0 0013.71 9c.19-.63.29-1.3.29-2s-.1-1.37-.29-2C12.85 2.11 10.17 0 7 0 3.13 0 0 3.13 0 7c0 3.17 2.11 5.85 5 6.71V17c0 3.31 2.69 6 6 6h3.29c.86 2.89 3.54 5 6.71 5 3.87 0 7-3.13 7-7 0-3.17-2.11-5.85-5-6.71zM4 7c0-1.65 1.35-3 3-3 .99 0 1.86.49 2.4 1.22.37.5.6 1.11.6 1.78 0 1.65-1.35 3-3 3-.67 0-1.28-.23-1.78-.6A2.986 2.986 0 014 7zm17 17c-.99 0-1.86-.49-2.4-1.22-.37-.5-.6-1.11-.6-1.78 0-1.65 1.35-3 3-3 .67 0 1.28.23 1.78.6.73.54 1.22 1.41 1.22 2.4 0 1.65-1.35 3-3 3z"
      ],
      tags: ["child"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: [
        "M23 14.29c-.63-.19-1.3-.29-2-.29s-1.37.1-2 .29A7.018 7.018 0 0014.29 19H11c-1.1 0-2-.9-2-2v-3.29A7.018 7.018 0 0013.71 9c.19-.63.29-1.3.29-2s-.1-1.37-.29-2C12.85 2.11 10.17 0 7 0 3.13 0 0 3.13 0 7c0 3.17 2.11 5.85 5 6.71V17c0 3.31 2.69 6 6 6h3.29c.86 2.89 3.54 5 6.71 5 3.87 0 7-3.13 7-7 0-3.17-2.11-5.85-5-6.71zM4 7c0-1.65 1.35-3 3-3 .99 0 1.86.49 2.4 1.22.37.5.6 1.11.6 1.78 0 1.65-1.35 3-3 3-.67 0-1.28-.23-1.78-.6A2.986 2.986 0 014 7zm17 17c-.99 0-1.86-.49-2.4-1.22-.37-.5-.6-1.11-.6-1.78 0-1.65 1.35-3 3-3 .67 0 1.28.23 1.78.6.73.54 1.22 1.41 1.22 2.4 0 1.65-1.35 3-3 3zm7-16h-4v4h-4V8h-4V4h4V0h4v4h4v4z"
      ],
      tags: ["child-add"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: ["m2.8 11.2 8.4-8.4L14 0l2.8 2.8 8.4 8.4-2.8 2.8L16 7.6V28h-4V7.6L5.6 14l-2.8-2.8z"],
      tags: ["long-arrow-up"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: ["m25.2 16.8-8.4 8.4L14 28l-2.8-2.8-8.4-8.4L5.6 14l6.4 6.4V0h4v20.4l6.4-6.4 2.8 2.8z"],
      tags: ["long-arrow-down"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: [
        "M14 10h3v4h-3v3h-4v-3H7v-4h3V7h4v3zm14 15-2.8 2.8-6.1-6.1c-2 1.4-4.4 2.3-7.1 2.3-6.6 0-12-5.4-12-12S5.4 0 12 0s12 5.4 12 12c0 2.5-.7 4.8-2.1 6.9L28 25zm-8-13c0-4.4-3.6-8-8-8s-8 3.6-8 8 3.6 8 8 8 8-3.6 8-8z"
      ],
      tags: ["zoom"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: [
        "m28 5.1-6.2 17.7h-4.1l-2.6-7.7c-.7-2.3-1-3.4-1.1-4.3-.2 1-.5 2-1.2 4.4l-2.6 7.6H5.9L0 5.1h4.7L7 12.7c.4 1.4.8 2.9 1.1 4.3.3-1.4.8-2.9 1.2-4.3l2.4-7.6h4.5l2.4 7.6c.2.7.9 3.4 1.1 4.6.2-1.2 1-3.8 1.2-4.6l2.4-7.6H28z"
      ],
      tags: ["width"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: [
        "M22 11h-2v-1c0-3.3-2.7-6-6-6s-6 2.7-6 6v1H6c-1.1 0-2 .9-2 2v9c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2v-9c0-1.1-.9-2-2-2zm-6 0h-4v-1c0-1.1.9-2 2-2s2 .9 2 2v1z"
      ],
      tags: ["lock"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: [
        "m13 11-9 9v-7c0-1.1.9-2 2-2h2v-1c0-3.3 2.7-6 6-6 1.7 0 3.2.7 4.2 1.8l-2.8 2.8c-.8-.8-2-.8-2.8 0-.4.4-.6.9-.6 1.4v1h1zm9 0h-.5l4.8-4.8-2.8-2.8L3.6 23.2 6.4 26l2-2H22c1.1 0 2-.9 2-2v-9c0-1.1-.9-2-2-2z"
      ],
      tags: ["unlock"],
      viewBox: ["0 0 28 28"]
    },
    {
      paths: [
        "M341.6 29.2L240.1 130.8l-9.4-9.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3l-9.4-9.4L482.8 170.4c39-39 39-102.2 0-141.1s-102.2-39-141.1 0zM55.4 323.3c-15 15-23.4 35.4-23.4 56.6v42.4L5.4 462.2c-8.5 12.7-6.8 29.6 4 40.4s27.7 12.5 40.4 4L89.7 480h42.4c21.2 0 41.6-8.4 56.6-23.4L309.4 335.9l-45.3-45.3L143.4 411.3c-3 3-7.1 4.7-11.3 4.7H96V379.9c0-4.2 1.7-8.3 4.7-11.3L221.4 247.9l-45.3-45.3L55.4 323.3z"
      ],
      tags: ["eyedropper"],
      viewBox: ["0 0 512 512"]
    }
  ];
  const getSearchIcon = (searchIcon) => SvgIcons.find((icon) => {
    return icon.tags[0] === searchIcon;
  });
  var Icon_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$2n = ["viewBox", "preserveAspectRatio", "innerHTML"];
  const __default__$19 = {
    name: "Icon"
  };
  const _sfc_main$34 = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$19), {
    props: {
      icon: null,
      rotate: { type: [Boolean, String, Number], default: false },
      bgSize: null,
      color: null,
      size: null,
      bgColor: null,
      stroke: null,
      rounded: { type: Boolean, default: false },
      preserveAspectRatio: null
    },
    setup(__props) {
      const props = __props;
      const iconStyles = Vue.computed(() => {
        return {
          width: props.bgSize + "px",
          height: props.bgSize + "px",
          color: props.color,
          fontSize: props.size + "px",
          background: props.bgColor,
          stroke: props.stroke,
          transform: elementTransform.value
        };
      });
      const iconClass = Vue.computed(() => {
        return {
          "znpb-editor-icon--rounded": props.rounded
        };
      });
      const iconSettings = Vue.computed(() => {
        const iconOption = getSearchIcon(props.icon);
        if (!iconOption) {
          return {};
        }
        let pathString = "";
        if (iconOption.circle) {
          for (const circle of iconOption.circle) {
            pathString += `<circle  ${circle} fill="currentColor"></circle>`;
          }
        }
        if (iconOption.rect) {
          for (const rect of iconOption.rect) {
            pathString += `<rect ${rect}></rect>`;
          }
        }
        if (iconOption.polygon) {
          for (const polygon of iconOption.polygon) {
            pathString += `<polygon points='${polygon}' fill="currentColor"></polygon>`;
          }
        }
        for (const path of iconOption.paths) {
          pathString += `<path fill="currentColor" d="${path}"></path>`;
        }
        return {
          viewBox: (iconOption == null ? void 0 : iconOption.viewBox) ? iconOption == null ? void 0 : iconOption.viewBox.join("") : "0 0 50 50 ",
          pathString
        };
      });
      const elementTransform = Vue.computed(() => {
        let cssStyles = "";
        if (props.rotate) {
          if (typeof props.rotate === "string" || typeof props.rotate === "number") {
            cssStyles = `rotate(${props.rotate}deg)`;
          } else
            cssStyles = "rotate(90deg)";
        }
        return cssStyles;
      });
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("span", {
          class: Vue.normalizeClass(["znpb-editor-icon-wrapper", Vue.unref(iconClass)]),
          style: Vue.normalizeStyle(Vue.unref(iconStyles))
        }, [
          Vue.unref(iconSettings) ? (Vue.openBlock(), Vue.createElementBlock("svg", {
            key: 0,
            class: Vue.normalizeClass(["zion-svg-inline znpb-editor-icon zion-icon", {
              [`zion-${__props.icon}`]: __props.icon
            }]),
            xmlns: "http://www.w3.org/2000/svg",
            "aria-hidden": "true",
            viewBox: Vue.unref(iconSettings).viewBox,
            preserveAspectRatio: props.preserveAspectRatio || "",
            innerHTML: Vue.unref(iconSettings).pathString
          }, null, 10, _hoisted_1$2n)) : Vue.createCommentVNode("", true)
        ], 6);
      };
    }
  }));
  var Accordion_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$2m = {
    key: 0,
    class: "znpb-accordion__content"
  };
  const __default__$18 = {
    name: "Accordion"
  };
  const _sfc_main$33 = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$18), {
    props: {
      collapsed: { type: Boolean, default: false },
      header: null
    },
    setup(__props) {
      const props = __props;
      const localCollapsed = Vue.ref(props.collapsed);
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", {
          class: Vue.normalizeClass(["znpb-accordion", { "znpb-accordion--collapsed": localCollapsed.value }])
        }, [
          Vue.createElementVNode("div", {
            class: "znpb-accordion__header",
            onClick: _cache[0] || (_cache[0] = ($event) => localCollapsed.value = !localCollapsed.value)
          }, [
            Vue.renderSlot(_ctx.$slots, "header", {}, () => [
              Vue.createTextVNode(Vue.toDisplayString(__props.header), 1)
            ]),
            Vue.createVNode(_sfc_main$34, {
              icon: "select",
              class: "znpb-accordion-title-icon"
            })
          ]),
          localCollapsed.value ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$2m, [
            Vue.renderSlot(_ctx.$slots, "default")
          ])) : Vue.createCommentVNode("", true)
        ], 2);
      };
    }
  }));
  var ActionsOverlay_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$2l = { class: "znpb-actions-overlay__wrapper" };
  const _hoisted_2$1x = {
    key: 0,
    class: "znpb-actions-overlay__actions-wrapper"
  };
  const _hoisted_3$11 = { class: "znpb-actions-overlay__actions" };
  const __default__$17 = {
    name: "ActionsOverlay"
  };
  const _sfc_main$32 = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$17), {
    props: {
      showOverlay: { type: Boolean, default: true }
    },
    setup(__props) {
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$2l, [
          Vue.renderSlot(_ctx.$slots, "default"),
          __props.showOverlay ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_2$1x, [
            Vue.createElementVNode("div", _hoisted_3$11, [
              Vue.renderSlot(_ctx.$slots, "actions")
            ])
          ])) : Vue.createCommentVNode("", true)
        ]);
      };
    }
  }));
  var BaseInput_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$2k = {
    key: 0,
    class: "zion-input__prefix"
  };
  const _hoisted_2$1w = {
    key: 0,
    class: "zion-input__prepend"
  };
  const _hoisted_3$10 = ["type", "value"];
  const _hoisted_4$E = ["value"];
  const _hoisted_5$v = {
    key: 4,
    class: "zion-input__suffix"
  };
  const _hoisted_6$m = {
    key: 1,
    class: "zion-input__append"
  };
  const __default__$16 = {
    name: "BaseInput",
    inheritAttrs: false
  };
  const _sfc_main$31 = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$16), {
    props: {
      modelValue: { default: "" },
      error: { type: Boolean, default: false },
      type: { default: "text" },
      icon: null,
      clearable: { type: Boolean, default: false },
      size: null,
      fontFamily: null,
      class: { default: "" }
    },
    emits: ["update:modelValue"],
    setup(__props, { expose, emit }) {
      const props = __props;
      const input = Vue.ref(null);
      const showClear = Vue.computed(() => {
        return props.clearable && props.modelValue ? true : false;
      });
      const hasSuffixContent = Vue.computed(() => {
        return props.icon || showClear.value;
      });
      const getStyle = Vue.computed(() => {
        return {
          fontFamily: props.fontFamily || ""
        };
      });
      const cssClass = Vue.computed(() => {
        return props.class;
      });
      function onKeyDown(e) {
        if (e.shiftKey) {
          e.stopPropagation();
        }
      }
      function focus() {
        var _a3;
        (_a3 = input.value) == null ? void 0 : _a3.focus();
      }
      function blur() {
        var _a3;
        (_a3 = input.value) == null ? void 0 : _a3.blur();
      }
      function onInput(e) {
        if (props.type === "number" && e.target.validity.badInput) {
          return;
        }
        emit("update:modelValue", e.target.value);
      }
      expose({
        input,
        focus,
        blur
      });
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", {
          class: Vue.normalizeClass(["zion-input", {
            "zion-input--has-prepend": _ctx.$slots.prepend,
            "zion-input--has-append": _ctx.$slots.append,
            "zion-input--has-suffix": Vue.unref(hasSuffixContent),
            "zion-input--error": __props.error,
            [`zion-input--size-${__props.size}`]: __props.size,
            [Vue.unref(cssClass)]: Vue.unref(cssClass)
          }]),
          onKeydown: onKeyDown
        }, [
          _ctx.$slots.prepend ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$2k, [
            _ctx.$slots.prepend ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_2$1w, [
              Vue.renderSlot(_ctx.$slots, "prepend")
            ])) : Vue.createCommentVNode("", true)
          ])) : Vue.createCommentVNode("", true),
          __props.type !== "textarea" ? (Vue.openBlock(), Vue.createElementBlock("input", Vue.mergeProps({
            key: 1,
            ref_key: "input",
            ref: input,
            type: __props.type,
            value: __props.modelValue,
            style: Vue.unref(getStyle)
          }, _ctx.$attrs, { onInput }), null, 16, _hoisted_3$10)) : (Vue.openBlock(), Vue.createElementBlock("textarea", Vue.mergeProps({
            key: 2,
            ref_key: "input",
            ref: input,
            class: "znpb-fancy-scrollbar",
            value: __props.modelValue
          }, _ctx.$attrs, {
            onInput: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event.target.value))
          }), "\n		", 16, _hoisted_4$E)),
          Vue.renderSlot(_ctx.$slots, "after-input"),
          Vue.unref(showClear) ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$34), {
            key: 3,
            class: "zion-input__suffix-icon zion-input__clear-text",
            icon: "close",
            onMousedown: _cache[1] || (_cache[1] = Vue.withModifiers(($event) => _ctx.$emit("update:modelValue", ""), ["stop", "prevent"]))
          })) : Vue.createCommentVNode("", true),
          _ctx.$slots.suffix || __props.icon || _ctx.$slots.append ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_5$v, [
            Vue.renderSlot(_ctx.$slots, "suffix"),
            __props.icon ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$34), {
              key: 0,
              class: "zion-input__suffix-icon",
              icon: __props.icon,
              onClick: _cache[2] || (_cache[2] = Vue.withModifiers(($event) => _ctx.$emit("update:modelValue", ""), ["stop", "prevent"]))
            }, null, 8, ["icon"])) : Vue.createCommentVNode("", true),
            _ctx.$slots.append ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_6$m, [
              Vue.renderSlot(_ctx.$slots, "append")
            ])) : Vue.createCommentVNode("", true)
          ])) : Vue.createCommentVNode("", true)
        ], 34);
      };
    }
  }));
  var Button_vue_vue_type_style_index_0_lang = "";
  const __default__$15 = {
    name: "Button"
  };
  const _sfc_main$30 = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$15), {
    props: {
      type: null
    },
    setup(__props) {
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", {
          class: Vue.normalizeClass(["znpb-button", { ["znpb-button--" + __props.type]: __props.type }])
        }, [
          Vue.renderSlot(_ctx.$slots, "default")
        ], 2);
      };
    }
  }));
  var ChangesBullet_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$2j = { class: "znpb-options-has-changes-wrapper" };
  const _hoisted_2$1v = { key: 0 };
  const __default__$14 = {
    name: "ChangesBullet"
  };
  const _sfc_main$2$ = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$14), {
    props: {
      discardChangesTitle: { default: () => window.zb.i18n.translate("discard_changes") }
    },
    emits: ["remove-styles"],
    setup(__props) {
      const showIcon = Vue.ref(false);
      return (_ctx, _cache) => {
        const _component_Icon = Vue.resolveComponent("Icon");
        const _directive_znpb_tooltip = Vue.resolveDirective("znpb-tooltip");
        return Vue.withDirectives((Vue.openBlock(), Vue.createElementBlock("span", _hoisted_1$2j, [
          Vue.createElementVNode("span", {
            class: "znpb-options__has-changes",
            onClick: _cache[0] || (_cache[0] = Vue.withModifiers(($event) => _ctx.$emit("remove-styles"), ["stop"])),
            onMouseover: _cache[1] || (_cache[1] = ($event) => showIcon.value = true),
            onMouseleave: _cache[2] || (_cache[2] = ($event) => showIcon.value = false)
          }, [
            !showIcon.value ? (Vue.openBlock(), Vue.createElementBlock("span", _hoisted_2$1v)) : (Vue.openBlock(), Vue.createBlock(_component_Icon, {
              key: 1,
              class: "znpb-options-has-changes-wrapper__delete",
              icon: "close",
              size: 6
            }))
          ], 32)
        ])), [
          [_directive_znpb_tooltip, __props.discardChangesTitle]
        ]);
      };
    }
  }));
  var tinycolor$1 = { exports: {} };
  (function(module2) {
    (function(Math2) {
      var trimLeft = /^\s+/, trimRight = /\s+$/, tinyCounter = 0, mathRound = Math2.round, mathMin = Math2.min, mathMax = Math2.max, mathRandom = Math2.random;
      function tinycolor2(color, opts) {
        color = color ? color : "";
        opts = opts || {};
        if (color instanceof tinycolor2) {
          return color;
        }
        if (!(this instanceof tinycolor2)) {
          return new tinycolor2(color, opts);
        }
        var rgb = inputToRGB(color);
        this._originalInput = color, this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, this._a = rgb.a, this._roundA = mathRound(100 * this._a) / 100, this._format = opts.format || rgb.format;
        this._gradientType = opts.gradientType;
        if (this._r < 1) {
          this._r = mathRound(this._r);
        }
        if (this._g < 1) {
          this._g = mathRound(this._g);
        }
        if (this._b < 1) {
          this._b = mathRound(this._b);
        }
        this._ok = rgb.ok;
        this._tc_id = tinyCounter++;
      }
      tinycolor2.prototype = {
        isDark: function() {
          return this.getBrightness() < 128;
        },
        isLight: function() {
          return !this.isDark();
        },
        isValid: function() {
          return this._ok;
        },
        getOriginalInput: function() {
          return this._originalInput;
        },
        getFormat: function() {
          return this._format;
        },
        getAlpha: function() {
          return this._a;
        },
        getBrightness: function() {
          var rgb = this.toRgb();
          return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
        },
        getLuminance: function() {
          var rgb = this.toRgb();
          var RsRGB, GsRGB, BsRGB, R, G, B;
          RsRGB = rgb.r / 255;
          GsRGB = rgb.g / 255;
          BsRGB = rgb.b / 255;
          if (RsRGB <= 0.03928) {
            R = RsRGB / 12.92;
          } else {
            R = Math2.pow((RsRGB + 0.055) / 1.055, 2.4);
          }
          if (GsRGB <= 0.03928) {
            G = GsRGB / 12.92;
          } else {
            G = Math2.pow((GsRGB + 0.055) / 1.055, 2.4);
          }
          if (BsRGB <= 0.03928) {
            B = BsRGB / 12.92;
          } else {
            B = Math2.pow((BsRGB + 0.055) / 1.055, 2.4);
          }
          return 0.2126 * R + 0.7152 * G + 0.0722 * B;
        },
        setAlpha: function(value) {
          this._a = boundAlpha(value);
          this._roundA = mathRound(100 * this._a) / 100;
          return this;
        },
        toHsv: function() {
          var hsv = rgbToHsv(this._r, this._g, this._b);
          return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a };
        },
        toHsvString: function() {
          var hsv = rgbToHsv(this._r, this._g, this._b);
          var h = mathRound(hsv.h * 360), s = mathRound(hsv.s * 100), v = mathRound(hsv.v * 100);
          return this._a == 1 ? "hsv(" + h + ", " + s + "%, " + v + "%)" : "hsva(" + h + ", " + s + "%, " + v + "%, " + this._roundA + ")";
        },
        toHsl: function() {
          var hsl = rgbToHsl(this._r, this._g, this._b);
          return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this._a };
        },
        toHslString: function() {
          var hsl = rgbToHsl(this._r, this._g, this._b);
          var h = mathRound(hsl.h * 360), s = mathRound(hsl.s * 100), l = mathRound(hsl.l * 100);
          return this._a == 1 ? "hsl(" + h + ", " + s + "%, " + l + "%)" : "hsla(" + h + ", " + s + "%, " + l + "%, " + this._roundA + ")";
        },
        toHex: function(allow3Char) {
          return rgbToHex(this._r, this._g, this._b, allow3Char);
        },
        toHexString: function(allow3Char) {
          return "#" + this.toHex(allow3Char);
        },
        toHex8: function(allow4Char) {
          return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
        },
        toHex8String: function(allow4Char) {
          return "#" + this.toHex8(allow4Char);
        },
        toRgb: function() {
          return { r: mathRound(this._r), g: mathRound(this._g), b: mathRound(this._b), a: this._a };
        },
        toRgbString: function() {
          return this._a == 1 ? "rgb(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" : "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
        },
        toPercentageRgb: function() {
          return { r: mathRound(bound01(this._r, 255) * 100) + "%", g: mathRound(bound01(this._g, 255) * 100) + "%", b: mathRound(bound01(this._b, 255) * 100) + "%", a: this._a };
        },
        toPercentageRgbString: function() {
          return this._a == 1 ? "rgb(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%)" : "rgba(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
        },
        toName: function() {
          if (this._a === 0) {
            return "transparent";
          }
          if (this._a < 1) {
            return false;
          }
          return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
        },
        toFilter: function(secondColor) {
          var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a);
          var secondHex8String = hex8String;
          var gradientType = this._gradientType ? "GradientType = 1, " : "";
          if (secondColor) {
            var s = tinycolor2(secondColor);
            secondHex8String = "#" + rgbaToArgbHex(s._r, s._g, s._b, s._a);
          }
          return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
        },
        toString: function(format) {
          var formatSet = !!format;
          format = format || this._format;
          var formattedString = false;
          var hasAlpha = this._a < 1 && this._a >= 0;
          var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "hex4" || format === "hex8" || format === "name");
          if (needsAlphaFormat) {
            if (format === "name" && this._a === 0) {
              return this.toName();
            }
            return this.toRgbString();
          }
          if (format === "rgb") {
            formattedString = this.toRgbString();
          }
          if (format === "prgb") {
            formattedString = this.toPercentageRgbString();
          }
          if (format === "hex" || format === "hex6") {
            formattedString = this.toHexString();
          }
          if (format === "hex3") {
            formattedString = this.toHexString(true);
          }
          if (format === "hex4") {
            formattedString = this.toHex8String(true);
          }
          if (format === "hex8") {
            formattedString = this.toHex8String();
          }
          if (format === "name") {
            formattedString = this.toName();
          }
          if (format === "hsl") {
            formattedString = this.toHslString();
          }
          if (format === "hsv") {
            formattedString = this.toHsvString();
          }
          return formattedString || this.toHexString();
        },
        clone: function() {
          return tinycolor2(this.toString());
        },
        _applyModification: function(fn, args) {
          var color = fn.apply(null, [this].concat([].slice.call(args)));
          this._r = color._r;
          this._g = color._g;
          this._b = color._b;
          this.setAlpha(color._a);
          return this;
        },
        lighten: function() {
          return this._applyModification(lighten, arguments);
        },
        brighten: function() {
          return this._applyModification(brighten, arguments);
        },
        darken: function() {
          return this._applyModification(darken, arguments);
        },
        desaturate: function() {
          return this._applyModification(desaturate, arguments);
        },
        saturate: function() {
          return this._applyModification(saturate, arguments);
        },
        greyscale: function() {
          return this._applyModification(greyscale, arguments);
        },
        spin: function() {
          return this._applyModification(spin, arguments);
        },
        _applyCombination: function(fn, args) {
          return fn.apply(null, [this].concat([].slice.call(args)));
        },
        analogous: function() {
          return this._applyCombination(analogous, arguments);
        },
        complement: function() {
          return this._applyCombination(complement, arguments);
        },
        monochromatic: function() {
          return this._applyCombination(monochromatic, arguments);
        },
        splitcomplement: function() {
          return this._applyCombination(splitcomplement, arguments);
        },
        triad: function() {
          return this._applyCombination(triad, arguments);
        },
        tetrad: function() {
          return this._applyCombination(tetrad, arguments);
        }
      };
      tinycolor2.fromRatio = function(color, opts) {
        if (typeof color == "object") {
          var newColor = {};
          for (var i in color) {
            if (color.hasOwnProperty(i)) {
              if (i === "a") {
                newColor[i] = color[i];
              } else {
                newColor[i] = convertToPercentage(color[i]);
              }
            }
          }
          color = newColor;
        }
        return tinycolor2(color, opts);
      };
      function inputToRGB(color) {
        var rgb = { r: 0, g: 0, b: 0 };
        var a = 1;
        var s = null;
        var v = null;
        var l = null;
        var ok = false;
        var format = false;
        if (typeof color == "string") {
          color = stringInputToObject(color);
        }
        if (typeof color == "object") {
          if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
            rgb = rgbToRgb(color.r, color.g, color.b);
            ok = true;
            format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
          } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
            s = convertToPercentage(color.s);
            v = convertToPercentage(color.v);
            rgb = hsvToRgb(color.h, s, v);
            ok = true;
            format = "hsv";
          } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
            s = convertToPercentage(color.s);
            l = convertToPercentage(color.l);
            rgb = hslToRgb(color.h, s, l);
            ok = true;
            format = "hsl";
          }
          if (color.hasOwnProperty("a")) {
            a = color.a;
          }
        }
        a = boundAlpha(a);
        return {
          ok,
          format: color.format || format,
          r: mathMin(255, mathMax(rgb.r, 0)),
          g: mathMin(255, mathMax(rgb.g, 0)),
          b: mathMin(255, mathMax(rgb.b, 0)),
          a
        };
      }
      function rgbToRgb(r, g, b) {
        return {
          r: bound01(r, 255) * 255,
          g: bound01(g, 255) * 255,
          b: bound01(b, 255) * 255
        };
      }
      function rgbToHsl(r, g, b) {
        r = bound01(r, 255);
        g = bound01(g, 255);
        b = bound01(b, 255);
        var max2 = mathMax(r, g, b), min2 = mathMin(r, g, b);
        var h, s, l = (max2 + min2) / 2;
        if (max2 == min2) {
          h = s = 0;
        } else {
          var d = max2 - min2;
          s = l > 0.5 ? d / (2 - max2 - min2) : d / (max2 + min2);
          switch (max2) {
            case r:
              h = (g - b) / d + (g < b ? 6 : 0);
              break;
            case g:
              h = (b - r) / d + 2;
              break;
            case b:
              h = (r - g) / d + 4;
              break;
          }
          h /= 6;
        }
        return { h, s, l };
      }
      function hslToRgb(h, s, l) {
        var r, g, b;
        h = bound01(h, 360);
        s = bound01(s, 100);
        l = bound01(l, 100);
        function hue2rgb(p2, q2, t) {
          if (t < 0)
            t += 1;
          if (t > 1)
            t -= 1;
          if (t < 1 / 6)
            return p2 + (q2 - p2) * 6 * t;
          if (t < 1 / 2)
            return q2;
          if (t < 2 / 3)
            return p2 + (q2 - p2) * (2 / 3 - t) * 6;
          return p2;
        }
        if (s === 0) {
          r = g = b = l;
        } else {
          var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          var p = 2 * l - q;
          r = hue2rgb(p, q, h + 1 / 3);
          g = hue2rgb(p, q, h);
          b = hue2rgb(p, q, h - 1 / 3);
        }
        return { r: r * 255, g: g * 255, b: b * 255 };
      }
      function rgbToHsv(r, g, b) {
        r = bound01(r, 255);
        g = bound01(g, 255);
        b = bound01(b, 255);
        var max2 = mathMax(r, g, b), min2 = mathMin(r, g, b);
        var h, s, v = max2;
        var d = max2 - min2;
        s = max2 === 0 ? 0 : d / max2;
        if (max2 == min2) {
          h = 0;
        } else {
          switch (max2) {
            case r:
              h = (g - b) / d + (g < b ? 6 : 0);
              break;
            case g:
              h = (b - r) / d + 2;
              break;
            case b:
              h = (r - g) / d + 4;
              break;
          }
          h /= 6;
        }
        return { h, s, v };
      }
      function hsvToRgb(h, s, v) {
        h = bound01(h, 360) * 6;
        s = bound01(s, 100);
        v = bound01(v, 100);
        var i = Math2.floor(h), f = h - i, p = v * (1 - s), q = v * (1 - f * s), t = v * (1 - (1 - f) * s), mod = i % 6, r = [v, q, p, p, t, v][mod], g = [t, v, v, q, p, p][mod], b = [p, p, t, v, v, q][mod];
        return { r: r * 255, g: g * 255, b: b * 255 };
      }
      function rgbToHex(r, g, b, allow3Char) {
        var hex = [
          pad2(mathRound(r).toString(16)),
          pad2(mathRound(g).toString(16)),
          pad2(mathRound(b).toString(16))
        ];
        if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
          return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
        }
        return hex.join("");
      }
      function rgbaToHex(r, g, b, a, allow4Char) {
        var hex = [
          pad2(mathRound(r).toString(16)),
          pad2(mathRound(g).toString(16)),
          pad2(mathRound(b).toString(16)),
          pad2(convertDecimalToHex(a))
        ];
        if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
          return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
        }
        return hex.join("");
      }
      function rgbaToArgbHex(r, g, b, a) {
        var hex = [
          pad2(convertDecimalToHex(a)),
          pad2(mathRound(r).toString(16)),
          pad2(mathRound(g).toString(16)),
          pad2(mathRound(b).toString(16))
        ];
        return hex.join("");
      }
      tinycolor2.equals = function(color1, color2) {
        if (!color1 || !color2) {
          return false;
        }
        return tinycolor2(color1).toRgbString() == tinycolor2(color2).toRgbString();
      };
      tinycolor2.random = function() {
        return tinycolor2.fromRatio({
          r: mathRandom(),
          g: mathRandom(),
          b: mathRandom()
        });
      };
      function desaturate(color, amount) {
        amount = amount === 0 ? 0 : amount || 10;
        var hsl = tinycolor2(color).toHsl();
        hsl.s -= amount / 100;
        hsl.s = clamp01(hsl.s);
        return tinycolor2(hsl);
      }
      function saturate(color, amount) {
        amount = amount === 0 ? 0 : amount || 10;
        var hsl = tinycolor2(color).toHsl();
        hsl.s += amount / 100;
        hsl.s = clamp01(hsl.s);
        return tinycolor2(hsl);
      }
      function greyscale(color) {
        return tinycolor2(color).desaturate(100);
      }
      function lighten(color, amount) {
        amount = amount === 0 ? 0 : amount || 10;
        var hsl = tinycolor2(color).toHsl();
        hsl.l += amount / 100;
        hsl.l = clamp01(hsl.l);
        return tinycolor2(hsl);
      }
      function brighten(color, amount) {
        amount = amount === 0 ? 0 : amount || 10;
        var rgb = tinycolor2(color).toRgb();
        rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * -(amount / 100))));
        rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * -(amount / 100))));
        rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * -(amount / 100))));
        return tinycolor2(rgb);
      }
      function darken(color, amount) {
        amount = amount === 0 ? 0 : amount || 10;
        var hsl = tinycolor2(color).toHsl();
        hsl.l -= amount / 100;
        hsl.l = clamp01(hsl.l);
        return tinycolor2(hsl);
      }
      function spin(color, amount) {
        var hsl = tinycolor2(color).toHsl();
        var hue = (hsl.h + amount) % 360;
        hsl.h = hue < 0 ? 360 + hue : hue;
        return tinycolor2(hsl);
      }
      function complement(color) {
        var hsl = tinycolor2(color).toHsl();
        hsl.h = (hsl.h + 180) % 360;
        return tinycolor2(hsl);
      }
      function triad(color) {
        var hsl = tinycolor2(color).toHsl();
        var h = hsl.h;
        return [
          tinycolor2(color),
          tinycolor2({ h: (h + 120) % 360, s: hsl.s, l: hsl.l }),
          tinycolor2({ h: (h + 240) % 360, s: hsl.s, l: hsl.l })
        ];
      }
      function tetrad(color) {
        var hsl = tinycolor2(color).toHsl();
        var h = hsl.h;
        return [
          tinycolor2(color),
          tinycolor2({ h: (h + 90) % 360, s: hsl.s, l: hsl.l }),
          tinycolor2({ h: (h + 180) % 360, s: hsl.s, l: hsl.l }),
          tinycolor2({ h: (h + 270) % 360, s: hsl.s, l: hsl.l })
        ];
      }
      function splitcomplement(color) {
        var hsl = tinycolor2(color).toHsl();
        var h = hsl.h;
        return [
          tinycolor2(color),
          tinycolor2({ h: (h + 72) % 360, s: hsl.s, l: hsl.l }),
          tinycolor2({ h: (h + 216) % 360, s: hsl.s, l: hsl.l })
        ];
      }
      function analogous(color, results, slices) {
        results = results || 6;
        slices = slices || 30;
        var hsl = tinycolor2(color).toHsl();
        var part = 360 / slices;
        var ret = [tinycolor2(color)];
        for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
          hsl.h = (hsl.h + part) % 360;
          ret.push(tinycolor2(hsl));
        }
        return ret;
      }
      function monochromatic(color, results) {
        results = results || 6;
        var hsv = tinycolor2(color).toHsv();
        var h = hsv.h, s = hsv.s, v = hsv.v;
        var ret = [];
        var modification = 1 / results;
        while (results--) {
          ret.push(tinycolor2({ h, s, v }));
          v = (v + modification) % 1;
        }
        return ret;
      }
      tinycolor2.mix = function(color1, color2, amount) {
        amount = amount === 0 ? 0 : amount || 50;
        var rgb1 = tinycolor2(color1).toRgb();
        var rgb2 = tinycolor2(color2).toRgb();
        var p = amount / 100;
        var rgba = {
          r: (rgb2.r - rgb1.r) * p + rgb1.r,
          g: (rgb2.g - rgb1.g) * p + rgb1.g,
          b: (rgb2.b - rgb1.b) * p + rgb1.b,
          a: (rgb2.a - rgb1.a) * p + rgb1.a
        };
        return tinycolor2(rgba);
      };
      tinycolor2.readability = function(color1, color2) {
        var c1 = tinycolor2(color1);
        var c2 = tinycolor2(color2);
        return (Math2.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math2.min(c1.getLuminance(), c2.getLuminance()) + 0.05);
      };
      tinycolor2.isReadable = function(color1, color2, wcag2) {
        var readability = tinycolor2.readability(color1, color2);
        var wcag2Parms, out;
        out = false;
        wcag2Parms = validateWCAG2Parms(wcag2);
        switch (wcag2Parms.level + wcag2Parms.size) {
          case "AAsmall":
          case "AAAlarge":
            out = readability >= 4.5;
            break;
          case "AAlarge":
            out = readability >= 3;
            break;
          case "AAAsmall":
            out = readability >= 7;
            break;
        }
        return out;
      };
      tinycolor2.mostReadable = function(baseColor, colorList, args) {
        var bestColor = null;
        var bestScore = 0;
        var readability;
        var includeFallbackColors, level, size;
        args = args || {};
        includeFallbackColors = args.includeFallbackColors;
        level = args.level;
        size = args.size;
        for (var i = 0; i < colorList.length; i++) {
          readability = tinycolor2.readability(baseColor, colorList[i]);
          if (readability > bestScore) {
            bestScore = readability;
            bestColor = tinycolor2(colorList[i]);
          }
        }
        if (tinycolor2.isReadable(baseColor, bestColor, { "level": level, "size": size }) || !includeFallbackColors) {
          return bestColor;
        } else {
          args.includeFallbackColors = false;
          return tinycolor2.mostReadable(baseColor, ["#fff", "#000"], args);
        }
      };
      var names = tinycolor2.names = {
        aliceblue: "f0f8ff",
        antiquewhite: "faebd7",
        aqua: "0ff",
        aquamarine: "7fffd4",
        azure: "f0ffff",
        beige: "f5f5dc",
        bisque: "ffe4c4",
        black: "000",
        blanchedalmond: "ffebcd",
        blue: "00f",
        blueviolet: "8a2be2",
        brown: "a52a2a",
        burlywood: "deb887",
        burntsienna: "ea7e5d",
        cadetblue: "5f9ea0",
        chartreuse: "7fff00",
        chocolate: "d2691e",
        coral: "ff7f50",
        cornflowerblue: "6495ed",
        cornsilk: "fff8dc",
        crimson: "dc143c",
        cyan: "0ff",
        darkblue: "00008b",
        darkcyan: "008b8b",
        darkgoldenrod: "b8860b",
        darkgray: "a9a9a9",
        darkgreen: "006400",
        darkgrey: "a9a9a9",
        darkkhaki: "bdb76b",
        darkmagenta: "8b008b",
        darkolivegreen: "556b2f",
        darkorange: "ff8c00",
        darkorchid: "9932cc",
        darkred: "8b0000",
        darksalmon: "e9967a",
        darkseagreen: "8fbc8f",
        darkslateblue: "483d8b",
        darkslategray: "2f4f4f",
        darkslategrey: "2f4f4f",
        darkturquoise: "00ced1",
        darkviolet: "9400d3",
        deeppink: "ff1493",
        deepskyblue: "00bfff",
        dimgray: "696969",
        dimgrey: "696969",
        dodgerblue: "1e90ff",
        firebrick: "b22222",
        floralwhite: "fffaf0",
        forestgreen: "228b22",
        fuchsia: "f0f",
        gainsboro: "dcdcdc",
        ghostwhite: "f8f8ff",
        gold: "ffd700",
        goldenrod: "daa520",
        gray: "808080",
        green: "008000",
        greenyellow: "adff2f",
        grey: "808080",
        honeydew: "f0fff0",
        hotpink: "ff69b4",
        indianred: "cd5c5c",
        indigo: "4b0082",
        ivory: "fffff0",
        khaki: "f0e68c",
        lavender: "e6e6fa",
        lavenderblush: "fff0f5",
        lawngreen: "7cfc00",
        lemonchiffon: "fffacd",
        lightblue: "add8e6",
        lightcoral: "f08080",
        lightcyan: "e0ffff",
        lightgoldenrodyellow: "fafad2",
        lightgray: "d3d3d3",
        lightgreen: "90ee90",
        lightgrey: "d3d3d3",
        lightpink: "ffb6c1",
        lightsalmon: "ffa07a",
        lightseagreen: "20b2aa",
        lightskyblue: "87cefa",
        lightslategray: "789",
        lightslategrey: "789",
        lightsteelblue: "b0c4de",
        lightyellow: "ffffe0",
        lime: "0f0",
        limegreen: "32cd32",
        linen: "faf0e6",
        magenta: "f0f",
        maroon: "800000",
        mediumaquamarine: "66cdaa",
        mediumblue: "0000cd",
        mediumorchid: "ba55d3",
        mediumpurple: "9370db",
        mediumseagreen: "3cb371",
        mediumslateblue: "7b68ee",
        mediumspringgreen: "00fa9a",
        mediumturquoise: "48d1cc",
        mediumvioletred: "c71585",
        midnightblue: "191970",
        mintcream: "f5fffa",
        mistyrose: "ffe4e1",
        moccasin: "ffe4b5",
        navajowhite: "ffdead",
        navy: "000080",
        oldlace: "fdf5e6",
        olive: "808000",
        olivedrab: "6b8e23",
        orange: "ffa500",
        orangered: "ff4500",
        orchid: "da70d6",
        palegoldenrod: "eee8aa",
        palegreen: "98fb98",
        paleturquoise: "afeeee",
        palevioletred: "db7093",
        papayawhip: "ffefd5",
        peachpuff: "ffdab9",
        peru: "cd853f",
        pink: "ffc0cb",
        plum: "dda0dd",
        powderblue: "b0e0e6",
        purple: "800080",
        rebeccapurple: "663399",
        red: "f00",
        rosybrown: "bc8f8f",
        royalblue: "4169e1",
        saddlebrown: "8b4513",
        salmon: "fa8072",
        sandybrown: "f4a460",
        seagreen: "2e8b57",
        seashell: "fff5ee",
        sienna: "a0522d",
        silver: "c0c0c0",
        skyblue: "87ceeb",
        slateblue: "6a5acd",
        slategray: "708090",
        slategrey: "708090",
        snow: "fffafa",
        springgreen: "00ff7f",
        steelblue: "4682b4",
        tan: "d2b48c",
        teal: "008080",
        thistle: "d8bfd8",
        tomato: "ff6347",
        turquoise: "40e0d0",
        violet: "ee82ee",
        wheat: "f5deb3",
        white: "fff",
        whitesmoke: "f5f5f5",
        yellow: "ff0",
        yellowgreen: "9acd32"
      };
      var hexNames = tinycolor2.hexNames = flip2(names);
      function flip2(o) {
        var flipped = {};
        for (var i in o) {
          if (o.hasOwnProperty(i)) {
            flipped[o[i]] = i;
          }
        }
        return flipped;
      }
      function boundAlpha(a) {
        a = parseFloat(a);
        if (isNaN(a) || a < 0 || a > 1) {
          a = 1;
        }
        return a;
      }
      function bound01(n, max2) {
        if (isOnePointZero(n)) {
          n = "100%";
        }
        var processPercent = isPercentage(n);
        n = mathMin(max2, mathMax(0, parseFloat(n)));
        if (processPercent) {
          n = parseInt(n * max2, 10) / 100;
        }
        if (Math2.abs(n - max2) < 1e-6) {
          return 1;
        }
        return n % max2 / parseFloat(max2);
      }
      function clamp01(val) {
        return mathMin(1, mathMax(0, val));
      }
      function parseIntFromHex(val) {
        return parseInt(val, 16);
      }
      function isOnePointZero(n) {
        return typeof n == "string" && n.indexOf(".") != -1 && parseFloat(n) === 1;
      }
      function isPercentage(n) {
        return typeof n === "string" && n.indexOf("%") != -1;
      }
      function pad2(c) {
        return c.length == 1 ? "0" + c : "" + c;
      }
      function convertToPercentage(n) {
        if (n <= 1) {
          n = n * 100 + "%";
        }
        return n;
      }
      function convertDecimalToHex(d) {
        return Math2.round(parseFloat(d) * 255).toString(16);
      }
      function convertHexToDecimal(h) {
        return parseIntFromHex(h) / 255;
      }
      var matchers = function() {
        var CSS_INTEGER = "[-\\+]?\\d+%?";
        var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
        var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
        var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
        var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
        return {
          CSS_UNIT: new RegExp(CSS_UNIT),
          rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
          rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
          hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
          hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
          hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
          hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
          hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
          hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
          hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
          hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
        };
      }();
      function isValidCSSUnit(color) {
        return !!matchers.CSS_UNIT.exec(color);
      }
      function stringInputToObject(color) {
        color = color.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
        var named = false;
        if (names[color]) {
          color = names[color];
          named = true;
        } else if (color == "transparent") {
          return { r: 0, g: 0, b: 0, a: 0, format: "name" };
        }
        var match;
        if (match = matchers.rgb.exec(color)) {
          return { r: match[1], g: match[2], b: match[3] };
        }
        if (match = matchers.rgba.exec(color)) {
          return { r: match[1], g: match[2], b: match[3], a: match[4] };
        }
        if (match = matchers.hsl.exec(color)) {
          return { h: match[1], s: match[2], l: match[3] };
        }
        if (match = matchers.hsla.exec(color)) {
          return { h: match[1], s: match[2], l: match[3], a: match[4] };
        }
        if (match = matchers.hsv.exec(color)) {
          return { h: match[1], s: match[2], v: match[3] };
        }
        if (match = matchers.hsva.exec(color)) {
          return { h: match[1], s: match[2], v: match[3], a: match[4] };
        }
        if (match = matchers.hex8.exec(color)) {
          return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            a: convertHexToDecimal(match[4]),
            format: named ? "name" : "hex8"
          };
        }
        if (match = matchers.hex6.exec(color)) {
          return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            format: named ? "name" : "hex"
          };
        }
        if (match = matchers.hex4.exec(color)) {
          return {
            r: parseIntFromHex(match[1] + "" + match[1]),
            g: parseIntFromHex(match[2] + "" + match[2]),
            b: parseIntFromHex(match[3] + "" + match[3]),
            a: convertHexToDecimal(match[4] + "" + match[4]),
            format: named ? "name" : "hex8"
          };
        }
        if (match = matchers.hex3.exec(color)) {
          return {
            r: parseIntFromHex(match[1] + "" + match[1]),
            g: parseIntFromHex(match[2] + "" + match[2]),
            b: parseIntFromHex(match[3] + "" + match[3]),
            format: named ? "name" : "hex"
          };
        }
        return false;
      }
      function validateWCAG2Parms(parms) {
        var level, size;
        parms = parms || { "level": "AA", "size": "small" };
        level = (parms.level || "AA").toUpperCase();
        size = (parms.size || "small").toLowerCase();
        if (level !== "AA" && level !== "AAA") {
          level = "AA";
        }
        if (size !== "small" && size !== "large") {
          size = "small";
        }
        return { "level": level, "size": size };
      }
      if (module2.exports) {
        module2.exports = tinycolor2;
      } else {
        window.tinycolor = tinycolor2;
      }
    })(Math);
  })(tinycolor$1);
  var tinycolor = tinycolor$1.exports;
  var _a;
  const isClient = typeof window !== "undefined";
  isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
  function identity(arg) {
    return arg;
  }
  function tryOnMounted(fn, sync = true) {
    if (Vue.getCurrentInstance())
      Vue.onMounted(fn);
    else if (sync)
      fn();
    else
      Vue.nextTick(fn);
  }
  isClient ? window : void 0;
  isClient ? window.document : void 0;
  isClient ? window.navigator : void 0;
  isClient ? window.location : void 0;
  function useSupported(callback, sync = false) {
    const isSupported = Vue.ref();
    const update2 = () => isSupported.value = Boolean(callback());
    update2();
    tryOnMounted(update2, sync);
    return isSupported;
  }
  const _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  const globalKey = "__vueuse_ssr_handlers__";
  _global[globalKey] = _global[globalKey] || {};
  _global[globalKey];
  function useEyeDropper(options2 = {}) {
    const { initialValue = "" } = options2;
    const isSupported = useSupported(() => typeof window !== "undefined" && "EyeDropper" in window);
    const sRGBHex = Vue.ref(initialValue);
    function open2(openOptions) {
      return __async(this, null, function* () {
        if (!isSupported.value)
          return;
        const eyeDropper = new window.EyeDropper();
        const result = yield eyeDropper.open(openOptions);
        sRGBHex.value = result.sRGBHex;
        return result;
      });
    }
    return { isSupported, sRGBHex, open: open2 };
  }
  var SwipeDirection;
  (function(SwipeDirection2) {
    SwipeDirection2["UP"] = "UP";
    SwipeDirection2["RIGHT"] = "RIGHT";
    SwipeDirection2["DOWN"] = "DOWN";
    SwipeDirection2["LEFT"] = "LEFT";
    SwipeDirection2["NONE"] = "NONE";
  })(SwipeDirection || (SwipeDirection = {}));
  var __defProp2 = Object.defineProperty;
  var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
  var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues2 = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp2.call(b, prop))
        __defNormalProp2(a, prop, b[prop]);
    if (__getOwnPropSymbols2)
      for (var prop of __getOwnPropSymbols2(b)) {
        if (__propIsEnum2.call(b, prop))
          __defNormalProp2(a, prop, b[prop]);
      }
    return a;
  };
  const _TransitionPresets = {
    easeInSine: [0.12, 0, 0.39, 0],
    easeOutSine: [0.61, 1, 0.88, 1],
    easeInOutSine: [0.37, 0, 0.63, 1],
    easeInQuad: [0.11, 0, 0.5, 0],
    easeOutQuad: [0.5, 1, 0.89, 1],
    easeInOutQuad: [0.45, 0, 0.55, 1],
    easeInCubic: [0.32, 0, 0.67, 0],
    easeOutCubic: [0.33, 1, 0.68, 1],
    easeInOutCubic: [0.65, 0, 0.35, 1],
    easeInQuart: [0.5, 0, 0.75, 0],
    easeOutQuart: [0.25, 1, 0.5, 1],
    easeInOutQuart: [0.76, 0, 0.24, 1],
    easeInQuint: [0.64, 0, 0.78, 0],
    easeOutQuint: [0.22, 1, 0.36, 1],
    easeInOutQuint: [0.83, 0, 0.17, 1],
    easeInExpo: [0.7, 0, 0.84, 0],
    easeOutExpo: [0.16, 1, 0.3, 1],
    easeInOutExpo: [0.87, 0, 0.13, 1],
    easeInCirc: [0.55, 0, 1, 0.45],
    easeOutCirc: [0, 0.55, 0.45, 1],
    easeInOutCirc: [0.85, 0, 0.15, 1],
    easeInBack: [0.36, 0, 0.66, -0.56],
    easeOutBack: [0.34, 1.56, 0.64, 1],
    easeInOutBack: [0.68, -0.6, 0.32, 1.6]
  };
  __spreadValues2({
    linear: identity
  }, _TransitionPresets);
  var rafSchd = function rafSchd2(fn) {
    var lastArgs = [];
    var frameId = null;
    var wrapperFn = function wrapperFn2() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      lastArgs = args;
      if (frameId) {
        return;
      }
      frameId = requestAnimationFrame(function() {
        frameId = null;
        fn.apply(void 0, lastArgs);
      });
    };
    wrapperFn.cancel = function() {
      if (!frameId) {
        return;
      }
      cancelAnimationFrame(frameId);
      frameId = null;
    };
    return wrapperFn;
  };
  var rafSchd$1 = rafSchd;
  var HueStrip_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$2i = { class: "znpb-colorpicker-inner-editor__hue" };
  const __default__$13 = {
    name: "HueStrip"
  };
  const _sfc_main$2_ = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$13), {
    props: {
      modelValue: null
    },
    emits: ["update:modelValue"],
    setup(__props, { emit }) {
      var _a3;
      const props = __props;
      const direction = Vue.ref("right");
      const oldHue = Vue.ref((_a3 = props.modelValue) == null ? void 0 : _a3.h);
      const lastHue = Vue.ref(null);
      const root2 = Vue.ref(null);
      let ownerWindow;
      const hueStyles = Vue.computed(() => {
        const { h } = props.modelValue;
        let positionValue = props.modelValue.h / 360 * 100;
        if (h === 0 && direction.value === "right") {
          positionValue = 100;
        }
        return {
          left: positionValue + "%"
        };
      });
      Vue.watch(
        () => props.modelValue,
        () => {
          const { h } = props.modelValue;
          if (h !== 0 && h > oldHue.value) {
            direction.value = "right";
          }
          if (h !== 0 && h < oldHue.value) {
            direction.value = "left";
          }
          oldHue.value = h;
        }
      );
      const rafDragCircle = rafSchd$1(dragHueCircle);
      function actHueCircleDrag() {
        ownerWindow.addEventListener("mousemove", rafDragCircle);
        ownerWindow.addEventListener("mouseup", deactivatedragHueCircle);
      }
      function deactivatedragHueCircle() {
        ownerWindow.removeEventListener("mousemove", rafDragCircle);
        ownerWindow.removeEventListener("mouseup", deactivatedragHueCircle);
        function preventClicks(e) {
          e.stopPropagation();
        }
        ownerWindow.addEventListener("click", preventClicks, true);
        setTimeout(() => {
          ownerWindow.removeEventListener("click", preventClicks, true);
        }, 100);
      }
      function dragHueCircle(event2) {
        if (!event2.which) {
          deactivatedragHueCircle();
          return false;
        }
        let h;
        const mouseLeftPosition = event2.clientX;
        const stripOffset = root2.value.getBoundingClientRect();
        const startX = stripOffset.left;
        const newLeft = mouseLeftPosition - startX;
        if (newLeft > stripOffset.width) {
          h = 360;
        } else if (newLeft < 0) {
          h = 0;
        } else {
          const percent = newLeft * 100 / stripOffset.width;
          h = 360 * percent / 100;
        }
        let newColor = __spreadProps(__spreadValues({}, props.modelValue), {
          h
        });
        if (lastHue.value !== h) {
          emit("update:modelValue", newColor);
        }
        lastHue.value = h;
      }
      Vue.onMounted(() => {
        ownerWindow = root2.value.ownerDocument.defaultView;
      });
      Vue.onBeforeUnmount(() => {
        deactivatedragHueCircle();
      });
      Vue.onUnmounted(() => {
        ownerWindow.removeEventListener("mousemove", dragHueCircle);
      });
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", {
          ref_key: "root",
          ref: root2,
          class: "znpb-colorpicker-inner-editor__hue-wrapper",
          onClick: dragHueCircle
        }, [
          Vue.createElementVNode("div", _hoisted_1$2i, [
            Vue.createElementVNode("span", {
              style: Vue.normalizeStyle(Vue.unref(hueStyles)),
              class: "znpb-colorpicker-inner-editor__hue-indicator",
              onMousedown: actHueCircleDrag
            }, null, 36)
          ])
        ], 512);
      };
    }
  }));
  var OpacityStrip_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$2Z = /* @__PURE__ */ Vue.defineComponent({
    __name: "OpacityStrip",
    props: {
      modelValue: null
    },
    emits: ["update:modelValue"],
    setup(__props, { emit }) {
      const props = __props;
      const root2 = Vue.ref(null);
      const opacityStrip = Vue.ref(null);
      const rafDragCircle = rafSchd$1(dragCircle);
      let lastA;
      let ownerWindow;
      const opacityStyles = Vue.computed(() => {
        return {
          left: props.modelValue.a * 100 + "%"
        };
      });
      const barStyles = Vue.computed(() => {
        const color = tinycolor(props.modelValue);
        return {
          "background-image": "linear-gradient(to right, rgba(255, 0, 0, 0)," + color.toHexString() + ")"
        };
      });
      function actCircleDrag() {
        ownerWindow.addEventListener("mousemove", rafDragCircle);
        ownerWindow.addEventListener("mouseup", deactivateDragCircle);
      }
      function deactivateDragCircle() {
        ownerWindow.removeEventListener("mousemove", rafDragCircle);
        ownerWindow.removeEventListener("mouseup", deactivateDragCircle);
        function preventClicks(e) {
          e.stopPropagation();
        }
        ownerWindow.addEventListener("click", preventClicks, true);
        setTimeout(() => {
          ownerWindow.removeEventListener("click", preventClicks, true);
        }, 100);
      }
      function dragCircle(event2) {
        if (!event2.which) {
          deactivateDragCircle();
          return false;
        }
        let a;
        const mouseLeftPosition = event2.clientX;
        const stripOffset = opacityStrip.value.getBoundingClientRect();
        const startX = stripOffset.left;
        const newLeft = mouseLeftPosition - startX;
        if (newLeft > stripOffset.width) {
          a = 1;
        } else if (newLeft < 0) {
          a = 0;
        } else {
          a = newLeft / stripOffset.width;
          a = Number(a.toFixed(2));
        }
        const newColor = __spreadProps(__spreadValues({}, props.modelValue), {
          a
        });
        if (lastA !== a) {
          emit("update:modelValue", newColor);
        }
        lastA = a;
      }
      Vue.onMounted(() => {
        var _a3;
        ownerWindow = (_a3 = root2.value) == null ? void 0 : _a3.ownerDocument.defaultView;
      });
      Vue.onBeforeUnmount(() => {
        deactivateDragCircle();
      });
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", {
          ref_key: "root",
          ref: root2,
          class: "znpb-colorpicker-inner-editor__opacity-wrapper",
          onMousedown: actCircleDrag
        }, [
          Vue.createElementVNode("div", {
            class: "znpb-colorpicker-inner-editor__opacity",
            onClick: dragCircle
          }, [
            Vue.createElementVNode("div", {
              ref_key: "opacityStrip",
              ref: opacityStrip,
              style: Vue.normalizeStyle(Vue.unref(barStyles)),
              class: "znpb-colorpicker-inner-editor__opacity-strip"
            }, null, 4),
            Vue.createElementVNode("span", {
              style: Vue.normalizeStyle(Vue.unref(opacityStyles)),
              class: "znpb-colorpicker-inner-editor__opacity-indicator",
              onMousedown: actCircleDrag
            }, null, 36)
          ])
        ], 544);
      };
    }
  });
  var InputNumber_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$2h = { class: "znpb-input-number" };
  const __default__$12 = {
    name: "InputNumber",
    inheritAttrs: false
  };
  const _sfc_main$2Y = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$12), {
    props: {
      modelValue: null,
      min: null,
      max: null,
      step: { default: 1 },
      shiftStep: { default: 5 },
      suffix: null,
      placeholder: { default: null }
    },
    emits: ["update:modelValue", "linked-value"],
    setup(__props, { emit }) {
      const props = __props;
      let shiftKey = Vue.ref(false);
      let initialPosition = 0;
      let lastPosition = 0;
      let dragTreshold = 3;
      let canChangeValue = false;
      const model = Vue.computed({
        get() {
          return props.modelValue;
        },
        set(newValue) {
          if (props.min !== void 0 && newValue < props.min) {
            newValue = props.min;
          }
          if (props.max !== void 0 && newValue > props.max) {
            newValue = props.max;
          }
          if (newValue !== props.modelValue) {
            emit("update:modelValue", +newValue);
          }
        }
      });
      function reset() {
        initialPosition = 0;
        lastPosition = 0;
        canChangeValue = false;
      }
      function actNumberDrag(event2) {
        if (event2 instanceof MouseEvent) {
          initialPosition = event2.clientY;
        }
        document.body.style.userSelect = "none";
        window.addEventListener("mousemove", dragNumber);
        window.addEventListener("mouseup", deactivatedragNumber);
        window.addEventListener("keyup", onKeyUp);
      }
      function onKeyDown(event2) {
        if (event2.altKey) {
          emit("linked-value");
        }
        shiftKey.value = event2.shiftKey;
      }
      function onKeyUp(event2) {
        emit("linked-value");
      }
      function deactivatedragNumber() {
        document.body.style.userSelect = "";
        document.body.style.pointerEvents = "";
        window.removeEventListener("mousemove", dragNumber);
        window.removeEventListener("mouseup", deactivatedragNumber);
        window.removeEventListener("keyup", onKeyUp);
        function preventClicks(e) {
          e.stopPropagation();
        }
        window.addEventListener("click", preventClicks, true);
        setTimeout(() => {
          window.removeEventListener("click", preventClicks, true);
        }, 100);
        reset();
      }
      function dragNumber(event2) {
        var _a3, _b;
        const distance = initialPosition - event2.clientY;
        const directionUp = event2.pageY < lastPosition;
        const initialValue = (_b = (_a3 = model.value) != null ? _a3 : props.min) != null ? _b : 0;
        if (Math.abs(distance) > dragTreshold) {
          canChangeValue = true;
        }
        if (canChangeValue && distance % 2 === 0) {
          document.body.style.pointerEvents = "none";
          const increment = event2.shiftKey ? props.shiftStep : props.step;
          model.value = directionUp ? +(initialValue + increment).toFixed(12) : +(initialValue - increment).toFixed(12);
          event2.preventDefault();
        }
        lastPosition = event2.clientY;
      }
      Vue.onBeforeUnmount(() => {
        deactivatedragNumber();
      });
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$2h, [
          Vue.createVNode(_sfc_main$31, {
            modelValue: Vue.unref(model),
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => Vue.isRef(model) ? model.value = $event : null),
            type: "number",
            class: "znpb-input-number__input",
            min: __props.min,
            max: __props.max,
            step: Vue.unref(shiftKey) ? __props.shiftStep : __props.step,
            placeholder: __props.placeholder,
            onKeydown: onKeyDown,
            onMousedown: actNumberDrag,
            onTouchstartPassive: Vue.withModifiers(actNumberDrag, ["prevent"]),
            onMouseup: deactivatedragNumber
          }, {
            suffix: Vue.withCtx(() => [
              Vue.renderSlot(_ctx.$slots, "default"),
              Vue.createTextVNode(" " + Vue.toDisplayString(__props.suffix), 1)
            ]),
            _: 3
          }, 8, ["modelValue", "min", "max", "step", "placeholder", "onTouchstartPassive"])
        ]);
      };
    }
  }));
  var InputNumberUnit_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$2g = { class: "znpb-input-number-unit" };
  const _sfc_main$2X = /* @__PURE__ */ Vue.defineComponent({
    __name: "InputNumberUnit",
    props: {
      modelValue: { default: "" },
      min: { default: -Infinity },
      max: { default: Infinity },
      step: { default: 1 },
      shift_step: { default: 5 },
      placeholder: { default: "" },
      default_unit: { default: "" }
    },
    emits: ["update:modelValue", "linked-value"],
    setup(__props, { emit }) {
      const props = __props;
      let mouseDownPositionTop = 0;
      let draggingPositionTop = 0;
      let dragThreshold = 3;
      let shiftDrag = false;
      let toTop = false;
      let directionReset = 0;
      let draggingCached = 0;
      let dragging = false;
      const dragNumberThrottle = rafSchd$1(dragNumber);
      const computedValueUnit = Vue.computed(() => {
        return getIntegerAndUnit(props.modelValue);
      });
      const computedIntegerValue = Vue.computed({
        get() {
          return computedValueUnit.value.value !== null ? computedValueUnit.value.value : 0;
        },
        set(newValue) {
          computedStringValue.value = `${newValue}${computedUnitValue.value}`;
        }
      });
      const computedUnitValue = Vue.computed(() => computedValueUnit.value.unit !== null ? computedValueUnit.value.unit : "");
      const computedStringValue = Vue.computed({
        get() {
          return props.modelValue ? props.modelValue : "";
        },
        set(newValue) {
          const integerAndUnit = getIntegerAndUnit(newValue);
          const value = integerAndUnit.value !== null ? getValueInRange(integerAndUnit.value) : "";
          const unit = integerAndUnit.unit !== null ? integerAndUnit.unit : "";
          if (value !== "" || unit !== "") {
            emit("update:modelValue", `${value}${unit}`);
          } else {
            emit("update:modelValue", newValue);
          }
        }
      });
      function getValueInRange(value) {
        return Math.max(props.min, Math.min(props.max, value));
      }
      function getIntegerAndUnit(string) {
        const match = typeof string === "string" && string ? string.match(/^([+-]?[0-9]+([.][0-9]*)?|[.][0-9]+)(\D+)?$/) : null;
        const value = match && match[1] ? parseInt(match[1]) : null;
        const unit = match && match[3] ? match[3] : null;
        return {
          value,
          unit
        };
      }
      function actNumberDrag(event2) {
        dragging = true;
        draggingCached = computedIntegerValue.value;
        mouseDownPositionTop = event2.clientY;
        if (!canUpdateNumber()) {
          return;
        }
        document.body.style.userSelect = "none";
        window.addEventListener("mousemove", dragNumberThrottle);
        window.addEventListener("mouseup", deactivateDragNumber);
      }
      function canUpdateNumber() {
        const integerAndUnit = getIntegerAndUnit(computedStringValue.value);
        return computedStringValue.value === "" || integerAndUnit.value !== null;
      }
      function onKeyDown(event2) {
        if (event2.altKey) {
          event2.preventDefault();
          emit("linked-value");
        }
        shiftDrag = event2.shiftKey;
        if (!canUpdateNumber()) {
          return;
        }
        if (event2.key === "ArrowUp" || event2.key === "ArrowDown") {
          toTop = event2.key === "ArrowUp";
          setDraggingValue(true);
          event2.preventDefault();
        }
      }
      function deactivateDragNumber() {
        dragNumberThrottle.cancel();
        dragging = false;
        document.body.style.userSelect = "";
        document.body.style.pointerEvents = "";
        window.removeEventListener("mousemove", dragNumberThrottle);
      }
      function removeEvents() {
        deactivateDragNumber();
        window.removeEventListener("mouseup", deactivateDragNumber);
      }
      function dragNumber(event2) {
        const pageY = event2.pageY;
        shiftDrag = event2.shiftKey;
        draggingPositionTop = event2.clientY;
        if (Math.abs(mouseDownPositionTop - draggingPositionTop) > dragThreshold) {
          if (pageY < directionReset) {
            toTop = true;
          } else {
            toTop = false;
          }
          document.body.style.pointerEvents = "none";
          if (pageY !== directionReset) {
            setDraggingValue(true);
          }
        }
        directionReset = event2.pageY;
      }
      function setDraggingValue(addUnit = false) {
        let newValue;
        if (dragging) {
          const dragged = mouseDownPositionTop - dragThreshold - draggingPositionTop;
          newValue = draggingCached + dragged;
          if (shiftDrag) {
            newValue = newValue % props.shift_step ? Math.ceil(newValue / props.shift_step) * props.shift_step : newValue;
          }
        } else {
          let increment = 1;
          if (shiftDrag) {
            increment = toTop ? props.shift_step : -props.shift_step;
          } else {
            increment = toTop ? props.step : -props.step;
          }
          newValue = computedIntegerValue.value + increment;
          if (shiftDrag) {
            newValue = newValue % props.shift_step ? Math.ceil(newValue / props.shift_step) * props.shift_step : newValue;
            if (toTop && computedIntegerValue.value % props.shift_step !== 0) {
              newValue -= props.shift_step;
            }
          }
        }
        if (addUnit && props.default_unit.length > 0) {
          computedStringValue.value = `${getValueInRange(newValue)}${props.default_unit}`;
        } else {
          computedIntegerValue.value = getValueInRange(newValue);
        }
      }
      Vue.onBeforeMount(() => {
        removeEvents();
      });
      Vue.onMounted(() => {
        window.removeEventListener("mousemove", dragNumberThrottle);
      });
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$2g, [
          Vue.createVNode(_sfc_main$31, {
            ref: "numberUnitInput",
            modelValue: Vue.unref(computedStringValue),
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => Vue.isRef(computedStringValue) ? computedStringValue.value = $event : null),
            class: "znpb-input-number--has-units",
            size: "narrow",
            placeholder: __props.placeholder,
            onMousedown: Vue.withModifiers(actNumberDrag, ["stop"]),
            onTouchstartPassive: Vue.withModifiers(actNumberDrag, ["prevent"]),
            onMouseup: deactivateDragNumber,
            onKeydown: onKeyDown
          }, null, 8, ["modelValue", "placeholder", "onMousedown", "onTouchstartPassive"])
        ]);
      };
    }
  });
  var InputLabel_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$2f = {
    key: 0,
    class: "znpb-form-label-content"
  };
  const _hoisted_2$1u = { key: 1 };
  const __default__$11 = {
    name: "InputLabel"
  };
  const _sfc_main$2W = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$11), {
    props: {
      label: null,
      align: { default: "center" },
      position: { default: "bottom" },
      icon: null
    },
    setup(__props) {
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("label", {
          class: Vue.normalizeClass(["znpb-form-label", {
            [`znpb-form-label--${__props.align}`]: __props.align,
            [`znpb-form-label--position-${__props.position}`]: __props.position
          }])
        }, [
          Vue.renderSlot(_ctx.$slots, "default"),
          _ctx.$slots.label || __props.label || __props.icon ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$2f, [
            __props.icon ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$34), {
              key: 0,
              icon: __props.icon
            }, null, 8, ["icon"])) : Vue.createCommentVNode("", true),
            !_ctx.$slots.label ? (Vue.openBlock(), Vue.createElementBlock("h4", _hoisted_2$1u, Vue.toDisplayString(__props.label), 1)) : Vue.createCommentVNode("", true),
            Vue.renderSlot(_ctx.$slots, "label")
          ])) : Vue.createCommentVNode("", true)
        ], 2);
      };
    }
  }));
  var RgbaElement_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$2e = { class: "znpb-colorpicker-inner-editor-rgba" };
  const _sfc_main$2V = /* @__PURE__ */ Vue.defineComponent({
    __name: "RgbaElement",
    props: {
      modelValue: null
    },
    emits: ["update:modelValue"],
    setup(__props, { emit }) {
      const props = __props;
      function updateValue(property2, newValue) {
        emit("update:modelValue", __spreadProps(__spreadValues({}, props.modelValue), {
          [property2]: newValue
        }));
      }
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$2e, [
          Vue.createVNode(Vue.unref(_sfc_main$2W), null, {
            default: Vue.withCtx(() => {
              var _a3;
              return [
                Vue.createVNode(Vue.unref(_sfc_main$2Y), {
                  modelValue: (_a3 = __props.modelValue) == null ? void 0 : _a3.r,
                  min: 0,
                  max: 255,
                  step: 1,
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => updateValue("r", $event))
                }, null, 8, ["modelValue"]),
                Vue.createTextVNode(" R ")
              ];
            }),
            _: 1
          }),
          Vue.createVNode(Vue.unref(_sfc_main$2W), null, {
            default: Vue.withCtx(() => {
              var _a3;
              return [
                Vue.createVNode(Vue.unref(_sfc_main$2Y), {
                  modelValue: (_a3 = __props.modelValue) == null ? void 0 : _a3.g,
                  min: 0,
                  max: 255,
                  step: 1,
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => updateValue("g", $event))
                }, null, 8, ["modelValue"]),
                Vue.createTextVNode(" G ")
              ];
            }),
            _: 1
          }),
          Vue.createVNode(Vue.unref(_sfc_main$2W), null, {
            default: Vue.withCtx(() => {
              var _a3;
              return [
                Vue.createVNode(Vue.unref(_sfc_main$2Y), {
                  modelValue: (_a3 = __props.modelValue) == null ? void 0 : _a3.b,
                  min: 0,
                  max: 255,
                  step: 1,
                  "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => updateValue("b", $event))
                }, null, 8, ["modelValue"]),
                Vue.createTextVNode(" B ")
              ];
            }),
            _: 1
          }),
          Vue.createVNode(Vue.unref(_sfc_main$2W), null, {
            default: Vue.withCtx(() => {
              var _a3;
              return [
                Vue.createVNode(Vue.unref(_sfc_main$2Y), {
                  modelValue: (_a3 = __props.modelValue) == null ? void 0 : _a3.a,
                  min: 0,
                  max: 1,
                  step: 0.01,
                  "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => updateValue("a", $event))
                }, null, 8, ["modelValue", "step"]),
                Vue.createTextVNode(" A ")
              ];
            }),
            _: 1
          })
        ]);
      };
    }
  });
  var HslaElement_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$2d = { class: "znpb-colorpicker-inner-editor-hsla" };
  const _hoisted_2$1t = /* @__PURE__ */ Vue.createElementVNode("span", { class: "znpb-colorpicker-inner-editor__number-unit" }, "%", -1);
  const _hoisted_3$$ = /* @__PURE__ */ Vue.createElementVNode("span", { class: "znpb-colorpicker-inner-editor__number-unit" }, "%", -1);
  const _sfc_main$2U = /* @__PURE__ */ Vue.defineComponent({
    __name: "HslaElement",
    props: {
      modelValue: null
    },
    emits: ["update:modelValue"],
    setup(__props, { emit }) {
      const props = __props;
      const hsla = Vue.computed(() => {
        const { h, s, l, a } = props.modelValue;
        return {
          h: Number(h.toFixed()),
          s: Number((s * 100).toFixed()),
          l: Number((l * 100).toFixed()),
          a
        };
      });
      function updateHex(property2, newValue) {
        const value = property2 === "s" || property2 === "l" ? newValue / 100 : newValue;
        emit("update:modelValue", __spreadProps(__spreadValues({}, props.modelValue), {
          [property2]: value
        }));
      }
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$2d, [
          Vue.createVNode(Vue.unref(_sfc_main$2W), null, {
            default: Vue.withCtx(() => [
              Vue.createVNode(Vue.unref(_sfc_main$2Y), {
                modelValue: Vue.unref(hsla).h,
                min: 0,
                max: 360,
                step: 1,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => updateHex("h", $event))
              }, null, 8, ["modelValue"]),
              Vue.createTextVNode(" H ")
            ]),
            _: 1
          }),
          Vue.createVNode(Vue.unref(_sfc_main$2W), { class: "znpb-colorpicker-inner-editor__number--has-percentage" }, {
            default: Vue.withCtx(() => [
              Vue.createVNode(Vue.unref(_sfc_main$2Y), {
                modelValue: Vue.unref(hsla).s,
                "onUpdate:modelValue": [
                  _cache[1] || (_cache[1] = ($event) => Vue.unref(hsla).s = $event),
                  _cache[2] || (_cache[2] = ($event) => updateHex("s", $event))
                ],
                min: 0,
                max: 100,
                step: 1
              }, {
                default: Vue.withCtx(() => [
                  _hoisted_2$1t
                ]),
                _: 1
              }, 8, ["modelValue"]),
              Vue.createTextVNode(" S ")
            ]),
            _: 1
          }),
          Vue.createVNode(Vue.unref(_sfc_main$2W), { class: "znpb-colorpicker-inner-editor__number--has-percentage" }, {
            default: Vue.withCtx(() => [
              Vue.createVNode(Vue.unref(_sfc_main$2Y), {
                modelValue: Vue.unref(hsla).l,
                "onUpdate:modelValue": [
                  _cache[3] || (_cache[3] = ($event) => Vue.unref(hsla).l = $event),
                  _cache[4] || (_cache[4] = ($event) => updateHex("l", $event))
                ],
                min: 0,
                max: 100,
                step: 1
              }, {
                default: Vue.withCtx(() => [
                  _hoisted_3$$
                ]),
                _: 1
              }, 8, ["modelValue"]),
              Vue.createTextVNode(" L ")
            ]),
            _: 1
          }),
          Vue.createVNode(Vue.unref(_sfc_main$2W), null, {
            default: Vue.withCtx(() => [
              Vue.createVNode(Vue.unref(_sfc_main$2Y), {
                modelValue: Vue.unref(hsla).a,
                "onUpdate:modelValue": [
                  _cache[5] || (_cache[5] = ($event) => Vue.unref(hsla).a = $event),
                  _cache[6] || (_cache[6] = ($event) => updateHex("a", $event))
                ],
                min: 0,
                max: 1,
                step: 0.01
              }, null, 8, ["modelValue", "step"]),
              Vue.createTextVNode(" A ")
            ]),
            _: 1
          })
        ]);
      };
    }
  });
  var HexElement_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$2c = { class: "znpb-colorpicker-inner-editor-hex" };
  const _sfc_main$2T = /* @__PURE__ */ Vue.defineComponent({
    __name: "HexElement",
    props: {
      modelValue: null
    },
    emits: ["update:modelValue"],
    setup(__props, { emit }) {
      const props = __props;
      const hexValue = Vue.computed({
        get() {
          return props.modelValue;
        },
        set(newValue) {
          emit("update:modelValue", newValue);
        }
      });
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$2c, [
          Vue.createVNode(Vue.unref(_sfc_main$2W), null, {
            default: Vue.withCtx(() => [
              Vue.createVNode(_sfc_main$31, {
                modelValue: Vue.unref(hexValue),
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => Vue.isRef(hexValue) ? hexValue.value = $event : null),
                class: "znpb-form-colorpicker__input-text"
              }, null, 8, ["modelValue"]),
              Vue.createTextVNode(" HEX ")
            ]),
            _: 1
          })
        ]);
      };
    }
  });
  var PanelHex_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$2b = { class: "znpb-colorpicker-inner-editor" };
  const _hoisted_2$1s = { class: "znpb-colorpicker-inner-editor__colors" };
  const _hoisted_3$_ = { class: "znpb-colorpicker-inner-editor__current-color" };
  const _hoisted_4$D = { class: "znpb-colorpicker-circle znpb-colorpicker-circle--opacity" };
  const _hoisted_5$u = { class: "znpb-colorpicker-inner-editor__stripes" };
  const _hoisted_6$l = { class: "znpb-colorpicker-inner-editor__rgba" };
  const _hoisted_7$f = { class: "znpb-color-picker-change-color znpb-input-number-arrow-wrapper" };
  const _sfc_main$2S = /* @__PURE__ */ Vue.defineComponent({
    __name: "PanelHex",
    props: {
      modelValue: null
    },
    emits: ["update:modelValue", "update:format"],
    setup(__props, { emit }) {
      const props = __props;
      const { isSupported, open: open2, sRGBHex } = useEyeDropper();
      function openEyeDropper() {
        return __async(this, null, function* () {
          let result;
          try {
            result = yield open2();
          } catch (error) {
          }
          if (result) {
            emit("update:modelValue", result.sRGBHex);
          }
        });
      }
      const hexValue = Vue.computed({
        get() {
          return props.modelValue.format === "hex8" ? props.modelValue.hex8 : props.modelValue.hex;
        },
        set(newValue) {
          emit("update:modelValue", newValue);
        }
      });
      const hslaValue = Vue.computed({
        get() {
          return props.modelValue.hsla;
        },
        set(hsla) {
          emit("update:modelValue", hsla);
        }
      });
      const rgbaValue = Vue.computed({
        get() {
          return props.modelValue.rgba;
        },
        set(rgba) {
          emit("update:modelValue", rgba);
        }
      });
      function changeHex() {
        if (props.modelValue.format === "hex" || props.modelValue.format === "hex8" || props.modelValue.format === "name") {
          emit("update:modelValue", props.modelValue.hsla);
        } else if (props.modelValue.format === "hsl") {
          emit("update:modelValue", props.modelValue.rgba);
        } else if (props.modelValue.format === "rgb") {
          emit("update:modelValue", props.modelValue.hex);
        }
      }
      function changeHexback() {
        if (props.modelValue.format === "hsl") {
          emit("update:modelValue", props.modelValue.hex);
        } else if (props.modelValue.format === "rgb") {
          emit("update:modelValue", props.modelValue.hsla);
        } else if (props.modelValue.format === "hex" || props.modelValue.format === "hex8" || props.modelValue.format === "name") {
          emit("update:modelValue", props.modelValue.rgba);
        }
      }
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$2b, [
          Vue.createElementVNode("div", _hoisted_2$1s, [
            Vue.createElementVNode("div", _hoisted_3$_, [
              Vue.createElementVNode("span", _hoisted_4$D, [
                Vue.createElementVNode("span", {
                  style: Vue.normalizeStyle({ backgroundColor: __props.modelValue.hex8 }),
                  class: "znpb-colorpicker-circle znpb-colorpicker-circle-color"
                }, null, 4)
              ])
            ]),
            Vue.createElementVNode("div", _hoisted_5$u, [
              Vue.createVNode(_sfc_main$2_, {
                modelValue: Vue.unref(hslaValue),
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => Vue.isRef(hslaValue) ? hslaValue.value = $event : null)
              }, null, 8, ["modelValue"]),
              Vue.createVNode(_sfc_main$2Z, {
                modelValue: Vue.unref(hslaValue),
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => Vue.isRef(hslaValue) ? hslaValue.value = $event : null)
              }, null, 8, ["modelValue"])
            ])
          ]),
          Vue.createElementVNode("div", _hoisted_6$l, [
            Vue.unref(isSupported) ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$34), {
              key: 0,
              icon: "eyedropper",
              class: "znpb-eyedropper",
              onClick: openEyeDropper
            })) : Vue.createCommentVNode("", true),
            __props.modelValue.format === "rgb" ? (Vue.openBlock(), Vue.createBlock(_sfc_main$2V, {
              key: 1,
              modelValue: Vue.unref(rgbaValue),
              "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => Vue.isRef(rgbaValue) ? rgbaValue.value = $event : null)
            }, null, 8, ["modelValue"])) : Vue.createCommentVNode("", true),
            __props.modelValue.format === "hsl" ? (Vue.openBlock(), Vue.createBlock(_sfc_main$2U, {
              key: 2,
              modelValue: Vue.unref(hslaValue),
              "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => Vue.isRef(hslaValue) ? hslaValue.value = $event : null)
            }, null, 8, ["modelValue"])) : Vue.createCommentVNode("", true),
            __props.modelValue.format === "hex" || __props.modelValue.format === "hex8" || __props.modelValue.format === "name" ? (Vue.openBlock(), Vue.createBlock(_sfc_main$2T, {
              key: 3,
              modelValue: Vue.unref(hexValue),
              "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => Vue.isRef(hexValue) ? hexValue.value = $event : null)
            }, null, 8, ["modelValue"])) : Vue.createCommentVNode("", true),
            Vue.createElementVNode("div", _hoisted_7$f, [
              Vue.createVNode(Vue.unref(_sfc_main$34), {
                icon: "select",
                rotate: 180,
                class: "znpb-arrow-increment",
                onClick: changeHex
              }),
              Vue.createVNode(Vue.unref(_sfc_main$34), {
                icon: "select",
                class: "znpb-arrow-decrement",
                onClick: changeHexback
              })
            ])
          ])
        ]);
      };
    }
  });
  var ColorBoard_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$2a = { class: "znpb-form-colorPicker-saturation__white" };
  const _hoisted_2$1r = { class: "znpb-form-colorPicker-saturation__black" };
  const _sfc_main$2R = /* @__PURE__ */ Vue.defineComponent({
    __name: "ColorBoard",
    props: {
      colorObject: null
    },
    emits: ["update:color-object"],
    setup(__props, { emit }) {
      const props = __props;
      const isDragging = Vue.ref(false);
      const root2 = Vue.ref(null);
      const boardContent = Vue.ref(null);
      let ownerWindow;
      const computedColorObject = Vue.computed({
        get() {
          return props.colorObject;
        },
        set(newValue) {
          emit("update:color-object", newValue);
        }
      });
      const pointStyles = Vue.computed(() => {
        const { v, s } = props.colorObject.hsva;
        const cssStyles = {
          top: 100 - v * 100 + "%",
          left: s * 100 + "%"
        };
        return cssStyles;
      });
      const bgColor = Vue.computed(() => {
        const { h } = props.colorObject.hsva;
        return `hsl(${h}, 100%, 50%)`;
      });
      const boardRect = Vue.computed(() => {
        return boardContent.value.getBoundingClientRect();
      });
      const rafDragCircle = rafSchd$1(dragCircle);
      function initiateDrag(event2) {
        isDragging.value = true;
        let { clientX, clientY } = event2;
        ownerWindow.addEventListener("mousemove", rafDragCircle);
        ownerWindow.addEventListener("mouseup", deactivateDragCircle, true);
        const newTop = clientY - boardRect.value.top;
        const newLeft = clientX - boardRect.value.left;
        let bright = 100 - newTop / boardRect.value.height * 100;
        let saturation = newLeft * 100 / boardRect.value.width;
        let newColor = __spreadProps(__spreadValues({}, props.colorObject.hsva), {
          v: bright / 100,
          s: saturation / 100
        });
        computedColorObject.value = newColor;
      }
      function deactivateDragCircle() {
        ownerWindow.removeEventListener("mousemove", rafDragCircle);
        ownerWindow.removeEventListener("mouseup", deactivateDragCircle, true);
        function preventClicks(e) {
          e.stopPropagation();
        }
        ownerWindow.addEventListener("click", preventClicks, true);
        setTimeout(() => {
          ownerWindow.removeEventListener("click", preventClicks, true);
        }, 100);
      }
      function dragCircle(event2) {
        if (!event2.which) {
          deactivateDragCircle();
          return false;
        }
        let { clientX, clientY } = event2;
        let newLeft = clientX - boardRect.value.left;
        if (newLeft > boardRect.value.width) {
          newLeft = boardRect.value.width;
        } else if (newLeft < 0) {
          newLeft = 0;
        }
        let newTop = clientY - boardRect.value.top;
        if (newTop >= boardRect.value.height) {
          newTop = boardRect.value.height;
        } else if (newTop < 0) {
          newTop = 0;
        }
        const bright = 100 - newTop / boardRect.value.height * 100;
        const saturation = newLeft * 100 / boardRect.value.width;
        let newColor = __spreadProps(__spreadValues({}, props.colorObject.hsva), {
          v: bright / 100,
          s: saturation / 100
        });
        computedColorObject.value = newColor;
      }
      Vue.onMounted(() => {
        ownerWindow = root2.value.ownerDocument.defaultView;
        root2.value.ownerDocument.body.classList.add("znpb-color-picker--backdrop");
      });
      Vue.onBeforeUnmount(() => {
        root2.value.ownerDocument.body.classList.remove("znpb-color-picker--backdrop");
        deactivateDragCircle();
      });
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", {
          ref_key: "root",
          ref: root2,
          class: "znpb-form-colorPicker-saturation"
        }, [
          Vue.createElementVNode("div", {
            ref_key: "boardContent",
            ref: boardContent,
            style: Vue.normalizeStyle({ background: Vue.unref(bgColor) }),
            class: "znpb-form-colorPicker-saturation__color",
            onMousedown: initiateDrag,
            onMouseup: deactivateDragCircle
          }, [
            Vue.createElementVNode("div", _hoisted_1$2a, [
              Vue.createElementVNode("div", _hoisted_2$1r, [
                Vue.createElementVNode("div", {
                  style: Vue.normalizeStyle(Vue.unref(pointStyles)),
                  class: "znpb-color-picker-pointer"
                }, null, 4)
              ])
            ])
          ], 36)
        ], 512);
      };
    }
  });
  var Colorpicker_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$29 = { class: "znpb-form-colorpicker-inner__panel" };
  const __default__$10 = {
    name: "ColorPicker",
    inheritAttrs: false
  };
  const _sfc_main$2Q = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$10), {
    props: {
      model: { default: "" },
      showLibrary: { type: Boolean, default: true },
      zIndex: null
    },
    emits: ["color-changed"],
    setup(__props, { emit }) {
      const props = __props;
      const computedModelValue = Vue.computed({
        get() {
          return props.model;
        },
        set(newValue) {
          if (newValue) {
            emit("color-changed", newValue);
          } else {
            emit("color-changed", "");
          }
        }
      });
      const computedColorObject = Vue.computed({
        get() {
          return getColorObject(props.model);
        },
        set(newValue) {
          const colorObject = tinycolor(newValue);
          const format = colorObject.getFormat();
          let emittedColor;
          if (colorObject.isValid()) {
            if (format === "hsl") {
              emittedColor = colorObject.toHslString();
            } else if (format === "rgb" || format === "hsv") {
              emittedColor = colorObject.toRgbString();
            } else if (format === "hex" || format === "hex8") {
              emittedColor = colorObject.getAlpha() < 1 ? colorObject.toHex8String() : colorObject.toHexString();
            } else if (format === "name") {
              emittedColor = newValue;
            }
          } else {
            emittedColor = newValue;
          }
          computedModelValue.value = emittedColor;
        }
      });
      const pickerStyle = Vue.computed(() => {
        if (props.appendTo) {
          return {
            zIndex: props.zIndex
          };
        }
        return {};
      });
      function getColorObject(model) {
        const colorObject = tinycolor(model);
        let hsva = {
          h: 0,
          s: 0,
          v: 0,
          a: 1
        };
        let hsla = {
          h: 0,
          s: 0,
          l: 0,
          a: 1
        };
        let hex8 = "";
        let rgba = "";
        let hex = model ? model : "";
        let format = "hex";
        if (colorObject.isValid()) {
          format = colorObject.getFormat();
          hsva = colorObject.toHsv();
          hsla = colorObject.toHsl();
          hex = format === "name" ? model : colorObject.toHexString();
          hex8 = colorObject.toHex8String();
          rgba = colorObject.toRgb();
        }
        return {
          hex,
          hex8,
          rgba,
          hsla,
          hsva,
          format
        };
      }
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", {
          ref: "colorPicker",
          class: Vue.normalizeClass(["znpb-form-colorpicker__color-picker-holder", { ["color-picker-holder--has-library"]: __props.showLibrary }]),
          style: Vue.normalizeStyle(Vue.unref(pickerStyle))
        }, [
          Vue.createVNode(_sfc_main$2R, {
            "color-object": Vue.unref(computedColorObject),
            "onUpdate:color-object": _cache[0] || (_cache[0] = ($event) => Vue.isRef(computedColorObject) ? computedColorObject.value = $event : null)
          }, null, 8, ["color-object"]),
          Vue.createElementVNode("div", _hoisted_1$29, [
            Vue.createVNode(_sfc_main$2S, {
              "model-value": Vue.unref(computedColorObject),
              "onUpdate:model-value": _cache[1] || (_cache[1] = ($event) => Vue.isRef(computedColorObject) ? computedColorObject.value = $event : null)
            }, null, 8, ["model-value"]),
            Vue.renderSlot(_ctx.$slots, "end")
          ])
        ], 6);
      };
    }
  }));
  var EmptyList_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$28 = /* @__PURE__ */ Vue.createElementVNode("div", { class: "znpb-empty-list__border-top-bottom" }, null, -1);
  const _hoisted_2$1q = /* @__PURE__ */ Vue.createElementVNode("div", { class: "znpb-empty-list__border-left-right" }, null, -1);
  const _hoisted_3$Z = { class: "znpb-empty-list__content" };
  const __default__$$ = {
    name: "EmptyList"
  };
  const _sfc_main$2P = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$$), {
    props: {
      noMargin: { type: Boolean, default: false }
    },
    setup(__props) {
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", {
          class: Vue.normalizeClass(["znpb-empty-list__container", { "znpb-empty-list__container--no-margin": __props.noMargin }])
        }, [
          _hoisted_1$28,
          _hoisted_2$1q,
          Vue.createElementVNode("div", _hoisted_3$Z, [
            Vue.renderSlot(_ctx.$slots, "default")
          ])
        ], 2);
      };
    }
  }));
  var GradientPreview_vue_vue_type_style_index_0_lang = "";
  const __default__$_ = {
    name: "GradientPreview"
  };
  const _sfc_main$2O = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$_), {
    props: {
      config: null,
      round: { type: Boolean }
    },
    setup(__props) {
      const props = __props;
      const filteredConfig = Vue.computed(() => {
        const { applyFilters: applyFilters2 } = window.zb.hooks;
        return applyFilters2("zionbuilder/options/model", JSON.parse(JSON.stringify(props.config)));
      });
      const getGradientPreviewStyle = Vue.computed(() => {
        const style = {};
        const gradient = [];
        filteredConfig.value.forEach((element) => {
          const colors = [];
          let position = "90deg";
          const colorsCopy = [...element.colors].sort((a, b) => {
            return a.position > b.position ? 1 : -1;
          });
          colorsCopy.forEach((color) => {
            colors.push(`${color.color} ${color.position}%`);
          });
          if (element.type === "radial") {
            const { x, y } = element.position || { x: 50, y: 50 };
            position = `circle at ${x}% ${y}%`;
          } else {
            position = `${element.angle}deg`;
          }
          gradient.push(`${element.type}-gradient(${position}, ${colors.join(", ")})`);
        });
        gradient.reverse();
        style["background-image"] = gradient.join(", ");
        return style;
      });
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", {
          class: Vue.normalizeClass(["znpb-gradient-preview-transparent", { "gradient-type-rounded": __props.round }])
        }, [
          Vue.createElementVNode("div", {
            class: Vue.normalizeClass(["znpb-gradient-preview", { "gradient-type-rounded": __props.round }]),
            style: Vue.normalizeStyle(Vue.unref(getGradientPreviewStyle))
          }, null, 6)
        ], 2);
      };
    }
  }));
  function getIconUnicode(unicodeValue) {
    return JSON.parse('"\\' + unicodeValue + '"');
  }
  function getIconAttributes(iconConfig) {
    const valueToReturn = {};
    if (iconConfig && iconConfig.family) {
      valueToReturn["data-znpbiconfam"] = iconConfig.family;
      valueToReturn["data-znpbicon"] = getIconUnicode(iconConfig.unicode);
    }
    return valueToReturn;
  }
  function getLinkAttributes(linkConfig) {
    const valueToReturn = {};
    if (linkConfig && linkConfig.link) {
      valueToReturn.href = linkConfig.link;
      if (linkConfig.title) {
        valueToReturn.title = linkConfig.title;
      }
      if (linkConfig.target) {
        valueToReturn.target = linkConfig.target;
      }
      if (Array.isArray(linkConfig.attributes)) {
        linkConfig.attributes.forEach((attributeConfig) => {
          if (typeof attributeConfig.key !== "undefined" && attributeConfig.key.length > 0) {
            valueToReturn[attributeConfig.key] = attributeConfig.value;
          }
        });
      }
    }
    return valueToReturn;
  }
  var md5 = { exports: {} };
  var core = { exports: {} };
  (function(module2, exports2) {
    (function(root2, factory) {
      {
        module2.exports = factory();
      }
    })(commonjsGlobal, function() {
      var CryptoJS = CryptoJS || function(Math2, undefined$1) {
        var crypto;
        if (typeof window !== "undefined" && window.crypto) {
          crypto = window.crypto;
        }
        if (typeof self !== "undefined" && self.crypto) {
          crypto = self.crypto;
        }
        if (typeof globalThis !== "undefined" && globalThis.crypto) {
          crypto = globalThis.crypto;
        }
        if (!crypto && typeof window !== "undefined" && window.msCrypto) {
          crypto = window.msCrypto;
        }
        if (!crypto && typeof commonjsGlobal !== "undefined" && commonjsGlobal.crypto) {
          crypto = commonjsGlobal.crypto;
        }
        if (!crypto && typeof commonjsRequire === "function") {
          try {
            crypto = require("crypto");
          } catch (err) {
          }
        }
        var cryptoSecureRandomInt = function() {
          if (crypto) {
            if (typeof crypto.getRandomValues === "function") {
              try {
                return crypto.getRandomValues(new Uint32Array(1))[0];
              } catch (err) {
              }
            }
            if (typeof crypto.randomBytes === "function") {
              try {
                return crypto.randomBytes(4).readInt32LE();
              } catch (err) {
              }
            }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        };
        var create = Object.create || function() {
          function F() {
          }
          return function(obj) {
            var subtype;
            F.prototype = obj;
            subtype = new F();
            F.prototype = null;
            return subtype;
          };
        }();
        var C = {};
        var C_lib = C.lib = {};
        var Base = C_lib.Base = function() {
          return {
            extend: function(overrides) {
              var subtype = create(this);
              if (overrides) {
                subtype.mixIn(overrides);
              }
              if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                subtype.init = function() {
                  subtype.$super.init.apply(this, arguments);
                };
              }
              subtype.init.prototype = subtype;
              subtype.$super = this;
              return subtype;
            },
            create: function() {
              var instance2 = this.extend();
              instance2.init.apply(instance2, arguments);
              return instance2;
            },
            init: function() {
            },
            mixIn: function(properties) {
              for (var propertyName in properties) {
                if (properties.hasOwnProperty(propertyName)) {
                  this[propertyName] = properties[propertyName];
                }
              }
              if (properties.hasOwnProperty("toString")) {
                this.toString = properties.toString;
              }
            },
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }();
        var WordArray = C_lib.WordArray = Base.extend({
          init: function(words2, sigBytes) {
            words2 = this.words = words2 || [];
            if (sigBytes != undefined$1) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words2.length * 4;
            }
          },
          toString: function(encoder) {
            return (encoder || Hex).stringify(this);
          },
          concat: function(wordArray) {
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;
            this.clamp();
            if (thisSigBytes % 4) {
              for (var i = 0; i < thatSigBytes; i++) {
                var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
              }
            } else {
              for (var j = 0; j < thatSigBytes; j += 4) {
                thisWords[thisSigBytes + j >>> 2] = thatWords[j >>> 2];
              }
            }
            this.sigBytes += thatSigBytes;
            return this;
          },
          clamp: function() {
            var words2 = this.words;
            var sigBytes = this.sigBytes;
            words2[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
            words2.length = Math2.ceil(sigBytes / 4);
          },
          clone: function() {
            var clone = Base.clone.call(this);
            clone.words = this.words.slice(0);
            return clone;
          },
          random: function(nBytes) {
            var words2 = [];
            for (var i = 0; i < nBytes; i += 4) {
              words2.push(cryptoSecureRandomInt());
            }
            return new WordArray.init(words2, nBytes);
          }
        });
        var C_enc = C.enc = {};
        var Hex = C_enc.Hex = {
          stringify: function(wordArray) {
            var words2 = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var hexChars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words2[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              hexChars.push((bite >>> 4).toString(16));
              hexChars.push((bite & 15).toString(16));
            }
            return hexChars.join("");
          },
          parse: function(hexStr) {
            var hexStrLength = hexStr.length;
            var words2 = [];
            for (var i = 0; i < hexStrLength; i += 2) {
              words2[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
            }
            return new WordArray.init(words2, hexStrLength / 2);
          }
        };
        var Latin1 = C_enc.Latin1 = {
          stringify: function(wordArray) {
            var words2 = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var latin1Chars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words2[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join("");
          },
          parse: function(latin1Str) {
            var latin1StrLength = latin1Str.length;
            var words2 = [];
            for (var i = 0; i < latin1StrLength; i++) {
              words2[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;
            }
            return new WordArray.init(words2, latin1StrLength);
          }
        };
        var Utf8 = C_enc.Utf8 = {
          stringify: function(wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e) {
              throw new Error("Malformed UTF-8 data");
            }
          },
          parse: function(utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
        };
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
          reset: function() {
            this._data = new WordArray.init();
            this._nDataBytes = 0;
          },
          _append: function(data2) {
            if (typeof data2 == "string") {
              data2 = Utf8.parse(data2);
            }
            this._data.concat(data2);
            this._nDataBytes += data2.sigBytes;
          },
          _process: function(doFlush) {
            var processedWords;
            var data2 = this._data;
            var dataWords = data2.words;
            var dataSigBytes = data2.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
              nBlocksReady = Math2.ceil(nBlocksReady);
            } else {
              nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }
            var nWordsReady = nBlocksReady * blockSize;
            var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
            if (nWordsReady) {
              for (var offset2 = 0; offset2 < nWordsReady; offset2 += blockSize) {
                this._doProcessBlock(dataWords, offset2);
              }
              processedWords = dataWords.splice(0, nWordsReady);
              data2.sigBytes -= nBytesReady;
            }
            return new WordArray.init(processedWords, nBytesReady);
          },
          clone: function() {
            var clone = Base.clone.call(this);
            clone._data = this._data.clone();
            return clone;
          },
          _minBufferSize: 0
        });
        C_lib.Hasher = BufferedBlockAlgorithm.extend({
          cfg: Base.extend(),
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
            this.reset();
          },
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          update: function(messageUpdate) {
            this._append(messageUpdate);
            this._process();
            return this;
          },
          finalize: function(messageUpdate) {
            if (messageUpdate) {
              this._append(messageUpdate);
            }
            var hash2 = this._doFinalize();
            return hash2;
          },
          blockSize: 512 / 32,
          _createHelper: function(hasher) {
            return function(message, cfg) {
              return new hasher.init(cfg).finalize(message);
            };
          },
          _createHmacHelper: function(hasher) {
            return function(message, key) {
              return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
          }
        });
        var C_algo = C.algo = {};
        return C;
      }(Math);
      return CryptoJS;
    });
  })(core);
  (function(module2, exports2) {
    (function(root2, factory) {
      {
        module2.exports = factory(core.exports);
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function(Math2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var T = [];
        (function() {
          for (var i = 0; i < 64; i++) {
            T[i] = Math2.abs(Math2.sin(i + 1)) * 4294967296 | 0;
          }
        })();
        var MD52 = C_algo.MD5 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878
            ]);
          },
          _doProcessBlock: function(M, offset2) {
            for (var i = 0; i < 16; i++) {
              var offset_i = offset2 + i;
              var M_offset_i = M[offset_i];
              M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H = this._hash.words;
            var M_offset_0 = M[offset2 + 0];
            var M_offset_1 = M[offset2 + 1];
            var M_offset_2 = M[offset2 + 2];
            var M_offset_3 = M[offset2 + 3];
            var M_offset_4 = M[offset2 + 4];
            var M_offset_5 = M[offset2 + 5];
            var M_offset_6 = M[offset2 + 6];
            var M_offset_7 = M[offset2 + 7];
            var M_offset_8 = M[offset2 + 8];
            var M_offset_9 = M[offset2 + 9];
            var M_offset_10 = M[offset2 + 10];
            var M_offset_11 = M[offset2 + 11];
            var M_offset_12 = M[offset2 + 12];
            var M_offset_13 = M[offset2 + 13];
            var M_offset_14 = M[offset2 + 14];
            var M_offset_15 = M[offset2 + 15];
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];
            a = FF(a, b, c, d, M_offset_0, 7, T[0]);
            d = FF(d, a, b, c, M_offset_1, 12, T[1]);
            c = FF(c, d, a, b, M_offset_2, 17, T[2]);
            b = FF(b, c, d, a, M_offset_3, 22, T[3]);
            a = FF(a, b, c, d, M_offset_4, 7, T[4]);
            d = FF(d, a, b, c, M_offset_5, 12, T[5]);
            c = FF(c, d, a, b, M_offset_6, 17, T[6]);
            b = FF(b, c, d, a, M_offset_7, 22, T[7]);
            a = FF(a, b, c, d, M_offset_8, 7, T[8]);
            d = FF(d, a, b, c, M_offset_9, 12, T[9]);
            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
            a = FF(a, b, c, d, M_offset_12, 7, T[12]);
            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
            b = FF(b, c, d, a, M_offset_15, 22, T[15]);
            a = GG(a, b, c, d, M_offset_1, 5, T[16]);
            d = GG(d, a, b, c, M_offset_6, 9, T[17]);
            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
            b = GG(b, c, d, a, M_offset_0, 20, T[19]);
            a = GG(a, b, c, d, M_offset_5, 5, T[20]);
            d = GG(d, a, b, c, M_offset_10, 9, T[21]);
            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
            b = GG(b, c, d, a, M_offset_4, 20, T[23]);
            a = GG(a, b, c, d, M_offset_9, 5, T[24]);
            d = GG(d, a, b, c, M_offset_14, 9, T[25]);
            c = GG(c, d, a, b, M_offset_3, 14, T[26]);
            b = GG(b, c, d, a, M_offset_8, 20, T[27]);
            a = GG(a, b, c, d, M_offset_13, 5, T[28]);
            d = GG(d, a, b, c, M_offset_2, 9, T[29]);
            c = GG(c, d, a, b, M_offset_7, 14, T[30]);
            b = GG(b, c, d, a, M_offset_12, 20, T[31]);
            a = HH(a, b, c, d, M_offset_5, 4, T[32]);
            d = HH(d, a, b, c, M_offset_8, 11, T[33]);
            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
            a = HH(a, b, c, d, M_offset_1, 4, T[36]);
            d = HH(d, a, b, c, M_offset_4, 11, T[37]);
            c = HH(c, d, a, b, M_offset_7, 16, T[38]);
            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
            a = HH(a, b, c, d, M_offset_13, 4, T[40]);
            d = HH(d, a, b, c, M_offset_0, 11, T[41]);
            c = HH(c, d, a, b, M_offset_3, 16, T[42]);
            b = HH(b, c, d, a, M_offset_6, 23, T[43]);
            a = HH(a, b, c, d, M_offset_9, 4, T[44]);
            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
            b = HH(b, c, d, a, M_offset_2, 23, T[47]);
            a = II(a, b, c, d, M_offset_0, 6, T[48]);
            d = II(d, a, b, c, M_offset_7, 10, T[49]);
            c = II(c, d, a, b, M_offset_14, 15, T[50]);
            b = II(b, c, d, a, M_offset_5, 21, T[51]);
            a = II(a, b, c, d, M_offset_12, 6, T[52]);
            d = II(d, a, b, c, M_offset_3, 10, T[53]);
            c = II(c, d, a, b, M_offset_10, 15, T[54]);
            b = II(b, c, d, a, M_offset_1, 21, T[55]);
            a = II(a, b, c, d, M_offset_8, 6, T[56]);
            d = II(d, a, b, c, M_offset_15, 10, T[57]);
            c = II(c, d, a, b, M_offset_6, 15, T[58]);
            b = II(b, c, d, a, M_offset_13, 21, T[59]);
            a = II(a, b, c, d, M_offset_4, 6, T[60]);
            d = II(d, a, b, c, M_offset_11, 10, T[61]);
            c = II(c, d, a, b, M_offset_2, 15, T[62]);
            b = II(b, c, d, a, M_offset_9, 21, T[63]);
            H[0] = H[0] + a | 0;
            H[1] = H[1] + b | 0;
            H[2] = H[2] + c | 0;
            H[3] = H[3] + d | 0;
          },
          _doFinalize: function() {
            var data2 = this._data;
            var dataWords = data2.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data2.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            var nBitsTotalH = Math2.floor(nBitsTotal / 4294967296);
            var nBitsTotalL = nBitsTotal;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 16711935 | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 4278255360;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 16711935 | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 4278255360;
            data2.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash2 = this._hash;
            var H = hash2.words;
            for (var i = 0; i < 4; i++) {
              var H_i = H[i];
              H[i] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash2;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        function FF(a, b, c, d, x, s, t) {
          var n = a + (b & c | ~b & d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        function GG(a, b, c, d, x, s, t) {
          var n = a + (b & d | c & ~d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        function HH(a, b, c, d, x, s, t) {
          var n = a + (b ^ c ^ d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        function II(a, b, c, d, x, s, t) {
          var n = a + (c ^ (b | ~d)) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        C.MD5 = Hasher._createHelper(MD52);
        C.HmacMD5 = Hasher._createHmacHelper(MD52);
      })(Math);
      return CryptoJS.MD5;
    });
  })(md5);
  var MD5 = md5.exports;
  function hash$2(object) {
    return MD5(JSON.stringify(object));
  }
  class ServerRequest {
    constructor() {
      this.queue = [];
      this.requestTimeout = 200;
      this.cache = {};
    }
    addToCache(id, result) {
      this.cache[id] = result;
    }
    getFromCache(cacheKey) {
      return this.cache[cacheKey];
    }
    isCached(cacheKey) {
      return typeof this.cache[cacheKey] !== "undefined";
    }
    request(data2, successCallback, failCallback) {
      const { applyFilters: applyFilters2 } = window.zb.hooks;
      const parsedData = applyFilters2("zionbuilder/server_request/data", data2);
      const rawData = JSON.parse(JSON.stringify(parsedData));
      const cacheKey = this.createCacheKey(rawData);
      if (data2.useCache && this.isCached(cacheKey)) {
        successCallback(this.getFromCache(cacheKey));
      } else {
        this.addToQueue(rawData, successCallback, failCallback);
        this.doQueue();
      }
    }
    createCacheKey(object) {
      return hash$2(object);
    }
    doQueue() {
      setTimeout(() => {
        const queueItems = {};
        const inProgress = [];
        if (this.queue.length === 0) {
          return;
        }
        this.queue.forEach((queueItem) => {
          queueItems[queueItem.key] = queueItem.data;
          inProgress.push(queueItem);
        });
        this.queue = [];
        bulkActions(queueItems).then(({ data: data2 }) => {
          inProgress.forEach((queueItem) => {
            if (typeof queueItem["successCallback"] === "function") {
              const { useCache } = queueItem.data;
              if (useCache) {
                this.addToCache(queueItem.key, data2[queueItem.key]);
              }
              queueItem["successCallback"](data2[queueItem.key]);
            }
          });
        }).catch(() => {
          inProgress.forEach((queueItem) => {
            if (typeof queueItem["failCallback"] === "function") {
              queueItem["failCallback"]();
            }
          });
        });
      }, this.requestTimeout);
    }
    addToQueue(data2, successCallback, failCallback) {
      const queueKey = this.createCacheKey(data2);
      this.queue.push({
        key: queueKey,
        data: data2,
        successCallback,
        failCallback
      });
    }
  }
  function getImage(imageConfig, serverRequester = new ServerRequest()) {
    return new Promise((resolve, reject) => {
      if (imageConfig && imageConfig.image && imageConfig.image_size && imageConfig.image_size !== "full") {
        let size = imageConfig.image_size;
        if (size === "custom") {
          const customSize = imageConfig.custom_size || {};
          let { width = 0, height = 0 } = customSize;
          width = width || 0;
          height = height || 0;
          size = `zion_custom_${width}x${height}`;
        }
        serverRequester.request(
          {
            type: "get_image",
            config: imageConfig,
            useCache: true
          },
          (response) => {
            resolve(response[size]);
          },
          function(message) {
            console.log("server Request fail", message);
            reject(new Error("image could not be retrieved"));
          }
        );
      } else if (imageConfig.image) {
        resolve(imageConfig.image);
      } else {
        reject(new Error("bad config for image", imageConfig));
      }
    });
  }
  function updateOptionValue(options2, path, newValue) {
    const newOptions = __spreadValues({}, options2);
    const pathArray = path.split(".");
    const pathLength = pathArray.length;
    let activeValue = newOptions;
    pathArray.forEach((pathItem, index2) => {
      if (index2 === pathLength - 1) {
        activeValue[pathItem] = newValue;
      } else {
        activeValue[pathItem] = __spreadValues({}, activeValue[pathItem]) || {};
      }
      activeValue = activeValue[pathItem];
    });
    return newOptions;
  }
  const generateUID = function(index2, lastDateInSeconds) {
    const startDate = new Date("2019");
    return function() {
      const d = new Date();
      const n = d - startDate;
      if (lastDateInSeconds === false) {
        lastDateInSeconds = n;
      }
      if (lastDateInSeconds !== n) {
        index2 = 0;
      }
      lastDateInSeconds = n;
      index2 += 1;
      return "uid" + n + index2;
    };
  }(0, false);
  function getCssFromSelector$1(selectors, styleConfig, args = {}) {
    console.warn("This was deprecated in favor of zb.editor.utill.getCssFromSelector");
    return window.zb.editor.utill.getCssFromSelector(selectors, styleConfig, args);
  }
  function getStyles$2(cssSelector, styleValues = {}, args) {
    console.warn("This was deprecated in favor of zb.editor.utill.getStyles");
    return window.zb.editor.utill.getStyles(cssSelector, styleValues, args);
  }
  function getPseudoStyles$1(cssSelector, pseudoSelectors2 = {}, args) {
    console.warn("This was deprecated in favor of zb.editor.utill.getPseudoStyles");
    return window.zb.editor.utill.getPseudoStyles(cssSelector, pseudoSelectors2, args);
  }
  function getResponsiveDeviceStyles$1(deviceId, styles) {
    console.warn("This was deprecated in favor of zb.editor.utill.getResponsiveDeviceStyles");
    return window.zb.editor.utill.getResponsiveDeviceStyles(deviceId, styles);
  }
  function compileStyleTabs$1(styleValues) {
    console.warn("This was deprecated in favor of zb.editor.utill.compileStyleTabs");
    return window.zb.editor.utill.compileStyleTabs(styleValues);
  }
  function getGradientCss$1(config) {
    console.warn("This was deprecated in favor of zb.editor.utill.getGradientCss");
    return window.zb.editor.utill.getGradientCss(config);
  }
  function compileFontTab$1(styleValues) {
    console.warn("This was deprecated in favor of zb.editor.utill.compileFontTab");
    return window.zb.editor.utill.compileFontTab(styleValues);
  }
  function isEditable(el = document.activeElement) {
    if (el && ~["input", "textarea"].indexOf(el.tagName.toLowerCase())) {
      return !el.readOnly && !el.disabled;
    }
    if (el && el.contentDocument) {
      return isEditable(el.contentDocument.activeElement);
    }
    return el.isContentEditable;
  }
  var Environment = {
    isMac: window.navigator.userAgent.indexOf("Macintosh") >= 0
  };
  const getDefaultGradient = () => {
    return [
      {
        type: "linear",
        angle: 114,
        colors: [
          {
            color: "#18208d",
            position: 0
          },
          {
            color: "#06bee1",
            position: 100
          }
        ],
        position: {
          x: 75,
          y: 48
        }
      }
    ];
  };
  var COMMONUTILS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    getIconUnicode,
    getIconAttributes,
    getLinkAttributes,
    getImage,
    Environment,
    updateOptionValue,
    generateUID,
    getCssFromSelector: getCssFromSelector$1,
    getStyles: getStyles$2,
    getPseudoStyles: getPseudoStyles$1,
    getResponsiveDeviceStyles: getResponsiveDeviceStyles$1,
    compileStyleTabs: compileStyleTabs$1,
    getGradientCss: getGradientCss$1,
    compileFontTab: compileFontTab$1,
    isEditable,
    ServerRequest,
    hash: hash$2,
    getDefaultGradient
  }, Symbol.toStringTag, { value: "Module" }));
  var GradientRadialDragger_vue_vue_type_style_index_0_scoped_true_lang = "";
  const __default__$Z = {
    name: "GradientRadialDragger"
  };
  const _sfc_main$2N = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$Z), {
    props: {
      position: null,
      active: { type: Boolean }
    },
    setup(__props) {
      const props = __props;
      const radialPosition = Vue.computed(() => {
        const { x, y } = props.position || { x: 50, y: 50 };
        const cssStyles = {
          left: x + "%",
          top: y + "%"
        };
        return cssStyles;
      });
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("span", {
          class: Vue.normalizeClass(["znpb-color-picker-pointer", { "znpb-color-picker-pointer--active": __props.active }]),
          style: Vue.normalizeStyle(Vue.unref(radialPosition))
        }, null, 6);
      };
    }
  }));
  var GradientRadialDragger = /* @__PURE__ */ _export_sfc(_sfc_main$2N, [["__scopeId", "data-v-72da235e"]]);
  var GradientBoard_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$27 = {
    key: 0,
    class: "znpb-gradient-radial-wrapper"
  };
  const __default__$Y = {
    name: "GradientBoard"
  };
  const _sfc_main$2M = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$Y), {
    props: {
      config: null,
      activegrad: null
    },
    emits: ["change-active-gradient", "position-changed"],
    setup(__props, { emit }) {
      const props = __props;
      const gradboard = Vue.ref(null);
      const rafMovePosition = rafSchd$1(onCircleDrag);
      const rafEndDragging = rafSchd$1(disableDragging);
      const radialArr = Vue.computed({
        get() {
          return props.config.filter((gradient) => gradient.type === "radial");
        },
        set(newArr) {
          radialArr.value = newArr;
        }
      });
      function enableDragging(gradient) {
        document.addEventListener("mousemove", rafMovePosition);
        document.addEventListener("mouseup", rafEndDragging);
        document.body.style.userSelect = "none";
        const activeGradientIndex = props.config.indexOf(gradient);
        emit("change-active-gradient", activeGradientIndex);
      }
      function disableDragging() {
        document.removeEventListener("mousemove", rafMovePosition);
        document.removeEventListener("mouseup", rafEndDragging);
        document.body.style.userSelect = "";
      }
      function onCircleDrag(event2) {
        const gradBoard = gradboard.value.getBoundingClientRect();
        const newLeft = clamp((event2.clientX - gradBoard.left) * 100 / gradBoard.width, 0, 100);
        const newTop = clamp((event2.clientY - gradBoard.top) * 100 / gradBoard.height, 0, 100);
        emit("position-changed", {
          x: Math.round(newLeft),
          y: Math.round(newTop)
        });
      }
      Vue.onBeforeUnmount(() => {
        disableDragging();
      });
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", {
          ref_key: "gradboard",
          ref: gradboard,
          class: "znpb-gradient-wrapper__board"
        }, [
          Vue.createVNode(_sfc_main$2O, { config: __props.config }, null, 8, ["config"]),
          Vue.unref(radialArr) != null ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$27, [
            (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList(Vue.unref(radialArr), (gradient, index2) => {
              return Vue.openBlock(), Vue.createBlock(GradientRadialDragger, {
                key: gradient.type + index2,
                position: gradient.position,
                active: __props.activegrad === gradient,
                onMousedown: ($event) => enableDragging(gradient)
              }, null, 8, ["position", "active", "onMousedown"]);
            }), 128))
          ])) : Vue.createCommentVNode("", true)
        ], 512);
      };
    }
  }));
  var GradientBarPreview_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$26 = ["title"];
  const _hoisted_2$1p = { class: "znpb-gradient-preview-transparent" };
  const __default__$X = {
    name: "GradientBarPreview"
  };
  const _sfc_main$2L = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$X), {
    props: {
      config: null
    },
    setup(__props) {
      const props = __props;
      const getGradientPreviewStyle = Vue.computed(() => {
        const style = {};
        const gradient = [];
        const colors = [];
        const colorsCopy = [...props.config.colors];
        colorsCopy.sort((a, b) => {
          return a.position > b.position ? 1 : -1;
        });
        colorsCopy.forEach((color) => {
          colors.push(`${color.color} ${color.position}%`);
        });
        gradient.push(`linear-gradient(90deg, ${colors.join(", ")})`);
        style["background"] = gradient.join(", ");
        return style;
      });
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", {
          class: "znpb-gradient-preview-transparent-container",
          title: _ctx.$translate("click_to_add_gradient_point")
        }, [
          Vue.createElementVNode("div", _hoisted_2$1p, [
            Vue.createElementVNode("div", {
              class: "znpb-gradient-preview",
              style: Vue.normalizeStyle(Vue.unref(getGradientPreviewStyle))
            }, null, 4)
          ])
        ], 8, _hoisted_1$26);
      };
    }
  }));
  let defaultOptions = {
    appendTo: "body",
    placement: "top"
  };
  const getDefaultOptions = () => {
    return defaultOptions;
  };
  var top = "top";
  var bottom = "bottom";
  var right = "right";
  var left = "left";
  var auto = "auto";
  var basePlacements = [top, bottom, right, left];
  var start = "start";
  var end = "end";
  var clippingParents = "clippingParents";
  var viewport = "viewport";
  var popper = "popper";
  var reference = "reference";
  var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
    return acc.concat([placement + "-" + start, placement + "-" + end]);
  }, []);
  var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
    return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
  }, []);
  var beforeRead = "beforeRead";
  var read = "read";
  var afterRead = "afterRead";
  var beforeMain = "beforeMain";
  var main = "main";
  var afterMain = "afterMain";
  var beforeWrite = "beforeWrite";
  var write = "write";
  var afterWrite = "afterWrite";
  var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
  function getNodeName(element) {
    return element ? (element.nodeName || "").toLowerCase() : null;
  }
  function getWindow(node) {
    if (node == null) {
      return window;
    }
    if (node.toString() !== "[object Window]") {
      var ownerDocument = node.ownerDocument;
      return ownerDocument ? ownerDocument.defaultView || window : window;
    }
    return node;
  }
  function isElement(node) {
    var OwnElement = getWindow(node).Element;
    return node instanceof OwnElement || node instanceof Element;
  }
  function isHTMLElement(node) {
    var OwnElement = getWindow(node).HTMLElement;
    return node instanceof OwnElement || node instanceof HTMLElement;
  }
  function isShadowRoot(node) {
    if (typeof ShadowRoot === "undefined") {
      return false;
    }
    var OwnElement = getWindow(node).ShadowRoot;
    return node instanceof OwnElement || node instanceof ShadowRoot;
  }
  function applyStyles(_ref) {
    var state = _ref.state;
    Object.keys(state.elements).forEach(function(name) {
      var style = state.styles[name] || {};
      var attributes = state.attributes[name] || {};
      var element = state.elements[name];
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(name2) {
        var value = attributes[name2];
        if (value === false) {
          element.removeAttribute(name2);
        } else {
          element.setAttribute(name2, value === true ? "" : value);
        }
      });
    });
  }
  function effect$2(_ref2) {
    var state = _ref2.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;
    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    }
    return function() {
      Object.keys(state.elements).forEach(function(name) {
        var element = state.elements[name];
        var attributes = state.attributes[name] || {};
        var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
        var style = styleProperties.reduce(function(style2, property2) {
          style2[property2] = "";
          return style2;
        }, {});
        if (!isHTMLElement(element) || !getNodeName(element)) {
          return;
        }
        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function(attribute) {
          element.removeAttribute(attribute);
        });
      });
    };
  }
  var applyStyles$1 = {
    name: "applyStyles",
    enabled: true,
    phase: "write",
    fn: applyStyles,
    effect: effect$2,
    requires: ["computeStyles"]
  };
  function getBasePlacement(placement) {
    return placement.split("-")[0];
  }
  var max = Math.max;
  var min = Math.min;
  var round = Math.round;
  function getUAString() {
    var uaData = navigator.userAgentData;
    if (uaData != null && uaData.brands) {
      return uaData.brands.map(function(item) {
        return item.brand + "/" + item.version;
      }).join(" ");
    }
    return navigator.userAgent;
  }
  function isLayoutViewport() {
    return !/^((?!chrome|android).)*safari/i.test(getUAString());
  }
  function getBoundingClientRect(element, includeScale, isFixedStrategy) {
    if (includeScale === void 0) {
      includeScale = false;
    }
    if (isFixedStrategy === void 0) {
      isFixedStrategy = false;
    }
    var clientRect = element.getBoundingClientRect();
    var scaleX = 1;
    var scaleY = 1;
    if (includeScale && isHTMLElement(element)) {
      scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
      scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
    }
    var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
    var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
    var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
    var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
    var width = clientRect.width / scaleX;
    var height = clientRect.height / scaleY;
    return {
      width,
      height,
      top: y,
      right: x + width,
      bottom: y + height,
      left: x,
      x,
      y
    };
  }
  function getLayoutRect(element) {
    var clientRect = getBoundingClientRect(element);
    var width = element.offsetWidth;
    var height = element.offsetHeight;
    if (Math.abs(clientRect.width - width) <= 1) {
      width = clientRect.width;
    }
    if (Math.abs(clientRect.height - height) <= 1) {
      height = clientRect.height;
    }
    return {
      x: element.offsetLeft,
      y: element.offsetTop,
      width,
      height
    };
  }
  function contains(parent2, child) {
    var rootNode = child.getRootNode && child.getRootNode();
    if (parent2.contains(child)) {
      return true;
    } else if (rootNode && isShadowRoot(rootNode)) {
      var next = child;
      do {
        if (next && parent2.isSameNode(next)) {
          return true;
        }
        next = next.parentNode || next.host;
      } while (next);
    }
    return false;
  }
  function getComputedStyle(element) {
    return getWindow(element).getComputedStyle(element);
  }
  function isTableElement(element) {
    return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
  }
  function getDocumentElement(element) {
    return ((isElement(element) ? element.ownerDocument : element.document) || window.document).documentElement;
  }
  function getParentNode(element) {
    if (getNodeName(element) === "html") {
      return element;
    }
    return element.assignedSlot || element.parentNode || (isShadowRoot(element) ? element.host : null) || getDocumentElement(element);
  }
  function getTrueOffsetParent(element) {
    if (!isHTMLElement(element) || getComputedStyle(element).position === "fixed") {
      return null;
    }
    return element.offsetParent;
  }
  function getContainingBlock(element) {
    var isFirefox = /firefox/i.test(getUAString());
    var isIE = /Trident/i.test(getUAString());
    if (isIE && isHTMLElement(element)) {
      var elementCss = getComputedStyle(element);
      if (elementCss.position === "fixed") {
        return null;
      }
    }
    var currentNode = getParentNode(element);
    if (isShadowRoot(currentNode)) {
      currentNode = currentNode.host;
    }
    while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
      var css = getComputedStyle(currentNode);
      if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
        return currentNode;
      } else {
        currentNode = currentNode.parentNode;
      }
    }
    return null;
  }
  function getOffsetParent(element) {
    var window2 = getWindow(element);
    var offsetParent = getTrueOffsetParent(element);
    while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
      offsetParent = getTrueOffsetParent(offsetParent);
    }
    if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static")) {
      return window2;
    }
    return offsetParent || getContainingBlock(element) || window2;
  }
  function getMainAxisFromPlacement(placement) {
    return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
  }
  function within(min$1, value, max$1) {
    return max(min$1, min(value, max$1));
  }
  function withinMaxClamp(min2, value, max2) {
    var v = within(min2, value, max2);
    return v > max2 ? max2 : v;
  }
  function getFreshSideObject() {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  }
  function mergePaddingObject(paddingObject) {
    return Object.assign({}, getFreshSideObject(), paddingObject);
  }
  function expandToHashMap(value, keys2) {
    return keys2.reduce(function(hashMap, key) {
      hashMap[key] = value;
      return hashMap;
    }, {});
  }
  var toPaddingObject = function toPaddingObject2(padding, state) {
    padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
      placement: state.placement
    })) : padding;
    return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  };
  function arrow(_ref) {
    var _state$modifiersData$;
    var state = _ref.state, name = _ref.name, options2 = _ref.options;
    var arrowElement = state.elements.arrow;
    var popperOffsets2 = state.modifiersData.popperOffsets;
    var basePlacement = getBasePlacement(state.placement);
    var axis = getMainAxisFromPlacement(basePlacement);
    var isVertical = [left, right].indexOf(basePlacement) >= 0;
    var len = isVertical ? "height" : "width";
    if (!arrowElement || !popperOffsets2) {
      return;
    }
    var paddingObject = toPaddingObject(options2.padding, state);
    var arrowRect = getLayoutRect(arrowElement);
    var minProp = axis === "y" ? top : left;
    var maxProp = axis === "y" ? bottom : right;
    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
    var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
    var arrowOffsetParent = getOffsetParent(arrowElement);
    var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    var centerToReference = endDiff / 2 - startDiff / 2;
    var min2 = paddingObject[minProp];
    var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
    var offset2 = within(min2, center, max2);
    var axisProp = axis;
    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
  }
  function effect$1(_ref2) {
    var state = _ref2.state, options2 = _ref2.options;
    var _options$element = options2.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
    if (arrowElement == null) {
      return;
    }
    if (typeof arrowElement === "string") {
      arrowElement = state.elements.popper.querySelector(arrowElement);
      if (!arrowElement) {
        return;
      }
    }
    if (!contains(state.elements.popper, arrowElement)) {
      return;
    }
    state.elements.arrow = arrowElement;
  }
  var arrow$1 = {
    name: "arrow",
    enabled: true,
    phase: "main",
    fn: arrow,
    effect: effect$1,
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"]
  };
  function getVariation(placement) {
    return placement.split("-")[1];
  }
  var unsetSides = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
  };
  function roundOffsetsByDPR(_ref) {
    var x = _ref.x, y = _ref.y;
    var win = window;
    var dpr = win.devicePixelRatio || 1;
    return {
      x: round(x * dpr) / dpr || 0,
      y: round(y * dpr) / dpr || 0
    };
  }
  function mapToStyles(_ref2) {
    var _Object$assign2;
    var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
    var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
    var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
      x,
      y
    }) : {
      x,
      y
    };
    x = _ref3.x;
    y = _ref3.y;
    var hasX = offsets.hasOwnProperty("x");
    var hasY = offsets.hasOwnProperty("y");
    var sideX = left;
    var sideY = top;
    var win = window;
    if (adaptive) {
      var offsetParent = getOffsetParent(popper2);
      var heightProp = "clientHeight";
      var widthProp = "clientWidth";
      if (offsetParent === getWindow(popper2)) {
        offsetParent = getDocumentElement(popper2);
        if (getComputedStyle(offsetParent).position !== "static" && position === "absolute") {
          heightProp = "scrollHeight";
          widthProp = "scrollWidth";
        }
      }
      offsetParent = offsetParent;
      if (placement === top || (placement === left || placement === right) && variation === end) {
        sideY = bottom;
        var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
        y -= offsetY - popperRect.height;
        y *= gpuAcceleration ? 1 : -1;
      }
      if (placement === left || (placement === top || placement === bottom) && variation === end) {
        sideX = right;
        var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
        x -= offsetX - popperRect.width;
        x *= gpuAcceleration ? 1 : -1;
      }
    }
    var commonStyles = Object.assign({
      position
    }, adaptive && unsetSides);
    var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
      x,
      y
    }) : {
      x,
      y
    };
    x = _ref4.x;
    y = _ref4.y;
    if (gpuAcceleration) {
      var _Object$assign;
      return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
    }
    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
  }
  function computeStyles(_ref5) {
    var state = _ref5.state, options2 = _ref5.options;
    var _options$gpuAccelerat = options2.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options2.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options2.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
    var commonStyles = {
      placement: getBasePlacement(state.placement),
      variation: getVariation(state.placement),
      popper: state.elements.popper,
      popperRect: state.rects.popper,
      gpuAcceleration,
      isFixed: state.options.strategy === "fixed"
    };
    if (state.modifiersData.popperOffsets != null) {
      state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.popperOffsets,
        position: state.options.strategy,
        adaptive,
        roundOffsets
      })));
    }
    if (state.modifiersData.arrow != null) {
      state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.arrow,
        position: "absolute",
        adaptive: false,
        roundOffsets
      })));
    }
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      "data-popper-placement": state.placement
    });
  }
  var computeStyles$1 = {
    name: "computeStyles",
    enabled: true,
    phase: "beforeWrite",
    fn: computeStyles,
    data: {}
  };
  var passive = {
    passive: true
  };
  function effect(_ref) {
    var state = _ref.state, instance2 = _ref.instance, options2 = _ref.options;
    var _options$scroll = options2.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options2.resize, resize = _options$resize === void 0 ? true : _options$resize;
    var window2 = getWindow(state.elements.popper);
    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.addEventListener("scroll", instance2.update, passive);
      });
    }
    if (resize) {
      window2.addEventListener("resize", instance2.update, passive);
    }
    return function() {
      if (scroll) {
        scrollParents.forEach(function(scrollParent) {
          scrollParent.removeEventListener("scroll", instance2.update, passive);
        });
      }
      if (resize) {
        window2.removeEventListener("resize", instance2.update, passive);
      }
    };
  }
  var eventListeners = {
    name: "eventListeners",
    enabled: true,
    phase: "write",
    fn: function fn() {
    },
    effect,
    data: {}
  };
  var hash$1 = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  };
  function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, function(matched) {
      return hash$1[matched];
    });
  }
  var hash = {
    start: "end",
    end: "start"
  };
  function getOppositeVariationPlacement(placement) {
    return placement.replace(/start|end/g, function(matched) {
      return hash[matched];
    });
  }
  function getWindowScroll(node) {
    var win = getWindow(node);
    var scrollLeft = win.pageXOffset;
    var scrollTop = win.pageYOffset;
    return {
      scrollLeft,
      scrollTop
    };
  }
  function getWindowScrollBarX(element) {
    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
  }
  function getViewportRect(element, strategy) {
    var win = getWindow(element);
    var html = getDocumentElement(element);
    var visualViewport = win.visualViewport;
    var width = html.clientWidth;
    var height = html.clientHeight;
    var x = 0;
    var y = 0;
    if (visualViewport) {
      width = visualViewport.width;
      height = visualViewport.height;
      var layoutViewport = isLayoutViewport();
      if (layoutViewport || !layoutViewport && strategy === "fixed") {
        x = visualViewport.offsetLeft;
        y = visualViewport.offsetTop;
      }
    }
    return {
      width,
      height,
      x: x + getWindowScrollBarX(element),
      y
    };
  }
  function getDocumentRect(element) {
    var _element$ownerDocumen;
    var html = getDocumentElement(element);
    var winScroll = getWindowScroll(element);
    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
    var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
    var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
    var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
    var y = -winScroll.scrollTop;
    if (getComputedStyle(body || html).direction === "rtl") {
      x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
    }
    return {
      width,
      height,
      x,
      y
    };
  }
  function isScrollParent(element) {
    var _getComputedStyle = getComputedStyle(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
  }
  function getScrollParent(node) {
    if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
      return node.ownerDocument.body;
    }
    if (isHTMLElement(node) && isScrollParent(node)) {
      return node;
    }
    return getScrollParent(getParentNode(node));
  }
  function listScrollParents(element, list) {
    var _element$ownerDocumen;
    if (list === void 0) {
      list = [];
    }
    var scrollParent = getScrollParent(element);
    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
    var win = getWindow(scrollParent);
    var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
    var updatedList = list.concat(target);
    return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
  }
  function rectToClientRect(rect) {
    return Object.assign({}, rect, {
      left: rect.x,
      top: rect.y,
      right: rect.x + rect.width,
      bottom: rect.y + rect.height
    });
  }
  function getInnerBoundingClientRect(element, strategy) {
    var rect = getBoundingClientRect(element, false, strategy === "fixed");
    rect.top = rect.top + element.clientTop;
    rect.left = rect.left + element.clientLeft;
    rect.bottom = rect.top + element.clientHeight;
    rect.right = rect.left + element.clientWidth;
    rect.width = element.clientWidth;
    rect.height = element.clientHeight;
    rect.x = rect.left;
    rect.y = rect.top;
    return rect;
  }
  function getClientRectFromMixedType(element, clippingParent, strategy) {
    return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
  }
  function getClippingParents(element) {
    var clippingParents2 = listScrollParents(getParentNode(element));
    var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle(element).position) >= 0;
    var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
    if (!isElement(clipperElement)) {
      return [];
    }
    return clippingParents2.filter(function(clippingParent) {
      return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
    });
  }
  function getClippingRect(element, boundary, rootBoundary, strategy) {
    var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
    var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
    var firstClippingParent = clippingParents2[0];
    var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
      var rect = getClientRectFromMixedType(element, clippingParent, strategy);
      accRect.top = max(rect.top, accRect.top);
      accRect.right = min(rect.right, accRect.right);
      accRect.bottom = min(rect.bottom, accRect.bottom);
      accRect.left = max(rect.left, accRect.left);
      return accRect;
    }, getClientRectFromMixedType(element, firstClippingParent, strategy));
    clippingRect.width = clippingRect.right - clippingRect.left;
    clippingRect.height = clippingRect.bottom - clippingRect.top;
    clippingRect.x = clippingRect.left;
    clippingRect.y = clippingRect.top;
    return clippingRect;
  }
  function computeOffsets(_ref) {
    var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
    var basePlacement = placement ? getBasePlacement(placement) : null;
    var variation = placement ? getVariation(placement) : null;
    var commonX = reference2.x + reference2.width / 2 - element.width / 2;
    var commonY = reference2.y + reference2.height / 2 - element.height / 2;
    var offsets;
    switch (basePlacement) {
      case top:
        offsets = {
          x: commonX,
          y: reference2.y - element.height
        };
        break;
      case bottom:
        offsets = {
          x: commonX,
          y: reference2.y + reference2.height
        };
        break;
      case right:
        offsets = {
          x: reference2.x + reference2.width,
          y: commonY
        };
        break;
      case left:
        offsets = {
          x: reference2.x - element.width,
          y: commonY
        };
        break;
      default:
        offsets = {
          x: reference2.x,
          y: reference2.y
        };
    }
    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
    if (mainAxis != null) {
      var len = mainAxis === "y" ? "height" : "width";
      switch (variation) {
        case start:
          offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
          break;
        case end:
          offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
          break;
      }
    }
    return offsets;
  }
  function detectOverflow(state, options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    var _options = options2, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
    var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
    var altContext = elementContext === popper ? reference : popper;
    var popperRect = state.rects.popper;
    var element = state.elements[altBoundary ? altContext : elementContext];
    var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
    var referenceClientRect = getBoundingClientRect(state.elements.reference);
    var popperOffsets2 = computeOffsets({
      reference: referenceClientRect,
      element: popperRect,
      strategy: "absolute",
      placement
    });
    var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
    var overflowOffsets = {
      top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
      bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
      left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
      right: elementClientRect.right - clippingClientRect.right + paddingObject.right
    };
    var offsetData = state.modifiersData.offset;
    if (elementContext === popper && offsetData) {
      var offset2 = offsetData[placement];
      Object.keys(overflowOffsets).forEach(function(key) {
        var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
        var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
        overflowOffsets[key] += offset2[axis] * multiply;
      });
    }
    return overflowOffsets;
  }
  function computeAutoPlacement(state, options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    var _options = options2, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
    var variation = getVariation(placement);
    var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
      return getVariation(placement2) === variation;
    }) : basePlacements;
    var allowedPlacements = placements$1.filter(function(placement2) {
      return allowedAutoPlacements.indexOf(placement2) >= 0;
    });
    if (allowedPlacements.length === 0) {
      allowedPlacements = placements$1;
    }
    var overflows = allowedPlacements.reduce(function(acc, placement2) {
      acc[placement2] = detectOverflow(state, {
        placement: placement2,
        boundary,
        rootBoundary,
        padding
      })[getBasePlacement(placement2)];
      return acc;
    }, {});
    return Object.keys(overflows).sort(function(a, b) {
      return overflows[a] - overflows[b];
    });
  }
  function getExpandedFallbackPlacements(placement) {
    if (getBasePlacement(placement) === auto) {
      return [];
    }
    var oppositePlacement = getOppositePlacement(placement);
    return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
  }
  function flip(_ref) {
    var state = _ref.state, options2 = _ref.options, name = _ref.name;
    if (state.modifiersData[name]._skip) {
      return;
    }
    var _options$mainAxis = options2.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options2.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options2.fallbackPlacements, padding = options2.padding, boundary = options2.boundary, rootBoundary = options2.rootBoundary, altBoundary = options2.altBoundary, _options$flipVariatio = options2.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options2.allowedAutoPlacements;
    var preferredPlacement = state.options.placement;
    var basePlacement = getBasePlacement(preferredPlacement);
    var isBasePlacement = basePlacement === preferredPlacement;
    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
    var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
      return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
        placement: placement2,
        boundary,
        rootBoundary,
        padding,
        flipVariations,
        allowedAutoPlacements
      }) : placement2);
    }, []);
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var checksMap = /* @__PURE__ */ new Map();
    var makeFallbackChecks = true;
    var firstFittingPlacement = placements2[0];
    for (var i = 0; i < placements2.length; i++) {
      var placement = placements2[i];
      var _basePlacement = getBasePlacement(placement);
      var isStartVariation = getVariation(placement) === start;
      var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
      var len = isVertical ? "width" : "height";
      var overflow = detectOverflow(state, {
        placement,
        boundary,
        rootBoundary,
        altBoundary,
        padding
      });
      var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
      if (referenceRect[len] > popperRect[len]) {
        mainVariationSide = getOppositePlacement(mainVariationSide);
      }
      var altVariationSide = getOppositePlacement(mainVariationSide);
      var checks = [];
      if (checkMainAxis) {
        checks.push(overflow[_basePlacement] <= 0);
      }
      if (checkAltAxis) {
        checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
      }
      if (checks.every(function(check) {
        return check;
      })) {
        firstFittingPlacement = placement;
        makeFallbackChecks = false;
        break;
      }
      checksMap.set(placement, checks);
    }
    if (makeFallbackChecks) {
      var numberOfChecks = flipVariations ? 3 : 1;
      var _loop = function _loop2(_i2) {
        var fittingPlacement = placements2.find(function(placement2) {
          var checks2 = checksMap.get(placement2);
          if (checks2) {
            return checks2.slice(0, _i2).every(function(check) {
              return check;
            });
          }
        });
        if (fittingPlacement) {
          firstFittingPlacement = fittingPlacement;
          return "break";
        }
      };
      for (var _i = numberOfChecks; _i > 0; _i--) {
        var _ret = _loop(_i);
        if (_ret === "break")
          break;
      }
    }
    if (state.placement !== firstFittingPlacement) {
      state.modifiersData[name]._skip = true;
      state.placement = firstFittingPlacement;
      state.reset = true;
    }
  }
  var flip$1 = {
    name: "flip",
    enabled: true,
    phase: "main",
    fn: flip,
    requiresIfExists: ["offset"],
    data: {
      _skip: false
    }
  };
  function getSideOffsets(overflow, rect, preventedOffsets) {
    if (preventedOffsets === void 0) {
      preventedOffsets = {
        x: 0,
        y: 0
      };
    }
    return {
      top: overflow.top - rect.height - preventedOffsets.y,
      right: overflow.right - rect.width + preventedOffsets.x,
      bottom: overflow.bottom - rect.height + preventedOffsets.y,
      left: overflow.left - rect.width - preventedOffsets.x
    };
  }
  function isAnySideFullyClipped(overflow) {
    return [top, right, bottom, left].some(function(side) {
      return overflow[side] >= 0;
    });
  }
  function hide(_ref) {
    var state = _ref.state, name = _ref.name;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var preventedOffsets = state.modifiersData.preventOverflow;
    var referenceOverflow = detectOverflow(state, {
      elementContext: "reference"
    });
    var popperAltOverflow = detectOverflow(state, {
      altBoundary: true
    });
    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
    state.modifiersData[name] = {
      referenceClippingOffsets,
      popperEscapeOffsets,
      isReferenceHidden,
      hasPopperEscaped
    };
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      "data-popper-reference-hidden": isReferenceHidden,
      "data-popper-escaped": hasPopperEscaped
    });
  }
  var hide$1 = {
    name: "hide",
    enabled: true,
    phase: "main",
    requiresIfExists: ["preventOverflow"],
    fn: hide
  };
  function distanceAndSkiddingToXY(placement, rects, offset2) {
    var basePlacement = getBasePlacement(placement);
    var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
    var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
      placement
    })) : offset2, skidding = _ref[0], distance = _ref[1];
    skidding = skidding || 0;
    distance = (distance || 0) * invertDistance;
    return [left, right].indexOf(basePlacement) >= 0 ? {
      x: distance,
      y: skidding
    } : {
      x: skidding,
      y: distance
    };
  }
  function offset(_ref2) {
    var state = _ref2.state, options2 = _ref2.options, name = _ref2.name;
    var _options$offset = options2.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
    var data2 = placements.reduce(function(acc, placement) {
      acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
      return acc;
    }, {});
    var _data$state$placement = data2[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
    if (state.modifiersData.popperOffsets != null) {
      state.modifiersData.popperOffsets.x += x;
      state.modifiersData.popperOffsets.y += y;
    }
    state.modifiersData[name] = data2;
  }
  var offset$1 = {
    name: "offset",
    enabled: true,
    phase: "main",
    requires: ["popperOffsets"],
    fn: offset
  };
  function popperOffsets(_ref) {
    var state = _ref.state, name = _ref.name;
    state.modifiersData[name] = computeOffsets({
      reference: state.rects.reference,
      element: state.rects.popper,
      strategy: "absolute",
      placement: state.placement
    });
  }
  var popperOffsets$1 = {
    name: "popperOffsets",
    enabled: true,
    phase: "read",
    fn: popperOffsets,
    data: {}
  };
  function getAltAxis(axis) {
    return axis === "x" ? "y" : "x";
  }
  function preventOverflow(_ref) {
    var state = _ref.state, options2 = _ref.options, name = _ref.name;
    var _options$mainAxis = options2.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options2.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options2.boundary, rootBoundary = options2.rootBoundary, altBoundary = options2.altBoundary, padding = options2.padding, _options$tether = options2.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options2.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
    var overflow = detectOverflow(state, {
      boundary,
      rootBoundary,
      padding,
      altBoundary
    });
    var basePlacement = getBasePlacement(state.placement);
    var variation = getVariation(state.placement);
    var isBasePlacement = !variation;
    var mainAxis = getMainAxisFromPlacement(basePlacement);
    var altAxis = getAltAxis(mainAxis);
    var popperOffsets2 = state.modifiersData.popperOffsets;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
      placement: state.placement
    })) : tetherOffset;
    var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
      mainAxis: tetherOffsetValue,
      altAxis: tetherOffsetValue
    } : Object.assign({
      mainAxis: 0,
      altAxis: 0
    }, tetherOffsetValue);
    var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
    var data2 = {
      x: 0,
      y: 0
    };
    if (!popperOffsets2) {
      return;
    }
    if (checkMainAxis) {
      var _offsetModifierState$;
      var mainSide = mainAxis === "y" ? top : left;
      var altSide = mainAxis === "y" ? bottom : right;
      var len = mainAxis === "y" ? "height" : "width";
      var offset2 = popperOffsets2[mainAxis];
      var min$1 = offset2 + overflow[mainSide];
      var max$1 = offset2 - overflow[altSide];
      var additive = tether ? -popperRect[len] / 2 : 0;
      var minLen = variation === start ? referenceRect[len] : popperRect[len];
      var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
      var arrowElement = state.elements.arrow;
      var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
        width: 0,
        height: 0
      };
      var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
      var arrowPaddingMin = arrowPaddingObject[mainSide];
      var arrowPaddingMax = arrowPaddingObject[altSide];
      var arrowLen = within(0, referenceRect[len], arrowRect[len]);
      var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
      var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
      var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
      var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
      var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
      var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
      var tetherMax = offset2 + maxOffset - offsetModifierValue;
      var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset2, tether ? max(max$1, tetherMax) : max$1);
      popperOffsets2[mainAxis] = preventedOffset;
      data2[mainAxis] = preventedOffset - offset2;
    }
    if (checkAltAxis) {
      var _offsetModifierState$2;
      var _mainSide = mainAxis === "x" ? top : left;
      var _altSide = mainAxis === "x" ? bottom : right;
      var _offset = popperOffsets2[altAxis];
      var _len = altAxis === "y" ? "height" : "width";
      var _min = _offset + overflow[_mainSide];
      var _max = _offset - overflow[_altSide];
      var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
      var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
      var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
      var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
      var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
      popperOffsets2[altAxis] = _preventedOffset;
      data2[altAxis] = _preventedOffset - _offset;
    }
    state.modifiersData[name] = data2;
  }
  var preventOverflow$1 = {
    name: "preventOverflow",
    enabled: true,
    phase: "main",
    fn: preventOverflow,
    requiresIfExists: ["offset"]
  };
  function getHTMLElementScroll(element) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  function getNodeScroll(node) {
    if (node === getWindow(node) || !isHTMLElement(node)) {
      return getWindowScroll(node);
    } else {
      return getHTMLElementScroll(node);
    }
  }
  function isElementScaled(element) {
    var rect = element.getBoundingClientRect();
    var scaleX = round(rect.width) / element.offsetWidth || 1;
    var scaleY = round(rect.height) / element.offsetHeight || 1;
    return scaleX !== 1 || scaleY !== 1;
  }
  function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
    if (isFixed === void 0) {
      isFixed = false;
    }
    var isOffsetParentAnElement = isHTMLElement(offsetParent);
    var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
    var documentElement = getDocumentElement(offsetParent);
    var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
    var scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    var offsets = {
      x: 0,
      y: 0
    };
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isHTMLElement(offsetParent)) {
        offsets = getBoundingClientRect(offsetParent, true);
        offsets.x += offsetParent.clientLeft;
        offsets.y += offsetParent.clientTop;
      } else if (documentElement) {
        offsets.x = getWindowScrollBarX(documentElement);
      }
    }
    return {
      x: rect.left + scroll.scrollLeft - offsets.x,
      y: rect.top + scroll.scrollTop - offsets.y,
      width: rect.width,
      height: rect.height
    };
  }
  function order(modifiers) {
    var map = /* @__PURE__ */ new Map();
    var visited = /* @__PURE__ */ new Set();
    var result = [];
    modifiers.forEach(function(modifier) {
      map.set(modifier.name, modifier);
    });
    function sort(modifier) {
      visited.add(modifier.name);
      var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
      requires.forEach(function(dep) {
        if (!visited.has(dep)) {
          var depModifier = map.get(dep);
          if (depModifier) {
            sort(depModifier);
          }
        }
      });
      result.push(modifier);
    }
    modifiers.forEach(function(modifier) {
      if (!visited.has(modifier.name)) {
        sort(modifier);
      }
    });
    return result;
  }
  function orderModifiers(modifiers) {
    var orderedModifiers = order(modifiers);
    return modifierPhases.reduce(function(acc, phase) {
      return acc.concat(orderedModifiers.filter(function(modifier) {
        return modifier.phase === phase;
      }));
    }, []);
  }
  function debounce(fn) {
    var pending;
    return function() {
      if (!pending) {
        pending = new Promise(function(resolve) {
          Promise.resolve().then(function() {
            pending = void 0;
            resolve(fn());
          });
        });
      }
      return pending;
    };
  }
  function mergeByName(modifiers) {
    var merged = modifiers.reduce(function(merged2, current) {
      var existing = merged2[current.name];
      merged2[current.name] = existing ? Object.assign({}, existing, current, {
        options: Object.assign({}, existing.options, current.options),
        data: Object.assign({}, existing.data, current.data)
      }) : current;
      return merged2;
    }, {});
    return Object.keys(merged).map(function(key) {
      return merged[key];
    });
  }
  var DEFAULT_OPTIONS = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
  };
  function areValidElements() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return !args.some(function(element) {
      return !(element && typeof element.getBoundingClientRect === "function");
    });
  }
  function popperGenerator(generatorOptions) {
    if (generatorOptions === void 0) {
      generatorOptions = {};
    }
    var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions2 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
    return function createPopper2(reference2, popper2, options2) {
      if (options2 === void 0) {
        options2 = defaultOptions2;
      }
      var state = {
        placement: "bottom",
        orderedModifiers: [],
        options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions2),
        modifiersData: {},
        elements: {
          reference: reference2,
          popper: popper2
        },
        attributes: {},
        styles: {}
      };
      var effectCleanupFns = [];
      var isDestroyed = false;
      var instance2 = {
        state,
        setOptions: function setOptions(setOptionsAction) {
          var options3 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
          cleanupModifierEffects();
          state.options = Object.assign({}, defaultOptions2, state.options, options3);
          state.scrollParents = {
            reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
            popper: listScrollParents(popper2)
          };
          var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
          state.orderedModifiers = orderedModifiers.filter(function(m) {
            return m.enabled;
          });
          runModifierEffects();
          return instance2.update();
        },
        forceUpdate: function forceUpdate() {
          if (isDestroyed) {
            return;
          }
          var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
          if (!areValidElements(reference3, popper3)) {
            return;
          }
          state.rects = {
            reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
            popper: getLayoutRect(popper3)
          };
          state.reset = false;
          state.placement = state.options.placement;
          state.orderedModifiers.forEach(function(modifier) {
            return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
          });
          for (var index2 = 0; index2 < state.orderedModifiers.length; index2++) {
            if (state.reset === true) {
              state.reset = false;
              index2 = -1;
              continue;
            }
            var _state$orderedModifie = state.orderedModifiers[index2], fn = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
            if (typeof fn === "function") {
              state = fn({
                state,
                options: _options,
                name,
                instance: instance2
              }) || state;
            }
          }
        },
        update: debounce(function() {
          return new Promise(function(resolve) {
            instance2.forceUpdate();
            resolve(state);
          });
        }),
        destroy: function destroy() {
          cleanupModifierEffects();
          isDestroyed = true;
        }
      };
      if (!areValidElements(reference2, popper2)) {
        return instance2;
      }
      instance2.setOptions(options2).then(function(state2) {
        if (!isDestroyed && options2.onFirstUpdate) {
          options2.onFirstUpdate(state2);
        }
      });
      function runModifierEffects() {
        state.orderedModifiers.forEach(function(_ref3) {
          var name = _ref3.name, _ref3$options = _ref3.options, options3 = _ref3$options === void 0 ? {} : _ref3$options, effect2 = _ref3.effect;
          if (typeof effect2 === "function") {
            var cleanupFn = effect2({
              state,
              name,
              instance: instance2,
              options: options3
            });
            var noopFn = function noopFn2() {
            };
            effectCleanupFns.push(cleanupFn || noopFn);
          }
        });
      }
      function cleanupModifierEffects() {
        effectCleanupFns.forEach(function(fn) {
          return fn();
        });
        effectCleanupFns = [];
      }
      return instance2;
    };
  }
  var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
  var createPopper = /* @__PURE__ */ popperGenerator({
    defaultModifiers
  });
  const getManager = () => {
    let zIndex = 1e4;
    const getZindex2 = () => {
      zIndex++;
      return zIndex;
    };
    const removeZindex2 = () => {
      zIndex--;
    };
    return {
      getZindex: getZindex2,
      removeZindex: removeZindex2
    };
  };
  const instance = getManager();
  const { getZindex, removeZindex } = instance;
  var Tooltip_vue_vue_type_style_index_0_lang = "";
  let preventOutsideClickPropagation = false;
  const _sfc_main$2K = {
    name: "Tooltip",
    inheritAttrs: false,
    props: {
      modifiers: {
        type: Array,
        required: false
      },
      tag: {
        default: "div"
      },
      content: {
        type: String,
        required: false,
        default: null
      },
      show: {
        type: Boolean,
        required: false,
        default: false
      },
      showOnMouseEnter: {
        type: Boolean,
        required: false,
        default: true
      },
      openDelay: {
        type: Number,
        required: false,
        default: 10
      },
      closeDelay: {
        type: Number,
        required: false,
        default: 10
      },
      enterable: {
        type: Boolean,
        required: false,
        default: true
      },
      hideAfter: {
        type: Number,
        required: false,
        default: null
      },
      showArrows: {
        type: Boolean,
        required: false,
        default: true
      },
      appendTo: {
        required: false
      },
      trigger: {
        type: String,
        required: false,
        default: "hover"
      },
      closeOnOutsideClick: {
        type: Boolean,
        required: false,
        default: false
      },
      closeOnEscape: {
        type: Boolean,
        required: false,
        default: false
      },
      popperRef: {
        type: Object,
        required: false,
        default() {
          return null;
        }
      },
      transition: {
        type: String,
        required: false
      },
      enterActiveClass: {
        type: String,
        required: false,
        default: ""
      },
      leaveActiveClass: {
        type: String,
        required: false,
        default: ""
      },
      tooltipClass: {
        type: String,
        required: false
      },
      tooltipStyle: {
        type: [Object, String],
        required: false,
        default: {}
      }
    },
    setup(props) {
      const root2 = Vue.ref(null);
      const popperSelector = Vue.ref(null);
      const ownerDocument = Vue.ref(null);
      return {
        popperSelector,
        root: root2,
        ownerDocument
      };
    },
    data() {
      return {
        visible: !!this.show,
        showTimeout: null,
        hideTimeout: null,
        hideAfterTimeout: null,
        zIndex: null
      };
    },
    computed: {
      getStyle() {
        return __spreadProps(__spreadValues({}, this.tooltipStyle), {
          "z-index": this.zIndex
        });
      },
      popperProps() {
        const props = {};
        if (this.enterActiveClass) {
          props.enterActiveClass = this.enterActiveClass;
        }
        if (this.leaveActiveClass) {
          props.leaveActiveClass = this.leaveActiveClass;
        }
        return props;
      },
      popperOptions() {
        const options2 = JSON.parse(JSON.stringify(getDefaultOptions()));
        const instanceOptions = JSON.parse(JSON.stringify(this.$attrs));
        instanceOptions.modifiers = this.modifiers || [];
        if (this.showArrows) {
          const hasOffsetModifier = instanceOptions.modifiers.find((modifier) => modifier.name === "offset");
          if (!hasOffsetModifier) {
            instanceOptions.modifiers.push({
              name: "offset",
              options: {
                offset: [0, 10]
              }
            });
          }
        }
        return merge$1(options2, instanceOptions);
      },
      appendToOption() {
        const options2 = JSON.parse(JSON.stringify(getDefaultOptions()));
        return this.appendTo || options2.appendTo;
      }
    },
    watch: {
      closeOnOutsideClick(newValue) {
        if (newValue) {
          this.ownerDocument.addEventListener("click", this.onOutsideClick, true);
        } else {
          this.ownerDocument.removeEventListener("click", this.onOutsideClick, true);
        }
      },
      hideAfter(newValue) {
        if (newValue) {
          this.onHideAfter();
        }
      },
      show(newValue, oldValue) {
        this.visible = !!newValue;
      },
      visible(newValue, oldvalue) {
        if (!!newValue !== !!oldvalue) {
          if (newValue) {
            this.zIndex = getZindex();
          } else if (this.zIndex) {
            removeZindex();
            this.zIndex = null;
          }
        }
      }
    },
    methods: {
      preventOutsideClickPropagation() {
        preventOutsideClickPropagation = true;
      },
      onTransitionEnter() {
        this.instantiatePopper();
        this.$emit("show");
        this.$emit("update:show", true);
      },
      onTransitionLeave() {
        this.destroyPopper();
        this.$emit("hide");
        this.$emit("update:show", false);
      },
      getAppendToElement() {
        if (this.appendToOption === "element") {
          return this.$el;
        } else {
          return this.ownerDocument.querySelector(this.appendToOption);
        }
      },
      showPopper() {
        this.visible = true;
      },
      hidePopper() {
        this.visible = false;
      },
      addPopperToDom() {
        if (this.popperElement && this.appendToOption !== "element") {
          const appendElement = this.getAppendToElement();
          if (!appendElement) {
            console.warn(
              `No HTMLElement was found matching ${appendElement}`
            );
            return;
          }
          appendElement.appendChild(this.popperElement);
        }
      },
      destroyPopper(completeRemove) {
        if (this.visible && !completeRemove) {
          return;
        }
        this.visible = false;
        if (this.popperInstance) {
          this.popperInstance.destroy();
          this.popperInstance = null;
        }
        this.removePopperEvents();
        if (this.popperElement && this.popperElement.parentNode && this.appendToOption !== "element") {
          this.popperElement.parentNode.removeChild(this.popperElement);
        }
        this.popperElement = null;
        preventOutsideClickPropagation = false;
      },
      instantiatePopper() {
        this.popperElement = this.$refs.popper;
        this.popperSelector = this.popperRef || this.root;
        this.ownerDocument = this.popperSelector.ownerDocument || this.root.ownerDocument;
        this.addPopperToDom();
        if (this.popperInstance && this.popperInstance.destroy) {
          this.popperInstance.destroy();
          this.popperInstance = null;
        }
        if (this.popperSelector) {
          this.popperInstance = createPopper(this.popperSelector, this.popperElement, this.popperOptions);
        }
        this.onHideAfter();
        this.addPopperEvents();
      },
      onMouseEnter(event2) {
        if (!this.showOnMouseEnter) {
          return;
        }
        clearTimeout(this.timeout);
        this.timeout = setTimeout(() => {
          this.showPopper();
        }, this.openDelay);
      },
      onMouseLeave(event2) {
        clearTimeout(this.timeout);
        this.timeout = setTimeout(() => {
          this.hidePopper();
        }, this.closeDelay);
      },
      onHideAfter() {
        if (this.hideAfter) {
          clearTimeout(this.timeout);
          this.timeout = setTimeout(() => {
            this.hidePopper();
          }, this.hideAfter);
        }
      },
      onClick: debounce$1(function(event2) {
        if (this.popperElement && this.popperElement.contains(event2.target)) {
          return;
        }
        this.visible = !this.visible;
      }, 10),
      onOutsideClick(event2) {
        if (!this.visible || preventOutsideClickPropagation) {
          return;
        }
        if (this.popperSelector && typeof this.popperSelector.contains === "function" && this.popperSelector.contains(event2.target)) {
          return;
        }
        if (this.popperElement && this.popperElement.contains(event2.target)) {
          return;
        }
        this.hidePopper();
        this.$emit("hide");
        this.$emit("update:show", false);
        preventOutsideClickPropagation = false;
      },
      onKeyUp(event2) {
        if (event2.which === 27) {
          this.hidePopper();
          event2.stopPropagation();
        }
      },
      scheduleUpdate() {
        if (this.popperInstance) {
          this.popperInstance.update();
        }
      },
      addPopperEvents() {
        if (this.closeOnOutsideClick) {
          this.ownerDocument.addEventListener("click", this.onOutsideClick, true);
        }
        if (this.trigger === "hover" && this.enterable && this.popperElement) {
          this.popperElement.addEventListener("mouseenter", this.onMouseEnter);
          this.popperElement.addEventListener("mouseleave", this.onMouseLeave);
        }
        if (this.closeOnEscape) {
          this.ownerDocument.addEventListener("keyup", this.onKeyUp);
        }
      },
      removePopperEvents() {
        if (this.ownerDocument) {
          this.ownerDocument.removeEventListener("click", this.onOutsideClick, true);
        }
        if (this.trigger === "hover" && this.enterable && this.popperElement) {
          this.popperElement.removeEventListener("mouseenter", this.onMouseEnter);
          this.popperElement.removeEventListener("mouseleave", this.onMouseLeave);
        }
        if (this.closeOnEscape && this.ownerDocument) {
          this.ownerDocument.removeEventListener("keyup", this.onKeyUp);
        }
      }
    },
    unmounted() {
      this.$el.removeEventListener("mouseenter", this.onMouseEnter);
      this.$el.removeEventListener("mouseleave", this.onMouseLeave);
      this.$el.removeEventListener("click", this.onClick);
      if (this.ownerDocument) {
        this.ownerDocument.removeEventListener("click", this.onOutsideClick, true);
        this.ownerDocument.removeEventListener("keyup", this.onKeyUp);
      }
      this.destroyPopper(true);
      if (this.zIndex) {
        removeZindex();
        this.zIndex = null;
      }
    },
    mounted() {
      if (this.trigger === "hover") {
        this.$el.addEventListener("mouseenter", this.onMouseEnter);
        this.$el.addEventListener("mouseleave", this.onMouseLeave);
      } else if (this.trigger === "click") {
        this.$el.addEventListener("click", this.onClick);
      }
      if (this.show) {
        this.zIndex = getZindex();
      }
    }
  };
  const _hoisted_1$25 = {
    key: 0,
    "data-popper-arrow": "true",
    class: "hg-popper--with-arrows"
  };
  function _sfc_render$19(_ctx, _cache, $props, $setup, $data, $options) {
    return Vue.openBlock(), Vue.createBlock(Vue.resolveDynamicComponent($props.tag), Vue.mergeProps(_ctx.$attrs, { ref: "root" }), {
      default: Vue.withCtx(() => [
        $data.visible ? (Vue.openBlock(), Vue.createBlock(Vue.Transition, Vue.mergeProps({
          key: 0,
          appear: "",
          name: $props.transition
        }, $options.popperProps, {
          onEnter: $options.onTransitionEnter,
          onAfterLeave: $options.onTransitionLeave
        }), {
          default: Vue.withCtx(() => [
            Vue.createElementVNode("div", {
              ref: "popper",
              class: Vue.normalizeClass(["hg-popper", $props.tooltipClass]),
              style: Vue.normalizeStyle($options.getStyle)
            }, [
              Vue.createTextVNode(Vue.toDisplayString($props.content) + " ", 1),
              Vue.renderSlot(_ctx.$slots, "content"),
              $props.showArrows ? (Vue.openBlock(), Vue.createElementBlock("span", _hoisted_1$25)) : Vue.createCommentVNode("", true)
            ], 6)
          ]),
          _: 3
        }, 16, ["name", "onEnter", "onAfterLeave"])) : Vue.createCommentVNode("", true),
        Vue.renderSlot(_ctx.$slots, "default")
      ]),
      _: 3
    }, 16);
  }
  var Tooltip = /* @__PURE__ */ _export_sfc(_sfc_main$2K, [["render", _sfc_render$19]]);
  const PopperDirective = {
    mounted(el, { value, arg }, vnode) {
      el.__ZnPbTooltip__ = initTooltip(el, value, arg);
    },
    beforeUnmount(el) {
      if (el.__ZnPbTooltip__) {
        el.__ZnPbTooltip__.destroy();
      }
    },
    updated(el, { value, arg }) {
      if (el.__ZnPbTooltip__) {
        el.__ZnPbTooltip__.setContent(value);
        const popperPosition = arg || "top";
        el.__ZnPbTooltip__.updatePosition(popperPosition);
      }
    },
    unmounted(el) {
      if (el.__ZnPbTooltip__ && el.__ZnPbTooltip__.popper) {
        el.__ZnPbTooltip__.popper.destroy();
      }
    }
  };
  function initTooltip(element, content, arg) {
    const tooltipObject = {};
    const doc = element.ownerDocument;
    const popperContent = doc.createElement("span");
    popperContent.classList.add("hg-popper", "hg-popper-tooltip");
    popperContent.innerHTML = content;
    popperContent.setAttribute("show-popper", "true");
    const arrow2 = doc.createElement("span");
    arrow2.classList.add("hg-popper--with-arrows");
    arrow2.setAttribute("data-popper-arrow", "true");
    popperContent.appendChild(arrow2);
    tooltipObject.element = element;
    tooltipObject.content = popperContent;
    let popperPosition = arg || "top";
    function showPopper() {
      doc.body.appendChild(popperContent);
      tooltipObject.popper = createPopper(
        element,
        popperContent,
        {
          placement: popperPosition,
          modifiers: [
            {
              name: "offset",
              options: {
                offset: [0, 10]
              }
            }
          ]
        }
      );
    }
    function updatePosition(placement) {
      popperPosition = placement;
    }
    function hidePopper() {
      if (popperContent.parentNode) {
        popperContent.parentNode.removeChild(popperContent);
      }
      if (tooltipObject.popper) {
        tooltipObject.popper.destroy();
      }
    }
    function setContent(content2) {
      if (popperContent.innerHTML !== content2) {
        popperContent.innerHTML = content2;
        popperContent.appendChild(arrow2);
      }
    }
    element.addEventListener("mouseenter", showPopper);
    element.addEventListener("mouseleave", hidePopper);
    function destroy() {
      hidePopper();
      element.removeEventListener("mouseenter", showPopper);
      element.removeEventListener("mouseleave", hidePopper);
    }
    return __spreadProps(__spreadValues({}, tooltipObject), {
      showPopper,
      hidePopper,
      destroy,
      setContent,
      updatePosition
    });
  }
  var GradientDragger_vue_vue_type_style_index_0_scoped_true_lang = "";
  const _hoisted_1$24 = { class: "znpb-gradient-dragger-wrapper" };
  const __default__$W = {
    name: "GradientDragger"
  };
  const _sfc_main$2J = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$W), {
    props: {
      modelValue: null
    },
    emits: ["update:modelValue", "color-picker-open"],
    setup(__props, { emit }) {
      const props = __props;
      const gradientCircle = Vue.ref(null);
      const colorpickerHolder = Vue.ref(null);
      const showPicker = Vue.ref(false);
      const circlePos = Vue.ref(null);
      const computedValue = Vue.computed({
        get() {
          return props.modelValue;
        },
        set(newValue) {
          emit("update:modelValue", newValue);
        }
      });
      const colorValue = Vue.computed({
        get() {
          return computedValue.value.color;
        },
        set(newValue) {
          computedValue.value = __spreadProps(__spreadValues({}, computedValue.value), {
            color: newValue
          });
        }
      });
      const colorPosition = Vue.computed(() => {
        const cssStyles = {
          left: computedValue.value.position + "%",
          background: computedValue.value.color
        };
        return cssStyles;
      });
      const parentPosition = Vue.computed(() => {
        return {
          left: circlePos.value.left,
          top: circlePos.value.top
        };
      });
      function openColorPicker() {
        showPicker.value = true;
        emit("color-picker-open", true);
        document.addEventListener("mousedown", closePanelOnOutsideClick);
      }
      function closePanelOnOutsideClick(event2) {
        const colorPicker = colorpickerHolder.value.$refs.colorPicker;
        if (!colorPicker.contains(event2.target)) {
          showPicker.value = false;
          document.removeEventListener("mousedown", closePanelOnOutsideClick);
          emit("color-picker-open", false);
        }
      }
      Vue.onMounted(() => {
        Vue.nextTick(() => {
          circlePos.value = gradientCircle.value.getBoundingClientRect();
        });
      });
      Vue.onUnmounted(() => {
        document.removeEventListener("mousedown", closePanelOnOutsideClick);
      });
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$24, [
          Vue.createVNode(Vue.unref(Tooltip), {
            show: showPicker.value,
            trigger: null,
            placement: "top"
          }, {
            content: Vue.withCtx(() => [
              showPicker.value ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$2Q), {
                key: 0,
                ref_key: "colorpickerHolder",
                ref: colorpickerHolder,
                "parent-position": Vue.unref(parentPosition),
                model: Vue.unref(computedValue).color,
                "show-library": false,
                onColorChanged: _cache[0] || (_cache[0] = ($event) => colorValue.value = $event)
              }, null, 8, ["parent-position", "model"])) : Vue.createCommentVNode("", true)
            ]),
            default: Vue.withCtx(() => [
              Vue.createElementVNode("span", {
                ref_key: "gradientCircle",
                ref: gradientCircle,
                class: "znpb-gradient-dragger",
                style: Vue.normalizeStyle(Vue.unref(colorPosition)),
                onDblclick: openColorPicker
              }, null, 36)
            ]),
            _: 1
          }, 8, ["show"])
        ]);
      };
    }
  }));
  var GradientDragger = /* @__PURE__ */ _export_sfc(_sfc_main$2J, [["__scopeId", "data-v-28fb396d"]]);
  var GradientColorConfig_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$23 = { class: "znpb-gradient-actions" };
  const _hoisted_2$1o = {
    key: 0,
    class: "znpb-gradient-actions__delete"
  };
  const __default__$V = {
    name: "GradientColorConfig"
  };
  const _sfc_main$2I = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$V), {
    props: {
      config: null,
      showDelete: { type: Boolean, default: true }
    },
    emits: ["delete-color", "update:modelValue"],
    setup(__props, { emit }) {
      const props = __props;
      const schema = {
        color: {
          type: "colorpicker",
          id: "color",
          width: "50"
        },
        position: {
          type: "number",
          id: "position",
          content: "%",
          width: "50",
          min: 0,
          max: 100
        }
      };
      const valueModel = Vue.computed({
        get() {
          const value = cloneDeep(props.config);
          if (Array.isArray(value.__dynamic_content__)) {
            value.__dynamic_content__ = {};
          }
          return value;
        },
        set(newValue) {
          emit("update:modelValue", newValue);
        }
      });
      return (_ctx, _cache) => {
        const _component_OptionsForm = Vue.resolveComponent("OptionsForm");
        return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$23, [
          Vue.createVNode(_component_OptionsForm, {
            modelValue: Vue.unref(valueModel),
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => Vue.isRef(valueModel) ? valueModel.value = $event : null),
            schema,
            class: "znpb-gradient-color-form"
          }, null, 8, ["modelValue"]),
          __props.showDelete ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_2$1o, [
            Vue.createVNode(_sfc_main$34, {
              icon: "close",
              class: "znpb-gradient-actions-delete",
              onClick: _cache[1] || (_cache[1] = Vue.withModifiers(($event) => _ctx.$emit("delete-color", __props.config), ["stop"]))
            })
          ])) : Vue.createCommentVNode("", true)
        ]);
      };
    }
  }));
  var GradientBar_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$22 = { class: "znpb-gradient-colors-legend" };
  const _hoisted_2$1n = { class: "znpb-form__input-title znpb-gradient-colors-legend-item" };
  const _hoisted_3$Y = { class: "znpb-form__input-title znpb-gradient-colors-legend-item" };
  const __default__$U = {
    name: "GradientBar"
  };
  const _sfc_main$2H = Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$U), {
    props: {
      modelValue: null
    },
    emits: ["update:modelValue"],
    setup(__props, { emit }) {
      const props = __props;
      const root2 = Vue.ref(null);
      const gradientbar = Vue.ref(null);
      const gradref = Vue.ref(null);
      const colorPickerOpen = Vue.ref(false);
      const deletedColorConfig = Vue.ref(null);
      const rafMovePosition = rafSchd$1(onCircleDrag);
      const rafEndDragging = rafSchd$1(disableDragging);
      let draggedCircleIndex;
      let draggedItem;
      const computedValue = Vue.computed({
        get() {
          return props.modelValue;
        },
        set(newValue) {
          emit("update:modelValue", newValue);
        }
      });
      const sortedColors = Vue.computed(() => {
        let colorsCopy = [...computedValue.value.colors].sort((a, b) => {
          return a.position > b.position ? 1 : -1;
        });
        return colorsCopy;
      });
      const activeDraggedItem = Vue.computed(() => {
        return computedValue.value.colors[draggedCircleIndex];
      });
      function onColorConfigUpdate(colorConfig, newValues) {
        const index2 = computedValue.value.colors.indexOf(colorConfig);
        const updatedValues = computedValue.value.colors.slice(0);
        updatedValues.splice(index2, 1, newValues);
        computedValue.value = __spreadProps(__spreadValues({}, computedValue.value), {
          colors: updatedValues
        });
      }
      function onDeleteColor(colorConfig) {
        const index2 = computedValue.value.colors.indexOf(colorConfig);
        const colorsClone = computedValue.value.colors.slice(0);
        deletedColorConfig.value = colorConfig;
        colorsClone.splice(index2, 1);
        computedValue.value = __spreadProps(__spreadValues({}, computedValue.value), {
          colors: colorsClone
        });
      }
      function reAddColor() {
        computedValue.value = __spreadProps(__spreadValues({}, computedValue.value), {
          colors: [...computedValue.value.colors, deletedColorConfig.value]
        });
        deletedColorConfig.value = null;
      }
      function addColor(event2) {
        const defaultColor = {
          color: "white",
          position: 0
        };
        const mouseLeftPosition = event2.clientX;
        const barOffset = root2.value.getBoundingClientRect();
        const startx = barOffset.left;
        const newLeft = mouseLeftPosition - startx;
        defaultColor.position = Math.round(newLeft / barOffset.width * 100);
        const updatedValues = __spreadProps(__spreadValues({}, computedValue.value), {
          colors: [...computedValue.value.colors, defaultColor]
        });
        computedValue.value = updatedValues;
      }
      function enableDragging(colorConfigIndex) {
        if (colorPickerOpen.value === false) {
          document.body.classList.add("znpb-color-gradient--backdrop");
          document.addEventListener("mousemove", rafMovePosition);
          document.addEventListener("mouseup", rafEndDragging);
          document.body.style.userSelect = "none";
          draggedCircleIndex = colorConfigIndex;
          draggedItem = computedValue.value.colors[colorConfigIndex];
          deletedColorConfig.value = null;
        }
      }
      function disableDragging() {
        document.body.classList.remove("znpb-color-gradient--backdrop");
        document.removeEventListener("mousemove", rafMovePosition);
        document.removeEventListener("mouseup", rafEndDragging);
        document.body.style.userSelect = "";
        deletedColorConfig.value = null;
        draggedCircleIndex = null;
      }
      function updateActiveConfigPosition(newPosition) {
        const newConfig = __spreadProps(__spreadValues({}, activeDraggedItem.value), {
          position: newPosition
        });
        onColorConfigUpdate(activeDraggedItem.value, newConfig);
      }
      function onCircleDrag(event2) {
        let newLeft = (event2.clientX - gradref.value.left) * 100 / gradref.value.width;
        const position = Math.min(Math.max(newLeft, 0), 100);
        if (newLeft > 100 || newLeft < 0) {
          if (sortedColors.value.length > 2 && deletedColorConfig.value === null) {
            onDeleteColor(draggedItem);
          }
        } else {
          if (deletedColorConfig.value !== null) {
            reAddColor();
          }
          Vue.nextTick(() => {
            updateActiveConfigPosition(Math.round(position));
          });
        }
      }
      Vue.onMounted(() => {
        Vue.nextTick(() => {
          gradref.value = gradientbar.value.getBoundingClientRect();
        });
      });
      Vue.onBeforeUnmount(() => {
        document.body.classList.remove("znpb-color-gradient--backdrop");
        disableDragging();
      });
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", {
          ref_key: "root",
          ref: root2,
          class: "znpb-gradient-bar-colors-wrapper"
        }, [
          Vue.createElementVNode("div", {
            ref_key: "gradientbar",
            ref: gradientbar,
            class: "znpb-gradient-bar-wrapper"
          }, [
            Vue.createVNode(_sfc_main$2L, {
              config: Vue.unref(computedValue),
              onClick: addColor
            }, null, 8, ["config"]),
            (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList(Vue.unref(computedValue).colors, (colorConfig, i) => {
              return Vue.openBlock(), Vue.createBlock(GradientDragger, {
                key: i,
                modelValue: colorConfig,
                "onUpdate:modelValue": ($event) => onColorConfigUpdate(colorConfig, $event),
                onColorPickerOpen: _cache[0] || (_cache[0] = ($event) => colorPickerOpen.value = $event),
                onMousedown: ($event) => enableDragging(i)
              }, null, 8, ["modelValue", "onUpdate:modelValue", "onMousedown"]);
            }), 128))
          ], 512),
          Vue.createElementVNode("div", _hoisted_1$22, [
            Vue.createElementVNode("span", _hoisted_2$1n, Vue.toDisplayString(_ctx.$translate("color")), 1),
            Vue.createElementVNode("span", _hoisted_3$Y, Vue.toDisplayString(_ctx.$translate("location")), 1)
          ]),
          (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList(Vue.unref(sortedColors), (colorConfig, i) => {
            return Vue.openBlock(), Vue.createBlock(_sfc_main$2I, {
              key: i,
              config: colorConfig,
              "show-delete": Vue.unref(sortedColors).length > 2,
              "onUpdate:modelValue": ($event) => onColorConfigUpdate(colorConfig, $event),
              onDeleteColor: ($event) => onDeleteColor(colorConfig)
            }, null, 8, ["config", "show-delete", "onUpdate:modelValue", "onDeleteColor"]);
          }), 128))
        ], 512);
      };
    }
  }));
  var InputWrapper_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$21 = { class: "znpb-forms-input-content" };
  const __default__$T = {
    name: "InputWrapper"
  };
  const _sfc_main$2G = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$T), {
    props: {
      title: { default: "" },
      description: { default: "" },
      layout: { default: "full" },
      fakeLabel: { type: Boolean },
      schema: null
    },
    setup(__props) {
      const props = __props;
      const computedWrapperStyle = Vue.computed(() => {
        const styles = {};
        if (props.schema !== void 0) {
          if (props.schema.grow) {
            styles.flex = props.schema.grow;
          }
          if (props.schema.width) {
            styles.width = `${props.schema.width}%`;
          }
        }
        return styles;
      });
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", {
          class: Vue.normalizeClass(["znpb-input-wrapper", {
            [`znpb-input-wrapper--${__props.layout}`]: true
          }]),
          style: Vue.normalizeStyle(Vue.unref(computedWrapperStyle))
        }, [
          __props.title ? (Vue.openBlock(), Vue.createElementBlock("div", {
            key: 0,
            class: Vue.normalizeClass(["znpb-form__input-title", { "znpb-form__input-title--fake-label": __props.fakeLabel }])
          }, [
            Vue.createElementVNode("span", null, Vue.toDisplayString(__props.title), 1),
            __props.description ? (Vue.openBlock(), Vue.createBlock(Vue.unref(Tooltip), {
              key: 0,
              enterable: false
            }, {
              content: Vue.withCtx(() => [
                Vue.createElementVNode("div", null, Vue.toDisplayString(__props.description), 1)
              ]),
              default: Vue.withCtx(() => [
                Vue.createVNode(Vue.unref(_sfc_main$34), { icon: "question-mark" })
              ]),
              _: 1
            })) : Vue.createCommentVNode("", true)
          ], 2)) : Vue.createCommentVNode("", true),
          Vue.createElementVNode("div", _hoisted_1$21, [
            Vue.renderSlot(_ctx.$slots, "default")
          ])
        ], 6);
      };
    }
  }));
  var InputRange_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$20 = { class: "znpb-input-range" };
  const _hoisted_2$1m = { class: "znpb-input-range__label" };
  const __default__$S = {
    name: "InputRange",
    inheritAttrs: false
  };
  const _sfc_main$2F = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$S), {
    props: {
      modelValue: { default: 0 },
      shift_step: { default: 10 },
      min: { default: 0 },
      max: { default: 100 },
      step: { default: 1 }
    },
    emits: ["update:modelValue"],
    setup(__props, { emit }) {
      const props = __props;
      const localStep = Vue.ref(props.step);
      const optionValue2 = Vue.computed({
        get() {
          var _a3;
          return (_a3 = props.modelValue) != null ? _a3 : props.min;
        },
        set(newValue) {
          emit("update:modelValue", +newValue);
        }
      });
      const trackWidth = Vue.computed(() => {
        const thumbSize = 14 * width.value / 100;
        return {
          width: `calc(${width.value}% - ${thumbSize}px)`
        };
      });
      const width = Vue.computed(() => {
        const minmax = props.max - props.min;
        return Math.round((props.modelValue - props.min) * 100 / minmax);
      });
      function onKeydown(event2) {
        if (event2.shiftKey) {
          localStep.value = props.shift_step;
        }
      }
      function onKeyUp(event2) {
        if (event2.key === "Shift") {
          localStep.value = props.step;
        }
      }
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$20, [
          Vue.createVNode(_sfc_main$31, {
            ref: "rangebase",
            modelValue: Vue.unref(optionValue2),
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => Vue.isRef(optionValue2) ? optionValue2.value = $event : null),
            type: "range",
            min: __props.min,
            max: __props.max,
            step: localStep.value,
            onKeydown,
            onKeyup: onKeyUp
          }, {
            suffix: Vue.withCtx(() => [
              Vue.createElementVNode("div", {
                class: "znpb-input-range__trackwidth",
                style: Vue.normalizeStyle(Vue.unref(trackWidth))
              }, null, 4)
            ]),
            _: 1
          }, 8, ["modelValue", "min", "max", "step"]),
          Vue.createElementVNode("label", _hoisted_2$1m, [
            Vue.createVNode(Vue.unref(_sfc_main$2Y), {
              modelValue: Vue.unref(optionValue2),
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => Vue.isRef(optionValue2) ? optionValue2.value = $event : null),
              class: "znpb-input-range-number",
              min: __props.min,
              max: __props.max,
              step: __props.step,
              shift_step: __props.shift_step,
              onKeydown,
              onKeyup: onKeyUp
            }, {
              default: Vue.withCtx(() => [
                Vue.renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["modelValue", "min", "max", "step", "shift_step"])
          ])
        ]);
      };
    }
  }));
  var InputRangeDynamic_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$1$ = { class: "znpb-input-range__label" };
  const __default__$R = {
    name: "InputRangeDynamic",
    inheritAttrs: false
  };
  const _sfc_main$2E = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$R), {
    props: {
      modelValue: { default: null },
      options: null,
      default_step: { default: 1 },
      default_shift_step: { default: 1 },
      min: null,
      max: null
    },
    emits: ["update:modelValue"],
    setup(__props, { emit }) {
      const props = __props;
      const rangebase = Vue.ref(null);
      const inputNumberUnit = Vue.ref(null);
      const step = Vue.ref(1);
      const unit = Vue.ref("");
      const customUnit = Vue.ref(false);
      const rafUpdateValue = rafSchd$1(updateValue);
      const activeOption = Vue.computed(() => {
        let activeOption2 = null;
        props.options.forEach((option) => {
          if (valueUnit.value && option.unit === valueUnit.value.unit) {
            activeOption2 = option;
          }
        });
        return activeOption2 || props.options[0];
      });
      const valueUnit = Vue.computed({
        get() {
          const match = typeof props.modelValue === "string" ? props.modelValue.match(/^([+-]?[0-9]+([.][0-9]*)?|[.][0-9]+)(\D+)$/) : null;
          const value = match && match[1] ? +match[1] : null;
          const unit2 = match ? match[3] : null;
          return {
            value,
            unit: unit2
          };
        },
        set(newValue) {
          if (newValue.value && newValue.unit) {
            if (Number(newValue.value) > activeOption.value.max) {
              computedValue.value = `${activeOption.value.max}${newValue.unit}`;
            } else if (Number(newValue.value) < activeOption.value.min) {
              computedValue.value = `${activeOption.value.min}${newValue.unit}`;
            }
          }
        }
      });
      const computedValue = Vue.computed({
        get() {
          return props.modelValue;
        },
        set(newValue) {
          rafUpdateValue(newValue);
        }
      });
      const rangeModel = Vue.computed({
        get() {
          return disabled.value ? 0 : valueUnit.value.value || props.min || 0;
        },
        set(newValue) {
          if (getUnit.value) {
            computedValue.value = `${newValue}${getUnit.value}`;
          }
        }
      });
      const getUnit = Vue.computed(() => {
        var _a3, _b, _c;
        return (_c = (_b = (_a3 = activeOption.value.unit) != null ? _a3 : valueUnit.value.unit) != null ? _b : unit.value) != null ? _c : null;
      });
      const getUnits = Vue.computed(() => props.options.map((option) => option.unit));
      const baseStep = Vue.computed(() => activeOption.value.step || props.default_step);
      const shiftStep = Vue.computed(() => activeOption.value.shiftStep || props.default_shift_step);
      const trackWidth = Vue.computed(() => {
        const thumbSize = 14 * width.value / 100;
        return {
          width: `calc(${width.value}% - ${thumbSize}px)`
        };
      });
      const width = Vue.computed(() => {
        const minmax = activeOption.value.max - activeOption.value.min;
        return Math.round((activeOption.value.value - activeOption.value.min) * 100 / minmax);
      });
      const disabled = Vue.computed(() => {
        const transformOriginUnits = ["left", "right", "top", "bottom", "center"];
        return transformOriginUnits.includes(unit.value) || customUnit.value;
      });
      function updateValue(newValue) {
        emit("update:modelValue", newValue);
      }
      function onUnitUpdate(event2) {
        unit.value = event2;
      }
      function onCustomUnit(event2) {
        customUnit.value = event2;
      }
      function onRangeKeydown(event2) {
        if (event2.shiftKey) {
          step.value = shiftStep.value;
        }
      }
      function onRangeKeyUp(event2) {
        if (event2.key === "Shift") {
          step.value = baseStep.value;
        }
      }
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", {
          class: Vue.normalizeClass(["znpb-input-range znpb-input-range--has-multiple-units", { ["znpb-input-range--disabled"]: Vue.unref(disabled) }])
        }, [
          Vue.createVNode(_sfc_main$31, {
            ref_key: "rangebase",
            ref: rangebase,
            modelValue: Vue.unref(rangeModel),
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => Vue.isRef(rangeModel) ? rangeModel.value = $event : null),
            type: "range",
            min: Vue.unref(activeOption).min,
            max: Vue.unref(activeOption).max,
            step: step.value,
            disabled: Vue.unref(disabled),
            onKeydown: onRangeKeydown,
            onKeyup: onRangeKeyUp
          }, {
            suffix: Vue.withCtx(() => [
              Vue.createElementVNode("div", {
                class: "znpb-input-range__trackwidth",
                style: Vue.normalizeStyle(Vue.unref(trackWidth))
              }, null, 4)
            ]),
            _: 1
          }, 8, ["modelValue", "min", "max", "step", "disabled"]),
          Vue.createElementVNode("label", _hoisted_1$1$, [
            Vue.createVNode(Vue.unref(_sfc_main$2X), {
              ref_key: "inputNumberUnit",
              ref: inputNumberUnit,
              modelValue: Vue.unref(computedValue),
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => Vue.isRef(computedValue) ? computedValue.value = $event : null),
              class: "znpb-input-range-number",
              min: Vue.unref(activeOption).min,
              max: Vue.unref(activeOption).max,
              units: Vue.unref(getUnits),
              step: step.value,
              shift_step: Vue.unref(shiftStep),
              onIsCustomUnit: onCustomUnit,
              onUnitUpdate
            }, null, 8, ["modelValue", "min", "max", "units", "step", "shift_step"])
          ])
        ], 2);
      };
    }
  }));
  const __default__$Q = {
    name: "Tab"
  };
  const _sfc_main$2D = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$Q), {
    props: {
      name: null,
      icon: null,
      id: null,
      active: { type: Boolean }
    },
    setup(__props) {
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock(Vue.Fragment, null, [
          Vue.renderSlot(_ctx.$slots, "title"),
          Vue.renderSlot(_ctx.$slots, "default")
        ], 64);
      };
    }
  }));
  var Tabs_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$1_ = ["onClick"];
  const __default__$P = {
    name: "Tabs"
  };
  const _sfc_main$2C = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$P), {
    props: {
      tabStyle: { default: "card" },
      titlePosition: { default: "start" },
      activeTab: { default: null },
      hasScroll: { default: () => [] }
    },
    emits: ["update:activeTab", "changed-tab"],
    setup(__props, { emit }) {
      var _a3;
      const props = __props;
      const tabs = Vue.ref();
      const activeTab = Vue.ref(props.activeTab);
      Vue.watch(
        () => props.activeTab,
        (newValue) => {
          activeTab.value = newValue;
        }
      );
      function RenderComponent(props2) {
        return typeof props2["render-slot"] === "string" ? props2["render-slot"] : props2["render-slot"]();
      }
      function getIdForTab(tab) {
        var _a4;
        if (!tab) {
          return;
        }
        const props2 = tab.props;
        return (_a4 = props2 == null ? void 0 : props2.id) != null ? _a4 : kebabCase$1(props2.name);
      }
      const slots = Vue.useSlots();
      if (slots.default) {
        tabs.value = getTabs(slots.default()).filter((child) => child.type.name === "Tab");
        activeTab.value = (_a3 = activeTab.value) != null ? _a3 : getIdForTab(tabs.value[0]);
      }
      function getTabs(vNodes) {
        let tabs2 = [];
        vNodes.forEach((tab) => {
          if (tab.type === Vue.Fragment) {
            tabs2 = [...tabs2, ...getTabs(tab.children)];
          } else {
            tabs2.push(tab);
          }
        });
        return tabs2;
      }
      function selectTab(tab) {
        const tabId2 = getIdForTab(tab);
        activeTab.value = tabId2;
        emit("changed-tab", tabId2);
        emit("update:activeTab", tabId2);
      }
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", {
          class: Vue.normalizeClass(["znpb-tabs", { [`znpb-tabs--${__props.tabStyle}`]: __props.tabStyle }])
        }, [
          Vue.createElementVNode("div", {
            class: Vue.normalizeClass(["znpb-tabs__header", { [`znpb-tabs__header--${__props.titlePosition}`]: __props.titlePosition }])
          }, [
            (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList(tabs.value, (tab, index2) => {
              var _a4, _b;
              return Vue.openBlock(), Vue.createElementBlock("div", {
                key: index2,
                class: Vue.normalizeClass(["znpb-tabs__header-item", {
                  "znpb-tabs__header-item--active": getIdForTab(tab) === activeTab.value,
                  [`znpb-tabs__header-item--${getIdForTab(tab)}`]: true
                }]),
                onClick: ($event) => selectTab(tab)
              }, [
                Vue.createVNode(RenderComponent, {
                  "render-slot": (_b = (_a4 = tab == null ? void 0 : tab.children) == null ? void 0 : _a4.title) != null ? _b : tab.props.name
                }, null, 8, ["render-slot"])
              ], 10, _hoisted_1$1_);
            }), 128))
          ], 2),
          Vue.createElementVNode("div", {
            class: Vue.normalizeClass(["znpb-tabs__content", { "znpb-fancy-scrollbar": __props.hasScroll }])
          }, [
            (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList(tabs.value, (tab, index2) => {
              var _a4;
              return Vue.withDirectives((Vue.openBlock(), Vue.createElementBlock("div", {
                key: index2,
                class: "znpb-tab__wrapper"
              }, [
                getIdForTab(tab) === activeTab.value ? (Vue.openBlock(), Vue.createBlock(RenderComponent, {
                  key: 0,
                  "render-slot": (_a4 = tab == null ? void 0 : tab.children) == null ? void 0 : _a4.default
                }, null, 8, ["render-slot"])) : Vue.createCommentVNode("", true)
              ])), [
                [Vue.vShow, getIdForTab(tab) === activeTab.value]
              ]);
            }), 128))
          ], 2)
        ], 2);
      };
    }
  }));
  var GradientOptions_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$1Z = { class: "znpb-gradient-options-wrapper" };
  const _hoisted_2$1l = { class: "znpb-radial-postion-wrapper" };
  const __default__$O = {
    name: "GradientOptions"
  };
  const _sfc_main$2B = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$O), {
    props: {
      modelValue: null
    },
    emits: ["update:modelValue"],
    setup(__props, { emit }) {
      const props = __props;
      const computedValue = Vue.computed({
        get() {
          return props.modelValue;
        },
        set(newValue) {
          emit("update:modelValue", newValue);
        }
      });
      const computedAngle = Vue.computed({
        get() {
          return computedValue.value.angle;
        },
        set(newValue) {
          computedValue.value = __spreadProps(__spreadValues({}, computedValue.value), {
            angle: newValue
          });
        }
      });
      const computedPosition = Vue.computed({
        get() {
          return computedValue.value.position || {};
        },
        set(newValue) {
          computedValue.value = __spreadProps(__spreadValues({}, computedValue.value), {
            position: newValue
          });
        }
      });
      const computedPositionX = Vue.computed({
        get() {
          var _a3;
          return ((_a3 = computedValue.value.position) == null ? void 0 : _a3.x) || 50;
        },
        set(newValue) {
          computedPosition.value = __spreadProps(__spreadValues({}, computedPosition.value), {
            x: newValue
          });
        }
      });
      const computedPositionY = Vue.computed({
        get() {
          var _a3;
          return ((_a3 = computedValue.value.position) == null ? void 0 : _a3.y) || 50;
        },
        set(newValue) {
          computedPosition.value = __spreadProps(__spreadValues({}, computedPosition.value), {
            y: newValue
          });
        }
      });
      function onTabChange(tabId2) {
        computedValue.value = __spreadProps(__spreadValues({}, computedValue.value), {
          type: tabId2
        });
      }
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$1Z, [
          Vue.createVNode(Vue.unref(_sfc_main$2G), {
            title: _ctx.$translate("gradient_type"),
            class: "znpb-gradient__type"
          }, {
            default: Vue.withCtx(() => [
              Vue.createVNode(Vue.unref(_sfc_main$2C), {
                "tab-style": "minimal",
                "active-tab": Vue.unref(computedValue).type,
                onChangedTab: onTabChange
              }, {
                default: Vue.withCtx(() => [
                  Vue.createVNode(Vue.unref(_sfc_main$2D), { name: "Linear" }, {
                    default: Vue.withCtx(() => [
                      Vue.createVNode(Vue.unref(_sfc_main$2G), {
                        title: _ctx.$translate("gradient_angle"),
                        class: "znpb-gradient__angle"
                      }, {
                        default: Vue.withCtx(() => [
                          Vue.createVNode(Vue.unref(_sfc_main$2F), {
                            modelValue: Vue.unref(computedAngle),
                            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => Vue.isRef(computedAngle) ? computedAngle.value = $event : null),
                            min: 0,
                            max: 360,
                            step: 1
                          }, {
                            default: Vue.withCtx(() => [
                              Vue.createTextVNode("deg")
                            ]),
                            _: 1
                          }, 8, ["modelValue"])
                        ]),
                        _: 1
                      }, 8, ["title"])
                    ]),
                    _: 1
                  }),
                  Vue.createVNode(Vue.unref(_sfc_main$2D), { name: "Radial" }, {
                    default: Vue.withCtx(() => [
                      Vue.createElementVNode("div", _hoisted_2$1l, [
                        Vue.createVNode(Vue.unref(_sfc_main$2G), {
                          title: "Position X",
                          layout: "inline"
                        }, {
                          default: Vue.withCtx(() => [
                            Vue.createVNode(Vue.unref(_sfc_main$2Y), {
                              modelValue: Vue.unref(computedPositionX),
                              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => Vue.isRef(computedPositionX) ? computedPositionX.value = $event : null),
                              min: 0,
                              max: 100,
                              step: 1
                            }, {
                              default: Vue.withCtx(() => [
                                Vue.createTextVNode(" % ")
                              ]),
                              _: 1
                            }, 8, ["modelValue"])
                          ]),
                          _: 1
                        }),
                        Vue.createVNode(Vue.unref(_sfc_main$2G), {
                          title: "Position Y",
                          layout: "inline"
                        }, {
                          default: Vue.withCtx(() => [
                            Vue.createVNode(Vue.unref(_sfc_main$2Y), {
                              modelValue: Vue.unref(computedPositionY),
                              "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => Vue.isRef(computedPositionY) ? computedPositionY.value = $event : null),
                              min: 0,
                              max: 100,
                              step: 1
                            }, {
                              default: Vue.withCtx(() => [
                                Vue.createTextVNode(" % ")
                              ]),
                              _: 1
                            }, 8, ["modelValue"])
                          ]),
                          _: 1
                        })
                      ])
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }, 8, ["active-tab"])
            ]),
            _: 1
          }, 8, ["title"]),
          Vue.createVNode(Vue.unref(_sfc_main$2G), {
            title: _ctx.$translate("gradient_bar")
          }, {
            default: Vue.withCtx(() => [
              Vue.createVNode(_sfc_main$2H, {
                modelValue: Vue.unref(computedValue),
                "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => Vue.isRef(computedValue) ? computedValue.value = $event : null),
                class: "znpb-gradient__bar"
              }, null, 8, ["modelValue"])
            ]),
            _: 1
          }, 8, ["title"])
        ]);
      };
    }
  }));
  var OneGradient_vue_vue_type_style_index_0_scoped_true_lang = "";
  const _hoisted_1$1Y = { class: "znpb-gradient-preview-transparent" };
  const __default__$N = {
    name: "OneGradient"
  };
  const _sfc_main$2A = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$N), {
    props: {
      config: null,
      round: { type: Boolean }
    },
    setup(__props) {
      const props = __props;
      const getGradientPreviewStyle = Vue.computed(() => {
        const style = {};
        const gradient = [];
        const colors = [];
        let position = "90deg";
        const colorsCopy = [...props.config.colors].sort((a, b) => {
          return a.position > b.position ? 1 : -1;
        });
        colorsCopy.forEach((color) => {
          colors.push(`${color.color} ${color.position}%`);
        });
        if (props.config.type === "radial") {
          const { x, y } = props.config.position || { x: 50, y: 50 };
          position = `circle at ${x}% ${y}%`;
        } else {
          position = `${props.config.angle}deg`;
        }
        gradient.push(`${props.config.type}-gradient(${position}, ${colors.join(", ")})`);
        style["background"] = gradient.join(", ");
        return style;
      });
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$1Y, [
          Vue.createElementVNode("div", {
            class: Vue.normalizeClass(["znpb-gradient-preview", { "gradient-type-rounded": __props.round }]),
            style: Vue.normalizeStyle(Vue.unref(getGradientPreviewStyle))
          }, null, 6)
        ]);
      };
    }
  }));
  var OneGradient = /* @__PURE__ */ _export_sfc(_sfc_main$2A, [["__scopeId", "data-v-08436a44"]]);
  var GradientElement_vue_vue_type_style_index_0_lang = "";
  const __default__$M = {
    name: "GradientElement"
  };
  const _sfc_main$2z = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$M), {
    props: {
      config: null,
      showRemove: { type: Boolean, default: true },
      isActive: { type: Boolean }
    },
    emits: ["change-active-gradient", "delete-gradient"],
    setup(__props) {
      const props = __props;
      const localConfig = Vue.computed({
        get() {
          return props.config;
        },
        set(newConfig) {
          localConfig.value = newConfig;
        }
      });
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", {
          class: Vue.normalizeClass(["znpb-gradient-element", { "znpb-gradient-element--active": __props.isActive }])
        }, [
          Vue.createVNode(OneGradient, {
            round: true,
            config: Vue.unref(localConfig),
            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("change-active-gradient", __props.config))
          }, null, 8, ["config"]),
          __props.showRemove ? (Vue.openBlock(), Vue.createBlock(_sfc_main$34, {
            key: 0,
            icon: "close",
            onClick: _cache[1] || (_cache[1] = Vue.withModifiers(($event) => _ctx.$emit("delete-gradient"), ["stop"]))
          })) : Vue.createCommentVNode("", true)
        ], 2);
      };
    }
  }));
  const cache$1 = Vue.ref({});
  function useSelectServerData(config) {
    let requester = Vue.inject("serverRequester", null);
    const items2 = Vue.ref([]);
    if (!requester) {
      if (window.zb.admin) {
        requester = window.zb.admin.serverRequest;
      }
    }
    function fetch2(config2) {
      if (!requester) {
        return Promise.reject("Server requester not provided");
      }
      const cacheKey = generateCacheKey(Vue.toRaw(config2));
      const saveItemsCache = generateItemsCacheKey(Vue.toRaw(config2));
      if (cache$1[cacheKey]) {
        saveItems(saveItemsCache, cache$1[cacheKey]);
        return Promise.resolve(cache$1[cacheKey]);
      } else {
        return new Promise((resolve, reject) => {
          config2.useCache = true;
          requester.request(
            {
              type: "get_input_select_options",
              config: config2
            },
            (response) => {
              saveItems(saveItemsCache, response.data);
              resolve(response.data);
            },
            function(message) {
              reject(message);
            }
          );
        });
      }
    }
    function getItems(config2) {
      const saveItemsCache = generateItemsCacheKey(Vue.toRaw(config2));
      return get(items2.value, saveItemsCache, []);
    }
    function getItem(config2, id) {
      const saveItemsCache = generateItemsCacheKey(Vue.toRaw(config2));
      const cachedItems = get(items2.value, saveItemsCache, []);
      return cachedItems.find((item) => item.id === id);
    }
    function generateItemsCacheKey(config2) {
      const { server_callback_method, server_callback_args } = config2;
      return hash$2({
        server_callback_method,
        server_callback_args
      });
    }
    function generateCacheKey(data2) {
      const _a3 = data2, { server_callback_method, server_callback_args, page, searchKeyword } = _a3, remainingProperties = __objRest(_a3, ["server_callback_method", "server_callback_args", "page", "searchKeyword"]);
      return hash$2({
        server_callback_method,
        server_callback_args,
        page,
        searchKeyword
      });
    }
    function saveItems(key, newItems) {
      const existingItems = get(items2.value, key, []);
      items2.value[key] = unionBy$1(existingItems, newItems, "id");
    }
    return {
      fetch: fetch2,
      getItem,
      getItems
    };
  }
  var InputSelect_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$2y = {
    name: "InputSelect",
    props: {
      modelValue: {
        type: [String, Number, Array, Boolean]
      },
      options: {
        type: Array,
        default: []
      },
      filterable: {
        type: Boolean
      },
      server_callback_method: {
        type: String
      },
      server_callback_args: {},
      server_callback_per_page: {
        type: Number,
        default: 25
      },
      placeholder: {
        type: String
      },
      placement: {
        type: String,
        required: false,
        default: "bottom"
      },
      style_type: {
        type: String,
        required: false
      },
      addable: {
        type: Boolean,
        required: false,
        default: false
      },
      multiple: {
        type: Boolean,
        required: false,
        default: false
      },
      local_callback_method: {
        type: String,
        required: false
      },
      filter_id: {
        type: String,
        required: false
      }
    },
    setup(props, { emit }) {
      const optionWrapper = Vue.ref(null);
      const searchInput = Vue.ref(null);
      const searchKeyword = Vue.ref("");
      const showDropdown = Vue.ref(false);
      const loading = Vue.ref(false);
      const loadingTitle = Vue.ref(false);
      const stopSearch = Vue.ref(false);
      const tooltipWidth = Vue.ref(null);
      const elementInfo = Vue.inject("elementInfo", null);
      let page = 1;
      const { fetch: fetch2, getItems } = useSelectServerData();
      const computedModelValue = Vue.computed(() => {
        if (props.modelValue && props.multiple && !Array.isArray(props.modelValue)) {
          return [props.modelValue];
        }
        if (!props.modelValue && props.multiple) {
          return [];
        }
        return props.modelValue;
      });
      const items2 = Vue.computed(() => {
        let options2 = [...props.options];
        if (props.server_callback_method) {
          const serverOptions = getItems({
            server_callback_method: props.server_callback_method,
            server_callback_args: props.server_callback_args
          });
          if (serverOptions.length > 0) {
            options2.push(...serverOptions);
          }
        }
        if (props.addable && props.modelValue) {
          if (props.multiple) {
            computedModelValue.value.forEach((savedValue) => {
              if (!options2.find((option) => option.id === savedValue)) {
                options2.push({
                  name: savedValue,
                  id: savedValue
                });
              }
            });
          } else if (!options2.find((option) => option.id === computedModelValue.value)) {
            options2.push({
              name: props.modelValue,
              id: props.modelValue
            });
          }
        }
        if (props.local_callback_method) {
          const localOptions = window[props.local_callback_method];
          if (typeof localOptions === "function") {
            options2.push(...localOptions(options2, elementInfo));
          }
        }
        if (props.filter_id) {
          const { applyFilters: applyFilters2 } = window.zb.hooks;
          options2 = applyFilters2(props.filter_id, options2, Vue.unref(elementInfo));
        }
        options2 = options2.map((option) => {
          let isSelected = false;
          if (props.multiple) {
            isSelected = computedModelValue.value.includes(option.id);
          } else {
            isSelected = computedModelValue.value === option.id;
          }
          return __spreadProps(__spreadValues({}, option), {
            isSelected
          });
        });
        return options2;
      });
      const visibleItems = Vue.computed(() => {
        let options2 = items2.value;
        if (props.filterable || props.addable) {
          if (searchKeyword.value.length > 0) {
            options2 = options2.filter((optionConfig) => {
              return optionConfig.name.toLowerCase().indexOf(searchKeyword.value.toLowerCase()) !== -1;
            });
          }
        }
        if (props.multiple) {
          options2.sort((item) => item.isSelected ? -1 : 1);
        }
        return options2;
      });
      Vue.watch(searchKeyword, () => {
        stopSearch.value = false;
        debouncedGetItems();
      });
      Vue.watch(showDropdown, (newValue) => {
        if (!newValue) {
          searchKeyword.value = "";
        }
      });
      const debouncedGetItems = debounce$1(() => {
        loadNext();
      }, 300);
      function loadNext() {
        if (!props.server_callback_method) {
          return;
        }
        if (loading.value) {
          return;
        }
        loading.value = true;
        const include = props.modelValue;
        fetch2({
          server_callback_method: props.server_callback_method,
          server_callback_args: props.server_callback_args,
          page,
          searchKeyword: searchKeyword.value,
          include
        }).then((response) => {
          if (props.server_callback_per_page === -1) {
            stopSearch.value = true;
          } else if (response.length < props.server_callback_per_page) {
            stopSearch.value = true;
          }
          loading.value = false;
          loadingTitle.value = false;
        });
      }
      function onScrollEnd() {
        if (!props.server_callback_method) {
          return;
        }
        if (props.server_callback_per_page === -1) {
          return;
        }
        if (!stopSearch.value) {
          page++;
          loadNext();
        }
      }
      if (props.server_callback_method) {
        loadNext();
      }
      const showPlaceholder = Vue.computed(() => {
        return typeof props.modelValue === "undefined" || props.multiple && computedModelValue.value.length === 0;
      });
      const dropdownPlaceholder = Vue.computed(() => {
        if (showPlaceholder.value) {
          return props.placeholder;
        } else {
          if (props.multiple) {
            const activeTitles = items2.value.filter((option) => computedModelValue.value.includes(option.id));
            if (activeTitles) {
              return activeTitles.map((item) => item.name).join(", ");
            } else if (props.addable) {
              return computedModelValue.value.join(",");
            }
          } else {
            const activeTitle = items2.value.find((option) => option.id === computedModelValue.value);
            if (activeTitle) {
              return activeTitle.name;
            } else if (props.addable) {
              return props.modelValue;
            }
          }
          return null;
        }
      });
      Vue.watchEffect(() => {
        if (dropdownPlaceholder.value === null && props.server_callback_method) {
          loadingTitle.value = true;
        }
      });
      function onOptionSelect(option) {
        if (props.multiple) {
          const oldValues = [...computedModelValue.value];
          if (option.isSelected) {
            const selectedOptionIndex = oldValues.indexOf(option.id);
            oldValues.splice(selectedOptionIndex, 1);
            emit("update:modelValue", oldValues);
          } else {
            oldValues.push(option.id);
            emit("update:modelValue", oldValues);
          }
        } else {
          emit("update:modelValue", option.id);
          showDropdown.value = false;
        }
      }
      function onModalShow() {
        if (optionWrapper.value) {
          tooltipWidth.value = optionWrapper.value.getBoundingClientRect().width;
        }
        if ((props.filterable || props.addable) && searchInput.value) {
          searchInput.value.focus();
        }
      }
      function getStyle(font) {
        if (props.style_type === "font-select") {
          return {
            fontFamily: font
          };
        } else
          return null;
      }
      function addItem() {
        onOptionSelect({
          name: searchKeyword.value,
          id: searchKeyword.value
        });
        showDropdown.value = false;
      }
      function onInputKeydown(event2) {
        if (props.addable && event2.keyCode === 13) {
          addItem();
        }
      }
      return {
        optionWrapper,
        tooltipWidth,
        searchInput,
        searchKeyword,
        dropdownPlaceholder,
        onOptionSelect,
        onScrollEnd,
        onModalShow,
        getStyle,
        addItem,
        onInputKeydown,
        loading,
        showDropdown,
        stopSearch,
        items: items2,
        loadingTitle,
        visibleItems,
        showPlaceholder
      };
    }
  };
  const _hoisted_1$1X = {
    key: 1,
    class: "znpb-option-selectOptionPlaceholderText"
  };
  const _hoisted_2$1k = { class: "znpb-inputDropdownIcon-wrapper" };
  const _hoisted_3$X = { class: "znpb-option-selectOptionListWrapper" };
  const _hoisted_4$C = ["onClick"];
  const _hoisted_5$t = {
    key: 1,
    class: "znpb-option-selectOptionListNoMoreText"
  };
  function _sfc_render$18(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Loader = Vue.resolveComponent("Loader");
    const _component_Icon = Vue.resolveComponent("Icon");
    const _component_BaseInput = Vue.resolveComponent("BaseInput");
    const _component_ListScroll = Vue.resolveComponent("ListScroll");
    const _component_Tooltip = Vue.resolveComponent("Tooltip");
    const _directive_znpb_tooltip = Vue.resolveDirective("znpb-tooltip");
    return Vue.openBlock(), Vue.createBlock(_component_Tooltip, {
      show: $setup.showDropdown,
      "onUpdate:show": _cache[2] || (_cache[2] = ($event) => $setup.showDropdown = $event),
      "append-to": "element",
      placement: $props.placement,
      trigger: "click",
      "close-on-outside-click": true,
      "tooltip-class": "znpb-option-selectTooltip hg-popper--no-padding",
      class: "znpb-option-selectWrapper",
      "tooltip-style": { width: $setup.tooltipWidth + "px" },
      "show-arrows": false,
      strategy: "fixed",
      modifiers: [
        {
          name: "preventOverflow",
          enabled: true
        },
        {
          name: "hide",
          enabled: true
        },
        {
          name: "flip",
          options: {
            fallbackPlacements: ["bottom", "top", "right", "left"]
          }
        }
      ],
      onShow: $setup.onModalShow
    }, {
      content: Vue.withCtx(() => [
        Vue.createElementVNode("div", _hoisted_3$X, [
          $props.filterable || $props.addable ? (Vue.openBlock(), Vue.createBlock(_component_BaseInput, {
            key: 0,
            ref: "searchInput",
            modelValue: $setup.searchKeyword,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.searchKeyword = $event),
            class: "znpb-option-selectOptionListSearchInput",
            placeholder: $props.addable ? _ctx.$translate("search_or_add") : _ctx.$translate("search"),
            clearable: true,
            icon: "search",
            autocomplete: "off",
            onKeydown: $setup.onInputKeydown
          }, Vue.createSlots({ _: 2 }, [
            $props.addable && $setup.searchKeyword.length > 0 ? {
              name: "after-input",
              fn: Vue.withCtx(() => [
                Vue.withDirectives(Vue.createVNode(_component_Icon, {
                  icon: "plus",
                  class: "znpb-inputAddableIcon",
                  onClick: Vue.withModifiers($setup.addItem, ["stop", "prevent"])
                }, null, 8, ["onClick"]), [
                  [_directive_znpb_tooltip, _ctx.$translate("add_new_item")]
                ])
              ]),
              key: "0"
            } : void 0
          ]), 1032, ["modelValue", "placeholder", "onKeydown"])) : Vue.createCommentVNode("", true),
          Vue.createVNode(_component_ListScroll, {
            loading: $setup.loading,
            "onUpdate:loading": _cache[1] || (_cache[1] = ($event) => $setup.loading = $event),
            class: "znpb-menuList znpb-mh-200",
            onScrollEnd: $setup.onScrollEnd
          }, {
            default: Vue.withCtx(() => [
              (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList($setup.visibleItems, (option) => {
                return Vue.openBlock(), Vue.createElementBlock("div", {
                  key: option.id,
                  class: Vue.normalizeClass(["znpb-menuListItem", {
                    "znpb-menuListItem--selected": !option.is_label && option.isSelected,
                    "znpb-menuListItem--is-label": option.is_label,
                    "znpb-menuListItem--is-group_item": option.is_group_item
                  }]),
                  style: Vue.normalizeStyle($setup.getStyle(option.name)),
                  onClick: Vue.withModifiers(($event) => $setup.onOptionSelect(option), ["stop"])
                }, Vue.toDisplayString(option.name), 15, _hoisted_4$C);
              }), 128))
            ]),
            _: 1
          }, 8, ["loading", "onScrollEnd"]),
          $setup.stopSearch ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_5$t, Vue.toDisplayString(_ctx.$translate("no_more_items")), 1)) : Vue.createCommentVNode("", true)
        ])
      ]),
      default: Vue.withCtx(() => [
        Vue.createElementVNode("div", {
          ref: "optionWrapper",
          class: Vue.normalizeClass(["znpb-option-selectOptionPlaceholder", {
            [`znpb-option-selectOptionPlaceholder--real`]: $setup.showPlaceholder
          }])
        }, [
          $setup.loadingTitle ? (Vue.openBlock(), Vue.createBlock(_component_Loader, {
            key: 0,
            size: 14
          })) : (Vue.openBlock(), Vue.createElementBlock("span", _hoisted_1$1X, Vue.toDisplayString($setup.dropdownPlaceholder), 1)),
          Vue.createElementVNode("span", _hoisted_2$1k, [
            Vue.createVNode(_component_Icon, {
              icon: "select",
              class: "znpb-inputDropdownIcon",
              rotate: $setup.showDropdown ? "180" : false
            }, null, 8, ["rotate"])
          ])
        ], 2)
      ]),
      _: 1
    }, 8, ["show", "placement", "tooltip-style", "onShow"]);
  }
  var InputSelect = /* @__PURE__ */ _export_sfc(_sfc_main$2y, [["render", _sfc_render$18]]);
  var PresetInput_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$1W = { class: "znpb-preset-input-wrapper" };
  const __default__$L = {
    name: "PresetInput"
  };
  const _sfc_main$2x = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$L), {
    props: {
      isGradient: { type: Boolean, default: true }
    },
    emits: ["save-preset", "cancel"],
    setup(__props, { emit }) {
      const props = __props;
      const presetName = Vue.ref("");
      const gradientType = Vue.ref("local");
      const hasError = Vue.ref(false);
      const { translate: translate2 } = window.zb.i18n;
      const gradientTypes = Vue.ref([
        {
          id: "local",
          name: translate2("local")
        },
        {
          id: "global",
          name: translate2("global")
        }
      ]);
      function savePreset() {
        if (presetName.value.length === 0) {
          hasError.value = true;
          return;
        }
        if (props.isGradient) {
          emit("save-preset", presetName.value, gradientType.value);
        } else {
          emit("save-preset", presetName.value);
        }
      }
      Vue.watch(hasError, (newValue) => {
        if (newValue) {
          setTimeout(() => {
            hasError.value = false;
          }, 500);
        }
      });
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$1W, [
          Vue.createVNode(Vue.unref(_sfc_main$31), {
            modelValue: presetName.value,
            "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => presetName.value = $event),
            placeholder: __props.isGradient ? _ctx.$translate("save_gradient_title") : _ctx.$translate("add_preset_title"),
            class: Vue.normalizeClass({ "znpb-backgroundGradient__nameInput": __props.isGradient }),
            error: hasError.value
          }, Vue.createSlots({ _: 2 }, [
            __props.isGradient ? {
              name: "prepend",
              fn: Vue.withCtx(() => [
                Vue.createVNode(Vue.unref(InputSelect), {
                  modelValue: gradientType.value,
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => gradientType.value = $event),
                  class: "znpb-backgroundGradient__typeDropdown",
                  options: gradientTypes.value,
                  placeholder: "Type"
                }, null, 8, ["modelValue", "options"])
              ]),
              key: "0"
            } : {
              name: "append",
              fn: Vue.withCtx(() => [
                Vue.createVNode(Vue.unref(_sfc_main$34), {
                  icon: "check",
                  onMousedown: Vue.withModifiers(savePreset, ["stop"])
                }, null, 8, ["onMousedown"]),
                Vue.createVNode(Vue.unref(_sfc_main$34), {
                  icon: "close",
                  onMousedown: _cache[1] || (_cache[1] = Vue.withModifiers(($event) => _ctx.$emit("cancel", true), ["prevent"]))
                })
              ]),
              key: "1"
            }
          ]), 1032, ["modelValue", "placeholder", "class", "error"]),
          __props.isGradient ? (Vue.openBlock(), Vue.createElementBlock(Vue.Fragment, { key: 0 }, [
            Vue.createVNode(Vue.unref(_sfc_main$34), {
              icon: "check",
              class: "znpb-backgroundGradient__action",
              onClick: Vue.withModifiers(savePreset, ["stop"])
            }, null, 8, ["onClick"]),
            Vue.createVNode(Vue.unref(_sfc_main$34), {
              icon: "close",
              class: "znpb-backgroundGradient__action",
              onClick: _cache[3] || (_cache[3] = Vue.withModifiers(($event) => _ctx.$emit("cancel", true), ["stop"]))
            })
          ], 64)) : Vue.createCommentVNode("", true)
        ]);
      };
    }
  }));
  var HostsManager = () => {
    let hosts2 = [];
    let iframes = [];
    const getHosts = () => {
      return hosts2;
    };
    const getIframes = () => {
      return iframes;
    };
    const resetHosts = () => {
      hosts2 = [document];
      iframes = [];
    };
    const fetchHosts = () => {
      resetHosts();
      const DOMIframes = document.querySelectorAll("iframe");
      DOMIframes.forEach((iframe) => {
        if (iframe.contentDocument) {
          hosts2.push(iframe.contentDocument);
          iframes.push(iframe);
        }
      });
      return globalThis;
    };
    return {
      getHosts,
      getIframes,
      fetchHosts
    };
  };
  var EventsManager = () => {
    let handled = false;
    const handle = () => {
      handled = true;
    };
    const isHandled = () => {
      return handled;
    };
    const reset = () => {
      handled = false;
    };
    return {
      handle,
      isHandled,
      reset
    };
  };
  function matches(element, value, context = null) {
    if (!value) {
      return false;
    } else if (value === "> *") {
      return matches(element.parentElement, context);
    } else if (value instanceof HTMLElement && value.nodeType > 0) {
      return element === value;
    } else if (typeof value === "string") {
      return element.matches(value);
    } else if (value instanceof NodeList || value instanceof Array) {
      return [...value].includes(element);
    } else if (typeof value === "function") {
      return value(element);
    }
    return false;
  }
  function closest(element, target, context = null) {
    let current = element;
    do {
      if (current && matches(current, target, context)) {
        return current;
      }
      if (current === context) {
        return false;
      }
      current = current.parentElement;
    } while (current && current !== document.body);
    return null;
  }
  var safeIsNaN = Number.isNaN || function ponyfill(value) {
    return typeof value === "number" && value !== value;
  };
  function isEqual(first, second) {
    if (first === second) {
      return true;
    }
    if (safeIsNaN(first) && safeIsNaN(second)) {
      return true;
    }
    return false;
  }
  function areInputsEqual(newInputs, lastInputs) {
    if (newInputs.length !== lastInputs.length) {
      return false;
    }
    for (var i = 0; i < newInputs.length; i++) {
      if (!isEqual(newInputs[i], lastInputs[i])) {
        return false;
      }
    }
    return true;
  }
  function memoizeOne(resultFn, isEqual2) {
    if (isEqual2 === void 0) {
      isEqual2 = areInputsEqual;
    }
    var cache2 = null;
    function memoized() {
      var newArgs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        newArgs[_i] = arguments[_i];
      }
      if (cache2 && cache2.lastThis === this && isEqual2(newArgs, cache2.lastArgs)) {
        return cache2.lastResult;
      }
      var lastResult = resultFn.apply(this, newArgs);
      cache2 = {
        lastResult,
        lastArgs: newArgs,
        lastThis: this
      };
      return lastResult;
    }
    memoized.clear = function clear() {
      cache2 = null;
    };
    return memoized;
  }
  var EventScheduler = (callbacks) => {
    const memoizedMove = memoizeOne((event2) => {
      callbacks.onMove(event2);
    });
    const move = rafSchd$1(memoizedMove);
    const cancel = () => {
      move.cancel();
    };
    return {
      move,
      cancel
    };
  };
  const _AbstractEvent = class {
    constructor(data2) {
      __publicField(this, "cancelled");
      __publicField(this, "data");
      this.cancelled = false;
      this.data = data2;
    }
    isCanceled() {
      return this.cancelled;
    }
    cancel() {
      if (this.isCancelable) {
        this.cancelled = true;
      }
    }
    get type() {
      return _AbstractEvent.type;
    }
    get isCancelable() {
      return _AbstractEvent.cancelable;
    }
  };
  let AbstractEvent = _AbstractEvent;
  __publicField(AbstractEvent, "type", "Event");
  __publicField(AbstractEvent, "cancelable", false);
  class MoveEvent extends AbstractEvent {
  }
  __publicField(MoveEvent, "type", "sortable:move");
  __publicField(MoveEvent, "cancelable", true);
  class Start extends AbstractEvent {
  }
  __publicField(Start, "type", "sortable:start");
  __publicField(Start, "cancelable", true);
  class End extends AbstractEvent {
  }
  __publicField(End, "type", "sortable:end");
  class ChangeEvent extends AbstractEvent {
  }
  __publicField(ChangeEvent, "type", "sortable:change");
  __publicField(ChangeEvent, "cancelable", true);
  class Drop extends AbstractEvent {
  }
  __publicField(Drop, "type", "sortable:drop");
  const hosts = HostsManager();
  const eventsManager = EventsManager();
  const getOffset = (currentDocument) => {
    const frameElement = hosts.getIframes().find((iframe) => {
      return iframe.contentDocument === currentDocument;
    });
    if (void 0 !== frameElement) {
      const { left: left2, top: top2 } = frameElement.getBoundingClientRect();
      return {
        left: left2,
        top: top2
      };
    }
    return {
      left: 0,
      top: 0
    };
  };
  memoizeOne(getOffset);
  const _sfc_main$2w = {
    name: "Sortable",
    props: {
      modelValue: {
        required: false,
        type: Array,
        default() {
          return [];
        }
      },
      allowDuplicate: {
        type: Boolean,
        default: false
      },
      duplicateCallback: {
        type: Function
      },
      tag: {
        type: String,
        required: false,
        default: "div"
      },
      dragTreshold: {
        type: Number,
        required: false,
        default: 5
      },
      dragDelay: {
        type: Number,
        required: false,
        default: 0
      },
      handle: {
        type: String,
        required: false,
        default: null
      },
      draggable: {
        type: String,
        required: false,
        default: "> *"
      },
      disabled: {
        type: Boolean,
        required: false,
        default: false
      },
      group: {
        type: [String, Object, Array],
        required: false,
        default: null
      },
      sort: {
        type: Boolean,
        required: false,
        default: true
      },
      placeholder: {
        type: Boolean,
        required: false,
        default: true
      },
      cssClasses: {
        type: Object,
        required: false,
        default() {
          return {};
        }
      },
      revert: {
        type: Boolean,
        required: false,
        default: true
      },
      axis: {
        type: String,
        required: false,
        default: null
      },
      preserveLastLocation: {
        type: Boolean,
        required: false,
        default: true
      }
    },
    setup(props, { slots, emit }) {
      let duplicateValue = false;
      let draggedItem = null;
      let dragItemInfo = null;
      let dragDelayCompleted = null;
      let dimensions = null;
      let initialX = null;
      let initialY = null;
      let currentDocument = null;
      let helperNode = null;
      let placeholderNode = null;
      let dragTimeout = null;
      let eventScheduler = null;
      let hasHelperSlot = false;
      let childItems = [];
      let hasPlaceholderSlot = false;
      let lastEvent = null;
      const sortableContainer = Vue.ref(null);
      const dragging = Vue.ref(null);
      const sortableItems = Vue.ref([]);
      const helper = Vue.ref(null);
      const placeholder = Vue.ref(null);
      const computedCssClasses = Vue.computed(() => {
        const defaultClasses = {
          body: "vuebdnd-draggable--active",
          source: "vuebdnd__source--dragging",
          "source:container": "vuebdnd__source-container--dragging",
          helper: "vuebdnd__helper",
          placeholder: "vuebdnd__placeholder",
          "placeholder:container": "vuebdnd__placeholder-container"
        };
        return __spreadValues(__spreadValues({}, defaultClasses), props.cssClasses);
      });
      const groupInfo = Vue.computed(() => {
        let group = props.group;
        if (!group || typeof group !== "object") {
          group = {
            name: group
          };
        }
        return group;
      });
      const getCssClass = (cssClass) => {
        return computedCssClasses.value[cssClass] || null;
      };
      const canPut = (dragItemInfo2) => {
        const dragGroupInfo = dragItemInfo2.group;
        const sameGroup = dragGroupInfo.value.name === groupInfo.value.name;
        const put = dragGroupInfo.put || null;
        if (put === null && sameGroup) {
          return true;
        } else if (put === null || put === false) {
          return false;
        } else if (typeof put === "function") {
          return put(dragItemInfo2, groupInfo);
        } else {
          if (put === true) {
            return true;
          } else if (typeof put === "string") {
            return put === dragGroupInfo.value.name;
          } else if (Array.isArray(put)) {
            return put.indexOf(dragGroupInfo.value.name) > -1;
          }
        }
        return false;
      };
      const movePlaceholder = (container, element, before) => {
        if (before === null) {
          if (dragItemInfo.lastContainer !== container) {
            removeCssClass("placeholder:container");
            if (props.placeholder) {
              placeholderNode.remove();
            }
            dragItemInfo.lastContainer = null;
          }
        } else {
          if (dragItemInfo.lastContainer !== container) {
            removeCssClass("placeholder:container");
          }
          if (props.placeholder) {
            container.insertBefore(placeholderNode, element);
          }
          if (dragItemInfo.lastContainer !== container) {
            addCssClass("placeholder:container");
          }
          const { container: from, item, index: startIndex, to, newIndex, toItem } = dragItemInfo;
          const changeEvent = new ChangeEvent({
            from,
            item,
            startIndex,
            to,
            newIndex,
            toItem,
            before
          });
          dragItemInfo.lastContainer = container;
          emit("change", changeEvent);
        }
      };
      const onDragStart = (event2) => {
        event2.preventDefault();
      };
      const getEvents = () => {
        return {
          onStart: [onDragStart],
          onMove: onMouseMove
        };
      };
      function onMouseDown(event2) {
        if (eventsManager.isHandled()) {
          return;
        }
        if (event2.button !== 0 || event2.ctrlKey || event2.metaKey) {
          return;
        }
        if (event2.target.isContentEditable) {
          return;
        }
        draggedItem = closest(event2.target, props.draggable, sortableContainer.value);
        const sortableDomElements = getDomElementsFromSortableItems();
        if (!draggedItem || !sortableDomElements.includes(draggedItem)) {
          return;
        }
        if (props.handle && !closest(event2.target, props.handle)) {
          return;
        }
        dragItemInfo = getInfoFromTarget(draggedItem);
        if (!canPull()) {
          return;
        }
        eventsManager.handle();
        dragDelayCompleted = !props.dragDelay;
        if (props.dragDelay) {
          clearTimeout(dragTimeout);
          dragTimeout = setTimeout(() => {
            dragDelayCompleted = true;
          }, props.dragDelay);
        }
        dimensions = draggedItem.getBoundingClientRect();
        const { clientX, clientY } = event2;
        initialX = clientX;
        initialY = clientY;
        currentDocument = event2.view.document;
        hosts.fetchHosts();
        hosts.getHosts().forEach((host) => {
          host.addEventListener("mousemove", onDraggableMouseMove);
          host.addEventListener("mouseup", finishDrag);
        });
      }
      const detachEvents = () => {
        hosts.getHosts().forEach((host) => {
          host.removeEventListener("mousemove", onDraggableMouseMove);
          host.removeEventListener("mouseup", finishDrag);
        });
        eventsManager.reset();
      };
      const startDrag = (event2) => {
        const startEvent = new Start(dragItemInfo);
        emit("start", startEvent);
        if (startEvent.isCanceled()) {
          finishDrag();
          return;
        }
        currentDocument.body.style.userSelect = "none";
        attachPlaceholder();
        attachHelper();
        addCssClass("body");
        addCssClass("source");
        addCssClass("source:container");
        addCssClass("placeholder:container");
        helperNode.style.willChange = "transform";
        helperNode.style.zIndex = 99999;
        helperNode.style.pointerEvents = "none";
        helperNode.style.position = "fixed";
        if (hasHelperSlot) {
          draggedItem.style.display = "none";
          const { width, height } = helperNode.getBoundingClientRect();
          helperNode.style.left = `${initialX - width / 2}px`;
          helperNode.style.top = `${initialY - height / 2}px`;
        } else {
          const { width, height, top: top2, left: left2 } = dimensions;
          if (groupInfo.value.pull !== "clone") {
            helperNode.style.left = `${left2}px`;
          }
          helperNode.style.top = `${top2}px`;
          helperNode.style.width = `${width}px`;
          helperNode.style.height = `${height}px`;
        }
      };
      const applyCssClass = (type, action) => {
        const cssClass = getCssClass(type);
        let node = null;
        if (!cssClass) {
          return;
        }
        if (type === "body") {
          node = currentDocument.body;
        } else if (type === "helper") {
          node = helperNode;
        } else if (type === "placeholder") {
          node = placeholderNode;
        } else if (type === "source") {
          node = draggedItem;
        } else if (type === "source:container") {
          node = draggedItem.parentNode;
        } else if (type === "placeholder:container") {
          node = placeholderNode.parentNode;
        }
        if (node) {
          node.classList[action](cssClass);
        }
      };
      const addCssClass = (type) => {
        applyCssClass(type, "add");
      };
      const removeCssClass = (type) => {
        applyCssClass(type, "remove");
      };
      const attachHelper = () => {
        if (hasHelperSlot) {
          helperNode = helper.value;
          sortableContainer.value.insertBefore(helperNode, draggedItem);
          draggedItem.insertAdjacentElement("afterend", helperNode);
        } else if (groupInfo.value.pull === "clone") {
          const clone = draggedItem.cloneNode(true);
          sortableContainer.value.insertBefore(clone, draggedItem);
          helperNode = clone;
        } else {
          helperNode = draggedItem;
        }
        addCssClass("helper");
      };
      function detachHelper() {
        if (helperNode) {
          removeCssClass("helper");
          if (hasHelperSlot || groupInfo.value.pull === "clone") {
            const helperContainer = helperNode.parentNode;
            if (helperContainer) {
              helperContainer.removeChild(helperNode);
            }
          }
        }
      }
      const attachPlaceholder = () => {
        if (!props.placeholder) {
          return;
        }
        if (hasPlaceholderSlot) {
          placeholderNode = placeholder.value;
        } else {
          placeholderNode = draggedItem.cloneNode(true);
          placeholderNode.style.visibility = "hidden";
        }
        if (placeholderNode && groupInfo.value.pull !== "clone") {
          sortableContainer.value.insertBefore(placeholderNode, draggedItem);
        }
        addCssClass("placeholder");
      };
      function detachPlaceholder() {
        if (placeholderNode) {
          removeCssClass("placeholder");
          const placeholderContainer = placeholderNode.parentNode;
          if (placeholderContainer) {
            placeholderContainer.removeChild(placeholderNode);
          }
        }
      }
      const finishDrag = () => {
        clearTimeout(dragTimeout);
        detachEvents();
        if (dragging.value) {
          dragging.value = false;
          currentDocument.body.style.userSelect = null;
          removeCssClass("body");
          removeCssClass("source");
          removeCssClass("source:container");
          removeCssClass("placeholder:container");
          detachPlaceholder();
          detachHelper();
          if (helperNode) {
            if (props.revert) {
              helperNode.style.position = null;
              helperNode.style.left = null;
              helperNode.style.top = null;
              helperNode.style.width = null;
              helperNode.style.height = null;
              helperNode.style.zIndex = null;
              helperNode.style.transform = null;
            }
            if (props.allowDuplicate && duplicateValue) {
              draggedItem.style.display = null;
              draggedItem.style.opacity = null;
            }
            helperNode.style.willChange = null;
            helperNode.style.pointerEvents = null;
            helperNode.style.zIndex = null;
          }
          if (hasHelperSlot) {
            draggedItem.style.display = null;
          }
          const { from, to, startIndex, newIndex, placeBefore } = lastEvent.data;
          let draggedValueModel = null;
          if (from && to && newIndex !== -1) {
            const toVm = to.__SORTABLE_INFO__;
            if (props.modelValue !== null) {
              let updatedNewIndex = placeBefore ? newIndex : newIndex + 1;
              draggedValueModel = props.duplicateCallback && duplicateValue ? props.duplicateCallback(props.modelValue[startIndex]) : props.modelValue[startIndex];
              if (from === to && startIndex !== newIndex && !duplicateValue) {
                updatePositionInList(startIndex, updatedNewIndex);
              } else if (from === to && startIndex === newIndex && !duplicateValue)
                ;
              else {
                if (!duplicateValue) {
                  removeItemFromList(startIndex);
                }
                toVm.addItemToList(draggedValueModel, updatedNewIndex);
              }
            }
            const dropEvent = new Drop(__spreadProps(__spreadValues({}, lastEvent.data), {
              toVm,
              draggedValueModel,
              fromDraggedValueModel: props.modelValue,
              newIndex,
              duplicateItem: duplicateValue
            }));
            toVm.emit("drop", dropEvent);
          }
          const endEvent = new End();
          emit("end", endEvent);
          eventScheduler.cancel();
          currentDocument = null;
          initialX = null;
          initialY = null;
          dimensions = null;
          draggedItem = null;
          dragDelayCompleted = null;
          dragItemInfo = null;
        }
      };
      const updatePositionInList = (oldIndex, newIndex) => {
        if (props.modelValue) {
          const list = [...props.modelValue];
          if (oldIndex >= newIndex) {
            list.splice(newIndex, 0, list.splice(oldIndex, 1)[0]);
          } else {
            list.splice(newIndex - 1, 0, list.splice(oldIndex, 1)[0]);
          }
          emit("update:modelValue", list);
        }
      };
      const addItemToList = (item, index2) => {
        if (props.modelValue) {
          const list = [...props.modelValue];
          list.splice(index2, 0, item);
          emit("update:modelValue", list);
        }
      };
      const removeItemFromList = (index2) => {
        if (props.modelValue) {
          const list = [...props.modelValue];
          list.splice(index2, 1);
          emit("update:modelValue", list);
        }
      };
      const onDraggableMouseMove = (event2) => {
        if (dragging.value) {
          eventScheduler.move(event2);
        } else {
          const { clientX, clientY } = event2;
          const xDistance = Math.abs(clientX - initialX);
          const yDistance = Math.abs(clientY - initialY);
          if (dragDelayCompleted && (xDistance >= props.dragTreshold || yDistance >= props.dragTreshold)) {
            dragging.value = true;
            Vue.nextTick(() => {
              startDrag();
            });
          }
        }
      };
      const getInfoFromTarget = (target) => {
        const validItem = closest(target, props.draggable, sortableContainer.value);
        const sortableDomElements = getDomElementsFromSortableItems();
        const item = sortableDomElements.includes(validItem) ? validItem : false;
        const index2 = sortableDomElements.indexOf(item);
        return {
          container: sortableContainer.value,
          item,
          index: index2,
          newIndex: index2,
          group: groupInfo
        };
      };
      const canPull = () => {
        if (groupInfo.value.pull === false) {
          return false;
        }
        return true;
      };
      const onMouseMove = (event2) => {
        let { clientX, clientY } = event2;
        let offset2 = {
          left: 0,
          top: 0
        };
        if (props.allowDuplicate && event2.ctrlKey) {
          draggedItem.style.display = null;
          draggedItem.style.opacity = 0.2;
          duplicateValue = true;
        } else {
          draggedItem.style.opacity = null;
          duplicateValue = false;
        }
        const movedX = clientX + offset2.left - initialX;
        const movedY = clientY + offset2.top - initialY;
        helperNode.style.transform = `translate3d(${movedX}px, ${movedY}px, 0)`;
        let overItem = {
          container: null,
          item: null,
          index: -1
        };
        const target = currentDocument.elementFromPoint(clientX, clientY);
        if (target) {
          const to2 = closest(target, getSortableContainer);
          const sameContainer = to2 === sortableContainer.value;
          if (sameContainer && !props.sort)
            ;
          else if (to2) {
            const targetVM = to2.__SORTABLE_INFO__;
            const overItemInfo = targetVM.getInfoFromTarget(target);
            overItem = __spreadValues(__spreadValues({}, overItem), overItemInfo);
            dragItemInfo.to = overItem.container;
            dragItemInfo.toItem = overItem.item;
            if (overItem.container) {
              if (overItem.item) {
                const collisionInfoData = collisionInfo(event2, overItem.item, targetVM);
                dragItemInfo.placeBefore = collisionInfoData.before;
                const whereToPutPlaceholder = targetVM.getItemFromList(overItem.index);
                const nextSibling = whereToPutPlaceholder.nextElementSibling;
                const insertBeforeElement = dragItemInfo.placeBefore ? whereToPutPlaceholder : nextSibling;
                movePlaceholderMemoized(overItem.container, insertBeforeElement, dragItemInfo.placeBefore);
                dragItemInfo.newIndex = overItem.index;
              } else {
                if (targetVM.modelValue && targetVM.modelValue.length === 0) {
                  dragItemInfo.newIndex = 0;
                  movePlaceholderMemoized(overItem.container, null, dragItemInfo.placeBefore);
                } else if (sameContainer && props.modelValue.length === 1) {
                  movePlaceholderMemoized(overItem.container, null, dragItemInfo.placeBefore);
                }
              }
            }
          } else if (!props.preserveLastLocation) {
            dragItemInfo.to = null;
            dragItemInfo.newIndex = null;
            dragItemInfo.toItem = null;
            dragItemInfo.placeBefore = null;
            movePlaceholderMemoized(null, null, null);
          }
        }
        const { container: from, item, index: startIndex, to, newIndex, toItem, placeBefore } = dragItemInfo;
        const moveEvent = new MoveEvent({
          from,
          item,
          startIndex,
          to,
          newIndex,
          toItem,
          nativeEvent: event2,
          placeBefore
        });
        emit("move", moveEvent);
        if (moveEvent.isCanceled()) {
          finishDrag();
        }
        lastEvent = moveEvent;
      };
      const collisionInfo = (event2, overItem, targetVm) => {
        const { clientX, clientY } = event2;
        const itemRect = overItem.getBoundingClientRect();
        const orientation = detectOrientation(targetVm);
        const center = orientation === "horizontal" ? itemRect.width / 2 : itemRect.height / 2;
        const before = orientation === "horizontal" ? clientX < itemRect.left + center : clientY < itemRect.top + center;
        return {
          before
        };
      };
      const detectOrientation = (targetVm) => {
        return targetVm.axis || "vertical";
      };
      const getDomElementsFromSortableItems = () => {
        return childItems.filter((el) => el).map((el) => {
          return el.el;
        });
      };
      const getItemFromList = (index2) => {
        const sortableDomElements = getDomElementsFromSortableItems();
        return sortableDomElements[index2];
      };
      const getSortableContainer = (target) => {
        return target && target.__SORTABLE_INFO__ && target.__SORTABLE_INFO__.canPut(dragItemInfo);
      };
      Vue.onMounted(() => {
        eventScheduler = EventScheduler(getEvents());
        sortableContainer.value.__SORTABLE_INFO__ = sortableInfo;
        collectChildren();
      });
      Vue.onUpdated(() => {
        collectChildren();
      });
      function collectChildren() {
        sortableItems.value = fetchChildren(childItems);
      }
      function fetchChildren(items2) {
        let children = [];
        if (Array.isArray(items2)) {
          items2.forEach((child) => {
            if (child.type === Vue.Fragment) {
              children = [...children, ...fetchChildren(child.children)];
            } else {
              children.push(child);
            }
          });
        }
        return children;
      }
      const movePlaceholderMemoized = memoizeOne(movePlaceholder);
      const sortableInfo = {
        group: props.group,
        axis: props.axis,
        getInfoFromTarget,
        canPut,
        getItemFromList,
        addItemToList,
        modelValue: props.modelValue,
        emit
      };
      return () => {
        const childElements = [];
        if (slots.start) {
          childElements.push(slots.start());
        }
        const draggableItems = slots.default();
        childItems = fetchChildren(draggableItems);
        childElements.push(draggableItems);
        if (dragging.value) {
          if (slots.helper) {
            hasHelperSlot = true;
            childElements.push(
              Vue.h(
                "div",
                {
                  class: "zion-editor__sortable-helper",
                  ref: helper
                },
                slots.helper()
              )
            );
          }
          if (slots.placeholder) {
            hasPlaceholderSlot = true;
            childElements.push(
              Vue.h(
                "div",
                {
                  class: "znpb-sortable__placeholder",
                  ref: placeholder
                },
                slots.placeholder()
              )
            );
          }
        }
        if (slots.end) {
          childElements.push(slots.end());
        }
        return Vue.h(
          props.tag,
          {
            onMousedown: props.disabled ? null : onMouseDown,
            onDragstart: onDragStart,
            ref: sortableContainer,
            class: {
              [`vuebdnd__placeholder-empty-container`]: childItems.length === 0 || dragging.value && childItems.length === 1
            }
          },
          [childElements]
        );
      };
    }
  };
  var GradientGenerator_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$1V = { class: "znpb-gradient-wrapper" };
  const _hoisted_2$1j = { class: "znpb-gradient-elements-wrapper" };
  const __default__$K = {
    name: "GradientGenerator"
  };
  const _sfc_main$2v = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$K), {
    props: {
      modelValue: null,
      saveToLibrary: { type: Boolean, default: true }
    },
    emits: ["update:modelValue"],
    setup(__props, { emit }) {
      const props = __props;
      const showPresetInput = Vue.ref(false);
      const activeGradientIndex = Vue.ref(0);
      const { addLocalGradient, addGlobalGradient } = useBuilderOptionsStore();
      const computedValue = Vue.computed({
        get() {
          var _a3;
          const clonedValue = JSON.parse(JSON.stringify((_a3 = props.modelValue) != null ? _a3 : getDefaultGradient()));
          const { applyFilters: applyFilters2 } = window.zb.hooks;
          return applyFilters2("zionbuilder/options/model", clonedValue);
        },
        set(newValue) {
          emit("update:modelValue", newValue);
        }
      });
      const activeGradient = Vue.computed({
        get() {
          return computedValue.value[activeGradientIndex.value];
        },
        set(newValue) {
          const valueToSend = [...computedValue.value];
          valueToSend[activeGradientIndex.value] = newValue;
          computedValue.value = valueToSend;
        }
      });
      function addGlobalPattern(name, type) {
        showPresetInput.value = false;
        const defaultGradient = {
          id: generateUID(),
          name,
          config: computedValue.value
        };
        type === "local" ? addLocalGradient(defaultGradient) : addGlobalGradient(defaultGradient);
      }
      function deleteGradient(gradientConfig) {
        const deletedGradientIndex = computedValue.value.indexOf(gradientConfig);
        if (activeGradient.value === gradientConfig) {
          if (deletedGradientIndex > 0) {
            activeGradientIndex.value = deletedGradientIndex - 1;
          } else {
            activeGradientIndex.value = deletedGradientIndex + 1;
          }
        } else {
          if (deletedGradientIndex < activeGradientIndex.value) {
            activeGradientIndex.value = activeGradientIndex.value - 1;
          }
        }
        const updatedValues = computedValue.value.slice(0);
        updatedValues.splice(deletedGradientIndex, 1);
        computedValue.value = updatedValues;
      }
      function addGradientConfig() {
        const defaultConfig = getDefaultGradient();
        computedValue.value = [...computedValue.value, defaultConfig[0]];
        Vue.nextTick(() => {
          const newGradientIndex = computedValue.value.length - 1;
          changeActive(newGradientIndex);
        });
      }
      function changeActive(index2) {
        activeGradientIndex.value = index2;
      }
      function changePosition(position) {
        activeGradient.value = __spreadProps(__spreadValues({}, activeGradient.value), {
          position
        });
      }
      function deleteGradientValue() {
        emit("update:modelValue", null);
      }
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$1V, [
          !__props.saveToLibrary ? (Vue.openBlock(), Vue.createBlock(_sfc_main$2M, {
            key: 0,
            config: Vue.unref(computedValue),
            activegrad: Vue.unref(activeGradient),
            onChangeActiveGradient: _cache[0] || (_cache[0] = ($event) => changeActive($event)),
            onPositionChanged: _cache[1] || (_cache[1] = ($event) => changePosition($event))
          }, null, 8, ["config", "activegrad"])) : (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$32), { key: 1 }, {
            actions: Vue.withCtx(() => [
              !showPresetInput.value ? (Vue.openBlock(), Vue.createElementBlock("span", {
                key: 0,
                class: "znpb-gradient__show-preset",
                onClick: _cache[4] || (_cache[4] = ($event) => showPresetInput.value = true)
              }, Vue.toDisplayString(_ctx.$translate("save_to_library")), 1)) : (Vue.openBlock(), Vue.createBlock(_sfc_main$2x, {
                key: 1,
                onSavePreset: addGlobalPattern,
                onCancel: _cache[5] || (_cache[5] = ($event) => showPresetInput.value = false)
              })),
              !showPresetInput.value ? (Vue.openBlock(), Vue.createBlock(_sfc_main$34, {
                key: 2,
                icon: "delete",
                "bg-size": 30,
                class: "znpb-gradient-wrapper__delete-gradient",
                onClick: Vue.withModifiers(deleteGradientValue, ["stop"])
              }, null, 8, ["onClick"])) : Vue.createCommentVNode("", true)
            ]),
            default: Vue.withCtx(() => [
              Vue.createVNode(_sfc_main$2M, {
                config: Vue.unref(computedValue),
                activegrad: Vue.unref(activeGradient),
                onChangeActiveGradient: _cache[2] || (_cache[2] = ($event) => changeActive($event)),
                onPositionChanged: _cache[3] || (_cache[3] = ($event) => changePosition($event))
              }, null, 8, ["config", "activegrad"])
            ]),
            _: 1
          })),
          Vue.createElementVNode("div", _hoisted_2$1j, [
            Vue.createVNode(Vue.unref(_sfc_main$2w), {
              modelValue: Vue.unref(computedValue),
              "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => Vue.isRef(computedValue) ? computedValue.value = $event : null),
              class: "znpb-admin-colors__container",
              handle: null,
              "drag-delay": 0,
              "drag-treshold": 10,
              disabled: false,
              revert: true,
              axis: "horizontal"
            }, {
              default: Vue.withCtx(() => [
                (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList(Vue.unref(computedValue), (gradient, i) => {
                  return Vue.openBlock(), Vue.createBlock(_sfc_main$2z, {
                    key: i,
                    class: "znpb-gradient-elements__delete-button",
                    config: gradient,
                    "show-remove": Vue.unref(computedValue).length > 1,
                    "is-active": activeGradientIndex.value === i,
                    onChangeActiveGradient: ($event) => changeActive(i),
                    onDeleteGradient: ($event) => deleteGradient(gradient)
                  }, null, 8, ["config", "show-remove", "is-active", "onChangeActiveGradient", "onDeleteGradient"]);
                }), 128))
              ]),
              _: 1
            }, 8, ["modelValue"]),
            Vue.createVNode(_sfc_main$34, {
              icon: "plus",
              class: "znpb-colorpicker-add-grad",
              onClick: addGradientConfig
            })
          ]),
          Vue.createVNode(_sfc_main$2B, {
            modelValue: Vue.unref(activeGradient),
            "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => Vue.isRef(activeGradient) ? activeGradient.value = $event : null)
          }, null, 8, ["modelValue"])
        ]);
      };
    }
  }));
  var LibraryElement_vue_vue_type_style_index_0_lang = "";
  const __default__$J = {
    name: "LibraryElement"
  };
  const _sfc_main$2u = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$J), {
    props: {
      animation: { type: Boolean, default: true },
      icon: null,
      hasInput: { type: Boolean }
    },
    emits: ["close-library"],
    setup(__props) {
      const onstart = Vue.ref(true);
      const expand = Vue.ref(false);
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", {
          class: Vue.normalizeClass(["znpb-form-library-inner-pattern-wrapper", {
            "znpb-form-library-inner-pattern-wrapper--start": onstart.value,
            "znpb-form-library-inner-pattern-wrapper--stretch": !expand.value,
            "znpb-form-library-inner-pattern-wrapper--expand": expand.value,
            "znpb-form-library-inner-pattern-wrapper--hasInput": __props.hasInput
          }])
        }, [
          !__props.hasInput ? (Vue.openBlock(), Vue.createElementBlock(Vue.Fragment, { key: 0 }, [
            __props.animation ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$34), {
              key: 0,
              icon: "more",
              class: "znpb-form-library-inner-action-icon",
              onClick: _cache[0] || (_cache[0] = Vue.withModifiers(($event) => (expand.value = !expand.value, onstart.value = false), ["stop"]))
            })) : Vue.createCommentVNode("", true),
            __props.icon ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$34), {
              key: 1,
              icon: __props.icon,
              class: "znpb-form-library-inner-action-icon",
              onClick: _cache[1] || (_cache[1] = Vue.withModifiers(($event) => _ctx.$emit("close-library"), ["stop"]))
            }, null, 8, ["icon"])) : Vue.createCommentVNode("", true)
          ], 64)) : Vue.createCommentVNode("", true),
          Vue.renderSlot(_ctx.$slots, "default")
        ], 2);
      };
    }
  }));
  var Label_vue_vue_type_style_index_0_lang = "";
  const __default__$I = {
    name: "Label"
  };
  const _sfc_main$2t = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$I), {
    props: {
      text: null,
      type: null
    },
    setup(__props) {
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("span", {
          class: Vue.normalizeClass(["znpb-label", { [`znpb-label--${__props.type}`]: __props.type }])
        }, Vue.toDisplayString(__props.text), 3);
      };
    }
  }));
  var GradientLibrary_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$1U = {
    key: 0,
    class: "znpb-form-library-grid__panel-content-message"
  };
  const _hoisted_2$1i = {
    key: 1,
    class: "znpb-form-library-grid__panel-content znpb-form-library-grid__panel-content--no-pd znpb-fancy-scrollbar"
  };
  const _hoisted_3$W = {
    key: 0,
    class: "znpb-colorpicker-global-wrapper--pro"
  };
  const _hoisted_4$B = {
    key: 0,
    class: "znpb-form-library-grid__panel-content-message"
  };
  const _hoisted_5$s = {
    key: 1,
    class: "znpb-form-library-grid__panel-content znpb-form-library-grid__panel-content--no-pd znpb-fancy-scrollbar"
  };
  const __default__$H = {
    name: "GradientLibrary"
  };
  const _sfc_main$2s = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$H), {
    props: {
      model: null
    },
    emits: ["activate-gradient", "close-library"],
    setup(__props, { emit }) {
      const updateValueByPath = Vue.inject("updateValueByPath");
      function getPro() {
        if (window.ZnPbComponentsData !== void 0) {
          return window.ZnPbComponentsData.is_pro_active;
        }
        return false;
      }
      const isPro = getPro();
      const schema = Vue.inject("schema");
      const { getOptionValue } = useBuilderOptionsStore();
      const getGlobalGradients = Vue.computed(() => {
        return getOptionValue("global_gradients");
      });
      const getLocalGradients = Vue.computed(() => {
        return getOptionValue("local_gradients");
      });
      function onGlobalGradientSelected(gradient) {
        const { id } = schema;
        updateValueByPath(`__dynamic_content__.${id}`, {
          type: "global-gradient",
          options: {
            gradient_id: gradient.id
          }
        });
        Vue.nextTick(() => {
          emit("activate-gradient", null);
        });
      }
      return (_ctx, _cache) => {
        const _component_Tab = Vue.resolveComponent("Tab");
        const _component_Tabs = Vue.resolveComponent("Tabs");
        return Vue.openBlock(), Vue.createBlock(_sfc_main$2u, {
          animation: false,
          icon: "close",
          onCloseLibrary: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("close-library"))
        }, {
          default: Vue.withCtx(() => [
            Vue.createVNode(_component_Tabs, { "tab-style": "minimal" }, {
              default: Vue.withCtx(() => [
                Vue.createVNode(_component_Tab, { name: "Local" }, {
                  default: Vue.withCtx(() => [
                    Vue.unref(getLocalGradients).length === 0 ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$1U, Vue.toDisplayString(_ctx.$translate("no_local_gradients")), 1)) : (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_2$1i, [
                      (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList(Vue.unref(getLocalGradients), (gradient, i) => {
                        return Vue.openBlock(), Vue.createBlock(_sfc_main$2O, {
                          key: i,
                          config: gradient.config,
                          round: true,
                          onClick: ($event) => _ctx.$emit("activate-gradient", gradient.config)
                        }, null, 8, ["config", "onClick"]);
                      }), 128))
                    ]))
                  ]),
                  _: 1
                }),
                Vue.createVNode(_component_Tab, { name: "Global" }, {
                  default: Vue.withCtx(() => [
                    !Vue.unref(isPro) ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_3$W, [
                      Vue.createTextVNode(Vue.toDisplayString(_ctx.$translate("global_colors_availability")) + " ", 1),
                      Vue.createVNode(Vue.unref(_sfc_main$2t), {
                        text: _ctx.$translate("pro"),
                        type: "pro"
                      }, null, 8, ["text"])
                    ])) : (Vue.openBlock(), Vue.createElementBlock(Vue.Fragment, { key: 1 }, [
                      Vue.unref(getGlobalGradients).length === 0 ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_4$B, Vue.toDisplayString(_ctx.$translate("no_global_gradients")), 1)) : (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_5$s, [
                        (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList(Vue.unref(getGlobalGradients), (gradient, i) => {
                          return Vue.openBlock(), Vue.createBlock(_sfc_main$2O, {
                            key: i,
                            config: gradient.config,
                            round: true,
                            onClick: ($event) => onGlobalGradientSelected(gradient)
                          }, null, 8, ["config", "onClick"]);
                        }), 128))
                      ]))
                    ], 64))
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })
          ]),
          _: 1
        });
      };
    }
  }));
  var OptionBreadcrumbs_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$1T = { class: "znpb-options-breadcrumbs" };
  const _hoisted_2$1h = ["innerHTML"];
  const __default__$G = {
    name: "OptionBreadcrumbs"
  };
  const _sfc_main$2r = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$G), {
    props: {
      breadcrumbs: null,
      showBackButton: { type: Boolean }
    },
    setup(__props) {
      const props = __props;
      const previousItem = Vue.computed(() => {
        var _a3;
        return (_a3 = props.breadcrumbs) == null ? void 0 : _a3[props.breadcrumbs.length - 2];
      });
      const computedBreadcrumbs = Vue.computed(() => {
        var _a3;
        return (_a3 = props.breadcrumbs) == null ? void 0 : _a3.slice(Math.max(props.breadcrumbs.length - 2, 1));
      });
      function onItemClicked(breadcrumbItem) {
        if (breadcrumbItem.callback !== void 0) {
          breadcrumbItem.callback();
        }
      }
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$1T, [
          __props.showBackButton ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$34), {
            key: 0,
            class: "znpb-back-icon-breadcrumbs",
            icon: "select",
            onClick: _cache[0] || (_cache[0] = ($event) => onItemClicked(Vue.unref(previousItem)))
          })) : Vue.createCommentVNode("", true),
          (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList(Vue.unref(computedBreadcrumbs), (breadcrumb, i) => {
            return Vue.openBlock(), Vue.createElementBlock("div", {
              key: i,
              class: Vue.normalizeClass(["znpb-options-breadcrumbs-path", { ["znpb-options-breadcrumbs-path--current"]: i === Vue.unref(computedBreadcrumbs).length - 1 }]),
              onClick: _cache[1] || (_cache[1] = ($event) => onItemClicked(Vue.unref(previousItem)))
            }, [
              Vue.createElementVNode("span", {
                innerHTML: breadcrumb.title
              }, null, 8, _hoisted_2$1h),
              i + 1 < Vue.unref(computedBreadcrumbs).length ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$34), {
                key: 0,
                icon: "select",
                class: "znpb-options-breadcrumbs-path-icon"
              })) : Vue.createCommentVNode("", true)
            ], 2);
          }), 128))
        ]);
      };
    }
  }));
  var HorizontalAccordion_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$1S = {
    key: 0,
    class: "znpb-horizontal-accordion__title"
  };
  const _hoisted_2$1g = { class: "znpb-horizontal-accordion__header-actions" };
  const _hoisted_3$V = {
    key: 0,
    class: "znpb-horizontal-accordion__content"
  };
  const __default__$F = {
    name: "HorizontalAccordion"
  };
  const _sfc_main$2q = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$F), {
    props: {
      hasBreadcrumbs: { type: Boolean, default: true },
      collapsed: { type: Boolean, default: false },
      title: null,
      icon: null,
      level: null,
      showTriggerArrow: { type: Boolean, default: true },
      showBackButton: { type: Boolean },
      showHomeButton: { type: Boolean },
      homeButtonText: null,
      combineBreadcrumbs: { type: Boolean }
    },
    emits: ["collapse", "expand"],
    setup(__props, { expose, emit }) {
      const props = __props;
      const parentAccordion = Vue.inject("parentAccordion", null);
      Vue.provide(
        "parentAccordion",
        parentAccordion || {
          addBreadcrumb,
          removeBreadcrumb
        }
      );
      expose({
        closeAccordion
      });
      const root2 = Vue.ref(null);
      const localCollapsed = Vue.ref(props.collapsed);
      const breadcrumbs = Vue.ref([
        {
          title: props.homeButtonText,
          callback: closeAccordion
        },
        {
          title: props.title
        }
      ]);
      const breadCrumbConfig = Vue.ref(null);
      const firstChildOpen = Vue.ref(false);
      const slots = Vue.useSlots();
      const hasHeaderSlot = Vue.computed(() => !!slots.header);
      const hasTitleSlot = Vue.computed(() => !!slots.title);
      Vue.watch(
        () => props.collapsed,
        (newValue) => {
          localCollapsed.value = newValue;
        }
      );
      const wrapperStyles = Vue.computed(() => {
        const cssStyles = {};
        if (!props.combineBreadcrumbs && parentAccordion === null && localCollapsed.value && firstChildOpen.value) {
          cssStyles["overflow"] = "hidden";
        }
        return cssStyles;
      });
      function addBreadcrumb(breadcrumb) {
        if (typeof breadcrumb.previousCallback === "function") {
          const lastItem = breadcrumbs.value[breadcrumbs.value.length - 1];
          lastItem.callback = breadcrumb.previousCallback;
        }
        breadcrumbs.value.push(breadcrumb);
        firstChildOpen.value = true;
      }
      function removeBreadcrumb(breadcrumb) {
        const breadCrumbIndex = breadcrumbs.value.indexOf(breadcrumb);
        if (breadCrumbIndex !== -1) {
          breadcrumbs.value.splice(breadCrumbIndex, 1);
          firstChildOpen.value = false;
        }
      }
      function closeAccordion() {
        localCollapsed.value = false;
        if (parentAccordion && breadCrumbConfig.value) {
          removeBreadcrumb(breadCrumbConfig.value);
        }
        emit("collapse", true);
      }
      function openAccordion() {
        var _a3, _b;
        localCollapsed.value = true;
        (_b = (_a3 = root2.value) == null ? void 0 : _a3.closest(".znpb-horizontal-accordion-wrapper")) == null ? void 0 : _b.scrollTo(0, 0);
        if (props.combineBreadcrumbs && parentAccordion) {
          injectBreadcrumbs();
        }
        emit("expand", false);
      }
      function injectBreadcrumbs() {
        breadCrumbConfig.value = {
          title: props.title || "",
          previousCallback: closeAccordion
        };
        addBreadcrumb(breadCrumbConfig.value);
      }
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", {
          ref_key: "root",
          ref: root2,
          class: "znpb-horizontal-accordion"
        }, [
          Vue.createVNode(Vue.Transition, { name: "slide-title" }, {
            default: Vue.withCtx(() => [
              Vue.withDirectives(Vue.createElementVNode("div", {
                class: Vue.normalizeClass(["znpb-horizontal-accordion__header", { "znpb-horizontal-accordion__header--has-slots": Vue.unref(hasHeaderSlot) }]),
                onClick: openAccordion
              }, [
                !Vue.unref(hasHeaderSlot) ? (Vue.openBlock(), Vue.createElementBlock("span", _hoisted_1$1S, [
                  !Vue.unref(hasTitleSlot) ? (Vue.openBlock(), Vue.createElementBlock(Vue.Fragment, { key: 0 }, [
                    __props.icon ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$34), {
                      key: 0,
                      icon: __props.icon
                    }, null, 8, ["icon"])) : Vue.createCommentVNode("", true),
                    Vue.createElementVNode("span", null, Vue.toDisplayString(__props.title), 1)
                  ], 64)) : Vue.createCommentVNode("", true),
                  Vue.renderSlot(_ctx.$slots, "title")
                ])) : Vue.createCommentVNode("", true),
                Vue.renderSlot(_ctx.$slots, "header"),
                Vue.createElementVNode("div", _hoisted_2$1g, [
                  Vue.renderSlot(_ctx.$slots, "actions"),
                  __props.showTriggerArrow ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$34), {
                    key: 0,
                    icon: "right-arrow"
                  })) : Vue.createCommentVNode("", true)
                ])
              ], 2), [
                [Vue.vShow, !localCollapsed.value]
              ])
            ]),
            _: 3
          }),
          Vue.createVNode(Vue.Transition, { name: "slide-body" }, {
            default: Vue.withCtx(() => [
              localCollapsed.value ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_3$V, [
                __props.hasBreadcrumbs && !(__props.combineBreadcrumbs && Vue.unref(parentAccordion)) ? (Vue.openBlock(), Vue.createBlock(_sfc_main$2r, {
                  key: 0,
                  "show-back-button": __props.showBackButton,
                  breadcrumbs: breadcrumbs.value
                }, null, 8, ["show-back-button", "breadcrumbs"])) : Vue.createCommentVNode("", true),
                Vue.createElementVNode("div", {
                  class: "znpb-horizontal-accordion-wrapper znpb-fancy-scrollbar",
                  style: Vue.normalizeStyle(Vue.unref(wrapperStyles))
                }, [
                  Vue.renderSlot(_ctx.$slots, "default")
                ], 4)
              ])) : Vue.createCommentVNode("", true)
            ]),
            _: 3
          })
        ], 512);
      };
    }
  }));
  var IconsLibraryModalContent_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$1R = { class: "znpb-icon-pack-modal__search" };
  const _hoisted_2$1f = { class: "znpb-icon-pack-modal-scroll znpb-fancy-scrollbar" };
  const __default__$E = {
    name: "IconsLibraryModalContent"
  };
  const _sfc_main$2p = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$E), {
    props: {
      modelValue: null,
      specialFilterPack: null
    },
    emits: ["update:modelValue", "selected"],
    setup(__props, { emit }) {
      const props = __props;
      const { dataSets } = storeToRefs(useDataSetsStore());
      const keyword = Vue.ref("");
      const activeIcon = Vue.ref(null);
      const activeCategory = Vue.ref("all");
      const getPacks = Vue.computed(() => {
        var _a3;
        return (_a3 = dataSets.value.icons) != null ? _a3 : [];
      });
      const searchModel = Vue.computed({
        get() {
          return keyword.value;
        },
        set(newVal) {
          keyword.value = newVal;
        }
      });
      const filteredList = Vue.computed(() => {
        if (keyword.value.length > 0) {
          const filtered = [];
          for (const pack of packList.value) {
            const copyPack = __spreadValues({}, pack);
            const b = copyPack.icons.filter((icon) => icon.name.includes(keyword.value.toLowerCase()));
            copyPack.icons = [...b];
            filtered.push(copyPack);
          }
          return filtered;
        } else
          return packList.value;
      });
      const getPlaceholder = Vue.computed(() => {
        const { translate: translate2 } = window.zb.i18n;
        return `${translate2("search_for_icons")} ${getIconNumber.value} ${translate2("icons")}`;
      });
      const getIconNumber = Vue.computed(() => {
        let iconNumber = 0;
        for (const pack of packList.value) {
          let packNumber = pack.icons.length;
          iconNumber = iconNumber + packNumber;
        }
        return iconNumber;
      });
      const packList = Vue.computed(() => {
        if (props.specialFilterPack !== void 0 && props.specialFilterPack.length) {
          return props.specialFilterPack;
        }
        if (activeCategory.value === "all") {
          return getPacks.value;
        } else {
          let newArray = [];
          for (const pack of getPacks.value) {
            if (pack.id === activeCategory.value) {
              newArray.push(pack);
            }
          }
          return newArray;
        }
      });
      const packsOptions = Vue.computed(() => {
        const options2 = [
          {
            name: "All",
            id: "all"
          }
        ];
        if (props.specialFilterPack === void 0 || !props.specialFilterPack.length) {
          getPacks.value.forEach((pack) => {
            let a = {
              name: pack.name,
              id: pack.id
            };
            options2.push(a);
          });
        }
        return options2;
      });
      function selectIcon(event2, name) {
        activeIcon.value = event2;
        const icon = {
          family: name,
          name: activeIcon.value.name,
          unicode: activeIcon.value.unicode
        };
        emit("update:modelValue", icon);
      }
      function insertIcon(event2, name) {
        activeIcon.value = event2;
        const icon = {
          family: name,
          name: activeIcon.value.name,
          unicode: activeIcon.value.unicode
        };
        emit("selected", icon);
      }
      return (_ctx, _cache) => {
        const _component_InputSelect = Vue.resolveComponent("InputSelect");
        const _component_BaseInput = Vue.resolveComponent("BaseInput");
        const _component_IconPackGrid = Vue.resolveComponent("IconPackGrid");
        return Vue.openBlock(), Vue.createElementBlock("div", {
          class: Vue.normalizeClass(["znpb-icon-pack-modal", { ["znpb-icon-pack-modal--has-special-filter"]: __props.specialFilterPack }])
        }, [
          Vue.createElementVNode("div", _hoisted_1$1R, [
            Vue.createVNode(_component_InputSelect, {
              modelValue: activeCategory.value,
              options: Vue.unref(packsOptions),
              class: "znpb-icons-category-select",
              placement: "bottom-start",
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => activeCategory.value = $event)
            }, null, 8, ["modelValue", "options"]),
            Vue.createVNode(_component_BaseInput, {
              modelValue: Vue.unref(searchModel),
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => Vue.isRef(searchModel) ? searchModel.value = $event : null),
              placeholder: Vue.unref(getPlaceholder),
              clearable: true,
              icon: "search"
            }, null, 8, ["modelValue", "placeholder"])
          ]),
          Vue.createElementVNode("div", _hoisted_2$1f, [
            (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList(Vue.unref(filteredList), (pack, i) => {
              var _a3, _b;
              return Vue.openBlock(), Vue.createBlock(_component_IconPackGrid, {
                key: i,
                "icon-list": pack.icons,
                family: pack.name,
                "active-icon": (_a3 = __props.modelValue) == null ? void 0 : _a3.name,
                "active-family": (_b = __props.modelValue) == null ? void 0 : _b.family,
                onIconSelected: ($event) => selectIcon($event, pack.name),
                "onUpdate:modelValue": ($event) => insertIcon($event, pack.name)
              }, null, 8, ["icon-list", "family", "active-icon", "active-family", "onIconSelected", "onUpdate:modelValue"]);
            }), 128))
          ])
        ], 2);
      };
    }
  }));
  var InputIcon_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$1Q = { class: "znpb-icon-options" };
  const _hoisted_2$1e = ["onClick"];
  const _hoisted_3$U = {
    key: 0,
    class: "znpb-icon-options__delete"
  };
  const _hoisted_4$A = ["data-znpbiconfam", "data-znpbicon"];
  const __default__$D = {
    name: "IconLibrary"
  };
  const _sfc_main$2o = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$D), {
    props: {
      specialFilterPack: null,
      title: null,
      modelValue: null
    },
    emits: ["update:modelValue"],
    setup(__props, { emit }) {
      const props = __props;
      const showModal = Vue.ref(false);
      const valueModel = Vue.computed({
        get() {
          return props.modelValue;
        },
        set(newValue) {
          emit("update:modelValue", newValue);
        }
      });
      function unicode(unicode2) {
        return JSON.parse('"\\' + unicode2 + '"');
      }
      function open2() {
        showModal.value = true;
      }
      return (_ctx, _cache) => {
        const _component_Icon = Vue.resolveComponent("Icon");
        const _component_Modal = Vue.resolveComponent("Modal");
        return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$1Q, [
          Vue.createElementVNode("div", {
            class: Vue.normalizeClass(["znpb-icon-trigger", { ["znpb-icon-trigger--no-icon"]: !__props.modelValue }]),
            onClick: Vue.withModifiers(open2, ["self"])
          }, [
            __props.modelValue ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_3$U, [
              Vue.createElementVNode("span", {
                class: "znpb-icon-preview",
                "data-znpbiconfam": __props.modelValue.family,
                "data-znpbicon": unicode(__props.modelValue.unicode),
                onClickPassive: _cache[0] || (_cache[0] = Vue.withModifiers(($event) => showModal.value = true, ["stop"]))
              }, null, 40, _hoisted_4$A),
              Vue.createVNode(_component_Icon, {
                icon: "delete",
                rounded: true,
                onClick: _cache[1] || (_cache[1] = Vue.withModifiers(($event) => _ctx.$emit("update:modelValue", null), ["stop"]))
              })
            ])) : (Vue.openBlock(), Vue.createElementBlock("span", {
              key: 1,
              onClick: _cache[2] || (_cache[2] = ($event) => showModal.value = true)
            }, Vue.toDisplayString(_ctx.$translate("select_icon")), 1))
          ], 10, _hoisted_2$1e),
          Vue.createVNode(_component_Modal, {
            show: showModal.value,
            "onUpdate:show": _cache[5] || (_cache[5] = ($event) => showModal.value = $event),
            width: 590,
            fullscreen: false,
            "append-to": ".znpb-center-area",
            "show-maximize": false,
            class: "znpb-icon-library-modal",
            title: _ctx.$translate("icon_library_title")
          }, {
            default: Vue.withCtx(() => [
              Vue.createVNode(_sfc_main$2p, {
                modelValue: Vue.unref(valueModel),
                "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => Vue.isRef(valueModel) ? valueModel.value = $event : null),
                "special-filter-pack": __props.specialFilterPack,
                onSelected: _cache[4] || (_cache[4] = ($event) => _ctx.$emit("update:modelValue", Vue.unref(valueModel)))
              }, null, 8, ["modelValue", "special-filter-pack"])
            ]),
            _: 1
          }, 8, ["show", "title"])
        ]);
      };
    }
  }));
  var InlineEdit_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$1P = ["readonly", "onKeydown"];
  const __default__$C = {
    name: "InlineEdit"
  };
  const _sfc_main$2n = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$C), {
    props: {
      modelValue: { default: "" },
      enabled: { type: Boolean, default: false },
      tag: { default: "div" }
    },
    emits: ["update:modelValue"],
    setup(__props, { emit }) {
      const props = __props;
      const root2 = Vue.ref(null);
      const isEnabled = Vue.ref(props.enabled);
      const computedModelValue = Vue.computed({
        get() {
          return props.modelValue;
        },
        set(newValue) {
          emit("update:modelValue", newValue);
        }
      });
      Vue.watch(isEnabled, (newValue) => {
        if (newValue) {
          document.addEventListener("click", disableOnOutsideClick, true);
        } else {
          document.removeEventListener("click", disableOnOutsideClick, true);
        }
      });
      Vue.onBeforeUnmount(() => {
        document.removeEventListener("click", disableOnOutsideClick, true);
      });
      function disableOnOutsideClick(event2) {
        if (event2.target !== root2.value) {
          disableEdit();
        }
      }
      function disableEdit() {
        var _a3;
        isEnabled.value = false;
        (_a3 = window.getSelection()) == null ? void 0 : _a3.removeAllRanges();
      }
      return (_ctx, _cache) => {
        return Vue.withDirectives((Vue.openBlock(), Vue.createElementBlock("input", {
          ref_key: "root",
          ref: root2,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => Vue.isRef(computedModelValue) ? computedModelValue.value = $event : null),
          readonly: !isEnabled.value,
          class: Vue.normalizeClass(["znpb-inlineEditInput", { "znpb-inlineEditInput--readonly": !isEnabled.value }]),
          onDblclick: _cache[1] || (_cache[1] = ($event) => isEnabled.value = true),
          onKeydown: Vue.withKeys(Vue.withModifiers(disableEdit, ["stop"]), ["escape"])
        }, null, 42, _hoisted_1$1P)), [
          [Vue.vModelText, Vue.unref(computedModelValue)]
        ]);
      };
    }
  }));
  var createHooksInstance = () => {
    const filters = {};
    const actions = {};
    const addAction2 = (event2, callback) => {
      if (typeof actions[event2] === "undefined") {
        actions[event2] = [];
      }
      actions[event2].push(callback);
    };
    function on(event2, callback) {
      console.warn("zb.hooks.on was deprecated in favour of window.zb.addAction");
      return addAction2(event2, callback);
    }
    const removeAction2 = (event2, callback) => {
      if (typeof actions[event2] !== "undefined") {
        const callbackIndex = actions[event2].indexOf(callback);
        if (callbackIndex !== -1) {
          actions[event2].splice(callbackIndex);
        }
      }
    };
    function off(event2, callback) {
      console.warn("zb.hooks.off was deprecated in favour of window.zb.addAction");
      return addAction2(event2, callback);
    }
    const doAction2 = (event2, ...data2) => {
      if (typeof actions[event2] !== "undefined") {
        actions[event2].forEach((callbackFunction) => {
          callbackFunction(...data2);
        });
      }
    };
    function trigger(event2, ...data2) {
      console.warn("zb.hooks.trigger was deprecated in favour of window.zb.addAction");
      return doAction2(event2, ...data2);
    }
    const addFilter2 = (id, callback) => {
      if (typeof filters[id] === "undefined") {
        filters[id] = [];
      }
      filters[id].push(callback);
    };
    const applyFilters2 = (id, value, ...params) => {
      if (typeof filters[id] !== "undefined") {
        filters[id].forEach((callback) => {
          value = callback(value, ...params);
        });
      }
      return value;
    };
    return {
      addAction: addAction2,
      removeAction: removeAction2,
      doAction: doAction2,
      addFilter: addFilter2,
      applyFilters: applyFilters2,
      on,
      off,
      trigger
    };
  };
  const hooks = createHooksInstance();
  const { addAction, removeAction, doAction, addFilter, applyFilters } = hooks;
  window.zb = window.zb || {};
  window.zb.hooks = hooks;
  var CustomSize_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$1O = { class: "znpb-forms-image-custom-size__wrapper" };
  const _hoisted_2$1d = { class: "znpb-forms-image-custom-size__option-separator" };
  const __default__$B = {
    name: "CustomSize",
    data() {
      return {};
    },
    methods: {}
  };
  const _sfc_main$2m = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$B), {
    props: {
      modelValue: null
    },
    emits: ["update:modelValue"],
    setup(__props, { emit }) {
      var _a3, _b;
      const props = __props;
      const width = Vue.ref((_a3 = props.modelValue) == null ? void 0 : _a3.width);
      const height = Vue.ref((_b = props.modelValue) == null ? void 0 : _b.height);
      function onCustomSizeClick() {
        if (width.value || height.value) {
          emit("update:modelValue", {
            width: width.value || "",
            height: height.value || ""
          });
        }
      }
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$1O, [
          Vue.createVNode(_sfc_main$2G, {
            title: _ctx.$translate("custom_width"),
            align: "center",
            class: "znpb-forms-image-custom-size__option-wrapper"
          }, {
            default: Vue.withCtx(() => [
              Vue.createVNode(_sfc_main$31, {
                modelValue: width.value,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => width.value = $event)
              }, null, 8, ["modelValue"])
            ]),
            _: 1
          }, 8, ["title"]),
          Vue.createElementVNode("div", _hoisted_2$1d, [
            Vue.createVNode(Vue.unref(_sfc_main$34), {
              icon: "close",
              size: 10
            })
          ]),
          Vue.createVNode(_sfc_main$2G, {
            title: _ctx.$translate("custom_height"),
            align: "center",
            class: "znpb-forms-image-custom-size__option-wrapper"
          }, {
            default: Vue.withCtx(() => [
              Vue.createVNode(_sfc_main$31, {
                modelValue: height.value,
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => height.value = $event)
              }, null, 8, ["modelValue"])
            ]),
            _: 1
          }, 8, ["title"]),
          Vue.createElementVNode("div", { class: "znpb-forms-image-custom-size__option-wrapper" }, [
            Vue.createElementVNode("button", {
              class: "znpb-button znpb-button--line znpb-forms-image-custom-size__apply-button",
              onClick: onCustomSizeClick
            }, " Apply ")
          ])
        ]);
      };
    }
  }));
  const __default__$A = {
    name: "Injection",
    inheritAttrs: false
  };
  const _sfc_main$2l = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$A), {
    props: {
      location: null,
      htmlTag: { default: "div" }
    },
    setup(__props) {
      const props = __props;
      const { getComponentsForLocation } = useInjections();
      const computedComponents = Vue.computed(() => getComponentsForLocation(props.location));
      return (_ctx, _cache) => {
        return Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList(Vue.unref(computedComponents), (customComponent, i) => {
          return Vue.openBlock(), Vue.createBlock(Vue.resolveDynamicComponent(customComponent), { key: i });
        }), 128);
      };
    }
  }));
  var InputImage_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$1N = { class: "znpb-input-image__wrapper" };
  const _hoisted_2$1c = { class: "znpb-input-image-holder__image-actions" };
  const _hoisted_3$T = ["onMousedown"];
  const _hoisted_4$z = /* @__PURE__ */ Vue.createElementVNode("span", { class: "znpb-input-image-holder__drag-button" }, null, -1);
  const _hoisted_5$r = [
    _hoisted_4$z
  ];
  const _hoisted_6$k = ["onClick"];
  const _hoisted_7$e = { class: "znpb-actions-overlay__expander-text" };
  const _hoisted_8$b = {
    key: 2,
    class: "znpb-input-image__custom-size-wrapper"
  };
  const wp = window.wp;
  const __default__$z = {
    name: "InputImage"
  };
  const _sfc_main$2k = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$z), {
    props: {
      modelValue: null,
      emptyText: { default: "No Image Selected" },
      shouldDragImage: { type: Boolean },
      positionLeft: { default: "50%" },
      positionTop: { default: "50%" },
      show_size: { type: Boolean }
    },
    emits: ["background-position-change", "update:modelValue"],
    setup(__props, { emit }) {
      const props = __props;
      const inputWrapper = Vue.inject("inputWrapper");
      const optionsForm = Vue.inject("optionsForm");
      const imageComponent = Vue.computed(() => {
        return applyFilters("zionbuilder/options/image/image_component", "img", props.modelValue);
      });
      const imageHolder = Vue.ref(null);
      const image = Vue.ref(null);
      const dragButton = Vue.ref(null);
      const attachmentId = Vue.ref(null);
      const isDragging = Vue.ref(false);
      const imageContainerPosition = Vue.ref({
        left: null,
        top: null
      });
      const imageHolderWidth = Vue.ref(null);
      const imageHolderHeight = Vue.ref(null);
      const previewExpanded = Vue.ref(false);
      const minHeight = Vue.ref(200);
      const imageHeight = Vue.ref(null);
      const initialX = Vue.ref(null);
      const initialY = Vue.ref(null);
      const attachmentModel = Vue.ref(null);
      const loading = Vue.ref(true);
      const dynamicImageSrc = Vue.ref(null);
      let mediaModal;
      Vue.watch(
        () => props.modelValue,
        (newValue, oldValue) => {
          if (newValue !== oldValue) {
            Vue.nextTick(() => {
              getImageHeight();
              if (previewExpanded.value) {
                toggleExpand();
              }
            });
          }
        }
      );
      const customComponent = Vue.computed(() => {
        const { applyFilters: applyFilters2 } = window.zb.hooks;
        return applyFilters2("zionbuilder/options/image/display_component", null, props.modelValue, inputWrapper, optionsForm);
      });
      const isSVG = Vue.computed(() => {
        if (imageSrc.value) {
          return imageSrc.value.endsWith(".svg");
        }
        return imageSrc.value;
      });
      const imageSizes = Vue.computed(() => {
        var _a3, _b, _c, _d;
        const options2 = [];
        const imageSizes2 = (_b = (_a3 = attachmentModel.value) == null ? void 0 : _a3.attributes) == null ? void 0 : _b.sizes;
        const customSizes = (_d = (_c = attachmentModel.value) == null ? void 0 : _c.attributes) == null ? void 0 : _d.zion_custom_sizes;
        const allSizes = __spreadValues(__spreadValues({}, imageSizes2), customSizes);
        Object.keys(allSizes).forEach((sizeKey) => {
          const name = startCase$1(sizeKey);
          const width = allSizes[sizeKey].width;
          const height = allSizes[sizeKey].height;
          const optionName = `${name} ( ${width} x ${height} )`;
          options2.push({
            name: optionName,
            id: sizeKey
          });
        });
        options2.push({
          name: "Custom",
          id: "custom"
        });
        return options2;
      });
      const sizeValue = Vue.computed({
        get() {
          var _a3;
          return typeof props.modelValue === "object" && ((_a3 = props.modelValue) == null ? void 0 : _a3.image_size) || "full";
        },
        set(newValue) {
          const value = typeof props.modelValue === "object" ? props.modelValue : {};
          emit("update:modelValue", __spreadProps(__spreadValues({}, value), {
            image_size: newValue
          }));
        }
      });
      const customSizeValue = Vue.computed({
        get() {
          var _a3;
          return typeof props.modelValue === "object" && ((_a3 = props.modelValue) == null ? void 0 : _a3.custom_size) || {};
        },
        set(newValue) {
          emit("update:modelValue", __spreadProps(__spreadValues({}, typeof props.modelValue === "object" && props.modelValue || {}), {
            custom_size: newValue
          }));
        }
      });
      const positionCircleStyle = Vue.computed(() => {
        return {
          left: props.positionLeft.includes("%") ? props.positionLeft : "",
          top: props.positionTop.includes("%") ? props.positionTop : ""
        };
      });
      const wrapperStyles = Vue.computed(() => {
        if (imageSrc.value && imageHolderHeight.value) {
          return {
            height: imageHolderHeight.value + "px"
          };
        }
        return {};
      });
      const imageValue = Vue.computed({
        get() {
          if (props.show_size) {
            return props.modelValue || {};
          } else {
            return props.modelValue || null;
          }
        },
        set(newValue) {
          if (props.show_size) {
            emit("update:modelValue", __spreadValues(__spreadValues({}, typeof props.modelValue === "object" && props.modelValue || {}), newValue));
          } else {
            emit("update:modelValue", newValue);
          }
        }
      });
      const imageSrc = Vue.computed(() => {
        var _a3;
        return dynamicImageSrc.value ? dynamicImageSrc.value : typeof props.modelValue === "object" ? ((_a3 = props.modelValue) == null ? void 0 : _a3.image) || null : props.modelValue || null;
      });
      const element = Vue.inject("ZionElement");
      Vue.watchEffect(() => {
        doAction("zionbuilder/input/image/src_url", dynamicImageSrc, props.modelValue, element);
      });
      const shouldDisplayExpander = Vue.computed(() => {
        return imageHolderHeight.value >= minHeight.value;
      });
      function getImageHeight() {
        if (!image.value) {
          return;
        }
        image.value.addEventListener("load", () => {
          const localImageHeight = image.value.getBoundingClientRect().height;
          imageHeight.value = localImageHeight;
          imageHolderHeight.value = localImageHeight < minHeight.value ? localImageHeight : minHeight.value;
        });
      }
      function toggleExpand() {
        previewExpanded.value = !previewExpanded.value;
        if (previewExpanded.value) {
          imageHolderHeight.value = imageHeight.value;
        } else {
          imageHolderHeight.value = minHeight.value;
        }
      }
      function startDrag(event2) {
        if (props.shouldDragImage) {
          window.addEventListener("mousemove", doDrag);
          window.addEventListener("mouseup", stopDrag);
          isDragging.value = true;
          const { height, width, left: left2, top: top2 } = imageHolder.value.getBoundingClientRect();
          imageHolderWidth.value = width;
          imageHolderHeight.value = height;
          imageContainerPosition.value.left = left2;
          imageContainerPosition.value.top = top2;
          initialX.value = event2.pageX;
          initialY.value = event2.pageY;
        }
      }
      function doDrag(event2) {
        window.document.body.style.userSelect = "none";
        const movedX = event2.clientX - imageContainerPosition.value.left;
        const movedY = event2.clientY - imageContainerPosition.value.top;
        let xToSend = clamp(Math.round(movedX / imageHolderWidth.value * 100), 0, 100);
        let yToSend = clamp(Math.round(movedY / imageHolderHeight.value * 100), 0, 100);
        if (event2.shiftKey) {
          xToSend = Math.round(xToSend / 5) * 5;
          yToSend = Math.round(yToSend / 5) * 5;
        }
        emit("background-position-change", { x: xToSend, y: yToSend });
      }
      function stopDrag(event2) {
        initialX.value = event2.pageX;
        initialY.value = event2.pageY;
        window.removeEventListener("mousemove", doDrag);
        window.removeEventListener("mouseup", stopDrag);
        window.document.body.style.userSelect = "";
        setTimeout(() => {
          isDragging.value = false;
        }, 100);
      }
      function openMediaModal() {
        if (isDragging.value) {
          return;
        }
        if (!mediaModal) {
          const args = {
            frame: "select",
            state: "zion-media",
            library: {
              type: "image"
            },
            button: {
              text: "Add Image"
            }
          };
          mediaModal = new window.wp.media.view.MediaFrame.ZionBuilderFrame(args);
          mediaModal.on("select update insert", selectMedia);
          mediaModal.on("open", setMediaModalSelection);
        }
        mediaModal.open();
      }
      function selectMedia() {
        const selection = mediaModal.state().get("selection").first();
        if (props.show_size) {
          emit("update:modelValue", {
            image: selection.get("url")
          });
        } else {
          imageValue.value = selection.get("url");
        }
        attachmentId.value = selection.get("id");
        attachmentModel.value = selection;
        loading.value = false;
      }
      function setMediaModalSelection() {
        const selection = mediaModal.state().get("selection");
        if (imageSrc.value && !attachmentId.value) {
          const attachment = wp.media.model.Attachment.get(imageSrc.value);
          attachment.fetch({
            data: {
              is_media_image: true,
              image_url: imageSrc.value
            }
          }).done((event2) => {
            if (event2 && event2.id) {
              attachmentId.value = event2.id;
              const attachment2 = wp.media.model.Attachment.get(attachmentId.value);
              selection.reset(attachment2 ? [attachment2] : []);
            }
          });
        } else if (imageSrc.value && attachmentId.value) {
          const attachment = wp.media.model.Attachment.get(attachmentId.value);
          selection.reset(attachment ? [attachment] : []);
        }
      }
      function deleteImage() {
        emit("update:modelValue", null);
        attachmentId.value = null;
        if (mediaModal) {
          let selection = mediaModal.state().get("selection");
          selection.reset([]);
        }
      }
      function getAttachmentModel() {
        if (imageSrc.value && !attachmentModel.value) {
          const attachment = wp.media.model.Attachment.get(imageSrc.value);
          attachment.fetch({
            data: {
              is_media_image: true,
              image_url: imageSrc.value
            }
          }).done((event2) => {
            if (event2 == null ? void 0 : event2.id) {
              attachmentId.value = event2.id;
              attachmentModel.value = wp.media.model.Attachment.get(attachmentId.value);
            }
            loading.value = false;
          });
        }
      }
      Vue.onMounted(() => {
        if (props.show_size) {
          getAttachmentModel();
        } else {
          loading.value = false;
        }
        getImageHeight();
      });
      Vue.watch(dynamicImageSrc, () => {
        getAttachmentModel();
      });
      Vue.onBeforeUnmount(() => {
        window.removeEventListener("mousemove", doDrag);
        window.removeEventListener("mouseup", stopDrag);
        window.document.body.style.userSelect = "";
        if (mediaModal) {
          mediaModal.detach();
        }
      });
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$1N, [
          Vue.unref(customComponent) ? (Vue.openBlock(), Vue.createBlock(Vue.resolveDynamicComponent(Vue.unref(customComponent)), { key: 0 })) : (Vue.openBlock(), Vue.createElementBlock("div", {
            key: 1,
            ref_key: "imageHolder",
            ref: imageHolder,
            class: "znpb-input-image-holder",
            style: Vue.normalizeStyle(Vue.unref(wrapperStyles)),
            onClick: openMediaModal
          }, [
            Vue.createVNode(Vue.unref(_sfc_main$32), {
              "show-overlay": !isDragging.value
            }, {
              actions: Vue.withCtx(() => [
                Vue.createElementVNode("div", _hoisted_2$1c, [
                  Vue.createVNode(_sfc_main$34, {
                    rounded: true,
                    icon: "delete",
                    "bg-size": 30,
                    onClick: Vue.withModifiers(deleteImage, ["stop"])
                  }, null, 8, ["onClick"]),
                  Vue.createVNode(Vue.unref(_sfc_main$2l), { location: "options/image/actions" })
                ])
              ]),
              default: Vue.withCtx(() => [
                (Vue.openBlock(), Vue.createBlock(Vue.resolveDynamicComponent(Vue.unref(imageComponent)), {
                  src: Vue.unref(imageSrc),
                  class: "znpb-input-image-holder__image"
                }, null, 8, ["src"]))
              ]),
              _: 1
            }, 8, ["show-overlay"]),
            __props.shouldDragImage && (previewExpanded.value || !Vue.unref(shouldDisplayExpander)) ? (Vue.openBlock(), Vue.createElementBlock("div", {
              key: 0,
              ref_key: "dragButton",
              ref: dragButton,
              class: "znpb-drag-icon-wrapper",
              style: Vue.normalizeStyle(Vue.unref(positionCircleStyle)),
              onMousedown: Vue.withModifiers(startDrag, ["stop"])
            }, _hoisted_5$r, 44, _hoisted_3$T)) : Vue.createCommentVNode("", true),
            !isDragging.value && __props.shouldDragImage && Vue.unref(shouldDisplayExpander) && Vue.unref(imageSrc) ? (Vue.openBlock(), Vue.createElementBlock("div", {
              key: 1,
              class: Vue.normalizeClass(["znpb-actions-overlay__expander", { "znpb-actions-overlay__expander--icon-rotated": previewExpanded.value }]),
              onClick: Vue.withModifiers(toggleExpand, ["stop"])
            }, [
              Vue.createElementVNode("strong", _hoisted_7$e, Vue.toDisplayString(previewExpanded.value ? "CONTRACT" : "EXPAND"), 1),
              Vue.createVNode(_sfc_main$34, {
                icon: "select",
                "bg-size": 12
              })
            ], 10, _hoisted_6$k)) : Vue.createCommentVNode("", true),
            !Vue.unref(imageSrc) && !Vue.unref(customComponent) ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$2P), {
              key: 2,
              class: "znpb-input-image-holder__empty",
              "no-margin": true
            }, {
              default: Vue.withCtx(() => [
                Vue.createTextVNode(Vue.toDisplayString(__props.emptyText) + " ", 1),
                Vue.createVNode(Vue.unref(_sfc_main$2l), { location: "options/image/actions" })
              ]),
              _: 1
            })) : Vue.createCommentVNode("", true)
          ], 4)),
          __props.show_size && Vue.unref(imageSrc) && !Vue.unref(isSVG) && !loading.value ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_8$b, [
            Vue.createVNode(Vue.unref(_sfc_main$2G), { title: "Image size" }, {
              default: Vue.withCtx(() => [
                Vue.createVNode(Vue.unref(InputSelect), {
                  modelValue: Vue.unref(sizeValue),
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => Vue.isRef(sizeValue) ? sizeValue.value = $event : null),
                  options: Vue.unref(imageSizes)
                }, null, 8, ["modelValue", "options"])
              ]),
              _: 1
            }),
            Vue.unref(sizeValue) === "custom" ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$2G), { key: 0 }, {
              default: Vue.withCtx(() => [
                Vue.createVNode(_sfc_main$2m, {
                  modelValue: Vue.unref(customSizeValue),
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => Vue.isRef(customSizeValue) ? customSizeValue.value = $event : null)
                }, null, 8, ["modelValue"])
              ]),
              _: 1
            })) : Vue.createCommentVNode("", true)
          ])) : Vue.createCommentVNode("", true)
        ]);
      };
    }
  }));
  const schemas = Vue.ref({
    element_advanced: window.ZnPbComponentsData.schemas.element_advanced,
    element_styles: window.ZnPbComponentsData.schemas.styles,
    typography: window.ZnPbComponentsData.schemas.typography,
    videoOptionSchema: window.ZnPbComponentsData.schemas.video,
    backgroundImageSchema: window.ZnPbComponentsData.schemas.background_image,
    shadowSchema: window.ZnPbComponentsData.schemas.shadow,
    styles: window.ZnPbComponentsData.schemas.styles
  });
  const useOptionsSchemas = () => {
    const getSchema = (schemaId) => {
      return cloneDeep(schemas.value[schemaId]) || {};
    };
    const registerSchema2 = (schemaId, schema) => {
      schemas.value[schemaId] = schema;
    };
    return {
      schemas,
      getSchema,
      registerSchema: registerSchema2
    };
  };
  var BackgroundImage_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$1M = { class: "znpb-input-background-image" };
  const __default__$y = {
    name: "InputBackgroundImage"
  };
  const _sfc_main$2j = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$y), {
    props: {
      modelValue: null
    },
    emits: ["update:modelValue"],
    setup(__props, { emit }) {
      const props = __props;
      const { getSchema } = useOptionsSchemas();
      const backgroundImageSchema = getSchema("backgroundImageSchema");
      const computedValue = Vue.computed({
        get() {
          return props.modelValue || {};
        },
        set(newValue) {
          emit("update:modelValue", newValue);
        }
      });
      const backgroundPositionXModel = Vue.computed(() => computedValue.value["background-position-x"]);
      const backgroundPositionYModel = Vue.computed(() => computedValue.value["background-position-y"]);
      function changeBackgroundPosition(position) {
        emit("update:modelValue", __spreadProps(__spreadValues({}, computedValue.value), {
          "background-position-x": `${position.x}%`,
          "background-position-y": `${position.y}%`
        }));
      }
      function onOptionUpdated(optionId, newValue) {
        const newValues = __spreadValues({}, props.modelValue);
        newValues[optionId] = newValue;
        computedValue.value = newValues;
      }
      return (_ctx, _cache) => {
        const _component_OptionsForm = Vue.resolveComponent("OptionsForm");
        return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$1M, [
          Vue.createVNode(_sfc_main$2k, {
            modelValue: Vue.unref(computedValue)["background-image"],
            "should-drag-image": true,
            "position-top": Vue.unref(backgroundPositionYModel),
            "position-left": Vue.unref(backgroundPositionXModel),
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => onOptionUpdated("background-image", $event)),
            onBackgroundPositionChange: changeBackgroundPosition
          }, null, 8, ["modelValue", "position-top", "position-left"]),
          Vue.createVNode(_component_OptionsForm, {
            modelValue: Vue.unref(computedValue),
            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => Vue.isRef(computedValue) ? computedValue.value = $event : null),
            schema: Vue.unref(backgroundImageSchema)
          }, null, 8, ["modelValue", "schema"])
        ]);
      };
    }
  }));
  /**
    reframe.js - Reframe.js: responsive iframes for embedded content
    @version v4.0.1
    @link https://github.com/yowainwright/reframe.ts#readme
    @author Jeff Wainwright <yowainwright@gmail.com> (http://jeffry.in)
    @license MIT
  **/
  function reframe(target, cName) {
    var _a3, _b;
    var frames = typeof target === "string" ? document.querySelectorAll(target) : target;
    var c = cName || "js-reframe";
    if (!("length" in frames))
      frames = [frames];
    for (var i = 0; i < frames.length; i += 1) {
      var frame = frames[i];
      var hasClass = frame.className.split(" ").indexOf(c) !== -1;
      if (hasClass || frame.style.width.indexOf("%") > -1) {
        return;
      }
      var height = frame.getAttribute("height") || frame.offsetHeight;
      var width = frame.getAttribute("width") || frame.offsetWidth;
      var heightNumber = typeof height === "string" ? parseInt(height) : height;
      var widthNumber = typeof width === "string" ? parseInt(width) : width;
      var padding = heightNumber / widthNumber * 100;
      var div = document.createElement("div");
      div.className = c;
      var divStyles = div.style;
      divStyles.position = "relative";
      divStyles.width = "100%";
      divStyles.paddingTop = "".concat(padding, "%");
      var frameStyle = frame.style;
      frameStyle.position = "absolute";
      frameStyle.width = "100%";
      frameStyle.height = "100%";
      frameStyle.left = "0";
      frameStyle.top = "0";
      (_a3 = frame.parentNode) === null || _a3 === void 0 ? void 0 : _a3.insertBefore(div, frame);
      (_b = frame.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(frame);
      div.appendChild(frame);
    }
  }
  let YoutubeApiLoadedState = 0;
  let vimeoApiLoadedState = 0;
  let videoIndex = 0;
  let vimeoVolume = 1;
  const globalEventBus = createHooksInstance();
  class Video {
    constructor(domNode, options2 = {}) {
      __publicField(this, "options", {});
      __publicField(this, "eventBus");
      __publicField(this, "on");
      __publicField(this, "off");
      __publicField(this, "trigger");
      __publicField(this, "domNode");
      __publicField(this, "videoIndex");
      __publicField(this, "videoContainer", null);
      __publicField(this, "videoSource", "local");
      __publicField(this, "YoutubeId");
      __publicField(this, "player");
      __publicField(this, "muted", true);
      __publicField(this, "playing", true);
      this.options = __spreadValues({
        autoplay: true,
        muted: true,
        loop: true,
        controls: true,
        controlsPosition: "bottom-left",
        videoSource: "local",
        responsive: true
      }, options2);
      this.eventBus = createHooksInstance();
      this.on = this.eventBus.addAction;
      this.off = this.eventBus.removeAction;
      this.trigger = this.eventBus.doAction;
      this.domNode = domNode;
      this.videoIndex = videoIndex++;
      this.videoContainer = null;
      if (this.options.responsive) {
        this.on("video_ready", () => {
          reframe(this.videoContainer);
        });
      }
      this.domNode.zionVideo = this;
      this.nextTick(() => {
        if (this.options.videoSource === "local" && this.options.mp4) {
          this.videoSource = "local";
          this.setupLocal();
        } else if (this.options.videoSource === "youtube" && this.options.youtubeURL) {
          this.videoSource = "youtube";
          this.YoutubeId = this.youtubeUrlParser(this.options.youtubeURL);
          this.setupYoutube();
        } else if (this.options.videoSource === "vimeo" && this.options.vimeoURL) {
          this.videoSource = "vimeo";
          this.setupVimeo();
        }
      });
    }
    youtubeUrlParser(url) {
      const regExp = /^.*((youtu.be\/)|(v\/)|(\/u\/\w\/)|(embed\/)|(watch\?))\??v?=?([^#&?]*).*/;
      const match = url.match(regExp);
      return match && match[7].length === 11 ? match[7] : false;
    }
    nextTick(callback) {
      setTimeout(() => {
        callback();
      }, 0);
    }
    setupYoutube() {
      const YtParams = {
        mute: this.options.muted ? 1 : 0,
        autoplay: this.options.autoplay ? 1 : 0,
        iv_load_policy: 3,
        showinfo: 0,
        controls: this.options.controls ? 1 : 0,
        modestbranding: 1,
        rel: 0,
        wmode: "transparent"
      };
      let YtParamsString = "";
      for (const [key, value] of Object.entries(YtParams)) {
        YtParamsString += `&${key}=${value}`;
      }
      const youtubeIframe = document.createElement("iframe");
      youtubeIframe.src = `https://www.youtube-nocookie.com/embed/${this.YoutubeId}?enablejsapi=1${YtParamsString}`;
      youtubeIframe.id = `znpb-video-bg-youtube-${this.videoIndex}`;
      youtubeIframe.allow = "autoplay; fullscreen";
      youtubeIframe.width = 425;
      youtubeIframe.height = 239;
      this.domNode.appendChild(youtubeIframe);
      if (YoutubeApiLoadedState === 0) {
        const youtubeTag = document.createElement("script");
        youtubeTag.src = "https://www.youtube.com/iframe_api";
        const firstScriptTag = document.getElementsByTagName("script")[0];
        firstScriptTag.parentNode.insertBefore(youtubeTag, firstScriptTag);
        const self2 = this;
        window.onYouTubeIframeAPIReady = function() {
          self2.enableYoutube();
          globalEventBus.doAction("youtube_api_ready");
          YoutubeApiLoadedState = 2;
        };
        YoutubeApiLoadedState = 1;
      } else if (YoutubeApiLoadedState === 1) {
        globalEventBus.on("youtube_api_ready", this.enableYoutube.bind(this));
      } else if (YoutubeApiLoadedState === 2) {
        this.enableYoutube();
      }
    }
    enableYoutube() {
      this.player = new window.YT.Player(`znpb-video-bg-youtube-${this.videoIndex}`, {
        height: "100%",
        width: "100%",
        videoId: this.YoutubeId
      });
      this.videoContainer = this.player.getIframe();
      this.trigger("video_ready");
    }
    setupVimeo() {
      const vimeoContainer = document.createElement("div");
      vimeoContainer.id = `znpb-video-bg-vimeo-${this.videoIndex}`;
      this.domNode.appendChild(vimeoContainer);
      if (vimeoApiLoadedState === 0) {
        const vimeoTag = document.createElement("script");
        vimeoTag.src = "https://player.vimeo.com/api/player.js";
        const secondScriptTag = document.getElementsByTagName("script")[1];
        const self2 = this;
        secondScriptTag.parentNode.insertBefore(vimeoTag, secondScriptTag);
        vimeoTag.onload = function() {
          self2.enableVimeo();
          globalEventBus.doAction("vimeo_api_ready");
          vimeoApiLoadedState = 2;
        };
        vimeoApiLoadedState = 1;
      } else if (vimeoApiLoadedState === 1) {
        globalEventBus.on("vimeo_api_ready", this.enableVimeo.bind(this));
      } else if (vimeoApiLoadedState === 2) {
        this.enableVimeo();
      }
    }
    enableVimeo() {
      this.player = new window.Vimeo.Player(`znpb-video-bg-vimeo-${this.videoIndex}`, {
        id: this.options.vimeoURL,
        background: this.options.autoplay,
        muted: this.options.muted,
        transparent: true,
        autoplay: this.options.autoplay,
        controls: this.options.controls
      });
      this.player.ready().then(() => {
        this.videoContainer = this.player.element;
        this.trigger("video_ready");
      });
    }
    setupLocal() {
      const autoplay = this.options.autoplay ? "autoplay" : "";
      const muted = this.options.muted ? "muted" : "";
      const loop = this.options.loop ? "loop" : "";
      const videoElement = document.createElement("video");
      videoElement.muted = muted;
      videoElement.autoplay = autoplay;
      videoElement.loop = loop;
      if (this.options.controls) {
        videoElement.controls = true;
      }
      if (this.options.mp4) {
        const sourceMP4 = document.createElement("source");
        sourceMP4.src = this.options.mp4;
        videoElement.appendChild(sourceMP4);
      }
      this.domNode.appendChild(videoElement);
      this.player = videoElement;
      this.videoContainer = videoElement;
      this.trigger("video_ready");
    }
    getVideoContainer() {
      return this.videoContainer;
    }
    play() {
      if (this.videoSource === "youtube") {
        this.player.playVideo();
      }
      if (this.videoSource === "vimeo") {
        this.player.play();
      }
      if (this.videoSource === "local") {
        this.player.play();
      }
      this.playing = true;
    }
    pause() {
      if (this.videoSource === "youtube") {
        this.player.pauseVideo();
      }
      if (this.videoSource === "vimeo") {
        this.player.pause();
      }
      if (this.videoSource === "local") {
        this.player.pause();
      }
      this.playing = false;
    }
    togglePlay() {
      if (this.playing) {
        this.pause();
      } else {
        this.play();
      }
    }
    mute() {
      if (this.videoSource === "youtube") {
        this.player.mute();
      }
      if (this.videoSource === "vimeo") {
        this.player.getVolume().then((volume) => {
          vimeoVolume = volume;
        });
        this.player.setVolume(0);
      }
      if (this.videoSource === "local") {
        this.player.muted = true;
      }
      this.muted = true;
    }
    unMute() {
      if (this.videoSource === "youtube") {
        this.player.unMute();
      }
      if (this.videoSource === "vimeo") {
        this.player.setVolume(vimeoVolume);
      }
      if (this.videoSource === "local") {
        this.player.muted = false;
      }
      this.muted = false;
    }
    toggleMute() {
      if (this.muted) {
        this.unMute();
      } else {
        this.mute();
      }
    }
    destroy() {
      this.trigger("beforeDestroy");
      this.player = null;
      while (this.domNode.firstChild) {
        this.domNode.removeChild(this.domNode.firstChild);
      }
    }
  }
  window.zbVideo = Video;
  var InputBackgroundVideo_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$1L = { class: "znpb-input-background-video" };
  const _hoisted_2$1b = { class: "znpb-input-background-video__holder" };
  const __default__$x = {
    name: "InputBackgroundVideo"
  };
  const _sfc_main$2i = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$x), {
    props: {
      modelValue: null,
      options: null,
      exclude_options: null
    },
    emits: ["update:modelValue"],
    setup(__props, { emit }) {
      const props = __props;
      const videoInstance = Vue.ref(null);
      const mediaModal = Vue.ref(null);
      const videoPreview = Vue.ref(null);
      const { getSchema } = useOptionsSchemas();
      const schema = Vue.computed(() => {
        const schema2 = __spreadValues({}, getSchema("videoOptionSchema"));
        if (props.exclude_options) {
          props.exclude_options.forEach((optionToRemove) => {
            if (schema2[optionToRemove]) {
              delete schema2[optionToRemove];
            }
          });
        }
        return schema2;
      });
      const computedValue = Vue.computed({
        get() {
          return props.modelValue || {};
        },
        set(newValue) {
          emit("update:modelValue", newValue);
        }
      });
      const hasVideo = Vue.computed(() => {
        if (videoSourceModel.value === "local" && computedValue.value.mp4) {
          return true;
        }
        if (videoSourceModel.value === "youtube" && computedValue.value.youtubeURL) {
          return true;
        }
        if (videoSourceModel.value === "vimeo" && computedValue.value.vimeoURL) {
          return true;
        }
        return false;
      });
      const videoSourceModel = Vue.computed({
        get() {
          return computedValue.value["videoSource"] || "local";
        },
        set(newValue) {
          emit("update:modelValue", __spreadProps(__spreadValues({}, props.modelValue), {
            videoSource: newValue
          }));
        }
      });
      Vue.watch(computedValue, () => {
        if (videoInstance.value) {
          videoInstance.value.destroy();
        }
        if (hasVideo.value) {
          initVideo();
        }
      });
      function initVideo() {
        Vue.nextTick(() => {
          videoInstance.value = new Video(videoPreview.value, computedValue.value);
        });
      }
      function openMediaModal() {
        if (mediaModal.value === null) {
          const args = {
            frame: "select",
            state: "library",
            library: { type: "video" },
            button: { text: "Add video" },
            selection: computedValue.value
          };
          mediaModal.value = window.wp.media(args);
          mediaModal.value.on("select update insert", selectMedia);
        }
        mediaModal.value.open();
      }
      function selectMedia() {
        const selection = mediaModal.value.state().get("selection").toJSON();
        emit("update:modelValue", __spreadProps(__spreadValues({}, computedValue.value), {
          mp4: selection[0].url
        }));
      }
      function deleteVideo() {
        const _a3 = computedValue.value, { mp4 } = _a3, rest = __objRest(_a3, ["mp4"]);
        emit("update:modelValue", __spreadValues({}, rest));
      }
      Vue.onMounted(() => {
        if (hasVideo.value) {
          initVideo();
        }
      });
      return (_ctx, _cache) => {
        const _component_OptionsForm = Vue.resolveComponent("OptionsForm");
        return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$1L, [
          Vue.createElementVNode("div", _hoisted_2$1b, [
            Vue.unref(hasVideo) ? (Vue.openBlock(), Vue.createElementBlock("div", {
              key: 0,
              ref_key: "videoPreview",
              ref: videoPreview,
              class: "znpb-input-background-video__source"
            }, null, 512)) : (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$2P), {
              key: 1,
              class: "znpb-input-background-video__empty znpb-input-background-video__source",
              "no-margin": true,
              onClick: openMediaModal
            }, {
              default: Vue.withCtx(() => [
                Vue.createTextVNode(Vue.toDisplayString(_ctx.$translate("no_video_selected")), 1)
              ]),
              _: 1
            })),
            Vue.unref(videoSourceModel) == "local" && Vue.unref(hasVideo) ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$34), {
              key: 2,
              class: "znpb-input-background-video__delete",
              icon: "delete",
              "bg-size": 30,
              "bg-color": "#fff",
              onClick: Vue.withModifiers(deleteVideo, ["stop"])
            }, null, 8, ["onClick"])) : Vue.createCommentVNode("", true)
          ]),
          Vue.createVNode(_component_OptionsForm, {
            modelValue: Vue.unref(computedValue),
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => Vue.isRef(computedValue) ? computedValue.value = $event : null),
            schema: Vue.unref(schema),
            class: "znpb-input-background-video__holder"
          }, null, 8, ["modelValue", "schema"])
        ]);
      };
    }
  }));
  var InputBorderControl_vue_vue_type_style_index_0_lang = "";
  const __default__$w = {
    name: "InputBorderControl"
  };
  const _sfc_main$2h = Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$w), {
    props: {
      modelValue: null,
      title: null,
      placeholder: { default: () => {
        return {};
      } }
    },
    emits: ["update:modelValue"],
    setup(__props, { emit }) {
      const props = __props;
      const schema = Vue.computed(() => {
        return {
          color: {
            id: "color",
            type: "colorpicker",
            css_class: "znpb-border-control-group-item",
            title: "Color",
            width: 100,
            placeholder: props.placeholder ? props.placeholder["color"] : null
          },
          width: {
            id: "width",
            type: "number_unit",
            title: "Width",
            min: 0,
            max: 999,
            default_unit: "px",
            step: 1,
            css_class: "znpb-border-control-group-item",
            width: 50,
            placeholder: props.placeholder ? props.placeholder["width"] : null
          },
          style: {
            id: "style",
            type: "select",
            title: "Style",
            options: ["solid", "dashed", "dotted", "double", "groove", "ridge", "inset", "outset"].map((style) => {
              return { name: style, id: style };
            }),
            css_class: "znpb-border-control-group-item",
            width: 50,
            placeholder: props.placeholder ? props.placeholder["style"] : "solid"
          }
        };
      });
      const computedValue = Vue.computed({
        get() {
          return props.modelValue || {};
        },
        set(newValue) {
          emit("update:modelValue", newValue);
        }
      });
      return (_ctx, _cache) => {
        const _component_OptionsForm = Vue.resolveComponent("OptionsForm");
        return Vue.openBlock(), Vue.createBlock(_component_OptionsForm, {
          modelValue: Vue.unref(computedValue),
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => Vue.isRef(computedValue) ? computedValue.value = $event : null),
          schema: Vue.unref(schema),
          class: "znpb-border-control-group"
        }, null, 8, ["modelValue", "schema"]);
      };
    }
  }));
  var InputBorderTabs_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$1K = { class: "znpb-input-border-tabs-wrapper" };
  const __default__$v = {
    name: "InputBorderTabs"
  };
  const _sfc_main$2g = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$v), {
    props: {
      modelValue: null,
      placeholder: null
    },
    emits: ["update:modelValue"],
    setup(__props, { emit }) {
      const props = __props;
      const positions = [
        {
          name: "all",
          icon: "all-sides",
          id: "all"
        },
        {
          name: "Top",
          icon: "border-top",
          id: "top"
        },
        {
          name: "right",
          icon: "border-right",
          id: "right"
        },
        {
          name: "bottom",
          icon: "border-bottom",
          id: "bottom"
        },
        {
          name: "left",
          icon: "border-left",
          id: "left"
        }
      ];
      const computedValue = Vue.computed(() => props.modelValue || {});
      function onValueUpdated(position, newValue) {
        const clonedValue = cloneDeep(props.modelValue || {});
        if (newValue === null) {
          unset(clonedValue, position);
        } else {
          set(clonedValue, position, newValue);
        }
        if (Object.keys(clonedValue).length > 0) {
          emit("update:modelValue", clonedValue);
        } else {
          emit("update:modelValue", null);
        }
      }
      return (_ctx, _cache) => {
        const _component_Tab = Vue.resolveComponent("Tab");
        const _component_Tabs = Vue.resolveComponent("Tabs");
        return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$1K, [
          Vue.createVNode(_component_Tabs, {
            "tab-style": "group",
            class: "znpb-input-border-tabs"
          }, {
            default: Vue.withCtx(() => [
              (Vue.openBlock(), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList(positions, (tab) => {
                return Vue.createVNode(_component_Tab, {
                  key: tab.id,
                  name: tab.name,
                  class: "znpb-input-border-tabs__tab"
                }, {
                  title: Vue.withCtx(() => [
                    Vue.createElementVNode("div", null, [
                      Vue.createVNode(Vue.unref(_sfc_main$34), {
                        icon: tab.icon
                      }, null, 8, ["icon"])
                    ])
                  ]),
                  default: Vue.withCtx(() => [
                    Vue.createVNode(_sfc_main$2h, {
                      modelValue: Vue.unref(computedValue)[tab.id] || {},
                      placeholder: __props.placeholder ? __props.placeholder[tab.id] : null,
                      "onUpdate:modelValue": ($event) => onValueUpdated(tab.id, $event)
                    }, null, 8, ["modelValue", "placeholder", "onUpdate:modelValue"])
                  ]),
                  _: 2
                }, 1032, ["name"]);
              }), 64))
            ]),
            _: 1
          })
        ]);
      };
    }
  }));
  var InputBorderRadius_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$1J = { class: "znpb-input-border-radius-wrapper" };
  const __default__$u = {
    name: "InputBorderRadius"
  };
  const _sfc_main$2f = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$u), {
    props: {
      modelValue: { default: "" },
      title: { default: "" }
    },
    emits: ["update:modelValue"],
    setup(__props, { emit }) {
      const props = __props;
      const computedValue = Vue.computed({
        get() {
          return props.modelValue;
        },
        set(newValue) {
          emit("update:modelValue", newValue);
        }
      });
      return (_ctx, _cache) => {
        const _component_InputLabel = Vue.resolveComponent("InputLabel");
        return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$1J, [
          __props.title.length ? (Vue.openBlock(), Vue.createBlock(_component_InputLabel, {
            key: 0,
            label: __props.title,
            class: "znpb-typography-group-item znpb-typography-group-item-font-weight"
          }, {
            default: Vue.withCtx(() => [
              Vue.createVNode(Vue.unref(_sfc_main$2X), {
                modelValue: Vue.unref(computedValue),
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => Vue.isRef(computedValue) ? computedValue.value = $event : null),
                min: 0,
                max: 999,
                default_unit: "px",
                step: 1,
                "default-unit": "px"
              }, null, 8, ["modelValue"])
            ]),
            _: 1
          }, 8, ["label"])) : Vue.createCommentVNode("", true)
        ]);
      };
    }
  }));
  var InputBorderRadiusTabs_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$2e = {
    name: "InputBorderRadiusTabs",
    components: {
      InputBorderRadius: _sfc_main$2f,
      Icon: _sfc_main$34
    },
    props: {
      modelValue: {
        default() {
          return {};
        },
        type: Object,
        required: false
      }
    },
    data() {
      return {
        borderRadiusTabs: {
          all: {
            name: "all borders",
            icon: "all-corners",
            id: "all-borders-radius",
            description: "All borders"
          },
          topLeft: {
            name: "top left",
            icon: "t-l-corner",
            id: "border-top-left-radius",
            description: "Top Left Border"
          },
          topRight: {
            name: "top right",
            icon: "t-r-corner",
            id: "border-top-right-radius",
            description: "Top Right Border"
          },
          bottomRight: {
            name: "bottom right",
            icon: "b-r-corner",
            id: "border-bottom-right-radius",
            description: "Bottom Right Border"
          },
          bottomLeft: {
            name: "bottom left",
            icon: "t-l-corner",
            id: "border-bottom-left-radius",
            description: "Bottom Left Border"
          }
        }
      };
    },
    computed: {
      computedValue() {
        return this.modelValue || {};
      }
    },
    methods: {
      onValueUpdated(position, newValue) {
        this.$emit("update:modelValue", __spreadProps(__spreadValues({}, this.modelValue), {
          [position]: newValue
        }));
      }
    }
  };
  const _hoisted_1$1I = { class: "znpb-input-border-radius-tabs-wrapper" };
  const _hoisted_2$1a = /* @__PURE__ */ Vue.createElementVNode("div", null, null, -1);
  function _sfc_render$17(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_InputBorderRadius = Vue.resolveComponent("InputBorderRadius");
    const _component_Tab = Vue.resolveComponent("Tab");
    const _component_Tabs = Vue.resolveComponent("Tabs");
    return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$1I, [
      Vue.createVNode(_component_Tabs, {
        "tab-style": "group",
        class: "znpb-input-border-radius-tabs"
      }, {
        default: Vue.withCtx(() => [
          (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList($data.borderRadiusTabs, (tab, index2) => {
            return Vue.openBlock(), Vue.createBlock(_component_Tab, {
              key: index2,
              name: tab.name
            }, {
              title: Vue.withCtx(() => [
                _hoisted_2$1a
              ]),
              default: Vue.withCtx(() => [
                Vue.createVNode(_component_InputBorderRadius, {
                  title: tab.name,
                  modelValue: $options.computedValue[tab.id] || null,
                  "onUpdate:modelValue": ($event) => $options.onValueUpdated(tab.id, $event)
                }, null, 8, ["title", "modelValue", "onUpdate:modelValue"])
              ]),
              _: 2
            }, 1032, ["name"]);
          }), 128))
        ]),
        _: 1
      })
    ]);
  }
  var InputBorderRadiusTabs = /* @__PURE__ */ _export_sfc(_sfc_main$2e, [["render", _sfc_render$17]]);
  var InputCheckbox_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$1H = ["aria-disabled"];
  const _hoisted_2$19 = ["disabled", "value"];
  const _hoisted_3$S = {
    key: 0,
    class: "znpb-checkmark-option"
  };
  const __default__$t = {
    name: "InputCheckbox"
  };
  const _sfc_main$2d = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$t), {
    props: {
      label: null,
      showLabel: { type: Boolean, default: true },
      modelValue: { type: [Boolean, Array], default: true },
      optionValue: { type: [String, Boolean] },
      disabled: { type: Boolean },
      checked: { type: Boolean },
      rounded: { type: Boolean },
      placeholder: { type: [Boolean, Array], default: () => {
        return [];
      } }
    },
    emits: ["update:modelValue", "change"],
    setup(__props, { emit }) {
      const props = __props;
      const isLimitExceeded = Vue.ref(false);
      const slots = Vue.useSlots();
      const model = Vue.computed({
        get() {
          return props.modelValue;
        },
        set(newValue) {
          var _a3, _b, _c, _d, _e;
          isLimitExceeded.value = false;
          const allowUnselect = (_a3 = parentGroup.value) == null ? void 0 : _a3.allowUnselect;
          if (Array.isArray(newValue)) {
            isLimitExceeded.value = false;
            if (((_b = parentGroup.value) == null ? void 0 : _b.min) !== void 0 && newValue.length < ((_c = parentGroup.value) == null ? void 0 : _c.min)) {
              isLimitExceeded.value = true;
            }
            if (((_d = parentGroup.value) == null ? void 0 : _d.max) && newValue.length > ((_e = parentGroup.value) == null ? void 0 : _e.max)) {
              isLimitExceeded.value = true;
            }
            if (isLimitExceeded.value === false) {
              emit("update:modelValue", newValue);
            } else if (allowUnselect && isLimitExceeded.value === true) {
              const clonedValues = [...newValue];
              clonedValues.shift();
              isLimitExceeded.value = false;
              emit("update:modelValue", clonedValues);
            }
          } else {
            emit("update:modelValue", newValue);
          }
        }
      });
      const instance2 = Vue.getCurrentInstance();
      const parentGroup = Vue.computed(() => {
        var _a3, _b;
        const isInGroup = ((_a3 = instance2 == null ? void 0 : instance2.parent) == null ? void 0 : _a3.type.name) === "InputCheckboxGroup";
        return isInGroup ? (_b = instance2 == null ? void 0 : instance2.parent) == null ? void 0 : _b.ctx : null;
      });
      const hasSlots = Vue.computed(() => {
        if (!slots.default) {
          return false;
        }
        const defaultSlot = slots.default();
        const normalNodes = [];
        if (Array.isArray(defaultSlot)) {
          defaultSlot.forEach((vNode) => {
            if (vNode.type !== Vue.Comment) {
              normalNodes.push(vNode);
            }
          });
        }
        return normalNodes.length > 0;
      });
      function onChange(event2) {
        const checkbox = event2.target;
        if (isLimitExceeded.value) {
          Vue.nextTick(() => {
            checkbox.checked = !checkbox.checked;
          });
          return;
        }
        emit("change", !!checkbox.checked);
      }
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("label", {
          class: "znpb-checkbox-wrapper",
          "aria-disabled": __props.disabled
        }, [
          Vue.withDirectives(Vue.createElementVNode("input", {
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => Vue.isRef(model) ? model.value = $event : null),
            type: "checkbox",
            "aria-hidden": "true",
            disabled: __props.disabled,
            value: __props.optionValue,
            class: "znpb-form__input-checkbox",
            onChange
          }, null, 40, _hoisted_2$19), [
            [Vue.vModelCheckbox, Vue.unref(model)]
          ]),
          Vue.createElementVNode("span", {
            class: Vue.normalizeClass(["znpb-checkmark", { "znpb-checkmark--rounded": __props.rounded }])
          }, null, 2),
          Vue.unref(hasSlots) || __props.label ? (Vue.openBlock(), Vue.createElementBlock("span", _hoisted_3$S, [
            Vue.renderSlot(_ctx.$slots, "default"),
            __props.showLabel && __props.label ? (Vue.openBlock(), Vue.createElementBlock(Vue.Fragment, { key: 0 }, [
              Vue.createTextVNode(Vue.toDisplayString(__props.label), 1)
            ], 64)) : Vue.createCommentVNode("", true)
          ])) : Vue.createCommentVNode("", true)
        ], 8, _hoisted_1$1H);
      };
    }
  }));
  var InputCheckboxGroup_vue_vue_type_style_index_0_lang = "";
  const __default__$s = {
    name: "InputCheckboxGroup"
  };
  const _sfc_main$2c = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$s), {
    props: {
      modelValue: { default: () => {
        return [];
      } },
      min: null,
      max: null,
      allowUnselect: { type: Boolean },
      direction: { default: "vertical" },
      options: null,
      disabled: { type: Boolean },
      displayStyle: null,
      placeholder: { default: () => {
        return [];
      } }
    },
    emits: ["update:modelValue"],
    setup(__props, { emit }) {
      const props = __props;
      const slots = Vue.useSlots();
      const model = Vue.computed({
        get() {
          return props.modelValue ? props.modelValue : [];
        },
        set(newValue) {
          emit("update:modelValue", newValue);
        }
      });
      const wrapperClasses = Vue.computed(() => {
        return {
          [`znpb-checkbox-list--${props.direction}`]: props.direction,
          [`znpb-checkbox-list-style--${props.displayStyle}`]: props.displayStyle
        };
      });
      const hasSlots = Vue.computed(() => {
        if (!slots.default) {
          return false;
        }
        const defaultSlot = slots.default();
        const normalNodes = [];
        if (Array.isArray(defaultSlot)) {
          defaultSlot.forEach((vNode) => {
            if (vNode.type !== Vue.Comment) {
              normalNodes.push(vNode);
            }
          });
        }
        return normalNodes.length > 0;
      });
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", {
          class: Vue.normalizeClass(["znpb-checkbox-list", Vue.unref(wrapperClasses)])
        }, [
          Vue.renderSlot(_ctx.$slots, "default"),
          !Vue.unref(hasSlots) ? (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, { key: 0 }, Vue.renderList(__props.options, (option, i) => {
            return Vue.openBlock(), Vue.createBlock(_sfc_main$2d, {
              key: i,
              modelValue: Vue.unref(model),
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => Vue.isRef(model) ? model.value = $event : null),
              "option-value": option.id,
              label: option.name,
              disabled: __props.disabled,
              placeholder: __props.placeholder,
              title: option.icon ? option.name : false,
              class: Vue.normalizeClass({
                [`znpb-checkbox-list--isPlaceholder`]: Vue.unref(model).length === 0 && __props.placeholder && __props.placeholder.includes(option.id)
              })
            }, {
              default: Vue.withCtx(() => [
                option.icon ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$34), {
                  key: 0,
                  icon: option.icon
                }, null, 8, ["icon"])) : Vue.createCommentVNode("", true)
              ]),
              _: 2
            }, 1032, ["modelValue", "option-value", "label", "disabled", "placeholder", "title", "class"]);
          }), 128)) : Vue.createCommentVNode("", true)
        ], 2);
      };
    }
  }));
  var InputCheckboxSwitch_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$2b = {
    name: "InputCheckboxSwitch",
    props: {
      label: {
        type: String,
        required: false
      },
      showLabel: {
        type: Boolean,
        required: false,
        default: true
      },
      modelValue: {
        type: [String, Array, Boolean],
        required: false
      },
      optionValue: {
        type: [String, Boolean],
        required: false
      },
      disabled: {
        type: Boolean,
        required: false
      },
      checked: {
        type: Boolean,
        required: false
      },
      rounded: {
        type: Boolean,
        required: false
      }
    },
    data() {
      return {
        isLimitExceeded: false
      };
    },
    computed: {
      model: {
        get() {
          return this.modelValue !== void 0 ? this.modelValue : false;
        },
        set(newValue) {
          this.isLimitExceeded = false;
          const allowUnselect = this.parentGroup.allowUnselect;
          if (this.isInGroup) {
            this.isLimitExceeded = false;
            if (this.parentGroup.min !== void 0 && newValue.length < this.parentGroup.min) {
              this.isLimitExceeded = true;
            }
            if (this.parentGroup.max !== void 0 && newValue.length > this.parentGroup.max) {
              this.isLimitExceeded = true;
            }
            if (this.isLimitExceeded === false) {
              this.$emit("update:modelValue", newValue);
            } else if (allowUnselect && this.isLimitExceeded === true) {
              const clonedValues = [...newValue];
              clonedValues.shift();
              this.isLimitExceeded = false;
              this.$emit("update:modelValue", clonedValues);
            }
          } else {
            this.$emit("update:modelValue", newValue);
          }
        }
      },
      isInGroup() {
        return this.$parent.$options.name === "InputCheckboxGroup";
      },
      parentGroup() {
        return this.isInGroup ? this.$parent : false;
      }
    },
    created() {
      this.checked && this.setInitialValue();
    },
    methods: {
      setInitialValue() {
        this.model = this.modelValue || true;
      },
      onChange(event2) {
        let checked = event2.target.checked;
        if (this.isLimitExceeded) {
          this.$nextTick(() => {
            event2.target.checked = !checked;
          });
          return;
        }
        this.$emit("change", !!event2.target.checked);
      }
    }
  };
  const _hoisted_1$1G = { class: "znpb-checkbox-switch-wrapper" };
  const _hoisted_2$18 = ["content"];
  const _hoisted_3$R = ["disabled", "modelValue"];
  const _hoisted_4$y = /* @__PURE__ */ Vue.createElementVNode("span", { class: "znpb-checkbox-switch-wrapper__button" }, null, -1);
  function _sfc_render$16(_ctx, _cache, $props, $setup, $data, $options) {
    return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$1G, [
      Vue.createElementVNode("label", {
        class: Vue.normalizeClass(["znpb-checkbox-switch-wrapper__label", { [`znpb-checkbox-switch--${$options.model ? "checked" : "unchecked"}`]: true }]),
        content: $options.model ? _ctx.$translate("yes") : _ctx.$translate("no")
      }, [
        Vue.withDirectives(Vue.createElementVNode("input", {
          type: "checkbox",
          disabled: $props.disabled,
          class: "znpb-checkbox-switch-wrapper__checkbox",
          modelValue: $props.optionValue,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $options.model = $event)
        }, null, 8, _hoisted_3$R), [
          [Vue.vModelCheckbox, $options.model]
        ]),
        _hoisted_4$y
      ], 10, _hoisted_2$18)
    ]);
  }
  var InputCheckboxSwitch = /* @__PURE__ */ _export_sfc(_sfc_main$2b, [["render", _sfc_render$16]]);
  var InputCode_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$1F = { class: "znpb-custom-code" };
  const _hoisted_2$17 = ["placeholder"];
  const __default__$r = {
    name: "InputCode"
  };
  const _sfc_main$2a = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$r), {
    props: {
      placeholder: null,
      mode: null,
      modelValue: { default: "" }
    },
    emits: ["update:modelValue"],
    setup(__props, { emit }) {
      const props = __props;
      let editor;
      const codeMirrorTextarea = Vue.ref(null);
      let ignoreChange = false;
      Vue.watch(
        () => props.modelValue,
        (newValue) => {
          if ((editor == null ? void 0 : editor.getValue()) !== newValue) {
            ignoreChange = true;
            editor.setValue(newValue);
          }
        }
      );
      function onEditorChange(instance2) {
        if (!ignoreChange) {
          emit("update:modelValue", instance2.getValue());
        }
        ignoreChange = false;
      }
      [
        "text/css",
        "text/javascript",
        "application/json",
        "application/ld+json",
        "text/typescript",
        "application/typescript",
        "htmlmixed"
      ].includes(props.mode || "");
      Vue.onMounted(() => {
        editor = window.wp.CodeMirror.fromTextArea(codeMirrorTextarea.value, {
          mode: props.mode,
          lineNumbers: true,
          lineWrapping: true,
          lint: false,
          autoCloseBrackets: true,
          matchBrackets: true,
          autoRefresh: true,
          autoCloseTags: true,
          continueComments: true,
          indentUnit: 2,
          indentWithTabs: true,
          styleActiveLine: true,
          tabSize: 2,
          matchTags: {
            bothTags: true
          },
          showHint: true,
          csslint: {
            "box-model": true,
            "display-property-grouping": true,
            "duplicate-properties": true,
            errors: true,
            "known-properties": true,
            "outline-none": true
          },
          jshint: {
            boss: true,
            curly: true,
            eqeqeq: true,
            eqnull: true,
            es3: true,
            expr: true,
            immed: true,
            noarg: true,
            nonbsp: true,
            onevar: true,
            quotmark: "single",
            trailing: true,
            undef: true,
            unused: true,
            browser: true,
            globals: {
              _: false,
              Backbone: false,
              jQuery: false,
              JSON: false,
              wp: false
            }
          },
          htmlhint: {
            "tagname-lowercase": true,
            "attr-lowercase": true,
            "attr-value-double-quotes": false,
            "doctype-first": false,
            "tag-pair": true,
            "spec-char-escape": true,
            "id-unique": true,
            "src-not-empty": true,
            "attr-no-duplication": true,
            "alt-require": true,
            "space-tab-mixed-disabled": "tab",
            "attr-unsafe-chars": true
          },
          gutters: ["CodeMirror-lint-markers"]
        });
        editor.on("keyup", function(editor2, event2) {
          var shouldAutocomplete, isAlphaKey = /^[a-zA-Z]$/.test(event2.key), lineBeforeCursor, innerMode, token;
          if (editor2.state.completionActive && isAlphaKey) {
            return;
          }
          token = editor2.getTokenAt(editor2.getCursor());
          if ("string" === token.type || "comment" === token.type) {
            return;
          }
          innerMode = window.wp.CodeMirror.innerMode(editor2.getMode(), token.state).mode.name;
          lineBeforeCursor = editor2.doc.getLine(editor2.doc.getCursor().line).substr(0, editor2.doc.getCursor().ch);
          if ("html" === innerMode || "xml" === innerMode) {
            shouldAutocomplete = "<" === event2.key || "/" === event2.key && "tag" === token.type || isAlphaKey && "tag" === token.type || isAlphaKey && "attribute" === token.type || "=" === token.string && token.state.htmlState && token.state.htmlState.tagName;
          } else if ("css" === innerMode) {
            shouldAutocomplete = isAlphaKey || ":" === event2.key || " " === event2.key && /:\s+$/.test(lineBeforeCursor);
          } else if ("javascript" === innerMode) {
            shouldAutocomplete = isAlphaKey || "." === event2.key;
          } else if ("clike" === innerMode && "php" === editor2.options.mode) {
            shouldAutocomplete = "keyword" === token.type || "variable" === token.type;
          }
          if (shouldAutocomplete) {
            editor2.showHint({ completeSingle: false });
          }
        });
        if (props.modelValue) {
          editor.setValue(props.modelValue);
        }
        editor.on("change", onEditorChange);
      });
      Vue.onBeforeUnmount(() => {
        if (editor) {
          editor.toTextArea();
        }
      });
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$1F, [
          Vue.createElementVNode("textarea", {
            ref_key: "codeMirrorTextarea",
            ref: codeMirrorTextarea,
            class: "znpb-custom-code__text-area",
            placeholder: __props.placeholder
          }, null, 8, _hoisted_2$17)
        ]);
      };
    }
  }));
  var GridColor_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$1E = { class: "znpb-form-library-grid__panel-content znpb-fancy-scrollbar" };
  const _sfc_main$29 = /* @__PURE__ */ Vue.defineComponent({
    __name: "GridColor",
    emits: ["add-new-color"],
    setup(__props) {
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$1E, [
          Vue.createVNode(Vue.unref(_sfc_main$34), {
            icon: "plus",
            class: "znpb-colorpicker-circle znpb-colorpicker-add-color",
            onMousedown: _cache[0] || (_cache[0] = Vue.withModifiers(($event) => _ctx.$emit("add-new-color"), ["stop"]))
          }),
          Vue.renderSlot(_ctx.$slots, "default")
        ]);
      };
    }
  });
  var PatternContainer_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$1D = { key: 0 };
  const _hoisted_2$16 = ["onClick"];
  const _hoisted_3$Q = {
    key: 0,
    class: "znpb-colorpicker-global-wrapper--pro"
  };
  const _hoisted_4$x = ["onClick"];
  const _hoisted_5$q = {
    key: 0,
    class: "znpb-colorpicker-circle__active-bg"
  };
  const __default__$q = {
    name: "PatternContainer"
  };
  const _sfc_main$28 = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$q), {
    props: {
      model: { default: "#000" }
    },
    emits: ["color-updated"],
    setup(__props) {
      const props = __props;
      const formApi = Vue.inject("OptionsForm");
      const getValueByPath = Vue.inject("getValueByPath");
      const schema = Vue.inject("schema", {});
      const { addLocalColor, getOptionValue, addGlobalColor } = useBuilderOptionsStore();
      const localColors = getOptionValue("local_colors", []);
      const globalColors = getOptionValue("global_colors", []);
      const showPresetInput = Vue.ref(false);
      const isPro = Vue.computed(() => {
        if (window.ZnPbComponentsData !== void 0) {
          return window.ZnPbComponentsData.is_pro_active;
        }
        return false;
      });
      const localColorPatterns = Vue.computed(() => {
        return [...localColors].reverse();
      });
      const globalColorPatterns = Vue.computed(() => {
        return [...globalColors].reverse();
      });
      const selectedGlobalColor = Vue.computed(() => {
        const { id = "" } = schema;
        const { options: options2 = {} } = getValueByPath(`__dynamic_content__.${id}`, {});
        return options2.color_id;
      });
      const activeTab = Vue.computed(() => {
        return selectedGlobalColor.value ? "global" : "local";
      });
      function addGlobal(name) {
        let globalColor = {
          id: name.split(" ").join("_"),
          color: props.model,
          name
        };
        showPresetInput.value = false;
        addGlobalColor(globalColor);
      }
      function onGlobalColorSelected(colorConfig) {
        const { id } = schema;
        formApi.updateValueByPath(`__dynamic_content__.${id}`, {
          type: "global-color",
          options: {
            color_id: colorConfig.id
          }
        });
      }
      return (_ctx, _cache) => {
        const _component_Tab = Vue.resolveComponent("Tab");
        const _component_Tabs = Vue.resolveComponent("Tabs");
        return Vue.openBlock(), Vue.createBlock(_sfc_main$2u, { "has-input": showPresetInput.value }, {
          default: Vue.withCtx(() => [
            !showPresetInput.value ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$1D, [
              Vue.createVNode(_component_Tabs, {
                "tab-style": "minimal",
                "active-tab": Vue.unref(activeTab)
              }, {
                default: Vue.withCtx(() => [
                  Vue.createVNode(_component_Tab, { name: "Local" }, {
                    default: Vue.withCtx(() => [
                      Vue.createVNode(_sfc_main$29, {
                        onAddNewColor: _cache[0] || (_cache[0] = ($event) => Vue.unref(addLocalColor)(__props.model))
                      }, {
                        default: Vue.withCtx(() => [
                          (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList(Vue.unref(localColorPatterns), (color, i) => {
                            return Vue.openBlock(), Vue.createElementBlock("span", {
                              key: i,
                              class: "znpb-colorpicker-circle znpb-colorpicker-circle-color",
                              style: Vue.normalizeStyle({ "background-color": color }),
                              onClick: ($event) => _ctx.$emit("color-updated", color)
                            }, null, 12, _hoisted_2$16);
                          }), 128))
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  }),
                  Vue.createVNode(_component_Tab, { name: "Global" }, {
                    default: Vue.withCtx(() => [
                      !Vue.unref(isPro) ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_3$Q, [
                        Vue.createTextVNode(" Global colors are available in "),
                        Vue.createVNode(Vue.unref(_sfc_main$2t), {
                          text: "PRO",
                          type: "pro"
                        })
                      ])) : (Vue.openBlock(), Vue.createBlock(_sfc_main$29, {
                        key: 1,
                        onAddNewColor: _cache[1] || (_cache[1] = ($event) => showPresetInput.value = !showPresetInput.value)
                      }, {
                        default: Vue.withCtx(() => [
                          (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList(Vue.unref(globalColorPatterns), (colorConfig, i) => {
                            return Vue.openBlock(), Vue.createElementBlock("span", {
                              key: i,
                              class: Vue.normalizeClass(["znpb-colorpicker-circle znpb-colorpicker-circle-color", { "znpb-colorpicker-circle--active": colorConfig.id === Vue.unref(selectedGlobalColor) }]),
                              style: Vue.normalizeStyle({ backgroundColor: colorConfig.id === Vue.unref(selectedGlobalColor) ? "" : colorConfig.color }),
                              onClick: Vue.withModifiers(($event) => onGlobalColorSelected(colorConfig), ["stop"])
                            }, [
                              colorConfig.id === Vue.unref(selectedGlobalColor) ? (Vue.openBlock(), Vue.createElementBlock("span", _hoisted_5$q, [
                                Vue.createElementVNode("span", {
                                  style: Vue.normalizeStyle({ "background-color": colorConfig.color })
                                }, null, 4)
                              ])) : Vue.createCommentVNode("", true)
                            ], 14, _hoisted_4$x);
                          }), 128))
                        ]),
                        _: 1
                      }))
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }, 8, ["active-tab"])
            ])) : Vue.createCommentVNode("", true),
            showPresetInput.value ? (Vue.openBlock(), Vue.createBlock(_sfc_main$2x, {
              key: 1,
              "is-gradient": false,
              onSavePreset: _cache[2] || (_cache[2] = ($event) => addGlobal($event)),
              onCancel: _cache[3] || (_cache[3] = ($event) => showPresetInput.value = false)
            })) : Vue.createCommentVNode("", true)
          ]),
          _: 1
        }, 8, ["has-input"]);
      };
    }
  }));
  var Color_vue_vue_type_style_index_0_lang = "";
  const __default__$p = {
    name: "Color"
  };
  const _sfc_main$27 = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$p), {
    props: {
      modelValue: { default: "" },
      showLibrary: { type: Boolean, default: true },
      dynamicContentConfig: null,
      placeholder: null
    },
    emits: ["update:modelValue", "option-updated", "open", "close"],
    setup(__props, { emit }) {
      const popper2 = Vue.ref(null);
      const colorpickerHolder = Vue.ref(null);
      const isDragging = Vue.ref(false);
      let backdrop;
      function onLibraryUpdate(newValue) {
        emit("update:modelValue", newValue);
      }
      function onColorPickerClick() {
        isDragging.value = false;
      }
      function onColorPickerMousedown() {
        isDragging.value = true;
      }
      function updateColor(color) {
        emit("option-updated", color);
        emit("update:modelValue", color);
      }
      function openColorPicker() {
        emit("open");
        document.addEventListener("click", closePanelOnOutsideClick, true);
        if (popper2.value) {
          backdrop = document.createElement("div");
          backdrop.classList.add("znpb-tooltip-backdrop");
          const parent2 = popper2.value.$el.parentNode;
          parent2.insertBefore(backdrop, popper2.value.$el);
        }
      }
      function closeColorPicker() {
        var _a3;
        emit("close");
        document.removeEventListener("click", closePanelOnOutsideClick);
        if (backdrop) {
          document.body.appendChild(backdrop);
          (_a3 = backdrop.parentNode) == null ? void 0 : _a3.removeChild(backdrop);
        }
      }
      function closePanelOnOutsideClick(event2) {
        var _a3, _b;
        if (((_a3 = popper2.value) == null ? void 0 : _a3.$el.contains(event2.target)) || ((_b = colorpickerHolder.value) == null ? void 0 : _b.$refs.colorPicker.contains(event2.target))) {
          return;
        }
        if (!isDragging.value && popper2.value) {
          popper2.value.hidePopper();
        }
        isDragging.value = false;
      }
      Vue.onBeforeUnmount(() => {
        var _a3;
        document.removeEventListener("click", closePanelOnOutsideClick);
        if (backdrop) {
          (_a3 = backdrop.parentNode) == null ? void 0 : _a3.removeChild(backdrop);
        }
      });
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createBlock(Vue.unref(Tooltip), {
          ref_key: "popper",
          ref: popper2,
          "tooltip-class": "hg-popper--no-padding",
          trigger: "click",
          "close-on-outside-click": true,
          "append-to": "body",
          modifiers: [
            {
              name: "preventOverflow",
              options: {
                rootBoundary: "viewport"
              }
            },
            {
              name: "offset",
              options: {
                offset: [0, 15]
              }
            },
            {
              name: "flip",
              options: {
                fallbackPlacements: ["left", "right", "bottom", "top"]
              }
            }
          ],
          strategy: "fixed",
          onShow: openColorPicker,
          onHide: closeColorPicker
        }, {
          content: Vue.withCtx(() => [
            Vue.createVNode(Vue.unref(_sfc_main$2Q), {
              ref_key: "colorpickerHolder",
              ref: colorpickerHolder,
              model: __props.modelValue && __props.modelValue.length > 0 ? __props.modelValue : __props.placeholder,
              onColorChanged: updateColor,
              onClick: Vue.withModifiers(onColorPickerClick, ["stop"]),
              onMousedown: Vue.withModifiers(onColorPickerMousedown, ["stop"])
            }, {
              end: Vue.withCtx(() => [
                __props.showLibrary ? (Vue.openBlock(), Vue.createBlock(_sfc_main$28, {
                  key: 0,
                  model: __props.modelValue,
                  "active-tab": __props.dynamicContentConfig ? "global" : "local",
                  onColorUpdated: onLibraryUpdate
                }, null, 8, ["model", "active-tab"])) : Vue.createCommentVNode("", true)
              ]),
              _: 1
            }, 8, ["model", "onClick", "onMousedown"])
          ]),
          default: Vue.withCtx(() => [
            Vue.renderSlot(_ctx.$slots, "trigger")
          ]),
          _: 3
        }, 512);
      };
    }
  }));
  const createI18n = (initialStrings = {}) => {
    let strings = {};
    const addStrings2 = (newStrings) => {
      strings = __spreadValues(__spreadValues({}, strings), newStrings);
    };
    const translate2 = (stringId) => {
      if (strings[stringId] !== void 0) {
        return strings[stringId];
      }
      console.error(`String with id ${stringId} was not found.`);
      return "";
    };
    if (initialStrings) {
      addStrings2(initialStrings);
    }
    return {
      addStrings: addStrings2,
      translate: translate2
    };
  };
  const i18n = createI18n();
  const install$1 = (app, strings) => {
    i18n.addStrings(strings);
    app.config.globalProperties.$translate = (string) => {
      return i18n.translate(string);
    };
  };
  const { addStrings, translate } = i18n;
  window.zb = window.zb || {};
  window.zb.i18n = {
    install: install$1,
    addStrings,
    translate
  };
  var InputColorPicker_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$1C = { class: "znpb-form-colorpicker" };
  const _hoisted_2$15 = {
    key: 1,
    class: "znpb-form-colorpicker__color-trigger znpb-colorpicker-circle znpb-colorpicker-circle--no-color"
  };
  const __default__$o = {
    name: "InputColorPicker",
    inheritAttrs: true
  };
  const _sfc_main$26 = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$o), {
    props: {
      modelValue: null,
      type: null,
      dynamicContentConfig: null,
      showLibrary: { type: Boolean, default: true },
      placeholder: { default: null }
    },
    emits: ["update:modelValue", "open", "close"],
    setup(__props, { emit }) {
      const props = __props;
      const color = Vue.ref(null);
      const computedPlaceholder = Vue.computed(() => {
        return props.placeholder || translate("color");
      });
      const colorModel = Vue.computed({
        get() {
          return props.modelValue || "";
        },
        set(newValue) {
          emit("update:modelValue", newValue);
        }
      });
      return (_ctx, _cache) => {
        const _directive_znpb_tooltip = Vue.resolveDirective("znpb-tooltip");
        return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$1C, [
          __props.type === "simple" ? (Vue.openBlock(), Vue.createBlock(_sfc_main$27, {
            key: 0,
            ref_key: "color",
            ref: color,
            modelValue: Vue.unref(colorModel),
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => Vue.isRef(colorModel) ? colorModel.value = $event : null),
            "show-library": __props.showLibrary,
            placeholder: __props.placeholder,
            class: "znpb-colorpicker-circle znpb-colorpicker-circle--trigger znpb-colorpicker-circle--opacity",
            onOpen: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("open")),
            onClose: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("close"))
          }, {
            trigger: Vue.withCtx(() => [
              Vue.createElementVNode("span", {
                style: Vue.normalizeStyle({ backgroundColor: __props.modelValue }),
                class: "znpb-form-colorpicker__color-trigger znpb-colorpicker-circle"
              }, null, 4),
              __props.dynamicContentConfig ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$34), {
                key: 0,
                icon: "globe",
                rounded: true,
                "bg-color": "#fff",
                "bg-size": 16,
                size: 12,
                class: "znpb-colorpicker-circle__global-icon"
              })) : Vue.createCommentVNode("", true),
              !__props.modelValue ? Vue.withDirectives((Vue.openBlock(), Vue.createElementBlock("span", _hoisted_2$15, null, 512)), [
                [_directive_znpb_tooltip, _ctx.$translate("no_color_chosen")]
              ]) : Vue.createCommentVNode("", true)
            ]),
            _: 1
          }, 8, ["modelValue", "show-library", "placeholder"])) : (Vue.openBlock(), Vue.createBlock(_sfc_main$31, {
            key: 1,
            modelValue: Vue.unref(colorModel),
            "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => Vue.isRef(colorModel) ? colorModel.value = $event : null),
            placeholder: Vue.unref(computedPlaceholder)
          }, {
            prepend: Vue.withCtx(() => [
              Vue.createVNode(_sfc_main$27, {
                modelValue: Vue.unref(colorModel),
                "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => Vue.isRef(colorModel) ? colorModel.value = $event : null),
                "show-library": __props.showLibrary,
                class: "znpb-colorpicker-circle znpb-colorpicker-circle--trigger znpb-colorpicker-circle--opacity",
                placeholder: __props.placeholder,
                onOpen: _cache[4] || (_cache[4] = ($event) => _ctx.$emit("open")),
                onClose: _cache[5] || (_cache[5] = ($event) => _ctx.$emit("close"))
              }, {
                trigger: Vue.withCtx(() => [
                  Vue.createElementVNode("span", null, [
                    !__props.modelValue || __props.modelValue === void 0 ? (Vue.openBlock(), Vue.createBlock(Vue.unref(Tooltip), {
                      key: 0,
                      content: _ctx.$translate("no_color_chosen"),
                      tag: "span"
                    }, {
                      default: Vue.withCtx(() => [
                        Vue.createElementVNode("span", {
                          style: Vue.normalizeStyle({ backgroundColor: __props.modelValue || __props.placeholder }),
                          class: "znpb-form-colorpicker__color-trigger znpb-colorpicker-circle"
                        }, null, 4)
                      ]),
                      _: 1
                    }, 8, ["content"])) : (Vue.openBlock(), Vue.createElementBlock("span", {
                      key: 1,
                      style: Vue.normalizeStyle({ backgroundColor: __props.modelValue || __props.placeholder }),
                      class: "znpb-form-colorpicker__color-trigger znpb-colorpicker-circle"
                    }, null, 4)),
                    __props.dynamicContentConfig ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$34), {
                      key: 2,
                      icon: "globe",
                      rounded: true,
                      "bg-color": "#fff",
                      "bg-size": 16,
                      size: 12,
                      class: "znpb-colorpicker-circle__global-icon"
                    })) : Vue.createCommentVNode("", true)
                  ])
                ]),
                _: 1
              }, 8, ["modelValue", "show-library", "placeholder"])
            ]),
            _: 1
          }, 8, ["modelValue", "placeholder"]))
        ]);
      };
    }
  }));
  var InputCustomSelector_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$1B = { class: "znpb-custom-selector" };
  const _hoisted_2$14 = { class: "znpb-custom-selector__list-wrapper" };
  const _hoisted_3$P = ["title", "onClick"];
  const _hoisted_4$w = {
    key: 0,
    class: "znpb-custom-selector__item-name"
  };
  const _hoisted_5$p = {
    key: 2,
    class: "znpb-custom-selector__icon-text-content"
  };
  const _hoisted_6$j = {
    key: 1,
    class: "znpb-custom-selector__item-name"
  };
  const __default__$n = {
    name: "InputCustomSelector"
  };
  const _sfc_main$25 = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$n), {
    props: {
      options: null,
      columns: null,
      modelValue: { type: [String, Number, Boolean, null] },
      textIcon: { type: Boolean },
      placeholder: { type: [String, Number, Boolean, null] }
    },
    emits: ["update:modelValue"],
    setup(__props, { emit }) {
      const props = __props;
      function changeValue(newValue) {
        let valueToSend = newValue;
        if (props.modelValue === newValue) {
          valueToSend = null;
        }
        emit("update:modelValue", valueToSend);
      }
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$1B, [
          Vue.createElementVNode("ul", _hoisted_2$14, [
            (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList(__props.options, (option, index2) => {
              return Vue.openBlock(), Vue.createElementBlock("li", {
                key: index2,
                class: Vue.normalizeClass(["znpb-custom-selector__item", {
                  ["znpb-custom-selector__item--activePlaceholder"]: !__props.modelValue && __props.placeholder === option.id,
                  ["znpb-custom-selector__item--active"]: __props.modelValue === option.id,
                  [`znpb-custom-selector__columns-${__props.columns}`]: __props.columns
                }]),
                title: option.icon ? option.name : "",
                onClick: ($event) => changeValue(option.id)
              }, [
                !option.icon ? (Vue.openBlock(), Vue.createElementBlock("span", _hoisted_4$w, Vue.toDisplayString(option.name), 1)) : Vue.createCommentVNode("", true),
                !__props.textIcon && option.icon ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$34), {
                  key: 1,
                  icon: option.icon
                }, null, 8, ["icon"])) : Vue.createCommentVNode("", true),
                __props.textIcon ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_5$p, [
                  option.icon ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$34), {
                    key: 0,
                    icon: option.icon
                  }, null, 8, ["icon"])) : Vue.createCommentVNode("", true),
                  option.name ? (Vue.openBlock(), Vue.createElementBlock("span", _hoisted_6$j, Vue.toDisplayString(option.name), 1)) : Vue.createCommentVNode("", true)
                ])) : Vue.createCommentVNode("", true)
              ], 10, _hoisted_3$P);
            }), 128))
          ])
        ]);
      };
    }
  }));
  var vueDatePick_vue_vue_type_style_index_0_lang = "";
  const formatRE = /,|\.|-| |:|\/|\\/;
  const dayRE = /D+/;
  const monthRE = /M+/;
  const yearRE = /Y+/;
  const hoursRE = /h+/i;
  const minutesRE = /m+/;
  const secondsRE = /s+/;
  const AMPMClockRE = /A/;
  const _sfc_main$24 = {
    props: {
      modelValue: {
        type: String,
        default: ""
      },
      format: {
        type: String,
        default: "YYYY-MM-DD"
      },
      displayFormat: {
        type: String
      },
      editable: {
        type: Boolean,
        default: true
      },
      hasInputElement: {
        type: Boolean,
        default: true
      },
      inputAttributes: {
        type: Object
      },
      selectableYearRange: {
        type: [Number, Object, Function],
        default: 40
      },
      startPeriod: {
        type: Object
      },
      parseDate: {
        type: Function
      },
      formatDate: {
        type: Function
      },
      pickTime: {
        type: Boolean,
        default: false
      },
      pickMinutes: {
        type: Boolean,
        default: true
      },
      pickSeconds: {
        type: Boolean,
        default: false
      },
      use12HourClock: {
        type: Boolean,
        default: false
      },
      isDateDisabled: {
        type: Function,
        default: () => false
      },
      nextMonthCaption: {
        type: String,
        default: "Next month"
      },
      prevMonthCaption: {
        type: String,
        default: "Previous month"
      },
      setTimeCaption: {
        type: String,
        default: "Set time:"
      },
      mobileBreakpointWidth: {
        type: Number,
        default: 500
      },
      weekdays: {
        type: Array,
        default: () => [
          "Mon",
          "Tue",
          "Wed",
          "Thu",
          "Fri",
          "Sat",
          "Sun"
        ]
      },
      months: {
        type: Array,
        default: () => [
          "January",
          "February",
          "March",
          "April",
          "May",
          "June",
          "July",
          "August",
          "September",
          "October",
          "November",
          "December"
        ]
      },
      startWeekOnSunday: {
        type: Boolean,
        default: false
      }
    },
    data() {
      return {
        inputValue: this.valueToInputFormat(this.modelValue),
        direction: void 0,
        positionClass: void 0,
        opened: !this.hasInputElement,
        currentPeriod: this.startPeriod || this.getPeriodFromValue(
          this.modelValue,
          this.format
        )
      };
    },
    computed: {
      valueDate() {
        const value = this.modelValue;
        const format = this.format;
        return value ? this.parseDateString(value, format) : void 0;
      },
      isReadOnly() {
        return !this.editable || this.inputAttributes && this.inputAttributes.readonly;
      },
      isValidValue() {
        const valueDate = this.valueDate;
        return this.modelValue ? Boolean(valueDate) : true;
      },
      currentPeriodDates() {
        const { year, month } = this.currentPeriod;
        const days = [];
        const date = new Date(year, month, 1);
        const today = new Date();
        const offset2 = this.startWeekOnSunday ? 1 : 0;
        const startDay = date.getDay() || 7;
        if (startDay > 1 - offset2) {
          for (let i = startDay - (2 - offset2); i >= 0; i--) {
            const prevDate = new Date(date);
            prevDate.setDate(-i);
            days.push({ outOfRange: true, date: prevDate });
          }
        }
        while (date.getMonth() === month) {
          days.push({ date: new Date(date) });
          date.setDate(date.getDate() + 1);
        }
        const daysLeft = 7 - days.length % 7;
        for (let i = 1; i <= daysLeft; i++) {
          const nextDate = new Date(date);
          nextDate.setDate(i);
          days.push({ outOfRange: true, date: nextDate });
        }
        days.forEach((day) => {
          day.disabled = this.isDateDisabled(day.date);
          day.today = areSameDates(day.date, today);
          day.dateKey = [
            day.date.getFullYear(),
            day.date.getMonth() + 1,
            day.date.getDate()
          ].join("-");
          day.selected = this.valueDate ? areSameDates(day.date, this.valueDate) : false;
        });
        return chunkArray(days, 7);
      },
      yearRange() {
        const currentYear = this.currentPeriod.year;
        const userRange = this.selectableYearRange;
        const userRangeType = typeof userRange;
        let yearsRange = [];
        if (userRangeType === "number") {
          yearsRange = range(
            currentYear - userRange,
            currentYear + userRange
          );
        } else if (userRangeType === "object") {
          yearsRange = range(
            userRange.from,
            userRange.to
          );
        } else if (userRangeType === "function") {
          yearsRange = userRange(this);
        }
        if (yearsRange.indexOf(currentYear) < 0) {
          yearsRange.push(currentYear);
          yearsRange = yearsRange.sort();
        }
        return yearsRange;
      },
      currentTime() {
        const currentDate = this.valueDate;
        if (!currentDate) {
          return void 0;
        }
        const hours = currentDate.getHours();
        const minutes = currentDate.getMinutes();
        const seconds = currentDate.getSeconds();
        return {
          hours,
          minutes,
          seconds,
          isPM: isPM(hours),
          hoursFormatted: (this.use12HourClock ? to12HourClock(hours) : hours).toString(),
          minutesFormatted: paddNum(minutes, 2),
          secondsFormatted: paddNum(seconds, 2)
        };
      },
      directionClass() {
        return this.direction ? `vdp${this.direction}Direction` : void 0;
      },
      weekdaysSorted() {
        if (this.startWeekOnSunday) {
          const weekdays = this.weekdays.slice();
          weekdays.unshift(weekdays.pop());
          return weekdays;
        } else {
          return this.weekdays;
        }
      }
    },
    watch: {
      modelValue(value) {
        if (this.isValidValue) {
          this.inputValue = this.valueToInputFormat(value);
          this.currentPeriod = this.getPeriodFromValue(value, this.format);
        }
      },
      currentPeriod(currentPeriod, oldPeriod) {
        const currentDate = new Date(currentPeriod.year, currentPeriod.month).getTime();
        const oldDate = new Date(oldPeriod.year, oldPeriod.month).getTime();
        this.direction = currentDate !== oldDate ? currentDate > oldDate ? "Next" : "Prev" : void 0;
        if (currentDate !== oldDate) {
          this.$emit("periodChange", {
            year: currentPeriod.year,
            month: currentPeriod.month
          });
        }
      }
    },
    beforeUnmount() {
      this.removeCloseEvents();
      this.teardownPosition();
    },
    methods: {
      valueToInputFormat(value) {
        return !this.displayFormat ? value : this.formatDateToString(
          this.parseDateString(value, this.format),
          this.displayFormat
        ) || value;
      },
      getPeriodFromValue(dateString, format) {
        const date = this.parseDateString(dateString, format) || new Date();
        return { month: date.getMonth(), year: date.getFullYear() };
      },
      parseDateString(dateString, dateFormat) {
        return !dateString ? void 0 : this.parseDate ? this.parseDate(dateString, dateFormat) : this.parseSimpleDateString(dateString, dateFormat);
      },
      formatDateToString(date, dateFormat) {
        return !date ? "" : this.formatDate ? this.formatDate(date, dateFormat) : this.formatSimpleDateToString(date, dateFormat);
      },
      parseSimpleDateString(dateString, dateFormat) {
        let day, month, year, hours, minutes, seconds;
        const dateParts = dateString.split(formatRE);
        const formatParts = dateFormat.split(formatRE);
        const partsSize = formatParts.length;
        for (let i = 0; i < partsSize; i++) {
          if (formatParts[i].match(dayRE)) {
            day = parseInt(dateParts[i], 10);
          } else if (formatParts[i].match(monthRE)) {
            month = parseInt(dateParts[i], 10);
          } else if (formatParts[i].match(yearRE)) {
            year = parseInt(dateParts[i], 10);
          } else if (formatParts[i].match(hoursRE)) {
            hours = parseInt(dateParts[i], 10);
          } else if (formatParts[i].match(minutesRE)) {
            minutes = parseInt(dateParts[i], 10);
          } else if (formatParts[i].match(secondsRE)) {
            seconds = parseInt(dateParts[i], 10);
          }
        }
        const resolvedDate = new Date(
          [paddNum(year, 4), paddNum(month, 2), paddNum(day, 2)].join("-")
        );
        if (isNaN(resolvedDate)) {
          return void 0;
        } else {
          const date = new Date(year, month - 1, day);
          [
            [year, "setFullYear"],
            [hours, "setHours"],
            [minutes, "setMinutes"],
            [seconds, "setSeconds"]
          ].forEach(([value, method]) => {
            typeof value !== "undefined" && date[method](value);
          });
          return date;
        }
      },
      formatSimpleDateToString(date, dateFormat) {
        return dateFormat.replace(yearRE, (match) => Number(date.getFullYear().toString().slice(-match.length))).replace(monthRE, (match) => paddNum(date.getMonth() + 1, match.length)).replace(dayRE, (match) => paddNum(date.getDate(), match.length)).replace(hoursRE, (match) => paddNum(
          AMPMClockRE.test(dateFormat) ? to12HourClock(date.getHours()) : date.getHours(),
          match.length
        )).replace(minutesRE, (match) => paddNum(date.getMinutes(), match.length)).replace(secondsRE, (match) => paddNum(date.getSeconds(), match.length)).replace(AMPMClockRE, (match) => isPM(date.getHours()) ? "PM" : "AM");
      },
      incrementMonth(increment = 1) {
        const refDate = new Date(this.currentPeriod.year, this.currentPeriod.month);
        const incrementDate = new Date(refDate.getFullYear(), refDate.getMonth() + increment);
        this.currentPeriod = {
          month: incrementDate.getMonth(),
          year: incrementDate.getFullYear()
        };
      },
      processUserInput(userText) {
        const userDate = this.parseDateString(
          userText,
          this.displayFormat || this.format
        );
        this.inputValue = userText;
        this.$emit(
          "update:modelValue",
          userDate ? this.formatDateToString(userDate, this.format) : userText
        );
      },
      toggle() {
        return this.opened ? this.close() : this.open();
      },
      open() {
        if (!this.opened) {
          this.opened = true;
          this.currentPeriod = this.startPeriod || this.getPeriodFromValue(
            this.modelValue,
            this.format
          );
          this.addCloseEvents();
          this.setupPosition();
        }
        this.direction = void 0;
      },
      close() {
        if (this.opened) {
          this.opened = false;
          this.direction = void 0;
          this.removeCloseEvents();
          this.teardownPosition();
        }
      },
      closeViaOverlay(e) {
        if (this.hasInputElement && e.target === this.$refs.outerWrap) {
          this.close();
        }
      },
      addCloseEvents() {
        if (!this.closeEventListener) {
          this.closeEventListener = (e) => this.inspectCloseEvent(e);
          ["click", "keyup", "focusin"].forEach(
            (eventName) => document.addEventListener(eventName, this.closeEventListener)
          );
        }
      },
      inspectCloseEvent(event2) {
        if (event2.keyCode) {
          event2.keyCode === 27 && this.close();
        } else if (!(event2.target === this.$el) && !this.$el.contains(event2.target)) {
          this.close();
        }
      },
      removeCloseEvents() {
        if (this.closeEventListener) {
          ["click", "keyup", "focusin"].forEach(
            (eventName) => document.removeEventListener(eventName, this.closeEventListener)
          );
          delete this.closeEventListener;
        }
      },
      setupPosition() {
        if (!this.positionEventListener) {
          this.positionEventListener = () => this.positionFloater();
          window.addEventListener("resize", this.positionEventListener);
        }
        this.positionFloater();
      },
      positionFloater() {
        const inputRect = this.$el.getBoundingClientRect();
        let verticalClass = "vdpPositionTop";
        let horizontalClass = "vdpPositionLeft";
        const calculate = () => {
          const rect = this.$refs.outerWrap.getBoundingClientRect();
          const floaterHeight = rect.height;
          const floaterWidth = rect.width;
          if (window.innerWidth > this.mobileBreakpointWidth) {
            if (inputRect.top + inputRect.height + floaterHeight > window.innerHeight && inputRect.top - floaterHeight > 0) {
              verticalClass = "vdpPositionBottom";
            }
            if (inputRect.left + floaterWidth > window.innerWidth) {
              horizontalClass = "vdpPositionRight";
            }
            this.positionClass = ["vdpPositionReady", verticalClass, horizontalClass].join(" ");
          } else {
            this.positionClass = "vdpPositionFixed";
          }
        };
        this.$refs.outerWrap ? calculate() : this.$nextTick(calculate);
      },
      teardownPosition() {
        if (this.positionEventListener) {
          this.positionClass = void 0;
          window.removeEventListener("resize", this.positionEventListener);
          delete this.positionEventListener;
        }
      },
      clear() {
        this.$emit("update:modelValue", "");
      },
      selectDateItem(item) {
        if (!item.disabled) {
          const newDate = new Date(item.date);
          if (this.currentTime) {
            newDate.setHours(this.currentTime.hours);
            newDate.setMinutes(this.currentTime.minutes);
            newDate.setSeconds(this.currentTime.seconds);
          }
          this.$emit("update:modelValue", this.formatDateToString(newDate, this.format));
          if (this.hasInputElement && !this.pickTime) {
            this.close();
          }
        }
      },
      set12HourClock(value) {
        const currentDate = new Date(this.valueDate);
        const currentHours = currentDate.getHours();
        currentDate.setHours(
          value === "PM" ? currentHours + 12 : currentHours - 12
        );
        this.$emit("update:modelValue", this.formatDateToString(currentDate, this.format));
      },
      inputHours(event2) {
        const currentDate = new Date(this.valueDate);
        const currentHours = currentDate.getHours();
        const targetValue = parseInt(event2.target.value, 10) || 0;
        const minHours = this.use12HourClock ? 1 : 0;
        const maxHours = this.use12HourClock ? 12 : 23;
        const numValue = boundNumber(targetValue, minHours, maxHours);
        currentDate.setHours(
          this.use12HourClock ? to24HourClock(numValue, isPM(currentHours)) : numValue
        );
        event2.target.value = paddNum(numValue, 1);
        this.$emit("update:modelValue", this.formatDateToString(currentDate, this.format));
      },
      inputTime(method, event2) {
        const currentDate = new Date(this.valueDate);
        const targetValue = parseInt(event2.target.value) || 0;
        const numValue = boundNumber(targetValue, 0, 59);
        event2.target.value = paddNum(numValue, 2);
        currentDate[method](numValue);
        this.$emit("update:modelValue", this.formatDateToString(currentDate, this.format));
      },
      onTimeInputFocus(event2) {
        event2.target.select && event2.target.select();
      }
    }
  };
  function paddNum(num, padsize) {
    return typeof num !== "undefined" ? num.toString().length > padsize ? num : new Array(padsize - num.toString().length + 1).join("0") + num : void 0;
  }
  function chunkArray(inputArray, chunkSize) {
    const results = [];
    while (inputArray.length) {
      results.push(inputArray.splice(0, chunkSize));
    }
    return results;
  }
  function areSameDates(date1, date2) {
    return date1.getDate() === date2.getDate() && date1.getMonth() === date2.getMonth() && date1.getFullYear() === date2.getFullYear();
  }
  function range(start2, end2) {
    const results = [];
    for (let i = start2; i <= end2; i++) {
      results.push(i);
    }
    return results;
  }
  function to12HourClock(hours) {
    const remainder = hours % 12;
    return remainder === 0 ? 12 : remainder;
  }
  function to24HourClock(hours, PM) {
    return PM ? hours === 12 ? hours : hours + 12 : hours === 12 ? 0 : hours;
  }
  function isPM(hours) {
    return hours >= 12;
  }
  function boundNumber(value, min2, max2) {
    return Math.min(Math.max(value, min2), max2);
  }
  const _hoisted_1$1A = ["readonly", "value"];
  const _hoisted_2$13 = { class: "vdpInnerWrap" };
  const _hoisted_3$O = { class: "vdpHeader" };
  const _hoisted_4$v = ["title"];
  const _hoisted_5$o = ["title"];
  const _hoisted_6$i = { class: "vdpPeriodControls" };
  const _hoisted_7$d = { class: "vdpPeriodControl" };
  const _hoisted_8$a = ["value"];
  const _hoisted_9$9 = { class: "vdpPeriodControl" };
  const _hoisted_10$8 = ["value"];
  const _hoisted_11$7 = { class: "vdpTable" };
  const _hoisted_12$6 = { class: "vdpHeadCellContent" };
  const _hoisted_13$5 = ["data-id", "onClick"];
  const _hoisted_14$3 = { class: "vdpCellContent" };
  const _hoisted_15$1 = {
    key: 0,
    class: "vdpTimeControls"
  };
  const _hoisted_16$1 = { class: "vdpTimeCaption" };
  const _hoisted_17$1 = { class: "vdpTimeUnit" };
  const _hoisted_18 = /* @__PURE__ */ Vue.createElementVNode("br", null, null, -1);
  const _hoisted_19 = ["disabled", "value"];
  const _hoisted_20 = {
    key: 0,
    class: "vdpTimeSeparator"
  };
  const _hoisted_21 = {
    key: 1,
    class: "vdpTimeUnit"
  };
  const _hoisted_22 = /* @__PURE__ */ Vue.createElementVNode("br", null, null, -1);
  const _hoisted_23 = ["disabled", "value"];
  const _hoisted_24 = {
    key: 2,
    class: "vdpTimeSeparator"
  };
  const _hoisted_25 = {
    key: 3,
    class: "vdpTimeUnit"
  };
  const _hoisted_26 = /* @__PURE__ */ Vue.createElementVNode("br", null, null, -1);
  const _hoisted_27 = ["disabled", "value"];
  const _hoisted_28 = ["disabled"];
  function _sfc_render$15(_ctx, _cache, $props, $setup, $data, $options) {
    return Vue.openBlock(), Vue.createElementBlock("div", {
      class: Vue.normalizeClass(["vdpComponent", { vdpWithInput: $props.hasInputElement }])
    }, [
      Vue.renderSlot(_ctx.$slots, "default", {
        open: $options.open,
        close: $options.close,
        toggle: $options.toggle,
        inputValue: $data.inputValue,
        processUserInput: $options.processUserInput,
        valueToInputFormat: $options.valueToInputFormat
      }, () => [
        $props.hasInputElement ? (Vue.openBlock(), Vue.createElementBlock("input", Vue.mergeProps({
          key: 0,
          type: "text"
        }, $props.inputAttributes, {
          readonly: $options.isReadOnly,
          value: $data.inputValue,
          onInput: _cache[0] || (_cache[0] = ($event) => $props.editable && $options.processUserInput($event.target.value)),
          onFocus: _cache[1] || (_cache[1] = ($event) => $props.editable && $options.open()),
          onClick: _cache[2] || (_cache[2] = ($event) => $props.editable && $options.open())
        }), null, 16, _hoisted_1$1A)) : Vue.createCommentVNode("", true),
        $props.editable && $props.hasInputElement && $data.inputValue ? (Vue.openBlock(), Vue.createElementBlock("button", {
          key: 1,
          class: "vdpClearInput",
          type: "button",
          onClick: _cache[3] || (_cache[3] = (...args) => $options.clear && $options.clear(...args))
        })) : Vue.createCommentVNode("", true)
      ]),
      Vue.createVNode(Vue.Transition, { name: "vdp-toggle-calendar" }, {
        default: Vue.withCtx(() => [
          $data.opened ? (Vue.openBlock(), Vue.createElementBlock("div", {
            key: 0,
            class: Vue.normalizeClass(["vdpOuterWrap", [$data.positionClass, { vdpFloating: $props.hasInputElement }]]),
            ref: "outerWrap",
            onClick: _cache[15] || (_cache[15] = (...args) => $options.closeViaOverlay && $options.closeViaOverlay(...args))
          }, [
            Vue.createElementVNode("div", _hoisted_2$13, [
              Vue.createElementVNode("header", _hoisted_3$O, [
                Vue.createElementVNode("button", {
                  class: "vdpArrow vdpArrowPrev",
                  title: $props.prevMonthCaption,
                  type: "button",
                  onClick: _cache[4] || (_cache[4] = ($event) => $options.incrementMonth(-1))
                }, Vue.toDisplayString($props.prevMonthCaption), 9, _hoisted_4$v),
                Vue.createElementVNode("button", {
                  class: "vdpArrow vdpArrowNext",
                  type: "button",
                  title: $props.nextMonthCaption,
                  onClick: _cache[5] || (_cache[5] = ($event) => $options.incrementMonth(1))
                }, Vue.toDisplayString($props.nextMonthCaption), 9, _hoisted_5$o),
                Vue.createElementVNode("div", _hoisted_6$i, [
                  Vue.createElementVNode("div", _hoisted_7$d, [
                    (Vue.openBlock(), Vue.createElementBlock("button", {
                      class: Vue.normalizeClass($options.directionClass),
                      key: $data.currentPeriod.month,
                      type: "button"
                    }, Vue.toDisplayString($props.months[$data.currentPeriod.month]), 3)),
                    Vue.withDirectives(Vue.createElementVNode("select", {
                      "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => $data.currentPeriod.month = $event)
                    }, [
                      (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList($props.months, (month, index2) => {
                        return Vue.openBlock(), Vue.createElementBlock("option", {
                          value: index2,
                          key: month
                        }, Vue.toDisplayString(month), 9, _hoisted_8$a);
                      }), 128))
                    ], 512), [
                      [Vue.vModelSelect, $data.currentPeriod.month]
                    ])
                  ]),
                  Vue.createElementVNode("div", _hoisted_9$9, [
                    (Vue.openBlock(), Vue.createElementBlock("button", {
                      class: Vue.normalizeClass($options.directionClass),
                      key: $data.currentPeriod.year,
                      type: "button"
                    }, Vue.toDisplayString($data.currentPeriod.year), 3)),
                    Vue.withDirectives(Vue.createElementVNode("select", {
                      "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => $data.currentPeriod.year = $event)
                    }, [
                      (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList($options.yearRange, (year) => {
                        return Vue.openBlock(), Vue.createElementBlock("option", {
                          value: year,
                          key: year
                        }, Vue.toDisplayString(year), 9, _hoisted_10$8);
                      }), 128))
                    ], 512), [
                      [Vue.vModelSelect, $data.currentPeriod.year]
                    ])
                  ])
                ])
              ]),
              Vue.createElementVNode("table", _hoisted_11$7, [
                Vue.createElementVNode("thead", null, [
                  Vue.createElementVNode("tr", null, [
                    (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList($options.weekdaysSorted, (weekday, weekdayIndex) => {
                      return Vue.openBlock(), Vue.createElementBlock("th", {
                        class: "vdpHeadCell",
                        key: weekdayIndex
                      }, [
                        Vue.createElementVNode("span", _hoisted_12$6, Vue.toDisplayString(weekday), 1)
                      ]);
                    }), 128))
                  ])
                ]),
                (Vue.openBlock(), Vue.createElementBlock("tbody", {
                  key: $data.currentPeriod.year + "-" + $data.currentPeriod.month,
                  class: Vue.normalizeClass($options.directionClass)
                }, [
                  (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList($options.currentPeriodDates, (week, weekIndex) => {
                    return Vue.openBlock(), Vue.createElementBlock("tr", {
                      class: "vdpRow",
                      key: weekIndex
                    }, [
                      (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList(week, (item) => {
                        return Vue.openBlock(), Vue.createElementBlock("td", {
                          class: Vue.normalizeClass(["vdpCell", {
                            selectable: $props.editable && !item.disabled,
                            selected: item.selected,
                            disabled: item.disabled,
                            today: item.today,
                            outOfRange: item.outOfRange
                          }]),
                          "data-id": item.dateKey,
                          key: item.dateKey,
                          onClick: ($event) => $props.editable && $options.selectDateItem(item)
                        }, [
                          Vue.createElementVNode("div", _hoisted_14$3, Vue.toDisplayString(item.date.getDate()), 1)
                        ], 10, _hoisted_13$5);
                      }), 128))
                    ]);
                  }), 128))
                ], 2))
              ]),
              $props.pickTime && $options.currentTime ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_15$1, [
                Vue.createElementVNode("span", _hoisted_16$1, Vue.toDisplayString($props.setTimeCaption), 1),
                Vue.createElementVNode("div", _hoisted_17$1, [
                  Vue.createElementVNode("pre", null, [
                    Vue.createElementVNode("span", null, Vue.toDisplayString($options.currentTime.hoursFormatted), 1),
                    _hoisted_18
                  ]),
                  Vue.createElementVNode("input", {
                    type: "number",
                    pattern: "\\d*",
                    class: "vdpHoursInput",
                    onInput: _cache[8] || (_cache[8] = Vue.withModifiers((...args) => $options.inputHours && $options.inputHours(...args), ["prevent"])),
                    onFocusin: _cache[9] || (_cache[9] = (...args) => $options.onTimeInputFocus && $options.onTimeInputFocus(...args)),
                    disabled: !$props.editable,
                    value: $options.currentTime.hoursFormatted
                  }, null, 40, _hoisted_19)
                ]),
                $props.pickMinutes ? (Vue.openBlock(), Vue.createElementBlock("span", _hoisted_20, ":")) : Vue.createCommentVNode("", true),
                $props.pickMinutes ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_21, [
                  Vue.createElementVNode("pre", null, [
                    Vue.createElementVNode("span", null, Vue.toDisplayString($options.currentTime.minutesFormatted), 1),
                    _hoisted_22
                  ]),
                  $props.pickMinutes ? (Vue.openBlock(), Vue.createElementBlock("input", {
                    key: 0,
                    type: "number",
                    pattern: "\\d*",
                    class: "vdpMinutesInput",
                    onInput: _cache[10] || (_cache[10] = ($event) => $options.inputTime("setMinutes", $event)),
                    onFocusin: _cache[11] || (_cache[11] = (...args) => $options.onTimeInputFocus && $options.onTimeInputFocus(...args)),
                    disabled: !$props.editable,
                    value: $options.currentTime.minutesFormatted
                  }, null, 40, _hoisted_23)) : Vue.createCommentVNode("", true)
                ])) : Vue.createCommentVNode("", true),
                $props.pickSeconds ? (Vue.openBlock(), Vue.createElementBlock("span", _hoisted_24, ":")) : Vue.createCommentVNode("", true),
                $props.pickSeconds ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_25, [
                  Vue.createElementVNode("pre", null, [
                    Vue.createElementVNode("span", null, Vue.toDisplayString($options.currentTime.secondsFormatted), 1),
                    _hoisted_26
                  ]),
                  $props.pickSeconds ? (Vue.openBlock(), Vue.createElementBlock("input", {
                    key: 0,
                    type: "number",
                    pattern: "\\d*",
                    class: "vdpSecondsInput",
                    onInput: _cache[12] || (_cache[12] = ($event) => $options.inputTime("setSeconds", $event)),
                    onFocusin: _cache[13] || (_cache[13] = (...args) => $options.onTimeInputFocus && $options.onTimeInputFocus(...args)),
                    disabled: !$props.editable,
                    value: $options.currentTime.secondsFormatted
                  }, null, 40, _hoisted_27)) : Vue.createCommentVNode("", true)
                ])) : Vue.createCommentVNode("", true),
                $props.use12HourClock ? (Vue.openBlock(), Vue.createElementBlock("button", {
                  key: 4,
                  type: "button",
                  class: "vdp12HourToggleBtn",
                  disabled: !$props.editable,
                  onClick: _cache[14] || (_cache[14] = ($event) => $options.set12HourClock($options.currentTime.isPM ? "AM" : "PM"))
                }, Vue.toDisplayString($options.currentTime.isPM ? "PM" : "AM"), 9, _hoisted_28)) : Vue.createCommentVNode("", true)
              ])) : Vue.createCommentVNode("", true)
            ])
          ], 2)) : Vue.createCommentVNode("", true)
        ]),
        _: 1
      })
    ], 2);
  }
  var vueDatePick = /* @__PURE__ */ _export_sfc(_sfc_main$24, [["render", _sfc_render$15]]);
  const _sfc_main$23 = {
    name: "InputDatePicker",
    components: {
      vueDatePick,
      BaseInput: _sfc_main$31
    },
    props: {
      modelValue: {
        type: String,
        required: true
      },
      readonly: {
        type: Boolean,
        required: false
      },
      pickTime: {
        type: Boolean,
        required: false,
        default: false
      },
      format: {
        type: String,
        required: false
      },
      use12HourClock: {
        type: Boolean,
        required: false
      },
      pastDisabled: {
        type: Boolean,
        required: false
      },
      futureDisabled: {
        type: Boolean,
        required: false,
        default: false
      }
    },
    data() {
      return {
        weekdaysStrings: [
          this.$translate("monday"),
          this.$translate("tuesday"),
          this.$translate("wednesday"),
          this.$translate("thursday"),
          this.$translate("friday"),
          this.$translate("saturday"),
          this.$translate("sunday")
        ],
        monthsStrings: [
          this.$translate("jan"),
          this.$translate("feb"),
          this.$translate("mar"),
          this.$translate("apr"),
          this.$translate("may"),
          this.$translate("jun"),
          this.$translate("jul"),
          this.$translate("aug"),
          this.$translate("sep"),
          this.$translate("oct"),
          this.$translate("nov"),
          this.$translate("dec")
        ]
      };
    },
    computed: {
      valueModel: {
        get() {
          return this.modelValue;
        },
        set(newValue) {
          this.$emit("update:modelValue", newValue);
        }
      }
    },
    methods: {
      disableDate(date) {
        const currentDate = new Date();
        currentDate.setHours(0, 0, 0, 0);
        if (this.pastDisabled) {
          return date < currentDate;
        } else if (this.futureDisabled) {
          return date > currentDate;
        } else
          return false;
      }
    }
  };
  function _sfc_render$14(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_BaseInput = Vue.resolveComponent("BaseInput");
    const _component_vueDatePick = Vue.resolveComponent("vueDatePick");
    return Vue.openBlock(), Vue.createBlock(_component_vueDatePick, {
      modelValue: $options.valueModel,
      "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $options.valueModel = $event),
      class: "znpb-input-date",
      "next-month-caption": _ctx.$translate("next_month"),
      "previous-month-caption": _ctx.$translate("previous_month"),
      "set-time-caption": _ctx.$translate("set_time"),
      weekdays: $data.weekdaysStrings,
      months: $data.monthsStrings,
      "pick-time": $props.pickTime,
      "use-12-hour-clock": $props.use12HourClock,
      format: $props.format,
      "is-date-disabled": $options.disableDate
    }, {
      default: Vue.withCtx(({ toggle }) => [
        Vue.createVNode(_component_BaseInput, Vue.mergeProps({
          modelValue: $options.valueModel,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $options.valueModel = $event),
          readonly: $props.readonly,
          class: "znpb-input-number__input"
        }, _ctx.$attrs, {
          onKeydown: toggle,
          onMouseup: toggle
        }), null, 16, ["modelValue", "readonly", "onKeydown", "onMouseup"])
      ]),
      _: 1
    }, 8, ["modelValue", "next-month-caption", "previous-month-caption", "set-time-caption", "weekdays", "months", "pick-time", "use-12-hour-clock", "format", "is-date-disabled"]);
  }
  var InputDatePicker = /* @__PURE__ */ _export_sfc(_sfc_main$23, [["render", _sfc_render$14]]);
  var InputEditor_vue_vue_type_style_index_0_lang = "";
  const __default__$m = {
    name: "InputEditor"
  };
  const _sfc_main$22 = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$m), {
    props: {
      modelValue: { default: "" }
    },
    emits: ["update:modelValue"],
    setup(__props, { emit }) {
      const props = __props;
      let editorTextarea;
      const root2 = Vue.ref(null);
      let editor;
      const randomNumber = Math.floor(Math.random() * 100 + 1);
      const editorID = `znpbwpeditor${randomNumber}`;
      const content = Vue.computed({
        get() {
          return props.modelValue || "";
        },
        set(newValue) {
          emit("update:modelValue", newValue);
        }
      });
      Vue.onBeforeUnmount(() => {
        editorTextarea.removeEventListener("keyup", onTextChanged);
        if (window.tinyMCE !== void 0 && editor) {
          window.tinyMCE.remove(editor);
        }
        editor = null;
      });
      Vue.onMounted(() => {
        root2.value.innerHTML = window.ZnPbInitialData.wp_editor.replace(/znpbwpeditorid/g, editorID).replace("%%ZNPB_EDITOR_CONTENT%%", content.value);
        editorTextarea = document.querySelectorAll(".wp-editor-area")[0];
        editorTextarea.addEventListener("keyup", onTextChanged);
        window.quicktags({
          buttons: "strong,em,del,link,img,close",
          id: editorID
        });
        const config = {
          id: editorID,
          selector: `#${editorID}`,
          setup: onEditorSetup,
          content_style: "body { background-color: #fff; }"
        };
        window.tinyMCEPreInit.mceInit[editorID] = Object.assign({}, window.tinyMCEPreInit.mceInit.znpbwpeditorid, config);
        window.switchEditors.go(editorID, "tmce");
      });
      Vue.watch(
        () => props.modelValue,
        (newValue) => {
          const currentValue = editor == null ? void 0 : editor.getContent();
          if (editor && currentValue !== newValue) {
            const value = newValue || "";
            editor.setContent(value);
            debouncedAddToHistory();
            editorTextarea.value = newValue;
          }
        }
      );
      const debouncedAddToHistory = debounce$1(() => {
        if (editor) {
          editor.undoManager.add();
        }
      }, 500);
      function onEditorSetup(editorInstance) {
        editor = editorInstance;
        editor.on("change KeyUp Undo Redo", onEditorContentChange);
      }
      function onEditorContentChange() {
        const currentValue = props.modelValue;
        const newValue = editor == null ? void 0 : editor.getContent();
        if (currentValue !== newValue) {
          emit("update:modelValue", newValue);
        }
      }
      function onTextChanged() {
        emit("update:modelValue", editorTextarea.value);
      }
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", {
          ref_key: "root",
          ref: root2,
          class: "znpb-wp-editor__wrapper znpb-wp-editor-custom"
        }, null, 512);
      };
    }
  }));
  var InputMedia_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$1z = { class: "znpb-input-media-wrapper" };
  const __default__$l = {
    name: "InputMedia"
  };
  const _sfc_main$21 = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$l), {
    props: {
      modelValue: null,
      media_type: { default: "image" },
      selectButtonText: { default: "select" },
      mediaConfig: { default: () => {
        return {
          inserTitle: "Add File",
          multiple: false
        };
      } }
    },
    emits: ["update:modelValue"],
    setup(__props, { emit }) {
      const props = __props;
      const mediaModal = Vue.ref(null);
      const inputValue = Vue.computed({
        get() {
          return props.modelValue || "";
        },
        set(newValue) {
          emit("update:modelValue", newValue);
        }
      });
      function openMediaModal() {
        if (mediaModal.value === null) {
          let selection = getSelection();
          const args = {
            frame: "select",
            state: "library",
            library: { type: props.media_type },
            button: { text: props.mediaConfig.inserTitle },
            selection
          };
          mediaModal.value = window.wp.media(args);
          mediaModal.value.on("select update insert", selectFont);
        }
        mediaModal.value.open();
      }
      function selectFont(e) {
        console.log("e", e);
        let selection = mediaModal.value.state().get("selection").toJSON();
        if (e !== void 0) {
          selection = e;
        }
        if (props.mediaConfig.multiple) {
          inputValue.value = selection.map((selectedItem) => selectedItem.url).join(",");
        } else {
          inputValue.value = selection[0].url;
        }
      }
      function getSelection() {
        if (typeof props.modelValue === "undefined")
          return;
        let idArray = props.modelValue.split(",");
        let args = { orderby: "post__in", order: "ASC", type: "image", perPage: -1, post__in: idArray };
        let attachments = window.wp.media.query(args);
        let selection = new window.wp.media.model.Selection(attachments.models, {
          props: attachments.props.toJSON(),
          multiple: true
        });
        return selection;
      }
      return (_ctx, _cache) => {
        const _component_Button = Vue.resolveComponent("Button");
        return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$1z, [
          Vue.createVNode(_sfc_main$31, {
            modelValue: Vue.unref(inputValue),
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => Vue.isRef(inputValue) ? inputValue.value = $event : null),
            class: "znpb-form__input-text",
            placeholder: "Type your text here",
            onClick: openMediaModal
          }, null, 8, ["modelValue"]),
          Vue.createVNode(_component_Button, {
            type: "line",
            onClick: openMediaModal
          }, {
            default: Vue.withCtx(() => [
              Vue.createTextVNode(Vue.toDisplayString(__props.selectButtonText), 1)
            ]),
            _: 1
          })
        ]);
      };
    }
  }));
  var InputFile_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$1y = { class: "znpb-input-media-wrapper" };
  const _hoisted_2$12 = ["accept"];
  const _hoisted_3$N = { key: 1 };
  const __default__$k = {
    name: "InputFile"
  };
  const _sfc_main$20 = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$k), {
    props: {
      modelValue: null,
      type: { default: "image" },
      selectButtonText: { default: "select" }
    },
    emits: ["update:modelValue"],
    setup(__props, { emit }) {
      const props = __props;
      const fileInput = Vue.ref(null);
      const loading = Vue.ref(false);
      const inputValue = Vue.computed({
        get() {
          return props.modelValue || "";
        },
        set(newValue) {
          emit("update:modelValue", newValue);
        }
      });
      function onButtonClick() {
        if (fileInput.value) {
          fileInput.value.click();
        }
      }
      function uploadFiles(fieldName, fileList) {
        return __async(this, null, function* () {
          const formData = new FormData();
          if (!fileList || !fileList.length)
            return;
          Array.from(fileList).forEach((file) => {
            formData.append(fieldName, file, file.name);
          });
          loading.value = true;
          try {
            const response = yield uploadFile(formData);
            const responseData = response.data;
            inputValue.value = responseData.file_url;
          } catch (err) {
            console.error(err);
          }
          loading.value = false;
        });
      }
      return (_ctx, _cache) => {
        const _component_Loader = Vue.resolveComponent("Loader");
        const _component_Button = Vue.resolveComponent("Button");
        return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$1y, [
          Vue.createVNode(_sfc_main$31, {
            modelValue: Vue.unref(inputValue),
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => Vue.isRef(inputValue) ? inputValue.value = $event : null),
            class: "znpb-form__input-text",
            placeholder: "Type your text here",
            onClick: onButtonClick
          }, null, 8, ["modelValue"]),
          Vue.createElementVNode("input", {
            ref_key: "fileInput",
            ref: fileInput,
            type: "file",
            style: { "display": "none" },
            accept: __props.type,
            name: "file",
            onChange: _cache[1] || (_cache[1] = ($event) => uploadFiles($event.target.name, $event.target.files))
          }, null, 40, _hoisted_2$12),
          Vue.createVNode(_component_Button, {
            type: "line",
            onClick: onButtonClick
          }, {
            default: Vue.withCtx(() => [
              loading.value ? (Vue.openBlock(), Vue.createBlock(_component_Loader, {
                key: 0,
                size: 14
              })) : (Vue.openBlock(), Vue.createElementBlock("span", _hoisted_3$N, Vue.toDisplayString(__props.selectButtonText), 1))
            ]),
            _: 1
          })
        ]);
      };
    }
  }));
  var InputRadioGroup_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$1$ = {
    props: {
      layout: {
        type: String,
        required: false
      }
    },
    data() {
      return {};
    },
    name: "InputRadioGroup"
  };
  function _sfc_render$13(_ctx, _cache, $props, $setup, $data, $options) {
    return Vue.openBlock(), Vue.createElementBlock("div", {
      class: Vue.normalizeClass(["zion-radio-group", {
        [`zion-radio-group--${$props.layout}`]: $props.layout
      }])
    }, [
      Vue.renderSlot(_ctx.$slots, "default")
    ], 2);
  }
  var InputRadioGroup = /* @__PURE__ */ _export_sfc(_sfc_main$1$, [["render", _sfc_render$13]]);
  var InputRadio_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$1_ = {
    name: "InputRadio",
    props: {
      modelValue: {
        type: String,
        required: false
      },
      label: {
        type: String,
        required: false
      },
      optionValue: {
        type: String,
        required: true
      },
      hideInput: {
        type: Boolean,
        required: false,
        default: false
      }
    },
    data() {
      return {
        checked: ""
      };
    },
    computed: {
      radioButtonValue: {
        get: function() {
          return this.modelValue;
        },
        set: function() {
          this.$emit("update:modelValue", this.optionValue);
        }
      },
      isSelected() {
        return this.modelValue === this.optionValue;
      }
    },
    methods: {}
  };
  const _hoisted_1$1x = ["modelValue"];
  const _hoisted_2$11 = /* @__PURE__ */ Vue.createElementVNode("span", { class: "znpb-radio-item-input" }, null, -1);
  const _hoisted_3$M = {
    key: 0,
    class: "znpb-radio-item-label"
  };
  function _sfc_render$12(_ctx, _cache, $props, $setup, $data, $options) {
    return Vue.openBlock(), Vue.createElementBlock("label", {
      class: Vue.normalizeClass(["znpb-radio-item", {
        "znpb-radio-item--active": $options.isSelected,
        "znpb-radio-item--hidden-input": $props.hideInput
      }])
    }, [
      Vue.withDirectives(Vue.createElementVNode("input", {
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $options.radioButtonValue = $event),
        modelValue: $props.optionValue,
        type: "radio",
        class: "znpb-form__input-toggle"
      }, null, 8, _hoisted_1$1x), [
        [Vue.vModelRadio, $options.radioButtonValue]
      ]),
      _hoisted_2$11,
      Vue.renderSlot(_ctx.$slots, "default"),
      $props.label ? (Vue.openBlock(), Vue.createElementBlock("span", _hoisted_3$M, Vue.toDisplayString($props.label), 1)) : Vue.createCommentVNode("", true)
    ], 2);
  }
  var InputRadio = /* @__PURE__ */ _export_sfc(_sfc_main$1_, [["render", _sfc_render$12]]);
  var InputRadioIcon_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$1Z = {
    name: "InputRadioIcon",
    components: {
      Icon: _sfc_main$34
    },
    props: {
      modelValue: {
        type: String,
        required: false
      },
      label: {
        type: String,
        required: false
      },
      optionValue: {
        type: String,
        required: true
      },
      icon: {
        type: String,
        required: false
      },
      bgSize: {
        type: Number,
        required: false,
        default: 32
      }
    },
    data() {
      return {
        checked: ""
      };
    },
    computed: {
      radioButtonValue: {
        get: function() {
          return this.modelValue;
        },
        set: function() {
          this.$emit("update:modelValue", this.optionValue);
        }
      },
      isSelected() {
        return this.modelValue === this.optionValue;
      }
    },
    methods: {}
  };
  const _hoisted_1$1w = ["modelValue"];
  function _sfc_render$11(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Icon = Vue.resolveComponent("Icon");
    return Vue.openBlock(), Vue.createElementBlock("label", {
      class: Vue.normalizeClass(["znpb-radio-icon-item", {
        "znpb-radio-icon-item--active": $options.isSelected
      }])
    }, [
      Vue.withDirectives(Vue.createElementVNode("input", {
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $options.radioButtonValue = $event),
        modelValue: $props.optionValue,
        type: "radio",
        class: "znpb-form__input-toggle"
      }, null, 8, _hoisted_1$1w), [
        [Vue.vModelRadio, $options.radioButtonValue]
      ]),
      $props.icon ? (Vue.openBlock(), Vue.createBlock(_component_Icon, {
        key: 0,
        icon: $props.icon,
        "bg-size": $props.bgSize,
        class: "znpb-radio-icon-item__icon"
      }, null, 8, ["icon", "bg-size"])) : Vue.createCommentVNode("", true),
      Vue.createTextVNode(" " + Vue.toDisplayString($props.label), 1)
    ], 2);
  }
  var InputRadioIcon = /* @__PURE__ */ _export_sfc(_sfc_main$1Z, [["render", _sfc_render$11]]);
  const _hoisted_1$1v = ["innerHTML"];
  const __default__$j = {
    name: "SvgMask"
  };
  const _sfc_main$1Y = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$j), {
    props: {
      shapePath: null,
      position: null,
      color: null,
      flip: { type: Boolean }
    },
    setup(__props) {
      const props = __props;
      const masks = Vue.inject("masks");
      const svgData = Vue.ref("");
      const getSvgIcon = Vue.computed(() => svgData.value);
      Vue.watch(
        () => props.shapePath,
        (newValue) => {
          getFile(newValue);
        }
      );
      function getFile(shapePath) {
        let url;
        if (shapePath.includes(".svg")) {
          url = shapePath;
        } else {
          const shapeConfig = masks[shapePath];
          url = shapeConfig.url;
        }
        fetch(url).then((response) => response.text()).then((svgFile) => {
          svgData.value = svgFile;
        }).catch((error) => {
          console.error(error);
        });
      }
      Vue.onMounted(() => {
        if (props.shapePath !== void 0 && props.shapePath.length) {
          getFile(props.shapePath);
        }
      });
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", {
          class: Vue.normalizeClass(["znpb-shape-divider-icon zb-mask", [__props.position === "top" ? "zb-mask-pos--top" : "zb-mask-pos--bottom", __props.flip ? "zb-mask-pos--flip" : ""]]),
          style: Vue.normalizeStyle({ color: __props.color }),
          innerHTML: Vue.unref(getSvgIcon)
        }, null, 14, _hoisted_1$1v);
      };
    }
  }));
  var InputShapeDividers_vue_vue_type_style_index_0_lang = "";
  const __default__$i = {
    name: "InputShapeDividers"
  };
  const _sfc_main$1X = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$i), {
    props: {
      modelValue: { default: () => {
        return {};
      } }
    },
    emits: ["update:modelValue"],
    setup(__props, { emit }) {
      const props = __props;
      const { translate: translate2 } = window.zb.i18n;
      const maskPosOptions = Vue.ref([
        {
          id: "top",
          name: translate2("top_masks")
        },
        {
          id: "bottom",
          name: translate2("bottom_masks")
        }
      ]);
      const activeMaskPosition = Vue.ref("top");
      const computedTitle = Vue.computed(() => {
        return activeMaskPosition.value === "top" ? translate2("select_top_mask") : translate2("select_bottom_mask");
      });
      const schema = Vue.computed(() => {
        return {
          shape: {
            type: "shape_component",
            id: "shape",
            width: "100",
            title: computedTitle.value,
            position: activeMaskPosition.value
          },
          color: {
            type: "colorpicker",
            id: "color",
            width: "100",
            title: translate2("select_mask_color")
          },
          height: {
            type: "dynamic_slider",
            id: "height",
            title: translate2("select_mask_height"),
            width: "100",
            responsive_options: true,
            options: [
              { unit: "px", min: 0, max: 4999, step: 1 },
              { unit: "%", min: 0, max: 100, step: 1 },
              { unit: "vh", min: 0, max: 100, step: 10 },
              { unit: "auto" }
            ]
          },
          flip: {
            type: "checkbox_switch",
            id: "flip",
            title: translate2("flip_mask"),
            width: "100",
            layout: "inline"
          }
        };
      });
      const computedValue = Vue.computed({
        get() {
          var _a3, _b;
          return (_b = (_a3 = props.modelValue) == null ? void 0 : _a3[activeMaskPosition.value]) != null ? _b : {};
        },
        set(newValue) {
          if (newValue === null) {
            emit("update:modelValue", null);
            return;
          }
          const shape = get(props.modelValue, `${activeMaskPosition.value}.shape`);
          if (shape !== newValue["shape"] && newValue["height"]) {
            newValue["height"] = "auto";
          }
          emit("update:modelValue", __spreadProps(__spreadValues({}, props.modelValue), {
            [activeMaskPosition.value]: newValue
          }));
        }
      });
      return (_ctx, _cache) => {
        const _component_OptionsForm = Vue.resolveComponent("OptionsForm");
        return Vue.openBlock(), Vue.createElementBlock("div", null, [
          Vue.createVNode(Vue.unref(_sfc_main$25), {
            modelValue: activeMaskPosition.value,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => activeMaskPosition.value = $event),
            options: maskPosOptions.value,
            columns: 2
          }, null, 8, ["modelValue", "options"]),
          Vue.createVNode(_component_OptionsForm, {
            modelValue: Vue.unref(computedValue),
            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => Vue.isRef(computedValue) ? computedValue.value = $event : null),
            schema: Vue.unref(schema)
          }, null, 8, ["modelValue", "schema"])
        ]);
      };
    }
  }));
  var Shape_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$1u = { class: "znpb-editor-shapeWrapper" };
  const __default__$h = {
    name: "Shape"
  };
  const _sfc_main$1W = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$h), {
    props: {
      shapePath: null,
      position: null
    },
    setup(__props) {
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$1u, [
          Vue.renderSlot(_ctx.$slots, "default"),
          __props.shapePath ? (Vue.openBlock(), Vue.createBlock(_sfc_main$1Y, {
            key: 0,
            "shape-path": __props.shapePath,
            position: __props.position
          }, null, 8, ["shape-path", "position"])) : Vue.createCommentVNode("", true)
        ]);
      };
    }
  }));
  var UpgradeToPro_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$1t = { class: "znpb-option__upgrade-to-pro" };
  const _hoisted_2$10 = { class: "znpb-option__upgrade-to-pro-container" };
  const _hoisted_3$L = ["href"];
  const _hoisted_4$u = {
    href: "https://zionbuilder.io/",
    target: "_blank",
    class: "znpb-button znpb-get-pro__cta znpb-button--secondary znpb-option__upgrade-to-pro-button"
  };
  const __default__$g = {
    name: "UpgradeToPro"
  };
  const _sfc_main$1V = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$g), {
    props: {
      message_title: { default: "" },
      message_description: { default: "" },
      info_text: { default: "" },
      info_link: { default: "https://zionbuilder.io/documentation/pro-version/" }
    },
    setup(__props) {
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$1t, [
          Vue.createElementVNode("div", _hoisted_2$10, [
            Vue.createVNode(_sfc_main$2t, {
              text: _ctx.$translate("pro"),
              type: "warning",
              class: "znpb-option__upgrade-to-pro-label"
            }, null, 8, ["text"]),
            Vue.createElementVNode("h4", null, Vue.toDisplayString(__props.message_title), 1),
            Vue.createElementVNode("p", null, Vue.toDisplayString(__props.message_description), 1),
            __props.info_text ? (Vue.openBlock(), Vue.createElementBlock("a", {
              key: 0,
              href: __props.info_link,
              target: "_blank"
            }, Vue.toDisplayString(__props.info_text), 9, _hoisted_3$L)) : Vue.createCommentVNode("", true),
            Vue.createElementVNode("div", null, [
              Vue.createElementVNode("a", _hoisted_4$u, Vue.toDisplayString(_ctx.$translate("upgrade_to_pro")), 1)
            ])
          ])
        ]);
      };
    }
  }));
  var ShapeDividerComponent_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$1s = { class: "znpb-shape-list znpb-fancy-scrollbar" };
  const __default__$f = {
    name: "ShapeDividerComponent"
  };
  const _sfc_main$1U = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$f), {
    props: {
      position: null,
      modelValue: null
    },
    emits: ["update:modelValue"],
    setup(__props) {
      const showDelete = Vue.ref(false);
      const masks = Vue.inject("masks");
      const isPro = window.ZnPbComponentsData.is_pro_active;
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", null, [
          Vue.createVNode(_sfc_main$1W, {
            class: Vue.normalizeClass(["znpb-active-shape-preview", [{ "mask-active": __props.modelValue }]]),
            "shape-path": __props.modelValue,
            position: __props.position
          }, {
            default: Vue.withCtx(() => [
              !__props.modelValue ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$2P), {
                key: 0,
                class: "znpb-style-shape__empty",
                "no-margin": true
              }, {
                default: Vue.withCtx(() => [
                  Vue.createTextVNode(Vue.toDisplayString(_ctx.$translate("select_shape")), 1)
                ]),
                _: 1
              })) : (Vue.openBlock(), Vue.createElementBlock("span", {
                key: 1,
                class: "znpb-active-shape-preview__action",
                onMouseover: _cache[1] || (_cache[1] = ($event) => showDelete.value = true),
                onMouseleave: _cache[2] || (_cache[2] = ($event) => showDelete.value = false)
              }, [
                Vue.createVNode(Vue.Transition, {
                  name: "slide-fade",
                  mode: "out-in"
                }, {
                  default: Vue.withCtx(() => [
                    !showDelete.value ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$34), {
                      key: "1",
                      icon: "check",
                      size: 10
                    })) : (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$34), {
                      key: "2",
                      icon: "close",
                      size: 10,
                      onClick: _cache[0] || (_cache[0] = Vue.withModifiers(($event) => (_ctx.$emit("update:modelValue", null), showDelete.value = false), ["stop"]))
                    }))
                  ]),
                  _: 1
                })
              ], 32))
            ]),
            _: 1
          }, 8, ["shape-path", "class", "position"]),
          Vue.createElementVNode("div", _hoisted_1$1s, [
            (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList(Vue.unref(masks), (shape, shapeID) => {
              return Vue.openBlock(), Vue.createBlock(_sfc_main$1W, {
                key: shapeID,
                "shape-path": shapeID,
                position: __props.position,
                onClick: ($event) => _ctx.$emit("update:modelValue", shapeID)
              }, null, 8, ["shape-path", "position", "onClick"]);
            }), 128)),
            !Vue.unref(isPro) ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$1V), {
              key: 0,
              message_title: _ctx.$translate("pro_masks_title"),
              message_description: _ctx.$translate("pro_masks_description"),
              info_text: _ctx.$translate("learn_more_about_pro")
            }, null, 8, ["message_title", "message_description", "info_text"])) : Vue.createCommentVNode("", true)
          ])
        ]);
      };
    }
  }));
  const __default__$e = {
    name: "InputTextAlign"
  };
  const _sfc_main$1T = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$e), {
    props: {
      modelValue: null,
      placeholder: null
    },
    emits: ["update:modelValue"],
    setup(__props, { emit }) {
      const props = __props;
      const { translate: translate2 } = window.zb.i18n;
      const textAlignOptions = [
        {
          icon: "align--left",
          id: "left",
          name: translate2("align_left")
        },
        {
          icon: "align--center",
          id: "center",
          name: translate2("align_center")
        },
        {
          icon: "align--right",
          id: "right",
          name: translate2("align_right")
        },
        {
          icon: "align--justify",
          id: "justify",
          name: translate2("justify")
        }
      ];
      const textAlignModel = Vue.computed({
        get() {
          return props.modelValue || "";
        },
        set(newValue) {
          emit("update:modelValue", newValue);
        }
      });
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", null, [
          Vue.createVNode(Vue.unref(_sfc_main$25), {
            modelValue: Vue.unref(textAlignModel),
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => Vue.isRef(textAlignModel) ? textAlignModel.value = $event : null),
            placeholder: __props.placeholder,
            options: textAlignOptions,
            columns: 4
          }, null, 8, ["modelValue", "placeholder"])
        ]);
      };
    }
  }));
  var InputTextShadow_vue_vue_type_style_index_0_lang = "";
  const __default__$d = {
    name: "InputTextShadow"
  };
  const _sfc_main$1S = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$d), {
    props: {
      modelValue: { default: () => {
        return {};
      } },
      inset: { type: Boolean },
      shadow_type: { default: "text-shadow" },
      placeholder: { default: () => {
        return {};
      } }
    },
    emits: ["update:modelValue"],
    setup(__props, { emit }) {
      const props = __props;
      const { getSchema } = useOptionsSchemas();
      const schema = Vue.computed(() => {
        let schema2 = getSchema("shadowSchema");
        if (props.shadow_type === "text-shadow") {
          schema2 = omit$1(schema2, ["inset", "spread"]);
        }
        if (Object.keys(props.placeholder).length > 0) {
          Object.keys(schema2).forEach((singleSchemaID) => {
            const singleSchema = schema2[singleSchemaID];
            if (typeof props.placeholder[singleSchemaID] !== "undefined") {
              singleSchema.placeholder = props.placeholder[singleSchemaID];
            }
          });
        }
        return schema2;
      });
      const valueModel = Vue.computed({
        get() {
          return props.modelValue || {};
        },
        set(newValue) {
          emit("update:modelValue", newValue);
        }
      });
      return (_ctx, _cache) => {
        const _component_OptionsForm = Vue.resolveComponent("OptionsForm");
        return Vue.openBlock(), Vue.createElementBlock("div", {
          class: Vue.normalizeClass(["znpb-shadow-option-wrapper__outer", `znpb-shadow-option--${__props.shadow_type}`])
        }, [
          Vue.createVNode(_component_OptionsForm, {
            modelValue: Vue.unref(valueModel),
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => Vue.isRef(valueModel) ? valueModel.value = $event : null),
            schema: Vue.unref(schema),
            class: "znpb-shadow-option"
          }, null, 8, ["modelValue", "schema"])
        ], 2);
      };
    }
  }));
  var InputRadioImage_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$1r = { class: "znpb-radio-image-container" };
  const _hoisted_2$$ = { class: "znpb-radio-image-wrapper znpb-fancy-scrollbar" };
  const _hoisted_3$K = ["onClick"];
  const _hoisted_4$t = ["src"];
  const _hoisted_5$n = {
    key: 0,
    class: "znpb-radio-image-list__item-name"
  };
  const _hoisted_6$h = {
    key: 0,
    class: "znpb-radio-image-search--noItems"
  };
  const __default__$c = {
    name: "InputRadioImage"
  };
  const _sfc_main$1R = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$c), {
    props: {
      modelValue: null,
      options: null,
      columns: { default: 3 },
      useSearch: { type: Boolean, default: true },
      searchText: { default: () => {
        const { translate: translate2 } = window.zb.i18n;
        return translate2("search");
      } }
    },
    emits: ["update:modelValue"],
    setup(__props, { emit }) {
      const props = __props;
      const searchKeyword = Vue.ref("");
      const visibleItems = Vue.computed(() => {
        if (searchKeyword.value.length > 0) {
          return props.options.filter(
            (option) => option.name && option.name.toLowerCase().includes(searchKeyword.value.toLowerCase())
          );
        }
        return props.options;
      });
      function changeValue(newValue) {
        emit("update:modelValue", newValue);
      }
      return (_ctx, _cache) => {
        const _component_BaseInput = Vue.resolveComponent("BaseInput");
        return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$1r, [
          __props.useSearch ? (Vue.openBlock(), Vue.createBlock(_component_BaseInput, {
            key: 0,
            modelValue: searchKeyword.value,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => searchKeyword.value = $event),
            placeholder: __props.searchText,
            clearable: true,
            class: "znpb-radio-image-search"
          }, null, 8, ["modelValue", "placeholder"])) : Vue.createCommentVNode("", true),
          Vue.createElementVNode("div", _hoisted_2$$, [
            Vue.createElementVNode("ul", {
              class: Vue.normalizeClass(["znpb-radio-image-list", [`znpb-radio-image-list--columns-${__props.columns}`]])
            }, [
              (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList(Vue.unref(visibleItems), (option, index2) => {
                return Vue.openBlock(), Vue.createElementBlock("li", {
                  key: index2,
                  class: "znpb-radio-image-list__item-wrapper",
                  onClick: ($event) => changeValue(option.value)
                }, [
                  Vue.createElementVNode("div", {
                    class: Vue.normalizeClass(["znpb-radio-image-list__item", { ["znpb-radio-image-list__item--active"]: __props.modelValue === option.value }])
                  }, [
                    option.image ? (Vue.openBlock(), Vue.createElementBlock("img", {
                      key: 0,
                      src: option.image,
                      class: "znpb-image-wrapper"
                    }, null, 8, _hoisted_4$t)) : Vue.createCommentVNode("", true),
                    option.class ? (Vue.openBlock(), Vue.createElementBlock("span", {
                      key: 1,
                      class: Vue.normalizeClass(["znpb-radio-image-list__preview-element animated", option.value])
                    }, null, 2)) : Vue.createCommentVNode("", true),
                    option.icon ? (Vue.openBlock(), Vue.createBlock(_sfc_main$34, {
                      key: 2,
                      class: "znpb-radio-image-list__icon",
                      icon: option.icon
                    }, null, 8, ["icon"])) : Vue.createCommentVNode("", true)
                  ], 2),
                  option.name ? (Vue.openBlock(), Vue.createElementBlock("span", _hoisted_5$n, Vue.toDisplayString(option.name), 1)) : Vue.createCommentVNode("", true)
                ], 8, _hoisted_3$K);
              }), 128)),
              __props.useSearch && Vue.unref(visibleItems).length === 0 ? (Vue.openBlock(), Vue.createElementBlock("li", _hoisted_6$h, Vue.toDisplayString(_ctx.$translate("no_items_found")), 1)) : Vue.createCommentVNode("", true)
            ], 2)
          ])
        ]);
      };
    }
  }));
  var RepeaterOption_vue_vue_type_style_index_0_lang = "";
  const __default__$b = {
    name: "RepeaterOption"
  };
  const _sfc_main$1Q = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$b), {
    props: {
      modelValue: { default: () => {
        return {};
      } },
      schema: null,
      propertyIndex: { default: 0 },
      item_title: null,
      default_item_title: null,
      deletable: { type: Boolean, default: true },
      clonable: { type: Boolean, default: true }
    },
    emits: ["update:modelValue", "clone-option", "delete-option"],
    setup(__props, { emit }) {
      const props = __props;
      const selectedOptionModel = Vue.computed({
        get() {
          return props.modelValue;
        },
        set(newValue) {
          emit("update:modelValue", newValue);
        }
      });
      const title = Vue.computed(() => {
        if (props.item_title && selectedOptionModel.value && selectedOptionModel.value[props.item_title]) {
          return selectedOptionModel.value[props.item_title];
        }
        return props.default_item_title.replace("%s", props.propertyIndex + 1);
      });
      function cloneOption() {
        const clone = JSON.parse(JSON.stringify(props.modelValue));
        emit("clone-option", clone);
      }
      function deleteOption(propertyIndex) {
        emit("delete-option", propertyIndex);
      }
      function onItemChange(newValues, index2) {
        emit("update:modelValue", { newValues, index: index2 });
      }
      return (_ctx, _cache) => {
        const _component_Icon = Vue.resolveComponent("Icon");
        const _component_OptionsForm = Vue.resolveComponent("OptionsForm");
        const _component_HorizontalAccordion = Vue.resolveComponent("HorizontalAccordion");
        return Vue.openBlock(), Vue.createBlock(_component_HorizontalAccordion, {
          title: Vue.unref(title),
          "combine-breadcrumbs": true,
          "show-back-button": true
        }, {
          actions: Vue.withCtx(() => [
            __props.clonable ? (Vue.openBlock(), Vue.createBlock(_component_Icon, {
              key: 0,
              class: "znpb-option-repeater-selector__clone-icon",
              icon: "copy",
              onClick: Vue.withModifiers(cloneOption, ["stop"])
            }, null, 8, ["onClick"])) : Vue.createCommentVNode("", true),
            __props.deletable ? (Vue.openBlock(), Vue.createBlock(_component_Icon, {
              key: 1,
              class: "znpb-option-repeater-selector__delete-icon",
              icon: "delete",
              onClick: _cache[0] || (_cache[0] = Vue.withModifiers(($event) => deleteOption(__props.propertyIndex), ["stop"]))
            })) : Vue.createCommentVNode("", true)
          ]),
          default: Vue.withCtx(() => [
            Vue.createVNode(_component_OptionsForm, {
              schema: __props.schema,
              modelValue: Vue.unref(selectedOptionModel),
              class: "znpb-option-repeater-form",
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => onItemChange($event, __props.propertyIndex))
            }, null, 8, ["schema", "modelValue"])
          ]),
          _: 1
        }, 8, ["title"]);
      };
    }
  }));
  var Repeater_vue_vue_type_style_index_0_lang = "";
  const __default__$a = {
    name: "Repeater"
  };
  const _sfc_main$1P = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$a), {
    props: {
      modelValue: null,
      addable: { type: Boolean, default: true },
      deletable: { type: Boolean, default: true },
      clonable: { type: Boolean, default: true },
      maxItems: null,
      add_button_text: { default: () => {
        const { translate: translate2 } = window.zb.i18n;
        return translate2("generic_add_new");
      } },
      child_options: null,
      item_title: null,
      default_item_title: null,
      add_template: null
    },
    emits: ["update:modelValue"],
    setup(__props, { emit }) {
      const props = __props;
      const sortableItems = Vue.computed({
        get() {
          return props.modelValue || [];
        },
        set(newValue) {
          emit("update:modelValue", newValue);
        }
      });
      const showButton = Vue.computed(() => {
        return props.maxItems ? props.addable && sortableItems.value.length < props.maxItems : props.addable;
      });
      const checkClonable = Vue.computed(() => {
        return !props.addable ? false : !props.maxItems ? props.clonable : sortableItems.value.length < props.maxItems;
      });
      function onItemChange(payload) {
        const { index: index2, newValues } = payload;
        let copiedValues = [...sortableItems.value];
        let clonedNewValue = newValues;
        if (newValues === null) {
          clonedNewValue = [];
        }
        copiedValues[index2] = clonedNewValue;
        emit("update:modelValue", copiedValues);
      }
      function addProperty() {
        var _a3;
        const clone = [...sortableItems.value];
        const newItem = (_a3 = props.add_template) != null ? _a3 : {};
        clone.push(newItem);
        emit("update:modelValue", clone);
      }
      function cloneOption(event2, index2) {
        if (props.maxItems && props.addable && sortableItems.value.length < props.maxItems || props.maxItems === void 0) {
          const repeaterClone = [...sortableItems.value];
          repeaterClone.splice(index2, 0, event2);
          emit("update:modelValue", repeaterClone);
        }
      }
      function deleteOption(optionIndex) {
        let copiedValues = [...sortableItems.value];
        copiedValues.splice(optionIndex, 1);
        emit("update:modelValue", copiedValues);
      }
      return (_ctx, _cache) => {
        const _component_Button = Vue.resolveComponent("Button");
        const _component_Sortable = Vue.resolveComponent("Sortable");
        return Vue.openBlock(), Vue.createBlock(_component_Sortable, {
          modelValue: Vue.unref(sortableItems),
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => Vue.isRef(sortableItems) ? sortableItems.value = $event : null),
          class: "znpb-option-repeater",
          handle: ".znpb-horizontal-accordion > .znpb-horizontal-accordion__header"
        }, {
          end: Vue.withCtx(() => [
            Vue.unref(showButton) ? (Vue.openBlock(), Vue.createBlock(_component_Button, {
              key: 0,
              class: "znpb-option-repeater__add-button",
              type: "line",
              onClick: addProperty
            }, {
              default: Vue.withCtx(() => [
                Vue.createTextVNode(Vue.toDisplayString(__props.add_button_text), 1)
              ]),
              _: 1
            })) : Vue.createCommentVNode("", true)
          ]),
          default: Vue.withCtx(() => [
            (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList(Vue.unref(sortableItems), (item, index2) => {
              return Vue.openBlock(), Vue.createBlock(_sfc_main$1Q, {
                key: index2,
                ref_for: true,
                ref: "repeaterItem",
                schema: __props.child_options,
                modelValue: item,
                "property-index": index2,
                item_title: __props.item_title,
                default_item_title: __props.default_item_title,
                deletable: !__props.addable ? false : __props.deletable,
                clonable: Vue.unref(checkClonable),
                onCloneOption: ($event) => cloneOption($event, index2),
                onDeleteOption: deleteOption,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => onItemChange($event))
              }, null, 8, ["schema", "modelValue", "property-index", "item_title", "default_item_title", "deletable", "clonable", "onCloneOption"]);
            }), 128))
          ]),
          _: 1
        }, 8, ["modelValue"]);
      };
    }
  }));
  var Loader_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$1q = { class: "znpb-loader-wrapper" };
  const __default__$9 = {
    name: "Loader"
  };
  const _sfc_main$1O = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$9), {
    props: {
      size: { default: 24 }
    },
    setup(__props) {
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$1q, [
          Vue.createElementVNode("div", {
            class: "znpb-loader",
            style: Vue.normalizeStyle({
              height: `${__props.size}px`,
              width: `${__props.size}px`
            })
          }, null, 4)
        ]);
      };
    }
  }));
  var Notice_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$1p = { class: "znpb-notices-wrapper" };
  const _hoisted_2$_ = {
    key: 0,
    class: "znpb-notice__title"
  };
  const _hoisted_3$J = { class: "znpb-notice__message" };
  const __default__$8 = {
    name: "Notice"
  };
  const _sfc_main$1N = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$8), {
    props: {
      error: null
    },
    emits: ["close-notice"],
    setup(__props, { emit }) {
      const props = __props;
      function hideOnEscape(event2) {
        if (event2.key === "Escape") {
          emit("close-notice");
          event2.preventDefault();
          document.removeEventListener("keydown", hideOnEscape);
        }
      }
      Vue.onMounted(() => {
        var _a3;
        const delay = (_a3 = props.error.delayClose) != null ? _a3 : 5e3;
        if (delay !== 0) {
          setTimeout(() => {
            emit("close-notice");
          }, delay);
        }
        document.addEventListener("keydown", hideOnEscape);
      });
      Vue.onBeforeUnmount(() => {
        document.removeEventListener("keydown", hideOnEscape);
      });
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createBlock(Vue.Transition, {
          appear: "",
          name: "move"
        }, {
          default: Vue.withCtx(() => [
            Vue.createElementVNode("div", _hoisted_1$1p, [
              Vue.createElementVNode("div", {
                class: Vue.normalizeClass(["znpb-notice", `znpb-notice--${__props.error.type || "success"}`])
              }, [
                Vue.createVNode(Vue.unref(_sfc_main$34), {
                  class: "znpb-notice__close",
                  icon: "close",
                  size: 12,
                  onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("close-notice"))
                }),
                __props.error.title ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_2$_, Vue.toDisplayString(__props.error.title), 1)) : Vue.createCommentVNode("", true),
                Vue.createElementVNode("div", _hoisted_3$J, Vue.toDisplayString(__props.error.message), 1)
              ], 2)
            ])
          ]),
          _: 1
        });
      };
    }
  }));
  var OptionWrapper_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$1o = {
    key: 0,
    class: "znpb-form__input-title"
  };
  const _hoisted_2$Z = ["innerHTML"];
  const _hoisted_3$I = ["onClick"];
  const _hoisted_4$s = ["onClick"];
  const _hoisted_5$m = { class: "znpb-input-content" };
  const __default__$7 = {
    name: "OptionWrapper"
  };
  const _sfc_main$1M = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$7), {
    props: {
      modelValue: null,
      schema: null,
      optionId: null,
      search_tags: { default: () => [] },
      label: { default: void 0 },
      compilePlaceholder: null,
      width: { default: void 0 },
      allModelValue: { default: () => {
        return {};
      } }
    },
    emits: ["update:modelValue"],
    setup(__props, { emit }) {
      const props = __props;
      const { getOption } = useOptions();
      const {
        deleteValueByPath,
        getTopModelValueByPath,
        updateTopModelValueByPath,
        deleteTopModelValueByPath,
        deleteValues,
        modelValue
      } = Vue.inject("OptionsForm");
      const showChanges = Vue.inject("showChanges");
      const { getSchema } = useOptionsSchemas();
      const { activeResponsiveDeviceInfo: activeResponsiveDeviceInfo2, builtInResponsiveDevices: builtInResponsiveDevices2, setActiveResponsiveDeviceId } = useResponsiveDevices();
      const activePseudo = Vue.ref(null);
      const showDevices = Vue.ref(false);
      const showPseudo = Vue.ref(false);
      const panel = Vue.inject("panel", null);
      const optionTypeConfig = Vue.ref(null);
      const localSchema = Vue.toRef(props, "schema");
      Vue.provide("schema", Vue.readonly(localSchema.value));
      const computedWrapperStyle = Vue.computed(() => {
        const styles = {};
        if (props.schema.grow) {
          styles.flex = props.schema.grow;
        }
        if (props.schema.width) {
          styles.width = `${props.schema.width}%`;
        }
        return styles;
      });
      const computedShowTitle = Vue.computed(() => {
        if (typeof props.schema.show_title !== "undefined") {
          return props.schema.show_title;
        }
        return true;
      });
      const activeResponsiveMedia = Vue.computed(() => {
        return activeResponsiveDeviceInfo2.value.id;
      });
      const compiledSchema = Vue.computed(() => {
        const _a3 = props.schema, {
          description,
          type,
          is_layout: isLayout,
          title,
          search_tags: searchTags,
          id,
          css_class: cssClass
        } = _a3, schema = __objRest(_a3, [
          "description",
          "type",
          "is_layout",
          "title",
          "search_tags",
          "id",
          "css_class"
        ]);
        return __spreadProps(__spreadValues(__spreadValues({}, optionTypeConfig.value.componentProps || {}), schema), {
          hasChanges: !!hasChanges.value
        });
      });
      const savedOptionValue = Vue.computed(() => {
        return props.schema.sync ? getTopModelValueByPath(props.compilePlaceholder(props.schema.sync)) : props.modelValue;
      });
      const hasChanges = Vue.computed(() => {
        if (props.schema.is_layout) {
          const childOptionsIds = getChildOptionsIds(props.schema);
          return childOptionsIds.find((optionId) => {
            let hasDynamicValue = get(props.modelValue, `__dynamic_content__[${optionId}]`);
            return savedOptionValue.value && savedOptionValue.value[optionId] || hasDynamicValue !== void 0;
          });
        } else {
          return typeof savedOptionValue.value !== "undefined" && savedOptionValue.value !== null;
        }
      });
      const optionValue2 = Vue.computed({
        get() {
          let value = typeof savedOptionValue.value !== "undefined" ? savedOptionValue.value : props.schema.default;
          if (props.schema.responsive_options === true) {
            let schemaDefault = props.schema.default;
            if (typeof props.schema.default === "object") {
              schemaDefault = (props.schema.default || {})[activeResponsiveMedia.value];
            }
            if (value && typeof value !== "object") {
              value = {
                default: value
              };
            }
            value = typeof (value || {})[activeResponsiveMedia.value] !== "undefined" ? (value || {})[activeResponsiveMedia.value] : schemaDefault;
          }
          if (Array.isArray(props.schema.pseudo_options)) {
            const activePseudoValue = activePseudo.value || props.schema.pseudo_options[0];
            value = typeof (value || {})[activePseudoValue] !== "undefined" ? (value || {})[activePseudoValue] : void 0;
          }
          return value;
        },
        set(newValue) {
          let valueToUpdate = newValue;
          let newValues = newValue;
          if (Array.isArray(props.schema.pseudo_options)) {
            const activePseudo2 = activePseudo2.value || props.schema.pseudo_options[0];
            let oldValues = props.modelValue;
            if (props.schema.responsive_options === true) {
              oldValues = typeof (props.modelValue || {})[activeResponsiveMedia.value] !== "undefined" ? (props.modelValue || {})[activeResponsiveMedia.value] : void 0;
              newValues = __spreadProps(__spreadValues({}, oldValues), {
                [activePseudo2]: newValue
              });
            } else {
              valueToUpdate = __spreadProps(__spreadValues({}, props.modelValue), {
                [activePseudo2]: newValues
              });
            }
          }
          if (props.schema.responsive_options === true) {
            valueToUpdate = __spreadProps(__spreadValues({}, props.modelValue), {
              [activeResponsiveMedia.value]: newValues
            });
          }
          if (props.schema.sync) {
            const syncValuePath = props.compilePlaceholder(props.schema.sync);
            if (valueToUpdate === null) {
              deleteTopModelValueByPath(syncValuePath);
            } else {
              updateTopModelValueByPath(syncValuePath, valueToUpdate);
            }
            if (panel) {
              panel.addToLocalHistory();
            }
          } else {
            if (valueToUpdate === null) {
              onDeleteOption();
            } else {
              const optionId = props.schema.is_layout ? false : props.optionId;
              emit("update:modelValue", [optionId, valueToUpdate]);
            }
          }
          if (props.schema.on_change) {
            if (props.schema.on_change === "refresh_iframe") {
              const { doAction: doAction2 } = window.zb.hooks;
              doAction2("refreshIframe");
            } else {
              window[props.schema.on_change].apply(null, [newValue]);
            }
          }
        }
      });
      const isValidInput = Vue.computed(() => {
        return optionTypeConfig.value;
      });
      Vue.watchEffect(() => {
        optionTypeConfig.value = Vue.markRaw(getOption(props.schema, optionValue2.value, modelValue.value));
      });
      function openResponsive() {
        showDevices.value = true;
      }
      function closeResponsive() {
        showDevices.value = false;
      }
      function closePseudo() {
        showPseudo.value = false;
      }
      function openPseudo() {
        showPseudo.value = true;
      }
      function activateDevice(device) {
        setActiveResponsiveDeviceId(device.id);
        setTimeout(() => {
          showDevices.value = false;
        }, 50);
      }
      function activatePseudo(selector) {
        activePseudo.value = selector;
        setTimeout(() => {
          showPseudo.value = false;
        }, 50);
      }
      function getPseudoIcon(pseudo) {
        return pseudo === "hover" ? "hover-state" : "default-state";
      }
      function onDeleteOption(optionId) {
        if (props.schema.sync) {
          let fullOptionIds = [];
          const childOptionsIds = getChildOptionsIds(props.schema, false);
          const compiledSync = props.compilePlaceholder(props.schema.sync);
          if (childOptionsIds.length > 0) {
            childOptionsIds.forEach((id) => {
              fullOptionIds.push(`${compiledSync}.${id}`);
            });
          } else {
            fullOptionIds.push(compiledSync);
          }
          deleteValues(fullOptionIds);
          deleteTopModelValueByPath(compiledSync);
        } else {
          if (props.schema.is_layout) {
            const childOptionsIds = getChildOptionsIds(props.schema);
            deleteValues(childOptionsIds);
          } else {
            optionId = optionId || props.optionId;
            deleteValueByPath(optionId);
          }
        }
      }
      function getChildOptionsIds(schema, includeSchemaId = true) {
        let ids = [];
        if (schema.type === "background") {
          const backgroundSchema = getSchema("backgroundImageSchema");
          Object.keys(backgroundSchema).forEach((optionId) => {
            const childIds = getChildOptionsIds(backgroundSchema[optionId]);
            if (childIds) {
              ids = [...ids, ...childIds, "background-color", "background-gradient", "background-video", "background-image"];
            }
          });
        } else if (schema.type === "dimensions" && typeof schema.dimensions === "object") {
          schema.dimensions.forEach((item) => {
            ids.push(item.id);
          });
        } else if (schema.type === "spacing") {
          const spacingPositions = [
            "margin-top",
            "margin-right",
            "margin-bottom",
            "margin-left",
            "padding-top",
            "padding-right",
            "padding-bottom",
            "padding-left"
          ];
          ids.push(...spacingPositions);
        } else if (schema.type === "typography") {
          const typographySchema = getSchema("typography");
          Object.keys(typographySchema).forEach((optionId) => {
            const childIds = getChildOptionsIds(typographySchema[optionId]);
            if (childIds) {
              ids = [...ids, ...childIds];
            }
          });
        } else if (schema.type === "responsive_group") {
          ids.push(activeResponsiveMedia.value);
        } else if (schema.type === "pseudo_group") {
          ids.push(activePseudo.value);
        }
        if (schema.is_layout && schema.child_options) {
          Object.keys(schema.child_options).forEach((optionId) => {
            const childIds = getChildOptionsIds(schema.child_options[optionId]);
            if (childIds) {
              ids = [...ids, ...childIds];
            }
          });
        } else if (includeSchemaId) {
          ids.push(schema.id);
        }
        return ids;
      }
      Vue.provide("inputWrapper", {
        schema: props.schema,
        hasChanges,
        optionId: props.optionId,
        optionTypeConfig
      });
      return (_ctx, _cache) => {
        const _component_Icon = Vue.resolveComponent("Icon");
        const _directive_znpb_tooltip = Vue.resolveDirective("znpb-tooltip");
        return Vue.unref(isValidInput) && (__props.schema.barebone || optionTypeConfig.value.config && optionTypeConfig.value.config.barebone) ? (Vue.openBlock(), Vue.createBlock(Vue.resolveDynamicComponent(optionTypeConfig.value.component), Vue.mergeProps({
          key: 0,
          modelValue: Vue.unref(optionValue2),
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => Vue.isRef(optionValue2) ? optionValue2.value = $event : null)
        }, Vue.unref(compiledSchema), {
          title: __props.schema.title,
          onDiscardChanges: onDeleteOption
        }), {
          default: Vue.withCtx(() => [
            __props.schema.content ? (Vue.openBlock(), Vue.createElementBlock(Vue.Fragment, { key: 0 }, [
              Vue.createTextVNode(Vue.toDisplayString(__props.schema.content), 1)
            ], 64)) : Vue.createCommentVNode("", true)
          ]),
          _: 1
        }, 16, ["modelValue", "title"])) : Vue.unref(isValidInput) ? (Vue.openBlock(), Vue.createElementBlock("div", {
          key: 1,
          class: Vue.normalizeClass(["znpb-input-wrapper", {
            [`znpb-input-type--${__props.schema.type}`]: true,
            [`${__props.schema.css_class}`]: __props.schema.css_class,
            [`znpb-forms-input-wrapper--${__props.schema.layout}`]: __props.schema.layout
          }]),
          style: Vue.normalizeStyle(Vue.unref(computedWrapperStyle))
        }, [
          __props.schema.title && Vue.unref(computedShowTitle) ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$1o, [
            Vue.createElementVNode("span", {
              innerHTML: __props.schema.title
            }, null, 8, _hoisted_2$Z),
            Vue.unref(showChanges) && Vue.unref(hasChanges) ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$2$), {
              key: 0,
              content: _ctx.$translate("discard_changes"),
              onRemoveStyles: onDeleteOption
            }, null, 8, ["content"])) : Vue.createCommentVNode("", true),
            __props.schema.description ? Vue.withDirectives((Vue.openBlock(), Vue.createBlock(_component_Icon, {
              key: 1,
              icon: "question-mark",
              class: "znpb-popper-trigger znpb-popper-trigger--circle"
            }, null, 512)), [
              [_directive_znpb_tooltip, __props.schema.description]
            ]) : Vue.createCommentVNode("", true),
            __props.schema.pseudo_options ? (Vue.openBlock(), Vue.createBlock(Vue.unref(Tooltip), {
              key: 2,
              show: showPseudo.value,
              "close-on-outside-click": true,
              "show-arrows": false,
              "append-to": "element",
              trigger: null,
              onShow: openPseudo,
              onHide: closePseudo
            }, {
              content: Vue.withCtx(() => [
                (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList(__props.schema.pseudo_options, (pseudo_selector, index2) => {
                  return Vue.openBlock(), Vue.createElementBlock("div", {
                    key: index2,
                    class: "znpb-has-pseudo-options__icon-button znpb-options-devices-buttons",
                    onClick: ($event) => activatePseudo(pseudo_selector)
                  }, [
                    Vue.createVNode(_component_Icon, {
                      icon: getPseudoIcon(pseudo_selector)
                    }, null, 8, ["icon"])
                  ], 8, _hoisted_3$I);
                }), 128))
              ]),
              default: Vue.withCtx(() => [
                Vue.createElementVNode("div", {
                  class: "znpb-has-pseudo-options__icon-button znpb-options-devices-buttons znpb-has-responsive-options__icon-button--trigger",
                  onClick: _cache[1] || (_cache[1] = ($event) => showPseudo.value = !showPseudo.value)
                }, [
                  Vue.createVNode(_component_Icon, {
                    icon: getPseudoIcon(activePseudo.value)
                  }, null, 8, ["icon"])
                ])
              ]),
              _: 1
            }, 8, ["show"])) : Vue.createCommentVNode("", true),
            __props.schema.responsive_options || __props.schema.show_responsive_buttons ? (Vue.openBlock(), Vue.createBlock(Vue.unref(Tooltip), {
              key: 3,
              show: showDevices.value,
              "show-arrows": false,
              "append-to": "element",
              trigger: null,
              placement: "bottom",
              "tooltip-class": "znpb-has-responsive-options",
              "close-on-outside-click": true,
              onShow: openResponsive,
              onHide: closeResponsive
            }, {
              content: Vue.withCtx(() => [
                (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList(Vue.unref(builtInResponsiveDevices2), (device, index2) => {
                  return Vue.openBlock(), Vue.createElementBlock("div", {
                    key: index2,
                    ref_for: true,
                    ref: "dropdown",
                    class: "znpb-options-devices-buttons znpb-has-responsive-options__icon-button",
                    onClick: ($event) => activateDevice(device)
                  }, [
                    Vue.createVNode(_component_Icon, {
                      icon: device.icon
                    }, null, 8, ["icon"])
                  ], 8, _hoisted_4$s);
                }), 128))
              ]),
              default: Vue.withCtx(() => [
                Vue.createElementVNode("div", {
                  class: "znpb-has-responsive-options__icon-button--trigger",
                  onClick: _cache[2] || (_cache[2] = ($event) => showDevices.value = !showDevices.value)
                }, [
                  Vue.createVNode(_component_Icon, {
                    icon: Vue.unref(activeResponsiveDeviceInfo2).icon
                  }, null, 8, ["icon"])
                ])
              ]),
              _: 1
            }, 8, ["show"])) : Vue.createCommentVNode("", true),
            Vue.createVNode(Vue.unref(_sfc_main$2l), {
              location: "input_wrapper/end",
              class: "znpb-options-injection--after-title"
            })
          ])) : Vue.createCommentVNode("", true),
          Vue.createElementVNode("div", _hoisted_5$m, [
            __props.schema.itemIcon ? (Vue.openBlock(), Vue.createBlock(_component_Icon, {
              key: 0,
              icon: __props.schema.itemIcon
            }, null, 8, ["icon"])) : Vue.createCommentVNode("", true),
            __props.schema.label || __props.schema["label-icon"] ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$2W), {
              key: 1,
              label: __props.schema.label,
              align: __props.schema["label-align"],
              position: __props.schema["label-position"],
              title: __props.schema["label-title"],
              icon: __props.schema["label-icon"]
            }, {
              default: Vue.withCtx(() => [
                (Vue.openBlock(), Vue.createBlock(Vue.resolveDynamicComponent(optionTypeConfig.value.component), Vue.mergeProps({
                  modelValue: Vue.unref(optionValue2),
                  "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => Vue.isRef(optionValue2) ? optionValue2.value = $event : null)
                }, Vue.unref(compiledSchema)), {
                  default: Vue.withCtx(() => [
                    __props.schema.content ? (Vue.openBlock(), Vue.createElementBlock(Vue.Fragment, { key: 0 }, [
                      Vue.createTextVNode(Vue.toDisplayString(__props.schema.content), 1)
                    ], 64)) : Vue.createCommentVNode("", true)
                  ]),
                  _: 1
                }, 16, ["modelValue"]))
              ]),
              _: 1
            }, 8, ["label", "align", "position", "title", "icon"])) : (Vue.openBlock(), Vue.createBlock(Vue.resolveDynamicComponent(optionTypeConfig.value.component), Vue.mergeProps({
              key: 2,
              modelValue: Vue.unref(optionValue2),
              "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => Vue.isRef(optionValue2) ? optionValue2.value = $event : null)
            }, Vue.unref(compiledSchema)), {
              default: Vue.withCtx(() => [
                __props.schema.content ? (Vue.openBlock(), Vue.createElementBlock(Vue.Fragment, { key: 0 }, [
                  Vue.createTextVNode(Vue.toDisplayString(__props.schema.content), 1)
                ], 64)) : Vue.createCommentVNode("", true)
              ]),
              _: 1
            }, 16, ["modelValue"]))
          ])
        ], 6)) : Vue.createCommentVNode("", true);
      };
    }
  }));
  var OptionsForm_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$1L = {
    name: "OptionsForm",
    components: {
      OptionWrapper: _sfc_main$1M
    },
    provide() {
      return {
        showChanges: this.showChanges,
        optionsForm: this
      };
    },
    props: {
      modelValue: {},
      schema: {
        type: Object,
        required: true
      },
      showChanges: {
        required: false,
        default: true
      },
      replacements: {
        type: Array,
        required: false,
        default: () => []
      }
    },
    setup(props, { emit }) {
      let topModelValue = Vue.inject("OptionsFormTopModelValue", null);
      if (null === topModelValue) {
        topModelValue = Vue.computed(() => props.modelValue);
        Vue.provide("OptionsFormTopModelValue", () => topModelValue);
      }
      const { activeResponsiveDeviceInfo: activeResponsiveDeviceInfo2 } = useResponsiveDevices();
      const { activePseudoSelector: activePseudoSelector2 } = usePseudoSelectors();
      function updateTopModelValueByPath(path, newValue) {
        set(topModelValue.value, path, newValue);
      }
      function deleteTopModelValueByPath(path) {
        unset(topModelValue.value, path);
        deleteNested(path, topModelValue.value);
      }
      function getTopModelValueByPath(path, defaultValue = null) {
        return get(topModelValue.value, path, defaultValue);
      }
      const getValueByPath = (path, defaultValue = null) => {
        return get(props.modelValue, path, defaultValue);
      };
      const updateValueByPath = (path, newValue) => {
        const clonedValue = cloneDeep(props.modelValue);
        set(clonedValue, path, newValue);
        emit("update:modelValue", clonedValue);
      };
      function deleteNestedEmptyObjects(paths, object) {
        paths.forEach((path) => {
          const remainingPaths = paths.slice(1, paths.length);
          if (typeof object[path] === "object") {
            object[path] = deleteNestedEmptyObjects(remainingPaths, object[path]);
            if (Object.keys(object[path]).length === 0) {
              delete object[path];
            }
          }
        });
        return object;
      }
      function deleteNested(path, model) {
        const paths = path.split(".");
        paths.pop();
        deleteNestedEmptyObjects(paths, model);
      }
      const deleteValueByPath = (path) => {
        const clonedValue = cloneDeep(props.modelValue);
        unset(clonedValue, path);
        deleteNested(path, clonedValue);
        if (Object.keys(clonedValue).length > 0) {
          emit("update:modelValue", clonedValue);
        } else {
          emit("update:modelValue", null);
        }
      };
      function deleteValues(allPaths) {
        let newValues = __spreadValues({}, props.modelValue);
        allPaths.forEach((path) => {
          const paths = path.split(".");
          paths.reduce((acc, key, index2) => {
            if (index2 === paths.length - 1) {
              let dynamicValue = get(acc, `__dynamic_content__[${key}]`);
              dynamicValue !== void 0 ? delete acc.__dynamic_content__ : delete acc[key];
              return true;
            }
            acc[key] = acc[key] ? __spreadValues({}, acc[key]) : {};
            return acc[key];
          }, newValues);
        });
        if (Object.keys(newValues).length > 0) {
          emit("update:modelValue", newValues);
        } else {
          emit("update:modelValue", null);
        }
      }
      Vue.provide("OptionsForm", {
        getValueByPath,
        updateValueByPath,
        deleteValueByPath,
        getTopModelValueByPath,
        updateTopModelValueByPath,
        deleteTopModelValueByPath,
        modelValue: Vue.computed(() => props.modelValue),
        deleteValues
      });
      const topOptionsForm = Vue.inject("topOptionsForm", null);
      if (!topOptionsForm) {
        Vue.provide(topOptionsForm, props.modelValue);
      }
      Vue.provide("updateValueByPath", updateValueByPath);
      Vue.provide("getValueByPath", getValueByPath);
      Vue.provide("deleteValueByPath", deleteValueByPath);
      return {
        activeResponsiveDeviceInfo: activeResponsiveDeviceInfo2,
        updateValueByPath,
        getValueByPath,
        activePseudoSelector: activePseudoSelector2,
        deleteValues,
        getTopModelValueByPath
      };
    },
    computed: {
      optionsSchema() {
        const schema = {};
        Object.keys(this.schema).forEach((optionId) => {
          const optionConfig = this.getProperSchema(this.schema[optionId]);
          const { dependency } = optionConfig;
          if (!dependency) {
            schema[optionId] = optionConfig;
            return;
          }
          let conditionsMet = true;
          dependency.forEach((element) => {
            const { option, value, type, option_path: optionPath } = element;
            let optionSchema;
            let savedValue;
            if (optionPath) {
              optionSchema = this.getOptionSchemaFromPath(optionPath);
            } else {
              optionSchema = this.getOptionConfigFromId(option);
            }
            if (optionPath) {
              const defaultValue = optionSchema ? optionSchema.default : false;
              savedValue = this.getTopModelValueByPath(optionPath, defaultValue);
            } else {
              savedValue = typeof this.modelValue[option] !== "undefined" ? this.modelValue[option] : optionSchema.default;
              if (optionSchema.sync) {
                const syncValue = this.compilePlaceholder(optionSchema.sync);
                savedValue = this.getTopModelValueByPath(syncValue, savedValue);
              }
            }
            const validationType = type || "includes";
            if (conditionsMet && validationType === "includes" && value.includes(savedValue)) {
              conditionsMet = true;
            } else if (conditionsMet && validationType === "not_in" && !value.includes(savedValue)) {
              conditionsMet = true;
            } else if (conditionsMet && validationType === "value_set" && typeof savedValue !== "undefined") {
              conditionsMet = true;
            } else {
              conditionsMet = false;
            }
          });
          if (conditionsMet) {
            schema[optionId] = optionConfig;
          }
        });
        return schema;
      }
    },
    methods: {
      updateModelValueByPath(path, newValue) {
        const clonedValue = cloneDeep(this.modelValue || {});
        const newValues = set(clonedValue, path, newValue);
        this.$emit("update:modelValue", newValues);
      },
      setValue(optionId, newValue) {
        if (optionId) {
          if (newValue === null) {
            const clonedValue = __spreadValues({}, this.modelValue);
            delete clonedValue[optionId];
            if (Object.keys(clonedValue).length === 0) {
              this.$emit("update:modelValue", null);
            } else {
              this.$emit("update:modelValue", clonedValue);
            }
          } else {
            this.$emit("update:modelValue", __spreadProps(__spreadValues({}, this.modelValue), {
              [optionId]: newValue
            }));
          }
        } else {
          if (newValue === null || Object.keys(newValue).length === 0) {
            this.$emit("update:modelValue", null);
          } else {
            let clonedValue = __spreadValues({}, this.modelValue);
            Object.keys(clonedValue).reduce((acc, key, index2) => {
              if (typeof newValue[key] === "undefined") {
                delete acc[key];
              }
              return acc;
            }, clonedValue);
            this.$emit("update:modelValue", __spreadValues(__spreadValues({}, clonedValue), newValue));
          }
        }
      },
      getValue(optionSchema) {
        if (optionSchema.is_layout) {
          return this.modelValue;
        } else {
          return this.modelValue[optionSchema.id];
        }
      },
      getOptionConfigFromId(optionId) {
        if (this.schema[optionId] && !this.schema[optionId].is_layout) {
          return this.schema[optionId];
        } else {
          return this.findOptionConfig(this.schema, optionId);
        }
      },
      findOptionConfig(schema, searchId) {
        let optionConfig;
        for (let [optionId, optionConfig2] of Object.entries(schema)) {
          if (optionConfig2.is_layout && optionConfig2.child_options) {
            optionConfig2 = this.findOptionConfig(optionConfig2.child_options, searchId);
          }
          if (optionConfig2 && optionConfig2.id === searchId) {
            return optionConfig2;
          }
        }
        return optionConfig;
      },
      getOptionSchemaFromPath(optionPath) {
        const pathArray = optionPath.split(".");
        return pathArray.reduce((acc, path, index2) => {
          if (acc[path]) {
            return acc[path];
          } else {
            return false;
          }
        }, this.schema);
      },
      onOptionChange(changed) {
        this.$emit("change", changed);
      },
      getProperSchema(schema) {
        const dataSetsStore = useDataSetsStore();
        if (typeof schema.data_source !== "undefined") {
          if (schema.data_source === "fonts") {
            schema.options = dataSetsStore.fontsListForOption;
            delete schema.data_source;
          } else if (schema.data_source === "taxonomies") {
            schema.options = dataSetsStore.dataSets.taxonomies;
            delete schema.data_source;
          }
        }
        if (schema.type === "textarea") {
          schema.type = "textarea";
        }
        schema = this.compilePlaceholders(schema);
        return schema;
      },
      isIterable(schema) {
        return Array.isArray(schema) || schema === Object(schema) && typeof schema !== "function";
      },
      compilePlaceholders(schema) {
        if (!this.isIterable(schema)) {
          return this.compilePlaceholder(schema);
        } else {
          for (const prop in schema) {
            if (prop !== "sync") {
              if (schema.hasOwnProperty(prop)) {
                schema[prop] = this.compilePlaceholders(schema[prop]);
              }
            }
          }
        }
        return schema;
      },
      compilePlaceholder(value) {
        if (typeof value !== "string") {
          return value;
        }
        const replacements = [
          {
            search: /%%RESPONSIVE_DEVICE%%/g,
            replacement: this.replaceResponsiveDevice
          },
          {
            search: /%%PSEUDO_SELECTOR%%/g,
            replacement: this.replacePseudoSelector
          },
          ...this.replacements
        ];
        replacements.forEach((replacementConfig) => {
          value = value.replace(replacementConfig.search, replacementConfig.replacement);
        });
        return value;
      },
      replaceResponsiveDevice(match) {
        return this.activeResponsiveDeviceInfo.id;
      },
      replacePseudoSelector(match) {
        return this.activePseudoSelector.id;
      }
    }
  };
  const _hoisted_1$1n = { class: "znpb-options-form-wrapper" };
  const _hoisted_2$Y = {
    key: 0,
    class: "znpb-options-breadcrumbs-path znpb-options-breadcrumbs-path--search"
  };
  const _hoisted_3$H = ["innerHTML"];
  const _hoisted_4$r = ["innerHTML"];
  function _sfc_render$10(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Icon = Vue.resolveComponent("Icon");
    const _component_OptionWrapper = Vue.resolveComponent("OptionWrapper");
    return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$1n, [
      (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList($options.optionsSchema, (optionConfig, optionId) => {
        return Vue.openBlock(), Vue.createElementBlock(Vue.Fragment, { key: optionId }, [
          optionConfig.breadcrumbs ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_2$Y, [
            (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList(optionConfig.breadcrumbs, (breadcrumb, i) => {
              return Vue.openBlock(), Vue.createElementBlock("div", {
                key: i,
                class: "znpb-options-breadcrumbs-path"
              }, [
                Vue.createElementVNode("span", {
                  innerHTML: optionConfig.breadcrumbs[i]
                }, null, 8, _hoisted_3$H),
                i <= optionConfig.breadcrumbs.length ? (Vue.openBlock(), Vue.createBlock(_component_Icon, {
                  key: 0,
                  icon: "select",
                  class: "znpb-options-breadcrumbs-path-icon"
                })) : Vue.createCommentVNode("", true)
              ]);
            }), 128)),
            Vue.createElementVNode("span", {
              innerHTML: optionConfig.title
            }, null, 8, _hoisted_4$r)
          ])) : Vue.createCommentVNode("", true),
          Vue.createVNode(_component_OptionWrapper, {
            schema: optionConfig,
            "option-id": optionId,
            modelValue: optionConfig.is_layout ? $props.modelValue : $props.modelValue[optionId],
            "compile-placeholder": $options.compilePlaceholder,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $options.setValue(...$event)),
            onChange: $options.onOptionChange
          }, null, 8, ["schema", "option-id", "modelValue", "compile-placeholder", "onChange"])
        ], 64);
      }), 128))
    ]);
  }
  var OptionsForm = /* @__PURE__ */ _export_sfc(_sfc_main$1L, [["render", _sfc_render$10]]);
  var Menu_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$1m = { class: "znpb-menu" };
  const _hoisted_2$X = ["onClick"];
  const _hoisted_3$G = { class: "znpb-menu-itemTitle" };
  const _hoisted_4$q = {
    key: 1,
    class: "znpb-menu-itemAppend"
  };
  const __default__$6 = {
    name: "Menu"
  };
  const _sfc_main$1K = Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$6), {
    props: {
      actions: null
    },
    emits: ["action"],
    setup(__props, { emit }) {
      const props = __props;
      function performAction(action) {
        action.action();
        emit("action");
      }
      const availableActions = Vue.computed(() => {
        return props.actions.filter((action) => action.disabled !== false);
      });
      return (_ctx, _cache) => {
        const _component_Icon = Vue.resolveComponent("Icon");
        return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$1m, [
          (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList(Vue.unref(availableActions), (action) => {
            return Vue.openBlock(), Vue.createElementBlock("div", {
              key: action.title,
              class: Vue.normalizeClass(["znpb-menu-item", [{ "znpb-menu-item--disabled": action.show === false }, action.cssClasses]]),
              onClick: Vue.withModifiers(($event) => performAction(action), ["stop"])
            }, [
              action.icon ? (Vue.openBlock(), Vue.createBlock(_component_Icon, {
                key: 0,
                class: "znpb-menu-itemIcon",
                icon: action.icon
              }, null, 8, ["icon"])) : Vue.createCommentVNode("", true),
              Vue.createElementVNode("span", _hoisted_3$G, Vue.toDisplayString(action.title), 1),
              action.append ? (Vue.openBlock(), Vue.createElementBlock("span", _hoisted_4$q, Vue.toDisplayString(action.append), 1)) : Vue.createCommentVNode("", true)
            ], 10, _hoisted_2$X);
          }), 128))
        ]);
      };
    }
  }));
  const __default__$5 = {
    name: "HiddenMenu"
  };
  const _sfc_main$1J = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$5), {
    props: {
      actions: null
    },
    setup(__props) {
      const expanded = Vue.ref(false);
      return (_ctx, _cache) => {
        const _component_Icon = Vue.resolveComponent("Icon");
        const _component_Tooltip = Vue.resolveComponent("Tooltip");
        return Vue.openBlock(), Vue.createBlock(_component_Tooltip, {
          show: expanded.value,
          "onUpdate:show": _cache[2] || (_cache[2] = ($event) => expanded.value = $event),
          "tooltip-class": "hg-popper--no-padding",
          trigger: "null",
          placement: "right",
          "close-on-outside-click": true,
          "close-on-escape": true,
          class: "znpb-hiddenMenuWrapper"
        }, {
          content: Vue.withCtx(() => [
            Vue.createVNode(_sfc_main$1K, {
              actions: __props.actions,
              onAction: _cache[0] || (_cache[0] = ($event) => expanded.value = !expanded.value)
            }, null, 8, ["actions"])
          ]),
          default: Vue.withCtx(() => [
            Vue.createVNode(_component_Icon, {
              icon: "more",
              "bg-size": 14,
              onClick: _cache[1] || (_cache[1] = Vue.withModifiers(($event) => expanded.value = !expanded.value, ["stop"]))
            })
          ]),
          _: 1
        }, 8, ["show"]);
      };
    }
  }));
  var clickOutside = {
    install(app) {
      app.directive("click-outside", this);
    },
    beforeMount: function(el, binding, vNode) {
      const clickOutsideHandler = (event2) => {
        if (!el.contains(event2.target)) {
          binding.value.call(event2);
        }
      };
      el.__CLICK_OUTSIDE_HANDLER = clickOutsideHandler;
      document.addEventListener("contextmenu", el.__CLICK_OUTSIDE_HANDLER, true);
      document.addEventListener("click", el.__CLICK_OUTSIDE_HANDLER, true);
      document.addEventListener("touchstart", el.__CLICK_OUTSIDE_HANDLER, true);
    },
    beforeUnmount: function(el) {
      document.removeEventListener("click", el.__CLICK_OUTSIDE_HANDLER, true);
      document.removeEventListener("touchstart", el.__CLICK_OUTSIDE_HANDLER, true);
      document.removeEventListener("contextmenu", el.__CLICK_OUTSIDE_HANDLER, true);
      el.__CLICK_OUTSIDE_HANDLER = null;
    }
  };
  var InputSpacing_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$1l = { class: "znpb-optSpacing" };
  const _hoisted_2$W = ["onMouseenter", "onMousedown"];
  const _hoisted_3$F = { class: "znpb-optSpacing-labelWrapper" };
  const _hoisted_4$p = { class: "znpb-optSpacing-label" };
  const _hoisted_5$l = { class: "znpb-optSpacing-svg" };
  const _hoisted_6$g = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 320 186"
  };
  const _hoisted_7$c = ["cursor", "d", "onMouseenter", "onMousedown"];
  const _hoisted_8$9 = ["onMouseenter", "onMousedown"];
  const _hoisted_9$8 = { class: "znpb-optSpacing-labelWrapper" };
  const _hoisted_10$7 = { class: "znpb-optSpacing-label" };
  const _hoisted_11$6 = { class: "znpb-optSpacing-svg" };
  const _hoisted_12$5 = {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 214 108"
  };
  const _hoisted_13$4 = ["cursor", "d", "onMouseenter", "onMousedown"];
  const _hoisted_14$2 = {
    key: 0,
    class: "znpb-optSpacing-info"
  };
  const __default__$4 = {
    name: "InputSpacing",
    directives: {
      clickOutside
    }
  };
  const _sfc_main$1I = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$4), {
    props: {
      modelValue: { default: () => {
        return {};
      } },
      placeholder: { default: () => {
        return {};
      } }
    },
    emits: ["update:modelValue"],
    setup(__props, { emit }) {
      const props = __props;
      const marginPositionId = [
        {
          position: "margin-top",
          type: "margin",
          title: translate("margin-top"),
          svg: {
            cursor: "n-resize",
            d: "M0 0h320l-50 36H50L0 0Z"
          },
          dragDirection: "vertical"
        },
        {
          position: "margin-right",
          type: "margin",
          title: translate("margin-right"),
          svg: {
            cursor: "e-resize",
            d: "m320 183-50-36V39l50-36v180Z"
          },
          dragDirection: "horizontal"
        },
        {
          position: "margin-bottom",
          type: "margin",
          title: translate("margin-bottom"),
          svg: {
            cursor: "s-resize",
            d: "M50 150h220l50 36H0l50-36Z"
          },
          dragDirection: "vertical"
        },
        {
          position: "margin-left",
          type: "margin",
          title: translate("margin-left"),
          svg: {
            cursor: "w-resize",
            d: "m0 3 50 36v108L0 183V3Z"
          },
          dragDirection: "horizontal"
        }
      ];
      const paddingPositionId = [
        {
          position: "padding-top",
          type: "padding",
          title: translate("padding-top"),
          svg: {
            cursor: "n-resize",
            d: "M0 0h214l-50 36H50L0 0Z"
          },
          dragDirection: "vertical"
        },
        {
          position: "padding-right",
          type: "padding",
          title: translate("padding-right"),
          svg: {
            cursor: "e-resize",
            d: "m214 105-50-36V39l50-36v102Z"
          },
          dragDirection: "horizontal"
        },
        {
          position: "padding-bottom",
          type: "padding",
          title: translate("padding-bottom"),
          svg: {
            cursor: "s-resize",
            d: "M214 108H0l50-36h114l50 36Z"
          },
          dragDirection: "vertical"
        },
        {
          position: "padding-left",
          type: "padding",
          title: translate("padding-left"),
          svg: {
            cursor: "w-resize",
            d: "m0 3 50 36v30L0 105V3Z"
          },
          dragDirection: "horizontal"
        }
      ];
      const allowedValues = [...marginPositionId, ...paddingPositionId].map((position) => position.position);
      const activeHover = Vue.ref(null);
      const lastChanged = Vue.ref(null);
      Vue.ref(null);
      function onDiscardChanges(position) {
        const clonedModelValue = __spreadValues({}, props.modelValue);
        delete clonedModelValue[position];
        emit("update:modelValue", clonedModelValue);
      }
      const computedValues = Vue.computed({
        get() {
          const values = {};
          Object.keys(props.modelValue).forEach((optionId) => {
            if (allowedValues.includes(optionId)) {
              values[optionId] = props.modelValue[optionId];
            }
          });
          return values;
        },
        set(newValues) {
          emit("update:modelValue", newValues);
        }
      });
      function onValueUpdated(sizePosition, type, newValue) {
        const isLinked2 = type === "margin" ? linkedMargin : linkedPadding;
        lastChanged.value = {
          position: sizePosition,
          type
        };
        if (isLinked2.value) {
          const valuesToUpdate = type === "margin" ? marginPositionId : paddingPositionId;
          const updatedValues = {};
          valuesToUpdate.forEach((position) => updatedValues[position.position] = newValue);
          computedValues.value = __spreadValues(__spreadValues({}, props.modelValue), updatedValues);
        } else {
          computedValues.value = __spreadProps(__spreadValues({}, props.modelValue), {
            [sizePosition]: newValue
          });
        }
      }
      const linkedMargin = Vue.ref(isLinked("margin"));
      const linkedPadding = Vue.ref(isLinked("padding"));
      function linkValues(type) {
        const valueToChange = type === "margin" ? linkedMargin : linkedPadding;
        valueToChange.value = !valueToChange.value;
        if (valueToChange.value) {
          if (lastChanged.value && lastChanged.value.type === type) {
            onValueUpdated(lastChanged.value.position, type, computedValues.value[lastChanged.value.position]);
          } else {
            const valuesToCheck = type === "margin" ? marginPositionId : paddingPositionId;
            const savedValueConfig = valuesToCheck.find(
              (positionConfig) => computedValues.value[positionConfig.position] !== "undefined"
            );
            if (savedValueConfig) {
              onValueUpdated(savedValueConfig.position, type, computedValues.value[savedValueConfig.position]);
            }
          }
        }
      }
      function isLinked(type) {
        const valuesToCheck = type === "margin" ? marginPositionId : paddingPositionId;
        return valuesToCheck.every((position) => {
          return computedValues.value[position.position] && computedValues.value[position.position] === computedValues.value[`${type}-top`];
        });
      }
      let startMousePosition;
      let dragDirection;
      let initialValue;
      let draggingConfig;
      const dragThreshold = 0;
      const validUnits = [
        {
          type: "px",
          isModifiable: true
        },
        {
          type: "%",
          isModifiable: true
        },
        {
          type: "vw",
          isModifiable: true
        },
        {
          type: "vh",
          isModifiable: true
        },
        {
          type: "rem",
          isModifiable: true
        },
        {
          type: "em",
          isModifiable: true
        },
        {
          type: "pt",
          isModifiable: true
        },
        {
          type: "auto",
          isModifiable: false
        },
        {
          type: "initial",
          isModifiable: false
        },
        {
          type: "unset",
          isModifiable: false
        }
      ];
      const isDragging = Vue.ref(false);
      function startDragging(event2, positionConfig) {
        const { clientY, clientX } = event2;
        startMousePosition = {
          clientY,
          clientX
        };
        dragDirection = positionConfig.dragDirection;
        const { position, type } = positionConfig;
        document.body.style.userSelect = "none";
        initialValue = getSplitValue(position);
        const unit = initialValue && initialValue.unit;
        const validUnit = validUnits.find((singleUnit) => singleUnit.type === unit);
        if (validUnit && validUnit.isModifiable) {
          const linkType = type === "margin" ? linkedMargin : linkedPadding;
          draggingConfig = {
            positionConfig,
            position,
            type,
            initialValue,
            activeLinkStatus: linkType.value,
            activeLinkComputedValue: linkType
          };
          window.addEventListener("mousemove", rafDragValue);
          window.addEventListener("mouseup", rafDeactivateDragging);
          window.addEventListener("keydown", onKeyDown);
          window.addEventListener("keyup", onKeyUp);
        }
      }
      function getSplitValue(position) {
        const savedValue = computedValues.value[position] ? computedValues.value[position] : "0px";
        const splitValue = savedValue.match(/^([+-]?(?:\d+|\d*\.\d+))([a-z]*|%)$/);
        if (!splitValue) {
          return null;
        }
        return {
          value: parseInt(splitValue[1]),
          unit: splitValue[2]
        };
      }
      function onKeyDown(event2) {
        if (isDragging.value) {
          const { activeLinkStatus, activeLinkComputedValue } = draggingConfig;
          if (!activeLinkStatus && event2.ctrlKey) {
            activeLinkComputedValue.value = true;
          } else {
            activeLinkComputedValue.value = activeLinkStatus;
          }
        }
      }
      function onKeyUp(event2) {
        if (isDragging.value) {
          const { activeLinkComputedValue } = draggingConfig;
          if (event2.ctrlKey) {
            activeLinkComputedValue.value = false;
          }
        }
      }
      function deactivateDragging() {
        document.body.style.userSelect = "";
        document.body.style.pointerEvents = "";
        rafDragValue.cancel();
        window.removeEventListener("mousemove", rafDragValue);
        window.removeEventListener("mouseup", rafDeactivateDragging);
        isDragging.value = false;
        startMousePosition = null;
        initialValue = null;
        draggingConfig = null;
      }
      function dragValue(event2) {
        const { clientX, clientY } = event2;
        document.body.style.pointerEvents = "none";
        const movedAmount = dragDirection === "vertical" ? Math.ceil(startMousePosition.clientY - clientY) : Math.ceil(startMousePosition.clientX - clientX) * -1;
        if (Math.abs(movedAmount) > dragThreshold) {
          const positionConfig = draggingConfig ? draggingConfig.positionConfig : null;
          isDragging.value = true;
          activeHover.value = positionConfig;
          setDraggingValue(movedAmount - dragThreshold, event2);
        }
      }
      function setDraggingValue(newValue, event2) {
        const { position, type, initialValue: initialValue2 } = draggingConfig;
        if (!initialValue2)
          return;
        const { value, unit } = initialValue2;
        let updatedValue = newValue + value;
        if (event2.shiftKey) {
          updatedValue = Math.round(updatedValue / 5) * 5;
        }
        const valueToUpdate = `${updatedValue}${unit}`;
        onValueUpdated(position, type, valueToUpdate);
      }
      const rafDragValue = rafSchd$1(dragValue);
      const rafDeactivateDragging = rafSchd$1(deactivateDragging);
      return (_ctx, _cache) => {
        const _component_ChangesBullet = Vue.resolveComponent("ChangesBullet");
        const _component_Icon = Vue.resolveComponent("Icon");
        return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$1l, [
          Vue.createElementVNode("div", {
            class: Vue.normalizeClass(["znpb-optSpacing-margin", {
              "znpb-optSpacing--linked": linkedMargin.value,
              "znpb-optSpacing--hover": activeHover.value && activeHover.value.position.includes("margin"),
              [`znpb-optSpacing--hover-${activeHover.value ? activeHover.value.position : ""}`]: activeHover.value
            }])
          }, [
            (Vue.openBlock(), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList(marginPositionId, (position) => {
              return Vue.createElementVNode("div", {
                key: position.position,
                class: Vue.normalizeClass([{
                  [`znpb-optSpacing-${position.position}`]: true
                }, "znpb-optSpacing-value znpb-optSpacing-value--margin"]),
                onMouseenter: ($event) => activeHover.value = position,
                onMouseleave: _cache[0] || (_cache[0] = ($event) => activeHover.value = null),
                onMousedown: ($event) => startDragging($event, position)
              }, [
                Vue.createVNode(Vue.unref(_sfc_main$2X), {
                  "model-value": Vue.unref(computedValues)[position.position],
                  units: ["px", "rem", "pt", "vh", "%"],
                  step: 1,
                  "default-unit": "px",
                  placeholder: __props.placeholder && typeof __props.placeholder[position.position] !== "undefined" ? __props.placeholder[position.position] : "-",
                  "onUpdate:modelValue": ($event) => onValueUpdated(position.position, "margin", $event)
                }, null, 8, ["model-value", "placeholder", "onUpdate:modelValue"]),
                Vue.unref(computedValues)[position.position] ? (Vue.openBlock(), Vue.createBlock(_component_ChangesBullet, {
                  key: 0,
                  content: Vue.unref(translate)("discard_changes"),
                  onRemoveStyles: ($event) => onDiscardChanges(position.position)
                }, null, 8, ["content", "onRemoveStyles"])) : Vue.createCommentVNode("", true)
              ], 42, _hoisted_2$W);
            }), 64)),
            Vue.createElementVNode("div", _hoisted_3$F, [
              Vue.createElementVNode("span", _hoisted_4$p, Vue.toDisplayString(Vue.unref(translate)("margin")), 1),
              Vue.createVNode(_component_Icon, {
                icon: linkedMargin.value ? "link" : "unlink",
                title: linkedMargin.value ? Vue.unref(translate)("unlink") : Vue.unref(translate)("link"),
                size: 12,
                class: Vue.normalizeClass(["znpb-optSpacing-link", {
                  "znpb-optSpacing-link--linked": linkedMargin.value
                }]),
                onClick: _cache[1] || (_cache[1] = ($event) => linkValues("margin"))
              }, null, 8, ["icon", "title", "class"])
            ]),
            Vue.createElementVNode("div", _hoisted_5$l, [
              (Vue.openBlock(), Vue.createElementBlock("svg", _hoisted_6$g, [
                (Vue.openBlock(), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList(marginPositionId, (position) => {
                  return Vue.createElementVNode("path", {
                    key: position.position,
                    cursor: position.svg.cursor,
                    d: position.svg.d,
                    class: Vue.normalizeClass({
                      [`znpb-optSpacing--path-${position.position}`]: true
                    }),
                    onMouseenter: ($event) => activeHover.value = position,
                    onMouseleave: _cache[2] || (_cache[2] = ($event) => activeHover.value = null),
                    onMousedown: ($event) => startDragging($event, position)
                  }, null, 42, _hoisted_7$c);
                }), 64))
              ]))
            ])
          ], 2),
          Vue.createElementVNode("div", {
            class: Vue.normalizeClass(["znpb-optSpacing-padding", {
              "znpb-optSpacing--linked": linkedPadding.value,
              "znpb-optSpacing--hover": activeHover.value && activeHover.value.position.includes("padding"),
              [`znpb-optSpacing--hover-${activeHover.value ? activeHover.value.position : ""}`]: activeHover.value
            }])
          }, [
            (Vue.openBlock(), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList(paddingPositionId, (position) => {
              return Vue.createElementVNode("div", {
                key: position.position,
                class: Vue.normalizeClass([{
                  [`znpb-optSpacing-${position.position}`]: true
                }, "znpb-optSpacing-value znpb-optSpacing-value--padding"]),
                onMouseenter: ($event) => activeHover.value = position,
                onMouseleave: _cache[3] || (_cache[3] = ($event) => activeHover.value = null),
                onMousedown: ($event) => startDragging($event, position)
              }, [
                Vue.createVNode(Vue.unref(_sfc_main$2X), {
                  "model-value": Vue.unref(computedValues)[position.position],
                  units: ["px", "rem", "pt", "vh", "%"],
                  step: 1,
                  "default-unit": "px",
                  min: 0,
                  placeholder: __props.placeholder && typeof __props.placeholder[position.position] !== "undefined" ? __props.placeholder[position.position] : "-",
                  "onUpdate:modelValue": ($event) => onValueUpdated(position.position, "padding", $event)
                }, null, 8, ["model-value", "placeholder", "onUpdate:modelValue"]),
                Vue.unref(computedValues)[position.position] ? (Vue.openBlock(), Vue.createBlock(_component_ChangesBullet, {
                  key: 0,
                  content: Vue.unref(translate)("discard_changes"),
                  onRemoveStyles: ($event) => onDiscardChanges(position.position)
                }, null, 8, ["content", "onRemoveStyles"])) : Vue.createCommentVNode("", true)
              ], 42, _hoisted_8$9);
            }), 64)),
            Vue.createElementVNode("div", _hoisted_9$8, [
              Vue.createElementVNode("span", _hoisted_10$7, Vue.toDisplayString(Vue.unref(translate)("padding")), 1),
              Vue.createVNode(_component_Icon, {
                icon: linkedPadding.value ? "link" : "unlink",
                title: linkedPadding.value ? Vue.unref(translate)("unlink") : Vue.unref(translate)("link"),
                size: 12,
                class: Vue.normalizeClass(["znpb-optSpacing-link", {
                  "znpb-optSpacing-link--linked": linkedPadding.value
                }]),
                onClick: _cache[4] || (_cache[4] = ($event) => linkValues("padding"))
              }, null, 8, ["icon", "title", "class"])
            ]),
            Vue.createElementVNode("div", _hoisted_11$6, [
              (Vue.openBlock(), Vue.createElementBlock("svg", _hoisted_12$5, [
                (Vue.openBlock(), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList(paddingPositionId, (position) => {
                  return Vue.createElementVNode("path", {
                    key: position.position,
                    cursor: position.svg.cursor,
                    d: position.svg.d,
                    class: Vue.normalizeClass({
                      [`znpb-optSpacing--path-${position.position}`]: true
                    }),
                    onMouseenter: ($event) => activeHover.value = position,
                    onMouseleave: _cache[5] || (_cache[5] = ($event) => activeHover.value = null),
                    onMousedown: ($event) => startDragging($event, position)
                  }, null, 42, _hoisted_13$4);
                }), 64))
              ]))
            ])
          ], 2),
          activeHover.value ? (Vue.openBlock(), Vue.createElementBlock("span", _hoisted_14$2, Vue.toDisplayString(activeHover.value.title), 1)) : Vue.createCommentVNode("", true)
        ]);
      };
    }
  }));
  var InputDimensions_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$1k = { class: "znpb-dimensions-wrapper" };
  const _hoisted_2$V = {
    key: 0,
    class: "znpb-dimensions_icon"
  };
  const _hoisted_3$E = {
    key: 2,
    class: "znpb-dimensions__center"
  };
  const __default__$3 = {
    name: "InputDimensions"
  };
  const _sfc_main$1H = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$3), {
    props: {
      modelValue: { default() {
        return {};
      } },
      dimensions: null,
      min: { default: 0 },
      max: { default: Infinity },
      placeholder: { default() {
        return {};
      } }
    },
    emits: ["update:modelValue"],
    setup(__props, { emit }) {
      const props = __props;
      const linked = Vue.ref(false);
      const computedDimensions = Vue.computed(() => {
        return [
          ...props.dimensions,
          {
            name: "link",
            id: "link"
          }
        ];
      });
      function handleLinkValues() {
        linked.value = !linked.value;
        if (linked.value) {
          const dimensionsIDs = props.dimensions.map((dimension) => dimension.id);
          const savedPositionValue = Object.keys(props.modelValue).find(
            (position) => dimensionsIDs.includes(position) && typeof props.modelValue[position] !== "undefined"
          );
          if (savedPositionValue) {
            onValueUpdated("", props.modelValue[savedPositionValue]);
          }
        }
      }
      function onValueUpdated(position, newValue) {
        if (linked.value) {
          const valuesToUpdate = props.dimensions.filter((dimension) => {
            return dimension.id !== "link";
          });
          let values = {};
          valuesToUpdate.forEach((value) => {
            values[value.id] = newValue;
          });
          emit("update:modelValue", __spreadValues(__spreadValues({}, props.modelValue), values));
        } else {
          emit("update:modelValue", __spreadProps(__spreadValues({}, props.modelValue), {
            [position]: newValue
          }));
        }
      }
      return (_ctx, _cache) => {
        const _component_Icon = Vue.resolveComponent("Icon");
        return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$1k, [
          (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList(Vue.unref(computedDimensions), (dimension, i) => {
            return Vue.openBlock(), Vue.createElementBlock("div", {
              key: i,
              class: Vue.normalizeClass(["znpb-dimension", `znpb-dimension--${i}`])
            }, [
              dimension.name !== "link" ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_2$V, [
                Vue.createVNode(_component_Icon, {
                  icon: dimension.icon
                }, null, 8, ["icon"])
              ])) : Vue.createCommentVNode("", true),
              dimension.name !== "link" ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$2X), {
                key: 1,
                "model-value": __props.modelValue[dimension.id],
                title: dimension.id,
                min: __props.min,
                max: __props.max,
                default_unit: "px",
                step: 1,
                "default-unit": "px",
                placeholder: __props.placeholder ? __props.placeholder[dimension.id] : "",
                "onUpdate:modelValue": ($event) => onValueUpdated(dimension.id, $event),
                onLinkedValue: handleLinkValues
              }, null, 8, ["model-value", "title", "min", "max", "placeholder", "onUpdate:modelValue"])) : Vue.createCommentVNode("", true),
              dimension.name === "link" ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_3$E, [
                Vue.createVNode(_component_Icon, {
                  icon: linked.value ? "link" : "unlink",
                  title: linked.value ? "Unlink" : "Link",
                  class: Vue.normalizeClass(["znpb-dimensions__link", { ["znpb-dimensions__link--linked"]: linked.value }]),
                  onClick: handleLinkValues
                }, null, 8, ["icon", "title", "class"])
              ])) : Vue.createCommentVNode("", true)
            ], 2);
          }), 128))
        ]);
      };
    }
  }));
  const _hoisted_1$1j = ["innerHTML"];
  const __default__$2 = {
    name: "HTML"
  };
  const _sfc_main$1G = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$2), {
    props: {
      content: { default: "" }
    },
    setup(__props) {
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", {
          class: "znpb-option__html",
          innerHTML: __props.content
        }, null, 8, _hoisted_1$1j);
      };
    }
  }));
  const options = [
    {
      id: "text",
      component: _sfc_main$31,
      dynamic: {
        type: "TEXT"
      }
    },
    {
      id: "icon_library",
      component: _sfc_main$2o,
      config: {
        barebone: true
      }
    },
    {
      id: "textarea",
      component: _sfc_main$31,
      componentProps: {
        type: "textarea"
      },
      dynamic: {
        type: "TEXT"
      }
    },
    {
      id: "password",
      componentProps: {
        type: "password"
      },
      component: _sfc_main$31
    },
    {
      id: "select",
      component: InputSelect
    },
    {
      id: "slider",
      component: _sfc_main$2F
    },
    {
      id: "dynamic_slider",
      component: _sfc_main$2E
    },
    {
      id: "editor",
      component: _sfc_main$22,
      dynamic: {
        type: "TEXT"
      }
    },
    {
      id: "media",
      component: _sfc_main$21
    },
    {
      id: "file",
      component: _sfc_main$20
    },
    {
      id: "image",
      component: _sfc_main$2k
    },
    {
      id: "number",
      component: _sfc_main$2Y
    },
    {
      id: "number_unit",
      component: _sfc_main$2X
    },
    {
      id: "code",
      component: _sfc_main$2a
    },
    {
      id: "custom_selector",
      component: _sfc_main$25
    },
    {
      id: "colorpicker",
      component: _sfc_main$26,
      dynamic: {
        type: "TYPE_HIDDEN",
        custom_dynamic: true
      }
    },
    {
      id: "checkbox",
      component: _sfc_main$2d
    },
    {
      id: "radio_image",
      component: _sfc_main$1R
    },
    {
      id: "checkbox_group",
      component: _sfc_main$2c
    },
    {
      id: "checkbox_switch",
      component: InputCheckboxSwitch
    },
    {
      id: "text_align",
      component: _sfc_main$1T
    },
    {
      id: "borders",
      component: _sfc_main$2g
    },
    {
      id: "shadow",
      component: _sfc_main$1S
    },
    {
      id: "video",
      component: _sfc_main$2i
    },
    {
      id: "date_input",
      component: InputDatePicker
    },
    {
      id: "shape_dividers",
      component: _sfc_main$1X
    },
    {
      id: "shape_component",
      component: _sfc_main$1U
    },
    {
      id: "spacing",
      component: _sfc_main$1I
    },
    {
      id: "repeater",
      component: _sfc_main$1P
    },
    {
      id: "upgrade_to_pro",
      component: _sfc_main$1V
    },
    {
      id: "dimensions",
      component: _sfc_main$1H
    },
    {
      id: "html",
      component: _sfc_main$1G
    }
  ];
  const useOptions = () => {
    const { applyFilters: applyFilters2 } = window.zb.hooks;
    const getOption = (schema, model = null, formModel = {}) => {
      let optionConfig = options.find((option) => option.id === schema.type);
      optionConfig = applyFilters2("zionbuilder/getOptionConfig", optionConfig, schema, model, formModel);
      if (!optionConfig) {
        console.warn(
          `Option type ${schema.type} not found. Please register the option type using ZionBuilderApi.options.registerOption!`
        );
        return null;
      }
      return optionConfig;
    };
    const getOptionComponent = (schema, model = null, formModel = {}) => {
      const optionConfig = getOption(schema.type);
      return applyFilters2("zionbuilder/getOption", optionConfig == null ? void 0 : optionConfig.component, schema, model, formModel);
    };
    const registerOption = (optionConfig) => {
      if (!Object.prototype.hasOwnProperty.call(optionConfig, "id")) {
        console.warn("You need to specify the option type id.", optionConfig);
      }
      if (!Object.prototype.hasOwnProperty.call(optionConfig, "component")) {
        console.warn("You need to specify the option type id.", optionConfig);
      }
      options.push(optionConfig);
    };
    return {
      registerOption,
      getOptionComponent,
      getOption
    };
  };
  const deviceSizesConfig = [
    {
      width: 992,
      icon: "laptop"
    },
    {
      width: 768,
      icon: "tablet"
    },
    {
      width: 575,
      icon: "mobile"
    }
  ];
  const activeResponsiveDeviceId = Vue.ref("default");
  const responsiveDevices = Vue.ref(window.ZnPbComponentsData.breakpoints);
  const activeResponsiveOptions = Vue.ref(null);
  const iframeWidth = Vue.ref(0);
  const autoScaleActive = Vue.ref(true);
  const scaleValue = Vue.ref(100);
  const ignoreWidthChangeFlag = Vue.ref(false);
  const orderedResponsiveDevices = Vue.computed(() => {
    return orderBy(responsiveDevices.value, ["width"], ["desc"]);
  });
  const responsiveDevicesAsIdWidth = Vue.computed(() => {
    const devices = {};
    orderedResponsiveDevices.value.forEach((deviceConfig) => {
      devices[deviceConfig.id] = deviceConfig.width;
    });
    return devices;
  });
  const activeResponsiveDeviceInfo = Vue.computed(
    () => responsiveDevices.value.find((device) => device.id === activeResponsiveDeviceId.value) || responsiveDevices.value[0]
  );
  const builtInResponsiveDevices = Vue.computed(
    () => responsiveDevices.value.filter((deviceConfig) => deviceConfig.builtIn === true)
  );
  const mobileFirstResponsiveDevices = Vue.computed(() => {
    const newDevices = {};
    let lastDeviceWidth = 0;
    const sortedDevices = Object.entries(responsiveDevicesAsIdWidth.value).sort((a, b) => a[1] > b[1] ? 1 : -1).reduce((acc, pair) => {
      acc[pair[0]] = pair[1];
      return acc;
    }, {});
    for (const [deviceId, deviceWidth] of Object.entries(sortedDevices)) {
      if (deviceId === "mobile") {
        newDevices[deviceId] = 0;
      } else {
        newDevices[deviceId] = lastDeviceWidth + 1;
      }
      if (deviceWidth) {
        lastDeviceWidth = deviceWidth;
      }
    }
    return newDevices;
  });
  const useResponsiveDevices = () => {
    function setActiveResponsiveDeviceId(device) {
      activeResponsiveDeviceId.value = device;
    }
    function setAutoScale(scaleEnabled) {
      autoScaleActive.value = scaleEnabled;
      if (scaleEnabled) {
        scaleValue.value = 100;
      }
    }
    function setCustomScale(newValue) {
      scaleValue.value = newValue;
    }
    function setActiveResponsiveOptions(instanceConfig) {
      activeResponsiveOptions.value = instanceConfig;
    }
    function getActiveResponsiveOptions() {
      return activeResponsiveOptions.value;
    }
    function removeActiveResponsiveOptions() {
      activeResponsiveOptions.value = null;
    }
    function updateBreakpoint(device, newWidth) {
      return __async(this, null, function* () {
        const editedDevice = responsiveDevices.value.find((deviceData) => deviceData === device);
        if (editedDevice && editedDevice.width !== newWidth) {
          editedDevice.width = newWidth;
          yield saveDevices();
          const AssetsStore = useAssetsStore();
          yield AssetsStore.regenerateCache();
        }
      });
    }
    function saveDevices() {
      return saveBreakpoints(responsiveDevices.value);
    }
    function setCustomIframeWidth(newWidth, changeDevice = false) {
      const actualWidth = newWidth < 240 ? 240 : newWidth;
      if (newWidth && changeDevice) {
        let activeDevice = "default";
        responsiveDevices.value.forEach((device) => {
          if (device.width && device.width >= actualWidth) {
            activeDevice = device.id;
          }
        });
        if (activeDevice && activeDevice !== activeResponsiveDeviceId.value) {
          ignoreWidthChangeFlag.value = true;
          setActiveResponsiveDeviceId(activeDevice);
        }
      }
      iframeWidth.value = actualWidth;
    }
    function addCustomBreakpoint(breakPoint) {
      const { width, icon = "desktop" } = breakPoint;
      const newDeviceData = {
        width,
        icon,
        isCustom: true,
        id: generateUID()
      };
      responsiveDevices.value.push(newDeviceData);
      return newDeviceData;
    }
    function deleteBreakpoint(breakpointID) {
      return __async(this, null, function* () {
        const deviceConfig = responsiveDevices.value.find((deviceConfig2) => deviceConfig2.id === breakpointID);
        if (deviceConfig) {
          const index2 = responsiveDevices.value.indexOf(deviceConfig);
          responsiveDevices.value.splice(index2, 1);
          yield saveDevices();
          const AssetsStore = useAssetsStore();
          yield AssetsStore.regenerateCache();
        }
      });
    }
    return {
      ignoreWidthChangeFlag,
      activeResponsiveDeviceId,
      activeResponsiveDeviceInfo,
      responsiveDevices,
      iframeWidth,
      autoScaleActive,
      scaleValue: Vue.readonly(scaleValue),
      setActiveResponsiveDeviceId,
      removeActiveResponsiveOptions,
      getActiveResponsiveOptions,
      setActiveResponsiveOptions,
      setCustomIframeWidth,
      setCustomScale,
      setAutoScale,
      addCustomBreakpoint,
      deleteBreakpoint,
      updateBreakpoint,
      saveDevices,
      mobileFirstResponsiveDevices,
      deviceSizesConfig,
      responsiveDevicesAsIdWidth,
      orderedResponsiveDevices,
      builtInResponsiveDevices
    };
  };
  const pseudoSelectors = Vue.ref([
    {
      name: "default",
      id: "default"
    },
    {
      name: ":hover",
      id: ":hover"
    },
    {
      name: ":before",
      id: ":before"
    },
    {
      name: ":after",
      id: ":after"
    },
    {
      name: ":active",
      id: ":active"
    },
    {
      name: ":focus",
      id: ":focus"
    },
    {
      name: ":custom",
      id: "custom"
    }
  ]);
  const activePseudoSelector = Vue.ref(pseudoSelectors.value[0]);
  const usePseudoSelectors = () => {
    function setActivePseudoSelector(value) {
      activePseudoSelector.value = value || pseudoSelectors.value[0];
    }
    function deleteCustomSelector(selector) {
      const selectorIndex = pseudoSelectors.value.indexOf(selector);
      if (selectorIndex !== -1) {
        pseudoSelectors.value.splice(selectorIndex, 1);
        activePseudoSelector.value = pseudoSelectors.value[0];
      }
    }
    function addCustomSelector(selector) {
      pseudoSelectors.value.push(selector);
    }
    return {
      activePseudoSelector,
      pseudoSelectors,
      addCustomSelector,
      setActivePseudoSelector,
      deleteCustomSelector
    };
  };
  var COMMON_COMPOSABLES = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    useLibrary,
    units,
    useInjections,
    useOptions,
    useOptionsSchemas,
    useResponsiveDevices,
    usePseudoSelectors
  }, Symbol.toStringTag, { value: "Module" }));
  var PseudoGroup_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$1F = {
    name: "PseudoGroup",
    props: {
      modelValue: {},
      child_options: {
        type: Object,
        required: true
      },
      save_to_id: {
        type: Boolean
      }
    },
    setup(props, { emit }) {
      const { activePseudoSelector: activePseudoSelector2 } = usePseudoSelectors();
      const valueModel = Vue.computed({
        get() {
          return (props.modelValue || {})[activePseudoSelector2.value.id] || {};
        },
        set(newValue) {
          const clonedValue = __spreadValues({}, props.modelValue);
          if (newValue === null && typeof clonedValue[activePseudoSelector2.value.id]) {
            delete clonedValue[activePseudoSelector2.value.id];
          } else {
            clonedValue[activePseudoSelector2.value.id] = newValue;
          }
          emit("update:modelValue", clonedValue);
        }
      });
      return {
        activePseudoSelector: activePseudoSelector2,
        valueModel
      };
    }
  };
  function _sfc_render$$(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_OptionsForm = Vue.resolveComponent("OptionsForm");
    return Vue.openBlock(), Vue.createBlock(_component_OptionsForm, {
      modelValue: $setup.valueModel,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.valueModel = $event),
      class: "znpb-option--pseudo-group",
      schema: $props.child_options
    }, null, 8, ["modelValue", "schema"]);
  }
  var PseudoGroup$1 = /* @__PURE__ */ _export_sfc(_sfc_main$1F, [["render", _sfc_render$$]]);
  var PseudoGroup = {
    id: "pseudo_group",
    component: PseudoGroup$1,
    config: {
      barebone: true
    }
  };
  var BackgroundColor_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$1E = {
    name: "BackgroundColor",
    props: {
      modelValue: {
        type: String,
        required: false
      },
      placeholder: {
        type: String || null,
        required: false,
        default: null
      }
    },
    data() {
      return {
        showColorPicker: false,
        preventNextClick: false,
        isDragging: false
      };
    },
    computed: {
      colorModel: {
        get() {
          let computedValue = null;
          if (this.modelValue !== void 0) {
            if (typeof this.modelValue === "string") {
              computedValue = this.modelValue;
            } else
              computedValue = this.modelValue.value;
          }
          return computedValue !== null ? computedValue : this.placeholder;
        },
        set(newColor) {
          this.$emit("update:modelValue", newColor);
        }
      },
      getColorStyle() {
        return {
          "background-color": this.colorModel || this.placeholder
        };
      }
    },
    methods: {
      deleteColor() {
        this.$emit("update:modelValue", null);
      }
    }
  };
  const _hoisted_1$1i = { class: "znpb-style-background-color" };
  function _sfc_render$_(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_EmptyList = Vue.resolveComponent("EmptyList");
    const _component_Icon = Vue.resolveComponent("Icon");
    const _component_ActionsOverlay = Vue.resolveComponent("ActionsOverlay");
    const _component_Color = Vue.resolveComponent("Color");
    return Vue.openBlock(), Vue.createBlock(_component_Color, {
      modelValue: $options.colorModel,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $options.colorModel = $event),
      onOpen: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("open")),
      onClose: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("close"))
    }, {
      trigger: Vue.withCtx(() => [
        Vue.createElementVNode("div", _hoisted_1$1i, [
          !$props.modelValue && !$props.placeholder ? (Vue.openBlock(), Vue.createBlock(_component_EmptyList, {
            key: 0,
            class: "znpb-input-background-image__empty",
            "no-margin": true
          }, {
            default: Vue.withCtx(() => [
              Vue.createTextVNode(Vue.toDisplayString(_ctx.$translate("select_background_color")), 1)
            ]),
            _: 1
          })) : (Vue.openBlock(), Vue.createBlock(_component_ActionsOverlay, { key: 1 }, Vue.createSlots({
            default: Vue.withCtx(() => [
              Vue.createElementVNode("div", {
                class: "znpb-style-background-color__holder",
                style: Vue.normalizeStyle($options.getColorStyle)
              }, null, 4)
            ]),
            _: 2
          }, [
            $props.modelValue ? {
              name: "actions",
              fn: Vue.withCtx(() => [
                Vue.createElementVNode("div", null, [
                  Vue.createVNode(_component_Icon, {
                    rounded: true,
                    icon: "delete",
                    "bg-size": 30,
                    onClick: Vue.withModifiers($options.deleteColor, ["stop"])
                  }, null, 8, ["onClick"])
                ])
              ]),
              key: "0"
            } : void 0
          ]), 1024))
        ])
      ]),
      _: 1
    }, 8, ["modelValue"]);
  }
  var InputBackgroundColor = /* @__PURE__ */ _export_sfc(_sfc_main$1E, [["render", _sfc_render$_]]);
  var BackgroundColor = {
    id: "background_color",
    component: InputBackgroundColor
  };
  var Background_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$1D = {
    name: "Background",
    components: {
      InputBackgroundColor
    },
    inject: {
      panel: {
        default: null
      }
    },
    props: {
      modelValue: {},
      placeholder: {
        type: Object,
        required: false,
        default: {}
      }
    },
    setup(props, { emit }) {
      const { activeResponsiveDeviceInfo: activeResponsiveDeviceInfo2 } = useResponsiveDevices();
      const { activePseudoSelector: activePseudoSelector2 } = usePseudoSelectors();
      const valueModel = Vue.computed({
        get() {
          return props.modelValue || {};
        },
        set(newValue) {
          emit("update:modelValue", newValue);
        }
      });
      const canShowBackground = Vue.computed(
        () => activeResponsiveDeviceInfo2.value.id === "default" && activePseudoSelector2.value.id === "default"
      );
      const bgColorSchema = Vue.computed(() => {
        return {
          id: "background-color",
          type: "background_color",
          placeholder: props.placeholder ? props.placeholder["background-color"] : null
        };
      });
      return {
        activeResponsiveDeviceInfo: activeResponsiveDeviceInfo2,
        activePseudoSelector: activePseudoSelector2,
        valueModel,
        canShowBackground,
        bgColorSchema
      };
    },
    data() {
      return {
        bgGradientSchema: {
          id: "background-gradient",
          type: "background_gradient"
        }
      };
    },
    methods: {
      onDeleteOption(optionId) {
        const newValues = __spreadValues({}, this.modelValue);
        delete newValues[optionId];
        this.valueModel = newValues;
      },
      onOptionUpdate(optionId, newValue) {
        const clonedValue = __spreadValues({}, this.modelValue);
        if (optionId) {
          if (newValue === null) {
            delete clonedValue[optionId];
          } else {
            clonedValue[optionId] = newValue;
          }
          this.valueModel = clonedValue;
        } else {
          if (newValue === null) {
            this.$emit("update:modelValue", null);
          } else {
            this.valueModel = newValue;
          }
        }
      }
    }
  };
  function _sfc_render$Z(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Icon = Vue.resolveComponent("Icon");
    const _component_OptionWrapper = Vue.resolveComponent("OptionWrapper");
    const _component_Tab = Vue.resolveComponent("Tab");
    const _component_InputBackgroundImage = Vue.resolveComponent("InputBackgroundImage");
    const _component_InputBackgroundVideo = Vue.resolveComponent("InputBackgroundVideo");
    const _component_Tabs = Vue.resolveComponent("Tabs");
    return Vue.openBlock(), Vue.createBlock(_component_Tabs, {
      "tab-style": "group",
      class: "znpb-background-option-tabs",
      "title-position": "center"
    }, {
      default: Vue.withCtx(() => [
        Vue.createVNode(_component_Tab, {
          name: "background-color",
          "tooltip-title": "Background color"
        }, {
          title: Vue.withCtx(() => [
            Vue.createVNode(_component_Icon, { icon: "drop" })
          ]),
          default: Vue.withCtx(() => [
            Vue.createVNode(_component_OptionWrapper, {
              schema: $setup.bgColorSchema,
              "option-id": $setup.bgColorSchema.id,
              modelValue: $setup.valueModel["background-color"],
              "delete-value": $options.onDeleteOption,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $options.onOptionUpdate(...$event))
            }, null, 8, ["schema", "option-id", "modelValue", "delete-value"])
          ]),
          _: 1
        }),
        Vue.createVNode(_component_Tab, {
          name: "background-gradient",
          "tooltip-title": "Background gradient"
        }, {
          title: Vue.withCtx(() => [
            Vue.createVNode(_component_Icon, { icon: "gradient" })
          ]),
          default: Vue.withCtx(() => [
            Vue.createVNode(_component_OptionWrapper, {
              schema: $data.bgGradientSchema,
              "option-id": $data.bgGradientSchema.id,
              modelValue: $setup.valueModel["background-gradient"],
              "delete-value": $options.onDeleteOption,
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $options.onOptionUpdate(...$event))
            }, null, 8, ["schema", "option-id", "modelValue", "delete-value"])
          ]),
          _: 1
        }),
        Vue.createVNode(_component_Tab, {
          name: "background-image",
          "tooltip-title": "Background image"
        }, {
          title: Vue.withCtx(() => [
            Vue.createVNode(_component_Icon, { icon: "picture" })
          ]),
          default: Vue.withCtx(() => [
            Vue.createVNode(_component_InputBackgroundImage, {
              class: "znpb-input__background-image",
              modelValue: $setup.valueModel,
              "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $options.onOptionUpdate(false, $event))
            }, null, 8, ["modelValue"])
          ]),
          _: 1
        }),
        $setup.canShowBackground ? (Vue.openBlock(), Vue.createBlock(_component_Tab, {
          key: 0,
          name: "background-video",
          "tooltip-title": "Background video"
        }, {
          title: Vue.withCtx(() => [
            Vue.createVNode(_component_Icon, { icon: "video" })
          ]),
          default: Vue.withCtx(() => [
            Vue.createVNode(_component_InputBackgroundVideo, {
              class: "znpb-input__background-video",
              modelValue: $setup.valueModel["background-video"],
              "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => $options.onOptionUpdate("background-video", $event))
            }, null, 8, ["modelValue"])
          ]),
          _: 1
        })) : Vue.createCommentVNode("", true)
      ]),
      _: 1
    });
  }
  var Background$1 = /* @__PURE__ */ _export_sfc(_sfc_main$1D, [["render", _sfc_render$Z]]);
  var Background = {
    id: "background",
    component: Background$1
  };
  var BackgroundGradient_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$1C = {
    name: "BackgroundGradient",
    props: {
      modelValue: {
        type: Array,
        required: false
      },
      hasLibrary: {
        type: Boolean,
        required: false,
        default: true
      }
    },
    data() {
      return {
        showLibrary: false
      };
    },
    computed: {
      gradientModel: {
        get() {
          return this.modelValue || null;
        },
        set(newGradient) {
          this.$emit("update:modelValue", newGradient);
        }
      }
    },
    methods: {
      addNewGradient() {
        this.gradientModel = getDefaultGradient();
      }
    }
  };
  const _hoisted_1$1h = { class: "znpb-style-background-gradient" };
  function _sfc_render$Y(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_EmptyList = Vue.resolveComponent("EmptyList");
    const _component_GradientGenerator = Vue.resolveComponent("GradientGenerator");
    const _component_GradientLibrary = Vue.resolveComponent("GradientLibrary");
    return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$1h, [
      !$props.modelValue && !$data.showLibrary ? (Vue.openBlock(), Vue.createBlock(_component_EmptyList, {
        key: 0,
        class: "znpb-style-background-gradient__empty",
        "no-margin": true
      }, {
        default: Vue.withCtx(() => [
          Vue.createElementVNode("a", {
            onClick: _cache[0] || (_cache[0] = (...args) => $options.addNewGradient && $options.addNewGradient(...args))
          }, Vue.toDisplayString(_ctx.$translate("add_background_gradient")), 1),
          $props.hasLibrary ? (Vue.openBlock(), Vue.createElementBlock(Vue.Fragment, { key: 0 }, [
            Vue.createElementVNode("div", null, Vue.toDisplayString(_ctx.$translate("or")), 1),
            Vue.createElementVNode("a", {
              onClick: _cache[1] || (_cache[1] = ($event) => $data.showLibrary = true)
            }, Vue.toDisplayString(_ctx.$translate("select_background_gradient")), 1)
          ], 64)) : Vue.createCommentVNode("", true)
        ]),
        _: 1
      })) : Vue.createCommentVNode("", true),
      $props.modelValue ? (Vue.openBlock(), Vue.createBlock(_component_GradientGenerator, {
        key: 1,
        ref: "gradientGenerator",
        modelValue: $options.gradientModel,
        "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $options.gradientModel = $event)
      }, null, 8, ["modelValue"])) : Vue.createCommentVNode("", true),
      $data.showLibrary ? (Vue.openBlock(), Vue.createBlock(_component_GradientLibrary, {
        key: 2,
        onCloseLibrary: _cache[3] || (_cache[3] = ($event) => $data.showLibrary = false),
        onActivateGradient: _cache[4] || (_cache[4] = ($event) => ($options.gradientModel = $event, $data.showLibrary = false))
      })) : Vue.createCommentVNode("", true)
    ]);
  }
  var BackgroundGradient$1 = /* @__PURE__ */ _export_sfc(_sfc_main$1C, [["render", _sfc_render$Y]]);
  var BackgroundGradient = {
    id: "background_gradient",
    component: BackgroundGradient$1
  };
  var Typography_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$1B = {
    name: "Typography",
    props: {
      modelValue: {
        type: Object,
        default() {
          return {};
        }
      },
      placeholder: {
        type: Object,
        required: false,
        default: null
      }
    },
    setup(props) {
      const computedSchema = Vue.computed(() => {
        const { getSchema } = useOptionsSchemas();
        const schema = getSchema("typography");
        if (props.placeholder) {
          const newSchema = {};
          Object.keys(schema).forEach((optionID) => {
            const childSchema = schema[optionID];
            if (typeof props.placeholder[optionID] !== "undefined") {
              childSchema.placeholder = props.placeholder[optionID];
            }
            newSchema[optionID] = childSchema;
          });
          return newSchema;
        } else {
          return schema;
        }
      });
      return {
        computedSchema
      };
    },
    computed: {
      valueModel: {
        get() {
          return this.modelValue || {};
        },
        set(newValue) {
          this.$emit("update:modelValue", newValue);
        }
      }
    }
  };
  function _sfc_render$X(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_OptionsForm = Vue.resolveComponent("OptionsForm");
    return Vue.openBlock(), Vue.createBlock(_component_OptionsForm, {
      modelValue: $options.valueModel,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $options.valueModel = $event),
      schema: $setup.computedSchema,
      class: "znpb-option__typography-wrapper"
    }, null, 8, ["modelValue", "schema"]);
  }
  var Typography$1 = /* @__PURE__ */ _export_sfc(_sfc_main$1B, [["render", _sfc_render$X]]);
  var Typography = {
    id: "typography",
    component: Typography$1
  };
  var Group_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$1A = {
    name: "Group",
    props: {
      modelValue: {},
      child_options: {
        type: Object,
        required: false
      },
      optionsLayout: {
        type: String,
        required: false
      }
    },
    data() {
      return {};
    },
    computed: {
      valueModel: {
        get() {
          return this.modelValue || {};
        },
        set(newValue) {
          this.$emit("update:modelValue", newValue);
        }
      }
    }
  };
  function _sfc_render$W(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_OptionsForm = Vue.resolveComponent("OptionsForm");
    return $props.child_options ? (Vue.openBlock(), Vue.createBlock(_component_OptionsForm, {
      key: 0,
      modelValue: $options.valueModel,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $options.valueModel = $event),
      class: Vue.normalizeClass(["znpb-option__type-option-group", {
        [`znpb-option__type-option-group-layout--${$props.optionsLayout}`]: $props.optionsLayout
      }]),
      schema: $props.child_options
    }, null, 8, ["modelValue", "class", "schema"])) : Vue.createCommentVNode("", true);
  }
  var Group$1 = /* @__PURE__ */ _export_sfc(_sfc_main$1A, [["render", _sfc_render$W]]);
  var Group = {
    id: "group",
    component: Group$1
  };
  var PanelAccordion_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$1z = {
    name: "PanelAccordion",
    props: {
      modelValue: {},
      child_options: {
        type: Object,
        required: false
      },
      title: {
        type: String
      },
      collapsed: {
        type: Boolean,
        default: false
      },
      hasChanges: {
        type: Boolean,
        default: false,
        required: false
      }
    },
    data() {
      return {
        expanded: !this.collapsed,
        height: null
      };
    },
    computed: {
      valueModel: {
        get() {
          return this.modelValue || {};
        },
        set(newValue) {
          this.$emit("update:modelValue", newValue);
        }
      }
    },
    methods: {
      toggle() {
        this.expanded = !this.expanded;
      }
    }
  };
  const _hoisted_1$1g = { class: "znpb-pannel-accordion" };
  const _hoisted_2$U = { class: "znpb-pannel-accordion__header-title" };
  function _sfc_render$V(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_ChangesBullet = Vue.resolveComponent("ChangesBullet");
    const _component_Icon = Vue.resolveComponent("Icon");
    const _component_OptionsForm = Vue.resolveComponent("OptionsForm");
    return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$1g, [
      Vue.createElementVNode("div", {
        class: "znpb-pannel-accordion__header",
        onClick: _cache[1] || (_cache[1] = (...args) => $options.toggle && $options.toggle(...args))
      }, [
        Vue.createElementVNode("div", _hoisted_2$U, [
          Vue.createTextVNode(Vue.toDisplayString($props.title) + " ", 1),
          $props.hasChanges ? (Vue.openBlock(), Vue.createBlock(_component_ChangesBullet, {
            key: 0,
            content: _ctx.$translate("discard_changes"),
            onRemoveStyles: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("discard-changes"))
          }, null, 8, ["content"])) : Vue.createCommentVNode("", true)
        ]),
        Vue.createVNode(_component_Icon, {
          class: "znpb-option-group-selector__clone-icon",
          icon: $data.expanded ? "minus" : "plus"
        }, null, 8, ["icon"])
      ]),
      $props.child_options && $data.expanded ? (Vue.openBlock(), Vue.createBlock(_component_OptionsForm, {
        key: 0,
        ref: "accordionOption",
        modelValue: $options.valueModel,
        "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $options.valueModel = $event),
        class: "znpb-option__type-option-accordion",
        schema: $props.child_options
      }, null, 8, ["modelValue", "schema"])) : Vue.createCommentVNode("", true)
    ]);
  }
  var PanelAccordion$1 = /* @__PURE__ */ _export_sfc(_sfc_main$1z, [["render", _sfc_render$V]]);
  var PanelAccordion = {
    id: "panel_accordion",
    component: PanelAccordion$1,
    config: {
      barebone: true
    }
  };
  var ResponsiveGroup_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$1y = /* @__PURE__ */ Vue.defineComponent({
    __name: "ResponsiveGroup",
    props: {
      modelValue: null,
      child_options: null
    },
    emits: ["update:modelValue"],
    setup(__props, { emit }) {
      const props = __props;
      const {
        activeResponsiveDeviceInfo: activeResponsiveDeviceInfo2,
        setActiveResponsiveOptions,
        removeActiveResponsiveOptions,
        orderedResponsiveDevices: orderedResponsiveDevices2
      } = useResponsiveDevices();
      const { activePseudoSelector: activePseudoSelector2 } = usePseudoSelectors();
      const computedChildOptionsSchema = Vue.computed(() => {
        if (activeResponsiveDeviceInfo2.value.id !== "default") {
          return applyPlaceholders(JSON.parse(JSON.stringify(props.child_options)));
        } else {
          return props.child_options;
        }
      });
      function applyPlaceholders(schema, existingPath = "") {
        const newSchema = {};
        Object.keys(schema).forEach((singleOptionId) => {
          const singleOptionSchema = schema[singleOptionId];
          let newPath = existingPath;
          if (singleOptionSchema.child_options) {
            singleOptionSchema.child_options = applyPlaceholders(singleOptionSchema.child_options, newPath);
          }
          if (!singleOptionSchema.is_layout) {
            newPath = existingPath ? existingPath + "." + singleOptionSchema.id : singleOptionId;
            const higherValue = getHigherResponsiveDeviceValue(newPath);
            if (higherValue !== null) {
              singleOptionSchema.placeholder = higherValue;
            }
          } else {
            const higherValue = getHigherResponsiveDeviceValue(existingPath, true);
            if (higherValue !== null) {
              singleOptionSchema.placeholder = higherValue;
            }
          }
          newSchema[singleOptionId] = singleOptionSchema;
        });
        return newSchema;
      }
      function getHigherResponsiveDeviceValue(schemaPath, isLayout = false) {
        let newValue = null;
        let oldValue = {};
        Object.keys(orderedResponsiveDevices2.value).forEach((index2) => {
          const deviceInfo = orderedResponsiveDevices2.value[index2];
          let fullPath;
          if (schemaPath.length > 0) {
            fullPath = `${deviceInfo.id}.${activePseudoSelector2.value.id}.${schemaPath}`;
          } else {
            fullPath = `${deviceInfo.id}.${activePseudoSelector2.value.id}`;
          }
          if (deviceInfo.id === "default" || deviceInfo.width > activeResponsiveDeviceInfo2.value.width) {
            const tempNewValue = get(props.modelValue, fullPath, null);
            if (tempNewValue !== null) {
              if (isLayout) {
                newValue = Object.assign({}, oldValue, tempNewValue || {});
              } else {
                newValue = tempNewValue;
              }
            }
            oldValue = newValue;
          }
        });
        return newValue;
      }
      const computedModelValue = Vue.computed({
        get() {
          return (props.modelValue || {})[activeResponsiveDeviceInfo2.value.id] || {};
        },
        set(newValue) {
          const clonedValue = __spreadValues({}, props.modelValue);
          if (newValue === null && typeof clonedValue[activeResponsiveDeviceInfo2.value.id]) {
            delete clonedValue[activeResponsiveDeviceInfo2.value.id];
          } else {
            clonedValue[activeResponsiveDeviceInfo2.value.id] = newValue;
          }
          emit("update:modelValue", clonedValue);
        }
      });
      function removeDeviceStyles(deviceID) {
        const clonedValues = __spreadValues({}, props.modelValue);
        delete clonedValues[deviceID];
        emit("update:modelValue", clonedValues);
      }
      const computedAllModelValue = Vue.computed(() => props.modelValue);
      Vue.onMounted(
        () => setActiveResponsiveOptions({
          modelValue: computedAllModelValue,
          removeDeviceStyles
        })
      );
      Vue.onBeforeUnmount(() => removeActiveResponsiveOptions());
      return (_ctx, _cache) => {
        const _component_OptionsForm = Vue.resolveComponent("OptionsForm");
        return Vue.openBlock(), Vue.createBlock(_component_OptionsForm, {
          modelValue: Vue.unref(computedModelValue),
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => Vue.isRef(computedModelValue) ? computedModelValue.value = $event : null),
          class: "znpb-option--responsive-group",
          schema: Vue.unref(computedChildOptionsSchema)
        }, null, 8, ["modelValue", "schema"]);
      };
    }
  });
  var ResponsiveGroup = {
    id: "responsive_group",
    component: _sfc_main$1y,
    config: {
      barebone: true
    }
  };
  var index = "";
  window.addEventListener("load", () => {
    const wp2 = window.wp;
    const Library = wp2.media.controller.Library;
    const _ = window._;
    const Select = window.wp.media.view.MediaFrame.Select;
    const MediaController = Library.extend(
      {
        defaults: _.defaults({
          id: "zion-media",
          filterable: "uploaded",
          priority: 60,
          syncSelection: true
        }, Library.prototype.defaults),
        initialize: function() {
          var library, comparator;
          Library.prototype.initialize.apply(this, arguments);
          library = this.get("library");
          comparator = library.comparator;
          library.comparator = function(a, b) {
            var aInQuery = !!this.mirroring.get(a.cid);
            var bInQuery = !!this.mirroring.get(b.cid);
            if (!aInQuery && bInQuery) {
              return -1;
            } else if (aInQuery && !bInQuery) {
              return 1;
            } else {
              return comparator.apply(this, arguments);
            }
          };
          library.observe(this.get("selection"));
        }
      }
    );
    const ZionBuilderFrame = Select.extend({
      initialize: function() {
        Select.prototype.initialize.apply(this, arguments);
      },
      createStates: function() {
        const options2 = this.options;
        this.states.add(new MediaController({
          library: wp2.media.query(options2.library),
          multiple: options2.multiple,
          title: options2.title
        }));
      }
    });
    window.wp.media.view.MediaFrame.ZionBuilderFrame = ZionBuilderFrame;
  });
  var IconPackGrid_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$1f = { class: "znpb-icon-pack-modal__icons" };
  const _hoisted_2$T = {
    key: 0,
    class: "znpb-icon-pack-modal__grid"
  };
  const _hoisted_3$D = ["onClick", "onDblclick"];
  const _hoisted_4$o = ["data-znpbiconfam", "data-znpbicon"];
  const _hoisted_5$k = { class: "znpb-modal-icon-wrapper__title" };
  const _hoisted_6$f = { key: 1 };
  const __default__$1 = {
    name: "IconPackGrid"
  };
  const _sfc_main$1x = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__$1), {
    props: {
      iconList: null,
      family: null,
      activeIcon: null,
      activeFamily: null
    },
    emits: ["icon-selected", "update:modelValue"],
    setup(__props) {
      function unicode(unicode2) {
        return JSON.parse('"\\' + unicode2 + '"');
      }
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$1f, [
          __props.iconList.length > 0 ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_2$T, [
            (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList(__props.iconList, (icon, i) => {
              return Vue.openBlock(), Vue.createElementBlock("div", {
                key: i,
                class: "znpb-icon-pack-modal-icon"
              }, [
                Vue.createElementVNode("div", {
                  class: Vue.normalizeClass(["znpb-modal-icon-wrapper", { "znpb-modal-icon-wrapper--active": __props.activeIcon === icon.name && __props.activeFamily === __props.family }]),
                  onClick: ($event) => _ctx.$emit("icon-selected", icon),
                  onDblclick: ($event) => _ctx.$emit("update:modelValue", icon)
                }, [
                  Vue.createElementVNode("span", {
                    "data-znpbiconfam": __props.family,
                    "data-znpbicon": unicode(icon.unicode)
                  }, null, 8, _hoisted_4$o)
                ], 42, _hoisted_3$D),
                Vue.createElementVNode("h4", _hoisted_5$k, Vue.toDisplayString(icon.name), 1)
              ]);
            }), 128))
          ])) : (Vue.openBlock(), Vue.createElementBlock("span", _hoisted_6$f, Vue.toDisplayString(_ctx.$translate("no_icons_in_package")) + " " + Vue.toDisplayString(__props.family), 1))
        ]);
      };
    }
  }));
  var Modal_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$1w = {
    name: "Modal",
    components: {
      Icon: _sfc_main$34
    },
    props: {
      show: {
        type: Boolean,
        required: false,
        default: false
      },
      title: {
        type: String,
        required: false,
        default: ""
      },
      width: {
        type: Number,
        required: false
      },
      fullscreen: {
        type: Boolean,
        required: false,
        default: false
      },
      appendTo: {
        type: String,
        required: false
      },
      closeOnClick: {
        type: Boolean,
        required: false,
        default: true
      },
      closeOnEscape: {
        type: Boolean,
        required: false,
        default: true
      },
      showClose: {
        type: Boolean,
        required: false,
        default: true
      },
      showMaximize: {
        type: Boolean,
        required: false,
        default: true
      },
      showBackdrop: {
        type: Boolean,
        required: false,
        default: true
      },
      position: {
        type: Object,
        required: false,
        default: null
      },
      enableDrag: {
        type: Boolean,
        required: false,
        default: true
      }
    },
    data: function() {
      return {
        fullSize: this.fullscreen,
        bg: this.showBackdrop,
        hasHeader: false,
        zIndex: null,
        initialPosition: {}
      };
    },
    computed: {
      modalStyle() {
        return {
          zIndex: this.zIndex,
          left: this.position === null || this.position.left + 60 > window.innerWidth || this.topPos === null ? null : "30px",
          top: this.position === null || this.leftPos === null || this.topPos === null ? null : "0",
          transform: this.position === null || this.leftPos === null || this.topPos === null ? null : `translate(${Math.round(this.leftPos)}px,${Math.round(this.topPos)}px)`
        };
      },
      leftPos() {
        return this.position === null || this.position.left + 60 > window.innerWidth ? null : this.position.left;
      },
      topPos() {
        let top2 = 0;
        if (this.position === null) {
          top2 = null;
        } else if (this.position.top - 30 < 0) {
          top2 = 0;
        } else if (this.position.top > window.innerHeight / 2) {
          top2 = this.position.top - 90;
        } else
          top2 = this.position.top;
        return top2;
      },
      hasHeaderSlot() {
        return !!this.$slots["header"];
      },
      maximizeIcon() {
        return this.fullSize ? "minimize" : "maximize";
      },
      modalContentStyle() {
        let modalStyle = {};
        if (this.width) {
          modalStyle["max-width"] = this.width + "px";
        }
        if (this.enableDrag) {
          modalStyle["position"] = "absolute";
        }
        if (this.fullSize) {
          modalStyle["max-height"] = "100%";
        }
        return modalStyle;
      },
      appendToElement() {
        return document.querySelector(this.appendTo);
      }
    },
    watch: {
      show(newValue) {
        if (newValue) {
          this.zIndex = getZindex();
          this.$nextTick(() => {
            if (this.$el.ownerDocument.getElementById("znpb-editor-iframe") !== void 0 && this.$el.ownerDocument.getElementById("znpb-editor-iframe") !== null) {
              document.getElementById("znpb-editor-iframe").contentWindow.document.body.style.overflow = "hidden";
            } else {
              this.$el.ownerDocument.body.style.overflow = "hidden";
            }
          });
        } else {
          this.$nextTick(() => {
            if (this.zIndex) {
              removeZindex();
              this.zIndex = null;
            }
            if (document.getElementById("znpb-editor-iframe") !== void 0 && document.getElementById("znpb-editor-iframe") !== null) {
              document.getElementById("znpb-editor-iframe").contentWindow.document.body.style.overflow = null;
            } else {
              this.$el.ownerDocument.body.style.overflow = null;
            }
          });
        }
      },
      fullscreen(newValue) {
        if (newValue) {
          this.fullSize = newValue;
        } else
          this.fullSize = this.fullscreen;
      },
      showBackdrop(newValue) {
        this.bg = newValue;
      }
    },
    mounted() {
      if (this.appendTo) {
        this.appendModal();
      }
      if (this.closeOnEscape) {
        document.addEventListener("keyup", this.onEscapeKeyPress);
      }
      if (this.show) {
        this.zIndex = getZindex();
      }
    },
    beforeUnmount() {
      window.removeEventListener("mousemove", this.drag);
      window.removeEventListener("mouseup", this.unDrag);
      document.removeEventListener("keyup", this.onEscapeKeyPress);
      if (this.$el.parentNode === this.appendToElement) {
        this.appendToElement.removeChild(this.$el);
      }
      if (this.zIndex) {
        removeZindex();
        this.zIndex = null;
      }
    },
    methods: {
      activateDrag() {
        if (this.enableDrag) {
          this.$refs.modalContent.style.transition = "none";
          const { left: left2, top: top2 } = this.$refs.modalContent.getBoundingClientRect();
          this.initialPosition = {
            clientX: event.clientX,
            clientY: event.clientY,
            left: left2,
            top: top2
          };
          window.addEventListener("mousemove", this.drag);
          window.addEventListener("mouseup", this.unDrag);
        }
      },
      drag(event2) {
        const left2 = event2.clientX - this.initialPosition.clientX + this.initialPosition.left;
        const top2 = event2.clientY - this.initialPosition.clientY + this.initialPosition.top;
        const procentualLeft = left2 * 100 / window.innerWidth + "%";
        const procentualTop = top2 * 100 / window.innerHeight + "%";
        this.$refs.modalContent.style.left = procentualLeft;
        this.$refs.modalContent.style.top = procentualTop;
      },
      unDrag() {
        if (this.$refs.modalContent) {
          this.$refs.modalContent.style.transition = "all .2s";
        }
        window.removeEventListener("mousemove", this.drag);
      },
      closeOnBackdropClick(event2) {
        if (this.closeOnClick) {
          if (this.$refs.modalContent && !this.$refs.modalContent.contains(event2.target)) {
            this.closeModal();
          }
        }
      },
      closeModal() {
        this.$emit("update:show", false);
        this.$emit("close-modal", true);
      },
      appendModal() {
        if (!this.appendToElement) {
          console.warn(`${this.$translate("no_html_matching")} ${this.appendTo}`);
          return;
        }
        this.appendToElement.appendChild(this.$el);
      },
      onEscapeKeyPress(event2) {
        if (event2.which === 27) {
          this.closeModal();
          event2.stopPropagation();
        }
      }
    }
  };
  const _hoisted_1$1e = {
    key: 0,
    class: "znpb-modal__header"
  };
  const _hoisted_2$S = { class: "znpb-modal__content" };
  function _sfc_render$U(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Icon = Vue.resolveComponent("Icon");
    return Vue.openBlock(), Vue.createBlock(Vue.Transition, { name: "modal-fade" }, {
      default: Vue.withCtx(() => [
        $props.show ? (Vue.openBlock(), Vue.createElementBlock("div", {
          key: 0,
          class: Vue.normalizeClass(["znpb-modal__backdrop", { "znpb-modal__backdrop--nobg": !_ctx.bg }]),
          style: Vue.normalizeStyle($options.modalStyle),
          onClick: _cache[3] || (_cache[3] = (...args) => $options.closeOnBackdropClick && $options.closeOnBackdropClick(...args))
        }, [
          Vue.createElementVNode("div", {
            ref: "modalContent",
            style: Vue.normalizeStyle($options.modalContentStyle),
            class: Vue.normalizeClass(["znpb-modal__wrapper", { "znpb-modal__wrapper--full-size": _ctx.fullSize }])
          }, [
            ($props.title || $props.showClose || $props.showMaximize) && !$options.hasHeaderSlot ? (Vue.openBlock(), Vue.createElementBlock("header", _hoisted_1$1e, [
              Vue.createElementVNode("div", {
                class: "znpb-modal__header-title",
                style: Vue.normalizeStyle(
                  $props.enableDrag ? {
                    cursor: "pointer",
                    "user-select": "none"
                  } : null
                ),
                onMousedown: _cache[0] || (_cache[0] = (...args) => $options.activateDrag && $options.activateDrag(...args))
              }, [
                Vue.createTextVNode(Vue.toDisplayString($props.title) + " ", 1),
                Vue.renderSlot(_ctx.$slots, "title")
              ], 36),
              $props.showMaximize ? (Vue.openBlock(), Vue.createBlock(_component_Icon, {
                key: 0,
                icon: _ctx.fullSize ? "shrink" : "maximize",
                class: "znpb-modal__header-button",
                onClick: _cache[1] || (_cache[1] = Vue.withModifiers(($event) => (_ctx.fullSize = !_ctx.fullSize, _ctx.$emit("update:fullscreen", _ctx.fullSize)), ["stop"]))
              }, null, 8, ["icon"])) : Vue.createCommentVNode("", true),
              $props.showClose ? (Vue.openBlock(), Vue.createElementBlock("span", {
                key: 1,
                class: "znpb-modal__header-button",
                onClick: _cache[2] || (_cache[2] = Vue.withModifiers((...args) => $options.closeModal && $options.closeModal(...args), ["stop"]))
              }, [
                Vue.renderSlot(_ctx.$slots, "close"),
                Vue.createVNode(_component_Icon, { icon: "close" })
              ])) : Vue.createCommentVNode("", true)
            ])) : Vue.createCommentVNode("", true),
            Vue.renderSlot(_ctx.$slots, "header"),
            Vue.createElementVNode("div", _hoisted_2$S, [
              Vue.renderSlot(_ctx.$slots, "default")
            ]),
            Vue.renderSlot(_ctx.$slots, "footer")
          ], 6)
        ], 6)) : Vue.createCommentVNode("", true)
      ]),
      _: 3
    });
  }
  var Modal = /* @__PURE__ */ _export_sfc(_sfc_main$1w, [["render", _sfc_render$U]]);
  var ModalConfirm_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$1v = {
    name: "ModalConfirm",
    components: {
      Modal,
      Button: _sfc_main$30
    },
    props: {
      confirmText: {
        type: String,
        required: false,
        default: "confirm"
      },
      cancelText: {
        type: String,
        required: false,
        default: "cancel"
      },
      width: {
        type: Number,
        required: false,
        default: 470
      }
    },
    data() {
      return {};
    }
  };
  const _hoisted_1$1d = { class: "znpb-modal__confirm" };
  const _hoisted_2$R = { class: "znpb-modal__confirm-buttons-wrapper" };
  function _sfc_render$T(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Button = Vue.resolveComponent("Button");
    const _component_Modal = Vue.resolveComponent("Modal");
    return Vue.openBlock(), Vue.createBlock(_component_Modal, {
      "show-close": false,
      "show-maximize": false,
      show: true,
      "append-to": "body",
      width: $props.width
    }, {
      default: Vue.withCtx(() => [
        Vue.createElementVNode("div", _hoisted_1$1d, [
          Vue.renderSlot(_ctx.$slots, "default")
        ]),
        Vue.createElementVNode("div", _hoisted_2$R, [
          $props.confirmText ? (Vue.openBlock(), Vue.createBlock(_component_Button, {
            key: 0,
            type: "danger",
            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("confirm"))
          }, {
            default: Vue.withCtx(() => [
              Vue.createTextVNode(Vue.toDisplayString($props.confirmText), 1)
            ]),
            _: 1
          })) : Vue.createCommentVNode("", true),
          $props.cancelText ? (Vue.openBlock(), Vue.createBlock(_component_Button, {
            key: 1,
            type: "gray",
            onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("cancel"))
          }, {
            default: Vue.withCtx(() => [
              Vue.createTextVNode(Vue.toDisplayString($props.cancelText), 1)
            ]),
            _: 1
          })) : Vue.createCommentVNode("", true)
        ])
      ]),
      _: 3
    }, 8, ["width"]);
  }
  var ModalConfirm = /* @__PURE__ */ _export_sfc(_sfc_main$1v, [["render", _sfc_render$T]]);
  var ModalTemplateSaveButton_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$1u = {
    name: "ModalTemplateSaveButton",
    components: {
      Button: _sfc_main$30
    },
    setup(props, { emit }) {
      const buttonType = Vue.computed(() => {
        return props.disabled ? "gray" : "secondary";
      });
      function onButtonClick() {
        if (!props.disabled) {
          emit("save-modal");
        }
      }
      return {
        buttonType,
        onButtonClick
      };
    }
  };
  const _hoisted_1$1c = { class: "znpb-modal-content-save-button" };
  const _hoisted_2$Q = { class: "znpb-modal-content-wrapper znpb-fancy-scrollbar" };
  const _hoisted_3$C = { class: "znpb-modal-content-save-button__button" };
  function _sfc_render$S(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Button = Vue.resolveComponent("Button");
    return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$1c, [
      Vue.createElementVNode("div", _hoisted_2$Q, [
        Vue.renderSlot(_ctx.$slots, "default")
      ]),
      Vue.createElementVNode("div", _hoisted_3$C, [
        Vue.createVNode(_component_Button, {
          type: $setup.buttonType,
          onClick: $setup.onButtonClick
        }, {
          default: Vue.withCtx(() => [
            Vue.createTextVNode(Vue.toDisplayString(_ctx.$translate("save")), 1)
          ]),
          _: 1
        }, 8, ["type", "onClick"])
      ])
    ]);
  }
  var ModalTemplateSaveButton = /* @__PURE__ */ _export_sfc(_sfc_main$1u, [["render", _sfc_render$S]]);
  const components = [
    _sfc_main$35,
    _sfc_main$30,
    _sfc_main$1V,
    _sfc_main$2t,
    _sfc_main$2P,
    _sfc_main$1K,
    _sfc_main$1J,
    Modal,
    ModalConfirm,
    ModalTemplateSaveButton,
    _sfc_main$34,
    Tooltip,
    _sfc_main$1O,
    _sfc_main$33,
    _sfc_main$1N,
    _sfc_main$2C,
    _sfc_main$2D,
    _sfc_main$2Q,
    _sfc_main$27,
    _sfc_main$2l,
    _sfc_main$1R,
    _sfc_main$2n,
    _sfc_main$32,
    _sfc_main$2O,
    _sfc_main$2v,
    _sfc_main$2s,
    _sfc_main$2q,
    _sfc_main$1x,
    _sfc_main$2w,
    _sfc_main$2$,
    _sfc_main$2j,
    _sfc_main$2i,
    _sfc_main$2c,
    _sfc_main$2d,
    InputCheckboxSwitch,
    _sfc_main$2W,
    _sfc_main$2a,
    InputRadio,
    InputRadioGroup,
    InputRadioIcon,
    InputDatePicker,
    _sfc_main$26,
    _sfc_main$25,
    _sfc_main$1X,
    _sfc_main$1U,
    _sfc_main$1Y,
    _sfc_main$2h,
    _sfc_main$2g,
    _sfc_main$2f,
    InputBorderRadiusTabs,
    _sfc_main$21,
    _sfc_main$20,
    _sfc_main$2k,
    _sfc_main$22,
    _sfc_main$31,
    _sfc_main$2G,
    InputSelect,
    _sfc_main$2F,
    _sfc_main$2E,
    _sfc_main$1S,
    _sfc_main$2Y,
    _sfc_main$2X,
    _sfc_main$1T,
    OptionsForm,
    _sfc_main$1M,
    _sfc_main$1I,
    _sfc_main$1P,
    _sfc_main$1H,
    _sfc_main$1G,
    getDefaultGradient
  ];
  function install(app) {
    components.forEach((component) => {
      app.component(component.name, component);
    });
    app.directive("znpb-tooltip", PopperDirective);
  }
  var COMMON = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    ListScroll: _sfc_main$35,
    install,
    Button: _sfc_main$30,
    UpgradeToPro: _sfc_main$1V,
    Label: _sfc_main$2t,
    EmptyList: _sfc_main$2P,
    Menu: _sfc_main$1K,
    HiddenMenu: _sfc_main$1J,
    Modal,
    ModalConfirm,
    ModalTemplateSaveButton,
    Icon: _sfc_main$34,
    Tooltip,
    Loader: _sfc_main$1O,
    Accordion: _sfc_main$33,
    Notice: _sfc_main$1N,
    Tabs: _sfc_main$2C,
    Tab: _sfc_main$2D,
    ColorPicker: _sfc_main$2Q,
    Color: _sfc_main$27,
    Injection: _sfc_main$2l,
    InputRadioImage: _sfc_main$1R,
    ActionsOverlay: _sfc_main$32,
    GradientPreview: _sfc_main$2O,
    GradientGenerator: _sfc_main$2v,
    GradientLibrary: _sfc_main$2s,
    HorizontalAccordion: _sfc_main$2q,
    IconPackGrid: _sfc_main$1x,
    Sortable: _sfc_main$2w,
    ChangesBullet: _sfc_main$2$,
    InputBackgroundImage: _sfc_main$2j,
    InputBackgroundVideo: _sfc_main$2i,
    InputCheckboxGroup: _sfc_main$2c,
    InputCheckbox: _sfc_main$2d,
    InputCheckboxSwitch,
    InputLabel: _sfc_main$2W,
    InputCode: _sfc_main$2a,
    InputRadio,
    InputRadioGroup,
    InputRadioIcon,
    InputDatePicker,
    InputColorPicker: _sfc_main$26,
    InputCustomSelector: _sfc_main$25,
    InputShapeDividers: _sfc_main$1X,
    ShapeDividerComponent: _sfc_main$1U,
    SvgMask: _sfc_main$1Y,
    InputBorderControl: _sfc_main$2h,
    InputBorderTabs: _sfc_main$2g,
    InputBorderRadius: _sfc_main$2f,
    InputBorderRadiusTabs,
    InputMedia: _sfc_main$21,
    InputFile: _sfc_main$20,
    InputImage: _sfc_main$2k,
    InputEditor: _sfc_main$22,
    BaseInput: _sfc_main$31,
    InputWrapper: _sfc_main$2G,
    InputSelect,
    InputRange: _sfc_main$2F,
    InputRangeDynamic: _sfc_main$2E,
    InputTextShadow: _sfc_main$1S,
    InputNumber: _sfc_main$2Y,
    InputNumberUnit: _sfc_main$2X,
    InputTextAlign: _sfc_main$1T,
    OptionsForm,
    OptionWrapper: _sfc_main$1M,
    InputSpacing: _sfc_main$1I,
    InputRepeater: _sfc_main$1P,
    InputDimensions: _sfc_main$1H,
    InputHTML: _sfc_main$1G,
    getDefaultGradient,
    utils: COMMONUTILS,
    useLibrary,
    units,
    useInjections,
    useOptions,
    useOptionsSchemas,
    useResponsiveDevices,
    usePseudoSelectors,
    useBuilderOptionsStore,
    useGoogleFontsStore,
    useNotificationsStore,
    useUsersStore,
    useDataSetsStore,
    useAssetsStore
  }, Symbol.toStringTag, { value: "Module" }));
  var LinkAttributeForm_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$1t = {
    name: "LinkAttributeForm",
    components: {
      BaseInput: _sfc_main$31
    },
    props: {
      attributeConfig: {
        type: Object
      },
      canDelete: {
        type: Boolean,
        required: false,
        default: true
      }
    },
    setup(props, { emit }) {
      function updateValue(key, value) {
        emit("update-attribute", __spreadProps(__spreadValues({}, props.attributeConfig), {
          [key]: value
        }));
      }
      return {
        updateValue
      };
    }
  };
  const _hoisted_1$1b = { class: "znpb-link-optionsAttribute" };
  const _hoisted_2$P = { class: "znpb-link-optionsAttributeInput znpb-link-optionsAttributeField" };
  const _hoisted_3$B = { class: "znpb-link-optionsAttributeInput znpb-link-optionsAttributeField" };
  const _hoisted_4$n = { class: "znpb-link-optionsAttributeDelete znpb-link-optionsAttributeField" };
  function _sfc_render$R(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_BaseInput = Vue.resolveComponent("BaseInput");
    const _component_Icon = Vue.resolveComponent("Icon");
    return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$1b, [
      Vue.createElementVNode("div", _hoisted_2$P, [
        Vue.createVNode(_component_BaseInput, {
          type: "text",
          placeholder: _ctx.$translate("attribute_key"),
          modelValue: $props.attributeConfig.key,
          spellcheck: false,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.updateValue("key", $event))
        }, null, 8, ["placeholder", "modelValue"])
      ]),
      Vue.createElementVNode("div", _hoisted_3$B, [
        Vue.createVNode(_component_BaseInput, {
          type: "text",
          placeholder: _ctx.$translate("attribute_value"),
          modelValue: $props.attributeConfig.value,
          spellcheck: false,
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $setup.updateValue("value", $event))
        }, null, 8, ["placeholder", "modelValue"])
      ]),
      Vue.createElementVNode("div", _hoisted_4$n, [
        Vue.createVNode(_component_Icon, {
          icon: "delete",
          class: Vue.normalizeClass({ "znpb-link-optionsAttributeDelete--disabled": !$props.canDelete }),
          onClick: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("delete", $props.attributeConfig))
        }, null, 8, ["class"])
      ])
    ]);
  }
  var LinkAttributeForm = /* @__PURE__ */ _export_sfc(_sfc_main$1t, [["render", _sfc_render$R]]);
  var Link_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$1s = {
    name: "Link",
    components: {
      Injection: _sfc_main$2l,
      Tooltip,
      LinkAttributeForm
    },
    props: {
      modelValue: {
        default() {
          return {};
        }
      },
      title: {},
      show_title: {
        type: Boolean,
        required: false,
        default: true
      },
      show_target: {
        type: Boolean,
        required: false,
        default: true
      }
    },
    setup(props, { emit }) {
      const urlInput = Vue.ref(false);
      const canShowSearchTooltip = Vue.ref(false);
      const popperRef = Vue.ref(false);
      const isSearchLoading = Vue.ref(false);
      const showResults = Vue.ref(false);
      const tooltipWidth = Vue.ref(null);
      const searchResults = Vue.ref([]);
      const linkURLComponent = Vue.computed(() => {
        return applyFilters("zionbuilder/options/link/url_component", "BaseInput", props.modelValue);
      });
      const linkModel = Vue.computed({
        get() {
          return props.modelValue && props.modelValue["link"] ? props.modelValue["link"] : "";
        },
        set(newValue) {
          emit("update:modelValue", __spreadProps(__spreadValues({}, props.modelValue), {
            link: newValue
          }));
        }
      });
      const targetModel = Vue.computed({
        get() {
          return props.modelValue && props.modelValue["target"] ? props.modelValue["target"] : "_self";
        },
        set(newValue) {
          emit("update:modelValue", __spreadProps(__spreadValues({}, props.modelValue), {
            target: newValue
          }));
        }
      });
      const titleModel = Vue.computed({
        get() {
          return props.modelValue && props.modelValue["title"] ? props.modelValue["title"] : "";
        },
        set(newValue) {
          emit("update:modelValue", __spreadProps(__spreadValues({}, props.modelValue), {
            title: newValue
          }));
        }
      });
      const linkAttributes = Vue.computed({
        get() {
          let attributes = get(props.modelValue, "attributes");
          if (Array.isArray(attributes) && attributes.length > 0) {
            return attributes;
          } else {
            return [
              {
                key: "",
                value: ""
              }
            ];
          }
        },
        set(newValue) {
          emit("update:modelValue", __spreadProps(__spreadValues({}, props.modelValue), {
            attributes: newValue
          }));
        }
      });
      const canDeleteAttributes = Vue.computed(() => linkAttributes.value.length > 1);
      function addLinkAttribute() {
        linkAttributes.value = [
          ...linkAttributes.value,
          {
            key: "",
            value: ""
          }
        ];
      }
      function deleteAttribute(index2) {
        const clone = [...linkAttributes.value];
        clone.splice(index2, 1);
        linkAttributes.value = clone;
      }
      function onAttributeUpdate(index2, attribute) {
        const clone = [...linkAttributes.value];
        clone.splice(index2, 1, attribute);
        linkAttributes.value = clone;
      }
      Vue.watchEffect(
        () => {
          canShowSearchTooltip.value = linkURLComponent.value === "BaseInput";
          popperRef.value = urlInput.value.$el;
        },
        {
          flush: "post"
        }
      );
      Vue.watch(linkModel, (newValue) => {
        if (newValue.length > 2 && newValue.indexOf("htt") === -1 && newValue.indexOf("#") !== 0) {
          searchPostDebounced();
        }
        if (newValue.length === 0) {
          showResults.value = false;
        }
      });
      const searchPostDebounced = debounce$1(() => {
        searchPost();
      }, 300);
      function searchPost() {
        const keyword = linkModel.value;
        const requester = window.zb.editor.serverRequest;
        isSearchLoading.value = true;
        requester.request(
          {
            type: "search_posts",
            config: {
              keyword
            }
          },
          (response) => {
            isSearchLoading.value = false;
            showResults.value = true;
            searchResults.value = response.data;
          },
          function(message) {
            console.error(message);
          }
        );
      }
      function onModalShow() {
        if (urlInput.value) {
          tooltipWidth.value = urlInput.value.$el.getBoundingClientRect().width;
        }
      }
      function onSearchItemClick(url) {
        linkModel.value = url;
        showResults.value = false;
      }
      return {
        titleModel,
        targetModel,
        linkModel,
        linkURLComponent,
        addLinkAttribute,
        linkAttributes,
        deleteAttribute,
        onAttributeUpdate,
        canDeleteAttributes,
        urlInput,
        popperRef,
        canShowSearchTooltip,
        isSearchLoading,
        showResults,
        onModalShow,
        onSearchItemClick,
        tooltipWidth,
        searchResults
      };
    },
    data() {
      return {
        targetOptions: [
          {
            id: "_blank",
            name: this.$translate("link_new_window")
          },
          {
            id: "_self",
            name: this.$translate("link_blank")
          }
        ]
      };
    }
  };
  const _hoisted_1$1a = { class: "znpb-link-wrapper" };
  const _hoisted_2$O = { class: "znpb-link-options" };
  const _hoisted_3$A = { class: "znpb-link-options-title" };
  const _hoisted_4$m = { class: "znpb-link-optionsAttributes" };
  const _hoisted_5$j = {
    key: 1,
    class: "znpb-menuList znpb-mh-200 znpb-fancy-scrollbar"
  };
  const _hoisted_6$e = ["onClick"];
  function _sfc_render$Q(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Loader = Vue.resolveComponent("Loader");
    const _component_Icon = Vue.resolveComponent("Icon");
    const _component_LinkAttributeForm = Vue.resolveComponent("LinkAttributeForm");
    const _component_Tooltip = Vue.resolveComponent("Tooltip");
    const _component_Injection = Vue.resolveComponent("Injection");
    const _component_InputWrapper = Vue.resolveComponent("InputWrapper");
    const _component_InputSelect = Vue.resolveComponent("InputSelect");
    const _component_BaseInput = Vue.resolveComponent("BaseInput");
    const _directive_znpb_tooltip = Vue.resolveDirective("znpb-tooltip");
    return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$1a, [
      Vue.createVNode(_component_InputWrapper, { layout: "full" }, {
        default: Vue.withCtx(() => [
          (Vue.openBlock(), Vue.createBlock(Vue.resolveDynamicComponent($setup.linkURLComponent), {
            ref: "urlInput",
            modelValue: $setup.linkModel,
            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $setup.linkModel = $event),
            placeholder: _ctx.$translate("add_an_url"),
            spellcheck: "false"
          }, {
            prepend: Vue.withCtx(() => [
              $setup.isSearchLoading ? (Vue.openBlock(), Vue.createBlock(_component_Loader, {
                key: 0,
                size: 14
              })) : (Vue.openBlock(), Vue.createBlock(_component_Icon, {
                key: 1,
                icon: "link"
              }))
            ]),
            append: Vue.withCtx(() => [
              Vue.createVNode(_component_Tooltip, {
                trigger: "click",
                "close-on-outside-click": true,
                "append-to": "body",
                "tooltip-class": "znpb-link-optionsTooltip",
                placement: "bottom-end",
                class: "znpb-flex znpb-flex--vcenter"
              }, {
                content: Vue.withCtx(() => [
                  Vue.createElementVNode("div", _hoisted_2$O, [
                    Vue.createElementVNode("div", _hoisted_3$A, Vue.toDisplayString(_ctx.$translate("link_attributes")), 1),
                    Vue.createElementVNode("div", _hoisted_4$m, [
                      (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList($setup.linkAttributes, (attribute, index2) => {
                        return Vue.openBlock(), Vue.createBlock(_component_LinkAttributeForm, {
                          key: index2,
                          "attribute-config": attribute,
                          "can-delete": $setup.canDeleteAttributes,
                          onUpdateAttribute: ($event) => $setup.onAttributeUpdate(index2, $event),
                          onDelete: ($event) => $setup.deleteAttribute(index2)
                        }, null, 8, ["attribute-config", "can-delete", "onUpdateAttribute", "onDelete"]);
                      }), 128)),
                      Vue.createElementVNode("div", {
                        class: "znpb-link-optionsAttributesAdd",
                        onClick: _cache[0] || (_cache[0] = (...args) => $setup.addLinkAttribute && $setup.addLinkAttribute(...args))
                      }, [
                        Vue.createVNode(_component_Icon, { icon: "plus" }),
                        Vue.createTextVNode(),
                        Vue.createElementVNode("span", null, Vue.toDisplayString(_ctx.$translate("add_custom_link_attribute")), 1)
                      ])
                    ])
                  ])
                ]),
                default: Vue.withCtx(() => [
                  Vue.withDirectives(Vue.createVNode(_component_Icon, { icon: "tags-attributes" }, null, 512), [
                    [_directive_znpb_tooltip, _ctx.$translate("edit_link_attributes")]
                  ])
                ]),
                _: 1
              }),
              Vue.createVNode(_component_Injection, { location: "options/link/append" })
            ]),
            _: 1
          }, 8, ["modelValue", "placeholder"]))
        ]),
        _: 1
      }),
      $props.show_target ? (Vue.openBlock(), Vue.createBlock(_component_InputWrapper, {
        key: 0,
        layout: "inline",
        schema: { width: 50 }
      }, {
        default: Vue.withCtx(() => [
          Vue.createVNode(_component_InputSelect, {
            modelValue: $setup.targetModel,
            "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $setup.targetModel = $event),
            options: $data.targetOptions
          }, null, 8, ["modelValue", "options"])
        ]),
        _: 1
      })) : Vue.createCommentVNode("", true),
      $props.show_title ? (Vue.openBlock(), Vue.createBlock(_component_InputWrapper, {
        key: 1,
        layout: "inline",
        schema: { width: 50 }
      }, {
        default: Vue.withCtx(() => [
          Vue.createVNode(_component_BaseInput, {
            modelValue: $setup.titleModel,
            "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => $setup.titleModel = $event),
            clearable: false,
            placeholder: _ctx.$translate("set_a_title")
          }, null, 8, ["modelValue", "placeholder"])
        ]),
        _: 1
      })) : Vue.createCommentVNode("", true),
      $setup.canShowSearchTooltip && $setup.popperRef ? (Vue.openBlock(), Vue.createBlock(_component_Tooltip, {
        key: 2,
        show: $setup.showResults,
        "onUpdate:show": _cache[4] || (_cache[4] = ($event) => $setup.showResults = $event),
        "popper-ref": $setup.popperRef,
        placement: "bottom",
        "show-arrows": false,
        "tooltip-style": { width: $setup.tooltipWidth + "px" },
        trigger: "click",
        "close-on-outside-click": true,
        "tooltip-class": "hg-popper--no-padding",
        onShow: $setup.onModalShow
      }, {
        content: Vue.withCtx(() => [
          $setup.isSearchLoading ? (Vue.openBlock(), Vue.createBlock(_component_Loader, {
            key: 0,
            size: 14
          })) : (Vue.openBlock(), Vue.createElementBlock("ul", _hoisted_5$j, [
            (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList($setup.searchResults, (post, index2) => {
              return Vue.openBlock(), Vue.createElementBlock("li", {
                key: index2,
                class: "znpb-menuListItem",
                onClick: ($event) => $setup.onSearchItemClick(post.url)
              }, Vue.toDisplayString(post.post_title), 9, _hoisted_6$e);
            }), 128))
          ]))
        ]),
        _: 1
      }, 8, ["show", "popper-ref", "tooltip-style", "onShow"])) : Vue.createCommentVNode("", true)
    ]);
  }
  var Link$1 = /* @__PURE__ */ _export_sfc(_sfc_main$1s, [["render", _sfc_render$Q]]);
  var Link = {
    id: "link",
    component: Link$1
  };
  var ColumnSize_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$1r = {
    name: "ColumnSize",
    props: {
      options: {
        type: Array
      },
      modelValue: {
        type: [String, Number],
        required: false
      }
    },
    computed: {
      valueModel: {
        get() {
          return this.modelValue;
        },
        set(newValue) {
          this.$emit("update:modelValue", newValue);
        }
      }
    },
    methods: {}
  };
  const _hoisted_1$19 = { class: "znpb-column-size" };
  const _hoisted_2$N = { class: "znpb-column-size-options" };
  const _hoisted_3$z = ["onClick"];
  function _sfc_render$P(_ctx, _cache, $props, $setup, $data, $options) {
    return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$19, [
      Vue.createElementVNode("div", _hoisted_2$N, [
        (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList($props.options, (option, index2) => {
          return Vue.openBlock(), Vue.createElementBlock("div", {
            key: index2,
            class: Vue.normalizeClass(["znpb-column-size__option", {
              "znpb-column-size__option--active": option.id === $options.valueModel
            }]),
            style: Vue.normalizeStyle({ flex: option.name === "auto" ? `0 0 ${100}%` : 1 }),
            onClick: ($event) => $options.valueModel = option.id
          }, Vue.toDisplayString(option.name), 15, _hoisted_3$z);
        }), 128))
      ])
    ]);
  }
  var ColumnSize$1 = /* @__PURE__ */ _export_sfc(_sfc_main$1r, [["render", _sfc_render$P]]);
  var ColumnSize = {
    id: "column_size",
    component: ColumnSize$1
  };
  var classCallCheck = function(instance2, Constructor) {
    if (!(instance2 instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };
  var createClass = function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  var inherits = function(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass)
      Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };
  var possibleConstructorReturn = function(self2, call) {
    if (!self2) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return call && (typeof call === "object" || typeof call === "function") ? call : self2;
  };
  var TypeRegistry = function() {
    function TypeRegistry2() {
      var initial = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      classCallCheck(this, TypeRegistry2);
      this.registeredTypes = initial;
    }
    createClass(TypeRegistry2, [{
      key: "get",
      value: function get2(type) {
        if (typeof this.registeredTypes[type] !== "undefined") {
          return this.registeredTypes[type];
        } else {
          return this.registeredTypes["default"];
        }
      }
    }, {
      key: "register",
      value: function register(type, item) {
        if (typeof this.registeredTypes[type] === "undefined") {
          this.registeredTypes[type] = item;
        }
      }
    }, {
      key: "registerDefault",
      value: function registerDefault(item) {
        this.register("default", item);
      }
    }]);
    return TypeRegistry2;
  }();
  var KeyExtractors = function(_TypeRegistry) {
    inherits(KeyExtractors2, _TypeRegistry);
    function KeyExtractors2(options2) {
      classCallCheck(this, KeyExtractors2);
      var _this = possibleConstructorReturn(this, (KeyExtractors2.__proto__ || Object.getPrototypeOf(KeyExtractors2)).call(this, options2));
      _this.registerDefault(function(el) {
        return el.getAttribute("name") || "";
      });
      return _this;
    }
    return KeyExtractors2;
  }(TypeRegistry);
  var InputReaders = function(_TypeRegistry) {
    inherits(InputReaders2, _TypeRegistry);
    function InputReaders2(options2) {
      classCallCheck(this, InputReaders2);
      var _this = possibleConstructorReturn(this, (InputReaders2.__proto__ || Object.getPrototypeOf(InputReaders2)).call(this, options2));
      _this.registerDefault(function(el) {
        return el.value;
      });
      _this.register("checkbox", function(el) {
        return el.getAttribute("value") !== null ? el.checked ? el.getAttribute("value") : null : el.checked;
      });
      _this.register("select", function(el) {
        return getSelectValue(el);
      });
      return _this;
    }
    return InputReaders2;
  }(TypeRegistry);
  function getSelectValue(elem) {
    var value, option, i;
    var options2 = elem.options;
    var index2 = elem.selectedIndex;
    var one = elem.type === "select-one";
    var values = one ? null : [];
    var max2 = one ? index2 + 1 : options2.length;
    if (index2 < 0) {
      i = max2;
    } else {
      i = one ? index2 : 0;
    }
    for (; i < max2; i++) {
      option = options2[i];
      if ((option.selected || i === index2) && !option.disabled && !(option.parentNode.disabled && option.parentNode.tagName.toLowerCase() === "optgroup")) {
        value = option.value;
        if (one) {
          return value;
        }
        values.push(value);
      }
    }
    return values;
  }
  var KeyAssignmentValidators = function(_TypeRegistry) {
    inherits(KeyAssignmentValidators2, _TypeRegistry);
    function KeyAssignmentValidators2(options2) {
      classCallCheck(this, KeyAssignmentValidators2);
      var _this = possibleConstructorReturn(this, (KeyAssignmentValidators2.__proto__ || Object.getPrototypeOf(KeyAssignmentValidators2)).call(this, options2));
      _this.registerDefault(function() {
        return true;
      });
      _this.register("radio", function(el) {
        return el.checked;
      });
      return _this;
    }
    return KeyAssignmentValidators2;
  }(TypeRegistry);
  function keySplitter(key) {
    var matches2 = key.match(/[^[\]]+/g);
    var lastKey = void 0;
    if (key.length > 1 && key.indexOf("[]") === key.length - 2) {
      lastKey = matches2.pop();
      matches2.push([lastKey]);
    }
    return matches2;
  }
  function getElementType(el) {
    var typeAttr = void 0;
    var tagName = el.tagName;
    var type = tagName;
    if (tagName.toLowerCase() === "input") {
      typeAttr = el.getAttribute("type");
      if (typeAttr) {
        type = typeAttr;
      } else {
        type = "text";
      }
    }
    return type.toLowerCase();
  }
  function getInputElements(element, options2) {
    return Array.prototype.filter.call(element.querySelectorAll("input,select,textarea"), function(el) {
      if (el.tagName.toLowerCase() === "input" && (el.type === "submit" || el.type === "reset")) {
        return false;
      }
      var myType = getElementType(el);
      var extractor = options2.keyExtractors.get(myType);
      var identifier = extractor(el);
      var foundInInclude = (options2.include || []).indexOf(identifier) !== -1;
      var foundInExclude = (options2.exclude || []).indexOf(identifier) !== -1;
      var foundInIgnored = false;
      var reject = false;
      if (options2.ignoredTypes) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = void 0;
        try {
          for (var _iterator = options2.ignoredTypes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var selector = _step.value;
            if (el.matches(selector)) {
              foundInIgnored = true;
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }
      if (foundInInclude) {
        reject = false;
      } else {
        if (options2.include) {
          reject = true;
        } else {
          reject = foundInExclude || foundInIgnored;
        }
      }
      return !reject;
    });
  }
  function assignKeyValue(obj, keychain, value) {
    if (!keychain) {
      return obj;
    }
    var key = keychain.shift();
    if (!obj[key]) {
      obj[key] = Array.isArray(key) ? [] : {};
    }
    if (keychain.length === 0) {
      if (!Array.isArray(obj[key])) {
        obj[key] = value;
      } else if (value !== null) {
        obj[key].push(value);
      }
    }
    if (keychain.length > 0) {
      assignKeyValue(obj[key], keychain, value);
    }
    return obj;
  }
  function serialize(element) {
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var data2 = {};
    options2.keySplitter = options2.keySplitter || keySplitter;
    options2.keyExtractors = new KeyExtractors(options2.keyExtractors || {});
    options2.inputReaders = new InputReaders(options2.inputReaders || {});
    options2.keyAssignmentValidators = new KeyAssignmentValidators(options2.keyAssignmentValidators || {});
    Array.prototype.forEach.call(getInputElements(element, options2), function(el) {
      var type = getElementType(el);
      var keyExtractor = options2.keyExtractors.get(type);
      var key = keyExtractor(el);
      var inputReader = options2.inputReaders.get(type);
      var value = inputReader(el);
      var validKeyAssignment = options2.keyAssignmentValidators.get(type);
      if (validKeyAssignment(el, key, value)) {
        var keychain = options2.keySplitter(key);
        data2 = assignKeyValue(data2, keychain, value);
      }
    });
    return data2;
  }
  (function(_TypeRegistry) {
    inherits(InputWriters, _TypeRegistry);
    function InputWriters(options2) {
      classCallCheck(this, InputWriters);
      var _this = possibleConstructorReturn(this, (InputWriters.__proto__ || Object.getPrototypeOf(InputWriters)).call(this, options2));
      _this.registerDefault(function(el, value) {
        el.value = value;
      });
      _this.register("checkbox", function(el, value) {
        if (value === null) {
          el.indeterminate = true;
        } else {
          el.checked = Array.isArray(value) ? value.indexOf(el.value) !== -1 : value;
        }
      });
      _this.register("radio", function(el, value) {
        if (value !== void 0) {
          el.checked = el.value === value.toString();
        }
      });
      _this.register("select", setSelectValue);
      return _this;
    }
    return InputWriters;
  })(TypeRegistry);
  function makeArray(arr) {
    var ret = [];
    if (arr !== null) {
      if (Array.isArray(arr)) {
        ret.push.apply(ret, arr);
      } else {
        ret.push(arr);
      }
    }
    return ret;
  }
  function setSelectValue(elem, value) {
    var optionSet, option;
    var options2 = elem.options;
    var values = makeArray(value);
    var i = options2.length;
    while (i--) {
      option = options2[i];
      if (values.indexOf(option.value) > -1) {
        option.setAttribute("selected", true);
        optionSet = true;
      }
    }
    if (!optionSet) {
      elem.selectedIndex = -1;
    }
  }
  const editorData$1 = Vue.ref(window.ZnPbInitialData);
  const useEditorData = () => {
    return {
      editorData: editorData$1
    };
  };
  const { editorData } = useEditorData();
  const userDataValues = Vue.reactive(__spreadValues({
    favorite_elements: []
  }, editorData.value.user_data));
  function useUserData() {
    function getUserData(key = null, defaultValue = null) {
      if (key !== null) {
        return userDataValues[key] || defaultValue;
      }
      return userDataValues;
    }
    function updateUserData(newData) {
      const dataToSave = __spreadValues(__spreadValues({}, userDataValues.value), newData);
      Object.assign(userDataValues, dataToSave);
      saveUserData(dataToSave).then((response) => {
        Object.assign(userDataValues, response.data);
      });
    }
    return {
      getUserData,
      updateUserData
    };
  }
  class ElementType {
    constructor(config) {
      __publicField(this, "element_type", "");
      __publicField(this, "name", "");
      __publicField(this, "component", null);
      __publicField(this, "category", "");
      __publicField(this, "deprecated", false);
      __publicField(this, "icon", "");
      __publicField(this, "thumb", "");
      __publicField(this, "is_child", false);
      __publicField(this, "keywords", []);
      __publicField(this, "label", "");
      __publicField(this, "options", {});
      __publicField(this, "scripts", {});
      __publicField(this, "styles", {});
      __publicField(this, "show_in_ui", true);
      __publicField(this, "style_elements", {});
      __publicField(this, "wrapper", false);
      __publicField(this, "content_orientation", "horizontal");
      Object.assign(this, config);
    }
    getComponent() {
      return this.component;
    }
    registerComponent(component) {
      this.component = Vue.markRaw(component);
    }
    resetComponent() {
      this.component = null;
    }
  }
  const useElementDefinitionsStore = defineStore("elementDefinitions", {
    state: () => {
      return {
        elementsDefinition: [
          new ElementType({
            element_type: "contentRoot",
            wrapper: true,
            show_in_ui: false,
            name: translate("root")
          })
        ],
        categories: []
      };
    },
    getters: {
      getVisibleElements: (state) => state.elementsDefinition.filter((element) => element.show_in_ui),
      getElementDefinition: (state) => (elementType) => find$1(state.elementsDefinition, { element_type: elementType }) || new ElementType({
        element_type: "invalid",
        name: translate("invalid_element")
      }),
      getElementIcon() {
        return (elementType) => {
          const element = this.getElementDefinition(elementType);
          return element.icon ? element.icon : null;
        };
      },
      getElementImage() {
        return (elementType) => {
          const element = this.getElementDefinition(elementType);
          return element.thumb ? element.thumb : null;
        };
      },
      getElementTypeCategory: (state) => (id) => find$1(state.categories, { id })
    },
    actions: {
      setCategories(categories) {
        this.categories = categories;
      },
      addElements(elements) {
        elements.forEach((elementConfig) => {
          this.addElement(elementConfig);
        });
      },
      addElement(config) {
        this.elementsDefinition.push(new ElementType(config));
      },
      registerElementComponent({ elementType, component }) {
        const element = this.getElementDefinition(elementType);
        if (!element) {
          console.warn(`element with ${elementType} could not be found.`);
          return;
        }
        element.component = Vue.markRaw(component);
      }
    }
  });
  const regenerateUIDs = (element) => {
    const uid = generateUID();
    element.uid = uid;
    if (Array.isArray(element.content)) {
      element.content = element.content.map((element2) => {
        return regenerateUIDs(element2);
      });
    }
    return element;
  };
  const removeElementID = (element) => {
    unset(element, "options._advanced_options._element_id");
    if (Array.isArray(element.content)) {
      element.content = element.content.map((element2) => {
        return removeElementID(element2);
      });
    }
    return element;
  };
  const regenerateUIDsForContent = (elements) => {
    return elements.map((element) => regenerateUIDs(element));
  };
  function getCssFromSelector(selectors, styleConfig, args = {}) {
    let css = "";
    if (styleConfig.styles) {
      css += getStyles$1(selectors.join(","), styleConfig.styles, args);
    }
    if (styleConfig.child_styles) {
      styleConfig.child_styles.forEach((childConfig) => {
        const { states = ["default"], selector, styles } = childConfig;
        const childSelectors = [];
        selectors.forEach((mainSelector) => {
          states.forEach((state) => {
            if (state === "default") {
              childSelectors.push(`${mainSelector} ${selector}`);
            } else {
              childSelectors.push(`${mainSelector}${state} ${selector}`);
            }
          });
        });
        css += getCssFromSelector(childSelectors, childConfig, args);
      });
    }
    return css;
  }
  function getStyles$1(cssSelector, styleValues = {}, args) {
    let compiledStyles = "";
    const { responsiveDevicesAsIdWidth: responsiveDevicesAsIdWidth2 } = useResponsiveDevices();
    Object.keys(responsiveDevicesAsIdWidth2.value).forEach((deviceId) => {
      const pseudoStyleValue = styleValues[deviceId];
      if (pseudoStyleValue) {
        let pseudoStyles = getPseudoStyles(cssSelector, pseudoStyleValue, args);
        compiledStyles += getResponsiveDeviceStyles(deviceId, pseudoStyles);
      }
    });
    return compiledStyles;
  }
  function getPseudoStyles(cssSelector, pseudoSelectors2 = {}, args) {
    let combinedStyles = "";
    if (args.forcehoverState) {
      if (typeof pseudoSelectors2[":hover"] !== "undefined") {
        const pseudoStyleValues = pseudoSelectors2[":hover"];
        combinedStyles += compilePseudoStyle(cssSelector, "default", pseudoStyleValues);
      }
    } else {
      Object.keys(pseudoSelectors2).forEach((pseudoSelectorId) => {
        const pseudoStyleValues = pseudoSelectors2[pseudoSelectorId];
        combinedStyles += compilePseudoStyle(cssSelector, pseudoSelectorId, pseudoStyleValues);
      });
    }
    return combinedStyles;
  }
  function compilePseudoStyle(cssSelector, pseudoSelector, styleValues) {
    const append = pseudoSelector !== "default" ? `${pseudoSelector}` : "";
    const compiledStyles = compileStyleTabs(styleValues);
    const content = styleValues.content;
    const contentStyle = content && content.length > 0 ? `content: '${content}';` : "";
    if (contentStyle || compiledStyles.length > 0) {
      return `${cssSelector}${append} { ${contentStyle}${compiledStyles} }`;
    }
    return "";
  }
  function getResponsiveDeviceStyles(deviceId, styles) {
    if (!deviceId || !styles) {
      return "";
    }
    const { responsiveDevicesAsIdWidth: responsiveDevicesAsIdWidth2 } = useResponsiveDevices();
    const responsiveWidthValue = responsiveDevicesAsIdWidth2.value[deviceId];
    const start2 = deviceId !== "default" ? `@media (max-width: ${responsiveWidthValue}px ) {` : "";
    const end2 = deviceId !== "default" ? `}` : "";
    return `${start2}${styles}${end2}`;
  }
  function compileStyleTabs(styleValues) {
    let combineStyles = "";
    let filtersGroup = "";
    const backgroundImageConfig = [];
    const _a3 = styleValues, {
      "background-gradient": backgroundGradient,
      "background-image": backgroundImage,
      "background-size": backgroundSize,
      "background-size-units": backgroundSizeUnits = {},
      "background-position-x": backgroundPositionX = "",
      "background-position-y": backgroundPositionY = "",
      "text-decoration": textDecoration,
      "text-shadow": textShadow = {},
      "box-shadow": boxShadow = {},
      border = {},
      "border-radius": borderRadius = {},
      transform = [],
      "transition-property": transitionProperty = "all",
      "transition-duration": transitionDuration = 0,
      "transition-timing-function": transitionTimingFunction = "linear",
      "transition-delay": transitionDelay = 0,
      "flex-reverse": flexReverse = false,
      "background-video": backGroundVideo = false,
      "custom-order": customFlexOrder = null,
      order: flexOrder = null,
      transform_origin_x_axis: transformOriginX,
      transform_origin_y_axis: transformOriginY,
      transform_origin_z_axis: transformOriginZ
    } = _a3, keyValueStyles = __objRest(_a3, [
      "background-gradient",
      "background-image",
      "background-size",
      "background-size-units",
      "background-position-x",
      "background-position-y",
      "text-decoration",
      "text-shadow",
      "box-shadow",
      "border",
      "border-radius",
      "transform",
      "transition-property",
      "transition-duration",
      "transition-timing-function",
      "transition-delay",
      "flex-reverse",
      "background-video",
      "custom-order",
      "order",
      "transform_origin_x_axis",
      "transform_origin_y_axis",
      "transform_origin_z_axis"
    ]);
    const filterProperties = [
      "grayscale",
      "sepia",
      "blur",
      "brightness",
      "saturate",
      "opacity",
      "contrast",
      "hue-rotate",
      "invert"
    ];
    const specialValues = {
      "flex-direction": (value) => {
        if (!flexReverse) {
          return value === "row" ? `-webkit-box-orient: horizontal; -webkit-box-direction:normal;  -ms-flex-direction: ${value}; flex-direction: ${value};` : `-webkit-box-orient: vertical; -webkit-box-direction:normal;  -ms-flex-direction: ${value}; flex-direction: ${value};`;
        } else {
          return value === "row" ? `-webkit-box-orient: horizontal; -webkit-box-direction:reverse; -ms-flex-direction: row-reverse; flex-direction: row-reverse;` : `-webkit-box-orient: vertical; -webkit-box-direction:reverse; -ms-flex-direction: column-reverse; flex-direction: column-reverse;`;
        }
      },
      "custom-order": (value) => {
        return `-ms-flex-order: ${value}; order: ${value};`;
      },
      order: (value) => {
        return `-ms-flex-order: ${value}; order: ${value};`;
      },
      "align-items": (value) => {
        let todelete = /flex-/gi;
        let cleanValue = value.replace(todelete, "");
        return `-webkit-box-align: ${cleanValue}; -ms-flex-align: ${cleanValue}; align-items: ${value};`;
      },
      "justify-content": (value) => {
        if (value === "space-around") {
          return `-ms-flex-pack: distribute; justify-content: space-around;`;
        } else if (value === "space-between") {
          return `-webkit-box-pack: justify; -ms-flex-pack: justify; justify-content: space-between;`;
        } else {
          let todelete = /flex-/gi;
          let cleanValue = value.replace(todelete, "");
          return `-webkit-box-pack: ${cleanValue}; -ms-flex-pack: ${cleanValue}; justify-content: ${value};`;
        }
      },
      "flex-wrap": (value) => {
        return `-ms-flex-wrap: ${value}; flex-wrap: ${value};`;
      },
      "align-content": (value) => {
        if (value === "space-around") {
          return `-ms-flex-line-pack: distribute; align-content: space-around;`;
        } else if (value === "space-between") {
          return `-ms-flex-line-pack: justify; align-content: space-between;`;
        } else {
          let todelete = /flex-/gi;
          let cleanValue = value.replace(todelete, "");
          return `-ms-flex-line-pack: ${cleanValue}; align-content: ${value};`;
        }
      },
      "flex-grow": (value) => {
        return `-webkit-box-flex: ${value}; -ms-flex-positive: ${value}; flex-grow: ${value};`;
      },
      "flex-shrink": (value) => {
        return `-ms-flex-negative: ${value};flex-shrink: ${value};`;
      },
      "flex-basis": (value) => {
        return `-ms-flex-preferred-size: ${value}; flex-basis: ${value};`;
      },
      "align-self": (value) => {
        let todelete = /flex-/gi;
        let cleanValue = value.replace(todelete, "");
        return `-ms-flex-item-align: ${cleanValue}; align-self:${value};`;
      },
      perspective: (value) => {
        return `perspective: ${value};`;
      },
      transform_style: (value) => {
        return `-ms-transform-style: ${value}; -webkit-transform-style: ${value}; transform-style: ${value};`;
      }
    };
    if (flexOrder || customFlexOrder) {
      const orderValue = customFlexOrder || flexOrder;
      combineStyles += `-ms-flex-order: ${orderValue}; order: ${orderValue};`;
    }
    Object.keys(keyValueStyles).forEach((property2) => {
      const value = keyValueStyles[property2];
      if (property2 !== "__dynamic_content__" && (value || value === 0)) {
        if (filterProperties.includes(property2)) {
          if (property2 === "hue-rotate") {
            filtersGroup += `${property2}(${value}deg) `;
          } else if (property2 === "blur") {
            filtersGroup += `${property2}(${value}px) `;
          } else
            filtersGroup += `${property2}(${value}%) `;
        } else if (typeof specialValues[property2] === "function") {
          combineStyles += specialValues[property2](value);
        } else {
          combineStyles += `${property2}: ${value};`;
        }
      }
    });
    if (transform.length) {
      let transformStyleString = "";
      let originStyleString = "";
      let perspectiveOrigin = {};
      transform.forEach((transformProperty) => {
        const property2 = transformProperty.property || "translate";
        const currentPropertyValues = transformProperty[property2];
        for (const propertyName in currentPropertyValues) {
          if (property2 === "transform-origin") {
            originStyleString += `${currentPropertyValues[propertyName]} `;
          } else if (property2 === "perspective") {
            if (propertyName === "perspective_value") {
              transformStyleString += `perspective(${currentPropertyValues[propertyName]}) `;
            }
            if (propertyName === "perspective_origin_x_axis") {
              perspectiveOrigin.x = `${currentPropertyValues[propertyName]}`;
            }
            if (propertyName === "perspective_origin_y_axis") {
              perspectiveOrigin.y = `${currentPropertyValues[propertyName]}`;
            }
          } else {
            transformStyleString += `${propertyName}(${currentPropertyValues[propertyName]}) `;
          }
        }
      });
      if (transformStyleString) {
        combineStyles += `-webkit-transform: ${transformStyleString};-ms-transform: ${transformStyleString};transform: ${transformStyleString};`;
      }
      if (originStyleString) {
        combineStyles += `-webkit-transform-origin: ${originStyleString}; transform-origin: ${originStyleString};`;
      }
      if (perspectiveOrigin.y !== void 0 || perspectiveOrigin.x !== void 0) {
        let xAxis = perspectiveOrigin.x !== void 0 ? perspectiveOrigin.x : "50%";
        let yAxis = perspectiveOrigin.y !== void 0 ? perspectiveOrigin.y : "50%";
        combineStyles += `-ms-perspective-origin: ${xAxis} ${yAxis}; -moz-perspective-origin: ${xAxis} ${yAxis}; -webkit-perspective-origin: ${xAxis} ${yAxis}; perspective-origin: ${xAxis} ${yAxis};`;
      }
    }
    if (transformOriginX || transformOriginY || transformOriginZ) {
      let originX = transformOriginX || "50%";
      let originY = transformOriginY || "50%";
      let originZ = transformOriginZ || "0";
      combineStyles += `transform-origin: ${originX} ${originY} ${originZ};-webkit-transform-origin: ${originX} ${originY} ${originZ};`;
    }
    if (backgroundGradient) {
      const gradientConfig = getGradientCss(backgroundGradient);
      if (gradientConfig) {
        backgroundImageConfig.push(gradientConfig);
      }
    }
    if (backgroundImage) {
      backgroundImageConfig.push(`url(${backgroundImage})`);
    }
    if (backgroundPositionX || backgroundPositionY) {
      const xPosition = backgroundPositionX || "50%";
      const yPosition = backgroundPositionY || "50%";
      combineStyles += `background-position: ${xPosition} ${yPosition};`;
    }
    if (backgroundImageConfig.length > 0) {
      combineStyles += `background-image: ${backgroundImageConfig.join(", ")};`;
    }
    if (backgroundSize && backgroundSize !== "custom") {
      combineStyles += `background-size: ${backgroundSize};`;
    } else if (backgroundSize === "custom") {
      const { x, y } = backgroundSizeUnits;
      if (x || y) {
        const { x: x2 = "auto", y: y2 = "auto" } = backgroundSizeUnits;
        combineStyles += `background-size: ${x2} ${y2};`;
      }
    }
    if (textDecoration) {
      let textDecorationValue = [];
      if (textDecoration.includes("underline")) {
        textDecorationValue.push("underline");
      }
      if (textDecoration.includes("line-through")) {
        textDecorationValue.push("line-through");
      }
      if (textDecorationValue.length > 0) {
        const textDecorationValueString = textDecorationValue.join(" ");
        combineStyles += `text-decoration: ${textDecorationValueString};`;
      }
      if (textDecoration.includes("italic")) {
        combineStyles += `font-style: italic;`;
      }
    }
    const shadow = compileShadow(textShadow);
    if (shadow) {
      combineStyles += `text-shadow: ${shadow};`;
    }
    const borderStyles = compileBorder(border);
    if (borderStyles) {
      combineStyles += borderStyles;
    }
    const borderRadiusStyles = compileBorderRadius(borderRadius);
    if (borderRadiusStyles) {
      combineStyles += borderRadiusStyles;
    }
    let transformGroup = {};
    if (filtersGroup.length) {
      combineStyles += `-webkit-filter: ${filtersGroup};filter: ${filtersGroup};`;
    }
    if (transformGroup["x"] !== void 0 || transformGroup["y"] !== void 0 || transformGroup["z"] !== void 0) {
      let xAxis = transformGroup["x"] !== void 0 ? transformGroup["x"] : "50%";
      let yAxis = transformGroup["y"] !== void 0 ? transformGroup["y"] : "50%";
      let zAxis = transformGroup["z"] !== void 0 ? transformGroup["z"] : "";
      combineStyles += `-webkit-transform-origin: ${xAxis} ${yAxis} ${zAxis}; transform-origin: ${xAxis} ${yAxis} ${zAxis};`;
    }
    if (boxShadow) {
      const shadow2 = compileShadow(boxShadow);
      if (shadow2) {
        combineStyles += `box-shadow: ${shadow2};`;
      }
    }
    if (transitionDuration) {
      let delayCompiled = transitionDelay !== 0 ? `${transitionDelay}ms` : "";
      combineStyles += `transition: ${transitionProperty} ${transitionDuration}ms ${transitionTimingFunction} ${delayCompiled};`;
    }
    return combineStyles;
  }
  function getGradientCss(config) {
    let gradient = [];
    let position;
    config.forEach((element) => {
      let colors = [];
      const colorsCopy = [...element.colors].sort((a, b) => {
        return a.position > b.position ? 1 : -1;
      });
      colorsCopy.forEach((color) => {
        colors.push(`${color.color} ${color.position}%`);
      });
      if (element.type === "radial") {
        const { x, y } = element.position || {
          x: 50,
          y: 50
        };
        position = `circle at ${x}% ${y}%`;
      } else {
        position = `${element.angle}deg`;
      }
      gradient.push(`${element.type}-gradient(${position}, ${colors.join(", ")})`);
    });
    gradient.reverse();
    return gradient.join(", ");
  }
  function compileShadow(textShadowValue) {
    let { "offset-x": offsetX, "offset-y": offsetY, blur, spread: spread2, color, inset } = textShadowValue;
    if (offsetX || offsetY || blur || spread2 || color || inset) {
      offsetX = offsetX || 0;
      offsetY = offsetY || 0;
      const shadowList = [offsetX, offsetY];
      if (blur) {
        shadowList.push(blur);
      }
      if (spread2) {
        shadowList.push(spread2);
      }
      if (color) {
        shadowList.push(color);
      }
      if (inset) {
        shadowList.push("inset");
      }
      return shadowList.join(" ");
    }
    return null;
  }
  function compileFontTab(styleValues) {
    let css = "";
    const _a3 = styleValues, {
      "font-display": fontDisplayGroup = {},
      "font-style": fontStyleGroup = {},
      "font-typography": fontTypography,
      "text-shadow": textShadow
    } = _a3, dynamicValues = __objRest(_a3, [
      "font-display",
      "font-style",
      "font-typography",
      "text-shadow"
    ]);
    const _b = fontStyleGroup, { "text-decoration": textDecoration } = _b, remainingFontStyleGroup = __objRest(_b, ["text-decoration"]);
    const keyValueProperties = __spreadValues(__spreadValues({}, dynamicValues), remainingFontStyleGroup);
    const { "line-height": lineHeight2, "letter-spacing": letterSpacing2 } = fontDisplayGroup;
    if (fontTypography) {
      const { "font-family": fontFamily, "font-settings": fontSettings } = fontTypography;
      if (fontFamily) {
        css += `font-family: ${fontFamily};`;
      }
      if (fontSettings) {
        const _c = fontSettings, { "font-size": fontSize2 } = _c, remainingProperties = __objRest(_c, ["font-size"]);
        if (fontSize2) {
          css += `font-size: ${fontSize2};`;
        }
        Object.keys(remainingProperties).forEach((cssProperty) => {
          if (remainingProperties[cssProperty]) {
            css += `${cssProperty}: ${remainingProperties[cssProperty]};`;
          }
        });
      }
    }
    if (lineHeight2) {
      css += `line-height: ${lineHeight2};`;
    }
    if (letterSpacing2) {
      css += `letter-spacing: ${letterSpacing2};`;
    }
    if (textDecoration) {
      let textDecorationValue = [];
      if (textDecoration.includes("underline")) {
        textDecorationValue.push("underline");
      }
      if (textDecoration.includes("strikethrough")) {
        textDecorationValue.push("line-through");
      }
      if (textDecorationValue.length > 0) {
        const textDecorationValueString = textDecorationValue.join(" ");
        css += `text-decoration: ${textDecorationValueString};`;
      }
      if (textDecoration.includes("italic")) {
        css += `font-style: italic;`;
      }
    }
    if (textShadow) {
      const shadow = compileShadow(textShadow);
      if (shadow) {
        css += `text-shadow: ${shadow};`;
      }
    }
    Object.keys(keyValueProperties).forEach((cssProperty) => {
      if (keyValueProperties[cssProperty]) {
        css += `${cssProperty}: ${keyValueProperties[cssProperty]};`;
      }
    });
    return css;
  }
  function compileBorder(borderValue) {
    let css = "";
    Object.keys(borderValue).forEach((borderPosition) => {
      const allBorders = borderPosition === "all";
      if (!borderValue[borderPosition]) {
        return;
      }
      const { width, color, style } = borderValue[borderPosition];
      if (!width) {
        return;
      }
      if (typeof width !== "undefined") {
        const styleValue = style || "solid";
        const colorValue = color || "";
        if (!allBorders) {
          css += `border-${borderPosition}: ${width} ${styleValue} ${colorValue};`;
        } else {
          css += `border: ${width} ${styleValue} ${colorValue};`;
        }
      }
    });
    return css;
  }
  function compileBorderRadius(borderRadiusValue) {
    let css = "";
    if (borderRadiusValue && Object.keys(borderRadiusValue).length === 0) {
      return css;
    }
    const borderTopLeft = typeof borderRadiusValue["border-top-left-radius"] !== "undefined" ? borderRadiusValue["border-top-left-radius"] : 0;
    const borderTopRight = typeof borderRadiusValue["border-top-right-radius"] !== "undefined" ? borderRadiusValue["border-top-right-radius"] : 0;
    const borderBottomLeft = typeof borderRadiusValue["border-bottom-left-radius"] !== "undefined" ? borderRadiusValue["border-bottom-left-radius"] : 0;
    const borderBottomRight = typeof borderRadiusValue["border-bottom-right-radius"] !== "undefined" ? borderRadiusValue["border-bottom-right-radius"] : 0;
    const bordersArray = [borderTopLeft, borderTopRight, borderBottomLeft, borderBottomRight];
    const equalBorders = bordersArray.every((v) => v === bordersArray[0]);
    if (equalBorders) {
      css += `border-radius: ${borderTopLeft};`;
    } else {
      css += `border-radius: ${borderTopLeft} ${borderTopRight} ${borderBottomRight} ${borderBottomLeft};`;
    }
    return css;
  }
  var UTILS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    regenerateUIDs,
    removeElementID,
    regenerateUIDsForContent,
    getCssFromSelector,
    getStyles: getStyles$1,
    getPseudoStyles,
    getResponsiveDeviceStyles,
    compileStyleTabs,
    getGradientCss,
    compileFontTab
  }, Symbol.toStringTag, { value: "Module" }));
  const serverRequest = new ServerRequest();
  var API = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    serverRequest
  }, Symbol.toStringTag, { value: "Module" }));
  class ZionElement {
    constructor(elementData, parent2) {
      __publicField(this, "element_type", "");
      __publicField(this, "content", []);
      __publicField(this, "uid", "");
      __publicField(this, "options", {});
      __publicField(this, "renderAttributes");
      __publicField(this, "parentUID", "");
      __publicField(this, "elementDefinition");
      __publicField(this, "isHighlighted", false);
      __publicField(this, "activeElementRename", false);
      __publicField(this, "scrollTo", false);
      __publicField(this, "isCut", false);
      __publicField(this, "widgetID", "");
      __publicField(this, "loading", false);
      __publicField(this, "serverRequester", null);
      __publicField(this, "addedTime", 0);
      __publicField(this, "isWrapper", false);
      __publicField(this, "callbacks", {});
      const contentStore = useContentStore();
      const elementDefinitionStore = useElementDefinitionsStore();
      this.elementDefinition = elementDefinitionStore.getElementDefinition(elementData.element_type);
      this.isWrapper = this.elementDefinition.wrapper;
      const parsedElement = Object.assign(
        {},
        {
          uid: generateUID(),
          content: [],
          options: {}
        },
        elementData
      );
      const options2 = isPlainObject(parsedElement.options) ? parsedElement.options : {};
      if (typeof options2._advanced_options !== "undefined" && !isPlainObject(parsedElement.options._advanced_options)) {
        options2._advanced_options = {};
      }
      this.uid = parsedElement.uid;
      this.element_type = parsedElement.element_type;
      this.options = options2;
      this.parentUID = parent2;
      this.addedTime = Date.now();
      const content = [];
      if (Array.isArray(elementData.content)) {
        elementData.content.forEach((el) => {
          const childElement = contentStore.registerElement(el, elementData.uid);
          content.push(childElement.uid);
        });
      }
      this.content = content;
      if (elementData.widget_id) {
        this.widgetID = elementData.widget_id;
      }
      this.serverRequester = this.createRequester();
    }
    get isRepeaterProvider() {
      return !!this.getOptionValue("_advanced_options.is_repeater_provider", false);
    }
    get isRepeaterConsumer() {
      return !!this.getOptionValue("_advanced_options.is_repeater_consumer", false);
    }
    get parent() {
      const contentStore = useContentStore();
      return contentStore.getElement(this.parentUID);
    }
    get name() {
      return get(this.options, "_advanced_options._element_name", this.elementDefinition.name);
    }
    set name(newName) {
      window.zb.run("editor/elements/rename", {
        elementUID: this.uid,
        newName
      });
    }
    get elementCssId() {
      let cssID = this.getOptionValue("_advanced_options._element_id", this.uid);
      cssID = applyFilters("zionbuilder/element/css_id", cssID, this);
      return cssID;
    }
    createRequester() {
      const request = (data2, successCallback, failCallback) => {
        const parsedData = JSON.parse(
          JSON.stringify(__spreadProps(__spreadValues(__spreadValues({}, applyFilters("zionbuilder/server_request/element_requester_data", {}, this)), data2), {
            useCache: true
          }))
        );
        return serverRequest.request(parsedData, successCallback, failCallback);
      };
      return {
        request
      };
    }
    setName(newName) {
      this.updateOptionValue("_advanced_options._element_name", newName);
    }
    getOptionValue(path, defaultValue = null) {
      return get(this.options, path, defaultValue);
    }
    updateOptionValue(path, newValue) {
      if (path) {
        update(this.options, path, () => newValue);
      } else {
        update(this, "options", () => newValue);
      }
      return this.options;
    }
    highlight() {
      if (!this.isHighlighted) {
        this.isHighlighted = true;
      }
    }
    unHighlight() {
      if (this.isHighlighted) {
        this.isHighlighted = false;
      }
    }
    get isVisible() {
      return get(this.options, "_isVisible", true);
    }
    set isVisible(isVisible) {
      window.zb.run("editor/elements/set_visibility", {
        elementUID: this.uid,
        isVisible
      });
    }
    setVisibility(isVisible) {
      update(this.options, "_isVisible", () => isVisible);
    }
    get indexInParent() {
      if (this.parent) {
        return this.parent.content.indexOf(this.uid);
      }
      return 0;
    }
    delete() {
      window.zb.run("editor/elements/delete", {
        elementUID: this.uid
      });
    }
    duplicate() {
      return window.zb.run("editor/elements/duplicate", {
        element: this
      });
    }
    toJSON() {
      const contentStore = useContentStore();
      const content = this.content.map((child) => {
        const element = contentStore.getElement(child);
        return element.toJSON();
      });
      const elementData = {
        uid: this.uid,
        content,
        element_type: this.element_type,
        options: this.options
      };
      if (this.widgetID) {
        elementData.widget_id = this.widgetID;
      }
      return JSON.parse(JSON.stringify(elementData));
    }
    wrapIn(wrapperType = "container") {
      window.zb.run("editor/elements/wrap_element", {
        wrapperType,
        element: this
      });
    }
    replaceChild(oldElement, newElement) {
      var _a3;
      const index2 = this.content.indexOf(oldElement.uid);
      if (newElement.parent) {
        pull$1((_a3 = newElement.parent) == null ? void 0 : _a3.content, newElement.uid);
      }
      newElement.parentUID = this.uid;
      this.content.splice(index2, 1, newElement.uid);
    }
    addChild(element, index2 = -1) {
      let elementInstance = null;
      if (element instanceof ZionElement) {
        elementInstance = element;
      } else {
        const contentStore = useContentStore();
        elementInstance = contentStore.registerElement(element, this.uid);
      }
      index2 = index2 === -1 ? this.content.length : index2;
      elementInstance.parentUID = this.uid;
      this.content.splice(index2, 0, elementInstance.uid);
      return elementInstance;
    }
    move(newParent, index2 = -1) {
      if (!this.parent) {
        return;
      }
      this.parent.removeChild(this);
      newParent.addChild(this, index2);
    }
    addChildren(elements, index2 = -1) {
      const addedElements = [];
      forEach(elements, (element) => {
        addedElements.push(this.addChild(element, index2));
        index2 = index2 !== -1 ? index2 + 1 : index2;
      });
      return addedElements;
    }
    removeChild(element) {
      const index2 = this.content.indexOf(element.uid);
      this.content.splice(index2, 1);
    }
    getClone() {
      const elementAsJson = this.toJSON();
      let clonedElement = regenerateUIDs(elementAsJson);
      clonedElement = removeElementID(clonedElement);
      return clonedElement;
    }
    trigger(type, ...data2) {
      const callbacks = this.callbacks[type] || [];
      callbacks.forEach((calback) => {
        calback(...data2);
      });
    }
    on(type, callback) {
      this.callbacks[type] = this.callbacks[type] || [];
      this.callbacks[type].push(callback);
    }
    off(type, callback) {
      const callbacks = this.callbacks[type] || [];
      const callbackIndex = callbacks.indexOf(callback);
      if (callbackIndex !== -1) {
        this.callbacks[type].splice(callbackIndex, 1);
      }
    }
  }
  const useContentStore = defineStore("content", {
    state: () => {
      return {
        areas: [],
        elements: []
      };
    },
    getters: {
      contentRootElement: (state) => state.elements.find((element) => element.uid === window.ZnPbInitialData.page_id),
      getArea: (state) => (areaID) => state.areas.find((area) => area.id === areaID),
      getAreaContentAsJSON(state) {
        return (areaID) => {
          const area = state.areas.find((area2) => area2.id === areaID);
          if (area) {
            return area.element.content.map((childUID) => {
              const element = this.getElement(childUID);
              return element.toJSON();
            });
          }
          return [];
        };
      },
      getElement: (state) => (elementUID) => state.elements.find((element) => element.uid === elementUID) || null,
      getElementName() {
        return (element) => {
          const elementName = get(element.options, "_advanced_options._element_name");
          if (elementName) {
            return elementName;
          } else {
            const elementsDefinitionStore = useElementDefinitionsStore();
            const elementDefinition = elementsDefinitionStore.getElementDefinition(element.element_type);
            return elementDefinition.name;
          }
        };
      },
      getElementIndexInParent() {
        return (element) => {
          var _a3;
          return (_a3 = element.parent) == null ? void 0 : _a3.content.indexOf(element.uid);
        };
      }
    },
    actions: {
      registerArea(areaConfig, areaContent) {
        const rootElement = {
          uid: areaConfig.id,
          element_type: "contentRoot",
          content: areaContent,
          options: {}
        };
        areaConfig.element = this.registerElement(rootElement);
        const existingAreaIndex = this.areas.findIndex((area) => area.id === areaConfig.id);
        if (existingAreaIndex >= 0) {
          this.areas.splice(existingAreaIndex, 1, areaConfig);
        } else {
          this.areas.push(areaConfig);
        }
      },
      registerElement(elementConfig, parentUID = "") {
        const newElement = new ZionElement(elementConfig, parentUID);
        const existingElementIndex = this.elements.findIndex((element) => element.uid === newElement.uid);
        if (existingElementIndex >= 0) {
          this.elements.splice(existingElementIndex, 1, newElement);
        } else {
          this.elements.push(newElement);
        }
        return newElement;
      },
      clearAreaContent(areaID) {
        const areaElement = this.getElement(areaID);
        if (areaElement) {
          [...areaElement.content].forEach((elementUID) => {
            this.deleteElement(elementUID);
          });
          areaElement.content = [];
        }
      },
      deleteElement(elementUID) {
        const element = this.getElement(elementUID);
        if (element) {
          if (element.parent) {
            pull$1(element.parent.content, element.uid);
          }
          if (element.content) {
            [...element.content].forEach((childUID) => this.deleteElement(childUID));
          }
          const UIStore = useUIStore();
          if (UIStore.editedElementUID === element.uid) {
            UIStore.unEditElement();
          }
          pull$1(this.elements, element);
        } else {
          console.log("element with uid not found");
        }
      },
      getElementValue(elementUID, path, defaultValue = null) {
        const element = this.getElement(elementUID);
        if (element) {
          return get(element, path, defaultValue);
        }
        return defaultValue;
      },
      updateElement(elementUID, path, newValue) {
        const element = this.getElement(elementUID);
        if (element) {
          set(element, path, newValue);
        }
      },
      duplicateElement(element) {
        if (!element.parent) {
          return;
        }
        const elementClone = element.getClone();
        const newElement = this.addElement(elementClone, element.parentUID, element.indexInParent + 1);
        return newElement;
      },
      addElement(elementConfig, parentUID, index2) {
        const parent2 = this.getElement(parentUID);
        if (!parent2) {
          return null;
        }
        const newElement = this.registerElement(elementConfig, parentUID);
        parent2.content.splice(index2, 0, newElement.uid);
        return newElement;
      },
      addElements(elements, parent2, index2 = -1) {
        const addedElementsUIDs = [];
        elements.forEach((element) => {
          addedElementsUIDs.push(this.addElement(element, parent2, index2));
          index2 = index2 !== -1 ? index2 + 1 : index2;
        });
        return addedElementsUIDs;
      }
    }
  });
  const useUIStore = defineStore("ui", {
    state: () => {
      const { getUserData } = useUserData();
      const UIUserData = getUserData();
      function getPanelData(panelID, extraData) {
        return Object.assign(
          {},
          {
            id: panelID,
            position: "relative",
            isDetached: false,
            isDragging: false,
            isExpanded: false,
            isActive: false,
            width: 360,
            height: null,
            group: null,
            saveOpenState: true,
            offsets: {
              posX: null,
              posY: null
            }
          },
          extraData,
          get(UIUserData, `panels.${panelID}`, {})
        );
      }
      const panels = [
        getPanelData("panel-element-options", {
          saveOpenState: false
        }),
        getPanelData("panel-global-settings", {
          saveOpenState: false
        }),
        getPanelData("preview-iframe", {
          isActive: true
        }),
        getPanelData("panel-history", {}),
        getPanelData("panel-tree", {})
      ];
      return {
        panelsOrder: get(UIUserData, "panelsOrder", [
          "panel-element-options",
          "panel-global-settings",
          "preview-iframe",
          "panel-history",
          "panel-tree"
        ]),
        panelPlaceholder: {},
        panels,
        mainBar: __spreadValues({
          position: "left",
          pointerEvents: false,
          draggingPosition: null
        }, UIUserData.mainBar || {}),
        mainBarDraggingPlaceholder: {
          top: null,
          left: null
        },
        iFrame: {
          pointerEvents: false
        },
        isLibraryOpen: false,
        isPreviewMode: false,
        loadTimestamp: 0,
        contentTimestamp: 0,
        isPreviewLoading: true,
        editedElementUID: null,
        activeElementMenu: null,
        isElementDragging: false,
        activeAddElementPopup: null,
        libraryInsertConfig: {}
      };
    },
    getters: {
      openPanels: (state) => filter(state.panels, { isActive: true }) || [],
      isAnyPanelDragging: (state) => filter(state.panels, { isDragging: true }).length > 0,
      editedElement: (state) => {
        const contentStore = useContentStore();
        return contentStore.getElement(state.editedElementUID);
      },
      openPanelsIDs() {
        return this.openPanels.map((panel) => panel.id);
      },
      getPanel: (state) => {
        return (panelId) => state.panels.find((panel) => panel.id === panelId);
      },
      getPanelPlacement: (state) => {
        return function(panelID) {
          const iframeIndex = state.panelsOrder.indexOf("preview-iframe");
          const panelIndex = state.panelsOrder.indexOf(panelID);
          return panelIndex < iframeIndex ? "left" : "right";
        };
      },
      getPanelOrder: (state) => {
        return function(panelID) {
          const panelIndex = state.panelsOrder.indexOf(panelID);
          return panelIndex != -1 ? panelIndex * 10 : 10;
        };
      },
      getPanelIndex: (state) => {
        return function(panelID) {
          return state.panelsOrder.indexOf(panelID);
        };
      }
    },
    actions: {
      setElementDragging(newValue) {
        this.isElementDragging = newValue;
      },
      setPreviewLoading(state) {
        this.isPreviewLoading = state;
      },
      setLoadTimestamp() {
        this.loadTimestamp = Date.now();
      },
      setContentTimestamp() {
        this.contentTimestamp = Date.now();
      },
      showElementMenu(element, selector, actions = {}) {
        if (this.isPreviewMode) {
          return;
        }
        this.activeElementMenu = {
          element,
          selector,
          actions,
          rand: new Date().getMilliseconds()
        };
      },
      showElementMenuFromEvent(element, event2) {
        let leftOffset = 0;
        let topOffset = 0;
        let scale = 1;
        if (event2.view !== window) {
          const iframe = window.frames["znpb-editor-iframe"];
          if (iframe) {
            const { left: left2, top: top2 } = iframe.getBoundingClientRect();
            const { scaleValue: scaleValue2 } = useResponsiveDevices();
            scale = scaleValue2.value / 100;
            leftOffset = left2;
            topOffset = top2;
          }
        }
        this.showElementMenu(element, {
          ownerDocument: window.document,
          getBoundingClientRect() {
            return {
              width: 0,
              height: 0,
              top: event2.clientY * scale + topOffset,
              left: event2.clientX * scale + leftOffset
            };
          }
        });
      },
      hideElementMenu() {
        this.activeElementMenu = null;
      },
      editElement(element) {
        this.editedElementUID = element.uid;
        this.openPanel("panel-element-options");
      },
      unEditElement() {
        this.closePanel("panel-element-options");
        this.editedElementUID = null;
      },
      openPanel(panelId) {
        const panelToOpen = this.getPanel(panelId);
        if (panelToOpen) {
          if (panelToOpen.group !== null) {
            this.openPanels.forEach((panel) => {
              if (panel.group !== null && panel.group === panelToOpen.group) {
                this.closePanel(panel.id);
              }
            });
          }
          panelToOpen.isActive = true;
          if (panelToOpen.saveOpenState) {
            this.saveUI();
          }
        }
      },
      closePanel(panelId) {
        const panel = this.getPanel(panelId);
        if (panel) {
          panel.isActive = false;
          if (panel.saveOpenState) {
            this.saveUI();
          }
        }
      },
      togglePanel(panelId) {
        const panel = this.getPanel(panelId);
        if (panel) {
          panel.isActive ? this.closePanel(panel.id) : this.openPanel(panel.id);
        }
      },
      updatePanel(panelId, key, value) {
        const panel = this.getPanel(panelId);
        if (panel) {
          panel[key] = value;
        }
      },
      setPanelPlaceholder(newValue) {
        this.panelPlaceholder = newValue;
      },
      setMainBarPosition(position) {
        this.mainBar.position = position;
        this.saveUI();
      },
      setIframePointerEvents(status) {
        this.iFrame.pointerEvents = status;
      },
      openLibrary(libraryInsertConfig = {}) {
        this.isLibraryOpen = true;
        this.libraryInsertConfig = libraryInsertConfig;
      },
      closeLibrary() {
        this.isLibraryOpen = false;
        this.libraryInsertConfig = {};
      },
      toggleLibrary() {
        this.isLibraryOpen = !this.isLibraryOpen;
      },
      saveUI() {
        const { updateUserData } = useUserData();
        const uiData = {
          mainBar: {
            position: this.mainBar.position
          },
          panels: {},
          panelsOrder: this.panelsOrder
        };
        this.panels.forEach((panel) => {
          const dataToReturn = {
            isDetached: panel.isDetached,
            offsets: panel.offsets,
            width: panel.width,
            height: panel.height,
            isActive: false
          };
          if (panel.saveOpenState) {
            dataToReturn.isActive = panel.isActive;
          }
          uiData.panels[panel.id] = dataToReturn;
        });
        updateUserData(uiData);
      },
      setPreviewMode(state) {
        this.isPreviewMode = state;
      },
      showAddElementsPopup(element, event2, placement = "inside") {
        if (this.activeAddElementPopup && this.activeAddElementPopup.element === element) {
          this.hideAddElementsPopup();
          return;
        }
        let leftOffset = 0;
        let topOffset = 0;
        let scale = 1;
        if (event2.view !== window) {
          const iframe = window.frames["znpb-editor-iframe"];
          if (iframe) {
            const { left: left2, top: top2 } = iframe.getBoundingClientRect();
            const { scaleValue: scaleValue2 } = useResponsiveDevices();
            scale = scaleValue2.value / 100;
            leftOffset = left2;
            topOffset = top2;
          }
        }
        let index2 = -1;
        if (placement === "next" && element.parent) {
          const elementUID = element.uid;
          index2 = element.parent.content.indexOf(elementUID) + 1;
          element = element.parent;
        }
        this.activeAddElementPopup = {
          element,
          selector: {
            ownerDocument: window.document,
            getBoundingClientRect() {
              return {
                width: 0,
                height: 0,
                top: event2.clientY * scale + topOffset,
                left: event2.clientX * scale + leftOffset
              };
            }
          },
          index: index2,
          key: Math.random()
        };
      },
      hideAddElementsPopup() {
        this.activeAddElementPopup = null;
      }
    }
  });
  const usePageSettingsStore = defineStore("pageSettings", {
    state: () => {
      return {
        settings: {}
      };
    },
    actions: {
      updatePageSettings(newValues) {
        this.settings = newValues;
      },
      unsetPageSettings() {
        this.settings = {};
      }
    }
  });
  const useCSSClassesStore = defineStore("CSSClasses", {
    state: () => {
      return {
        CSSClasses: [],
        copiedStyles: null
      };
    },
    getters: {
      getClassesByFilter: (state) => {
        return (keyword) => {
          const keyToLower = keyword.toLowerCase();
          return state.CSSClasses.filter(
            (cssClass) => cssClass.name.toLowerCase().indexOf(keyToLower) !== -1 || cssClass.id.toLowerCase().indexOf(keyToLower) !== -1
          );
        };
      },
      getClassConfig: (state) => {
        return (classId) => state.CSSClasses.find((classConfig) => classConfig.id === classId);
      },
      getStylesConfig() {
        return (classId) => {
          const config = this.getClassConfig(classId);
          if (!config) {
            alert(`class with id ${classId} not found`);
          }
          return config.styles || {};
        };
      }
    },
    actions: {
      addCSSClass(config) {
        const classToAdd = __spreadValues({}, config);
        classToAdd.uid = config.uid || generateUID();
        this.CSSClasses.push(classToAdd);
      },
      removeCSSClass(cssClass) {
        const cssClassIndex = this.CSSClasses.indexOf(cssClass);
        this.CSSClasses.splice(cssClassIndex, 1);
      },
      updateCSSClass(classId, newValues) {
        const editedClass = this.CSSClasses.find((cssClassConfig) => {
          return cssClassConfig.id === classId;
        });
        if (!editedClass) {
          console.warn("could not find class with config ", { classId, newValues });
          return;
        }
        const cssClassIndex = this.CSSClasses.indexOf(editedClass);
        const updatedValues = __spreadValues(__spreadValues({}, editedClass), newValues);
        this.CSSClasses[cssClassIndex] = updatedValues;
      },
      removeAllCssClasses() {
        this.CSSClasses = [];
      },
      setCSSClasses(newValue) {
        this.CSSClasses = newValue;
      },
      copyClassStyles(styles) {
        this.copiedStyles = cloneDeep(styles);
      },
      pasteClassStyles(classId) {
        const oldStyles = this.getStylesConfig(classId);
        const mergedStyles = merge$1(oldStyles || {}, cloneDeep(this.copiedStyles));
        this.updateCSSClass(classId, {
          styles: mergedStyles
        });
      }
    }
  });
  const useUserStore = defineStore("user", {
    state: () => {
      return {
        lockedUserInfo: null,
        permissions: window.ZnPbInitialData.user_permissions
      };
    },
    getters: {
      isPostLocked: (state) => state.lockedUserInfo && !!state.lockedUserInfo.message,
      userCanEditContent: (state) => !state.permissions.only_content
    },
    actions: {
      setPostLock(lockData) {
        this.lockedUserInfo = lockData;
      },
      takeOverPost() {
        this.lockedUserInfo = {};
      }
    }
  });
  const useHistoryStore = defineStore("history", {
    state: () => {
      return {
        state: [],
        activeHistoryIndex: -1,
        isDirty: false
      };
    },
    getters: {
      canUndo: (state) => {
        return state.activeHistoryIndex > 0;
      },
      canRedo: (state) => {
        return state.activeHistoryIndex < state.state.length - 1;
      }
    },
    actions: {
      addHistoryItem(item) {
        if (this.state.length === 0) {
          this.state.push({
            title: translate("editing_started")
          });
          this.activeHistoryIndex++;
        }
        this.activeHistoryIndex += 1;
        if (this.activeHistoryIndex !== this.state.length) {
          const itemsToRemove = this.state.length - this.activeHistoryIndex;
          this.state.splice(this.activeHistoryIndex, itemsToRemove, item);
        } else {
          this.state.push(item);
        }
        this.isDirty = true;
      },
      addHistoryItemDebounced: debounce$1(function(item) {
        this.addHistoryItem(item);
      }, 800),
      undo() {
        if (this.activeHistoryIndex - 1 >= 0) {
          const newHistoryIndex = this.activeHistoryIndex - 1;
          this.restoreHistoryToIndex(newHistoryIndex);
          this.isDirty = true;
        }
      },
      redo() {
        const newHistoryIndex = this.activeHistoryIndex + 1;
        if (newHistoryIndex < this.state.length) {
          this.restoreHistoryToIndex(newHistoryIndex);
          this.isDirty = true;
        }
      },
      restoreHistoryToIndex(newHistoryIndex) {
        if (newHistoryIndex === this.activeHistoryIndex) {
          return;
        }
        if (newHistoryIndex < this.activeHistoryIndex) {
          for (let i = this.activeHistoryIndex; i > newHistoryIndex; i--) {
            const historyItem = this.state[i];
            if (historyItem.undo) {
              historyItem.undo(historyItem);
            }
          }
        } else if (newHistoryIndex > this.activeHistoryIndex) {
          const historyForRestore = this.state.slice(this.activeHistoryIndex + 1, newHistoryIndex + 1);
          historyForRestore.forEach((historyItem) => {
            if (historyItem.redo) {
              historyItem.redo(historyItem);
            }
          });
        }
        this.activeHistoryIndex = newHistoryIndex;
        this.isDirty = true;
      }
    }
  });
  var STORE = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    useUIStore,
    usePageSettingsStore,
    useCSSClassesStore,
    useContentStore,
    useElementDefinitionsStore,
    useUserStore,
    useHistoryStore
  }, Symbol.toStringTag, { value: "Module" }));
  var WPWidget_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$18 = { class: "znpb-element-form__wp_widget" };
  const _hoisted_2$M = {
    key: 0,
    class: "znpb-element-form__wp_widget-loading"
  };
  const _hoisted_3$y = ["innerHTML"];
  const _sfc_main$1q = /* @__PURE__ */ Vue.defineComponent({
    __name: "WPWidget",
    props: {
      value: { default: () => {
        return {};
      } },
      element_type: null
    },
    emits: ["update:modelValue"],
    setup(__props, { emit }) {
      const props = __props;
      const UIStore = useUIStore();
      const form = Vue.ref(null);
      const loading = Vue.ref(true);
      const optionsFormContent = Vue.ref("");
      getOptionsForm(UIStore.editedElement).then((response) => {
        optionsFormContent.value = response.data.form;
        loading.value = false;
        const wp2 = window.wp;
        const jQuery = window.jQuery;
        Vue.nextTick(() => {
          if (wp2.textWidgets) {
            let widgetContainer = jQuery(form.value);
            const event2 = new jQuery.Event("widget-added");
            widgetContainer.addClass("open");
            wp2.textWidgets.handleWidgetAdded(event2, widgetContainer);
            wp2.mediaWidgets.handleWidgetAdded(event2, widgetContainer);
            if (wp2.customHtmlWidgets) {
              wp2.customHtmlWidgets.handleWidgetAdded(event2, widgetContainer);
            }
            jQuery(":input", jQuery(form.value)).on("input", onInputChange);
            jQuery(":input", jQuery(form.value)).on("change", onInputChange);
          }
        });
      });
      function onInputChange() {
        const widgetId = `widget-${props.element_type}`;
        const formData = serialize(form.value);
        emit("update:modelValue", formData[widgetId]["ZION_BUILDER_PLACEHOLDER_ID"]);
      }
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$18, [
          loading.value ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_2$M, Vue.toDisplayString(Vue.unref(translate)("loading")), 1)) : (Vue.openBlock(), Vue.createElementBlock("form", {
            key: 1,
            ref_key: "form",
            ref: form,
            innerHTML: optionsFormContent.value
          }, null, 8, _hoisted_3$y))
        ]);
      };
    }
  });
  var WPWidget = {
    id: "wp_widget",
    component: _sfc_main$1q
  };
  var TabGroup_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$1p = {
    name: "TabGroup",
    props: {
      modelValue: {
        type: Object,
        required: false
      },
      child_options: {
        type: Object
      }
    },
    setup(props, { emit }) {
      let activeTab = Vue.ref(null);
      const keys2 = Object.keys(props.child_options);
      activeTab.value = keys2[0];
      const valueModel = Vue.computed({
        get: () => {
          return typeof (props.modelValue || {})[activeTab.value] !== "undefined" ? (props.modelValue || {})[activeTab.value] || {} : {};
        },
        set: (newValue) => {
          const newValues = __spreadProps(__spreadValues({}, props.modelValue), {
            [activeTab.value]: newValue
          });
          if (null === newValue) {
            delete newValues[activeTab.value];
          }
          emit("update:modelValue", newValues);
        }
      });
      return {
        activeTab,
        valueModel
      };
    }
  };
  function _sfc_render$O(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_OptionsForm = Vue.resolveComponent("OptionsForm");
    const _component_Tab = Vue.resolveComponent("Tab");
    const _component_Tabs = Vue.resolveComponent("Tabs");
    return Vue.openBlock(), Vue.createBlock(_component_Tabs, {
      "tab-style": "group",
      class: "znpb-options__tab",
      activeTab: $setup.activeTab,
      "onUpdate:activeTab": _cache[1] || (_cache[1] = ($event) => $setup.activeTab = $event)
    }, {
      default: Vue.withCtx(() => [
        (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList($props.child_options, (tabConfig, tabId2) => {
          return Vue.openBlock(), Vue.createBlock(_component_Tab, {
            name: tabConfig.title,
            key: tabId2,
            id: tabId2
          }, {
            default: Vue.withCtx(() => [
              Vue.createVNode(_component_OptionsForm, {
                schema: $props.child_options[tabId2].child_options,
                modelValue: $setup.valueModel,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.valueModel = $event)
              }, null, 8, ["schema", "modelValue"])
            ]),
            _: 2
          }, 1032, ["name", "id"]);
        }), 128))
      ]),
      _: 1
    }, 8, ["activeTab"]);
  }
  var TabGroup$1 = /* @__PURE__ */ _export_sfc(_sfc_main$1p, [["render", _sfc_render$O]]);
  var TabGroup = {
    id: "tabs",
    component: TabGroup$1,
    config: {
      barebone: true
    }
  };
  const isSavePageLoading = Vue.ref(false);
  let previewWindow = null;
  function useSavePage() {
    const save = (status = "publish") => {
      const contentStore = useContentStore();
      const notificationsStore = useNotificationsStore();
      const pageSettings = usePageSettingsStore();
      const cssClasses = useCSSClassesStore();
      const { editorData: editorData2 } = useEditorData();
      const historyStore = useHistoryStore();
      const { responsiveDevices: responsiveDevices2 } = useResponsiveDevices();
      const pageData = {
        page_id: editorData2.value.page_id,
        template_data: contentStore.getAreaContentAsJSON(editorData2.value.page_id),
        page_settings: pageSettings.settings,
        css_classes: cssClasses.CSSClasses,
        breakpoints: responsiveDevices2.value
      };
      if (status) {
        pageData.status = status;
      }
      if (status !== "autosave") {
        isSavePageLoading.value = true;
      }
      return new Promise((resolve, reject) => {
        savePage(pageData).then((response) => {
          if (status !== "autosave") {
            notificationsStore.add({
              message: status === "publish" ? translate("page_saved_publish") : translate("page_saved"),
              delayClose: 5e3,
              type: "success"
            });
          }
          refreshPreviewWindow();
          historyStore.isDirty = false;
          return Promise.resolve(response);
        }).catch((error) => {
          notificationsStore.add({
            message: error.message,
            type: "error",
            delayClose: 5e3
          });
          reject(error);
        }).finally(() => {
          isSavePageLoading.value = false;
          resolve();
        });
      });
    };
    const savePage$1 = () => {
      return save();
    };
    const saveDraft = () => {
      return save("draft");
    };
    const saveAutosave = () => {
      return save("autosave");
    };
    function openPreviewPage(event2) {
      return __async(this, null, function* () {
        const { editorData: editorData2 } = useEditorData();
        yield saveDraft();
        previewWindow = window.open(editorData2.value.urls.preview_url, `zion-preview-${editorData2.value.page_id}`);
        event2.preventDefault();
      });
    }
    function refreshPreviewWindow() {
      if (previewWindow) {
        try {
          previewWindow.location.reload();
        } catch (error) {
        }
      }
    }
    return {
      savePage: savePage$1,
      saveDraft,
      saveAutosave,
      isSavePageLoading,
      previewWindow,
      openPreviewPage,
      refreshPreviewWindow
    };
  }
  const useKeyBindings = () => {
    const UIStore = useUIStore();
    const userStore = useUserStore();
    const { savePage: savePage2, isSavePageLoading: isSavePageLoading2 } = useSavePage();
    const { copyElement, pasteElement, resetCopiedElement, copyElementStyles, pasteElementStyles } = useElementActions();
    const { editorData: editorData2 } = useEditorData();
    const controlKey = Environment.isMac ? "metaKey" : "ctrlKey";
    const applyShortcuts = (e) => {
      if (e.which === 83 && e[controlKey] && !e.shiftKey) {
        e.preventDefault();
        if (!isSavePageLoading2.value) {
          savePage2();
        }
      }
      if (e.which === 80 && e[controlKey]) {
        UIStore.setPreviewMode(!UIStore.isPreviewMode);
        e.preventDefault();
      }
      if (isEditable()) {
        return;
      }
      if (UIStore.isPreviewMode) {
        return;
      }
      if (UIStore.editedElement && !userStore.permissions.only_content) {
        const activeElementFocus = UIStore.editedElement;
        if (e.which === 68 && e[controlKey] && !e.shiftKey) {
          activeElementFocus.duplicate();
          e.preventDefault();
        }
        if (e.which === 67 && e[controlKey] && !e.shiftKey) {
          copyElement(activeElementFocus);
        }
        if (e.which === 86 && e[controlKey] && !e.shiftKey) {
          pasteElement(activeElementFocus);
        }
        if (e.which === 88 && e[controlKey]) {
          copyElement(activeElementFocus, "cut");
        }
        if (e.code === "Escape") {
          resetCopiedElement();
        }
        if (e.which === 46 || Environment.isMac && e.which === 8) {
          activeElementFocus.delete();
        }
        if (e[controlKey] && e.shiftKey && e.which === 67) {
          copyElementStyles(activeElementFocus);
          e.preventDefault();
        }
        if (e[controlKey] && e.shiftKey && e.which === 86) {
          pasteElementStyles(activeElementFocus);
          e.preventDefault();
        }
        if (e.which === 72 && e[controlKey]) {
          if (activeElementFocus) {
            activeElementFocus.toggleVisibility();
            e.preventDefault();
          }
        }
      }
      if (e.which === 90 && e[controlKey] && !e.shiftKey) {
        const historyStore = useHistoryStore();
        if (historyStore.canUndo) {
          historyStore.undo();
        }
        e.preventDefault();
      }
      if (e.code === "KeyD" && e[controlKey] && e.shiftKey) {
        window.open(editorData2.value.urls.edit_page, "_blank");
      }
      if (e.which === 90 && e[controlKey] && e.shiftKey || e[controlKey] && e.which === 89) {
        const historyStore = useHistoryStore();
        if (historyStore.canRedo) {
          historyStore.redo();
        }
        e.preventDefault();
      }
      if (e.shiftKey && e.code === "KeyT") {
        UIStore.togglePanel("panel-tree");
        e.preventDefault();
      }
      if (e.shiftKey && e.code === "KeyL") {
        UIStore.toggleLibrary();
        e.preventDefault();
      }
      if (e.shiftKey && e.code === "KeyO") {
        UIStore.togglePanel("panel-global-settings");
        e.preventDefault();
      }
    };
    return {
      applyShortcuts
    };
  };
  const useElementProvide = () => {
    const provideElement = (element) => {
      Vue.provide("ZionElement", element);
    };
    const injectElement = () => {
      const element = Vue.inject("ZionElement");
      if (!element) {
        console.error("No element was provided");
      }
      return element;
    };
    return {
      provideElement,
      injectElement
    };
  };
  const windows = {
    main: window
  };
  const useWindows = () => {
    const getWindows = (windowID = null) => {
      return windowID ? windows[windowID] : windows;
    };
    const addWindow = (id, document2) => {
      windows[id] = document2;
    };
    const addEventListener = (type, callback, options2) => {
      forEach(windows, (doc) => {
        doc.addEventListener(type, callback, options2);
      });
    };
    const removeWindow = (id) => {
      delete windows[id];
    };
    const removeEventListener = (type, callback, options2) => {
      forEach(windows, (doc) => {
        doc.removeEventListener(type, callback, options2);
      });
    };
    return {
      getWindows,
      addWindow,
      removeWindow,
      addEventListener,
      removeEventListener
    };
  };
  const activeSaveElement = Vue.ref({});
  const useSaveTemplate = () => {
    const showSaveElement = (element, type = "template") => {
      activeSaveElement.value = {
        element,
        type
      };
    };
    const hideSaveElement = () => {
      activeSaveElement.value = {};
    };
    return {
      activeSaveElement,
      showSaveElement,
      hideSaveElement
    };
  };
  const localStorageKey = "zionbuilder";
  function useLocalStorage() {
    function getStorageData() {
      const savedData = localStorage.getItem(localStorageKey);
      return savedData !== null ? JSON.parse(savedData) : {};
    }
    function addData(path, value) {
      const storageData = getStorageData();
      set(storageData, path, value);
      localStorage.setItem(localStorageKey, JSON.stringify(storageData));
    }
    function getData(path, defaultValue = null) {
      const storageData = getStorageData();
      return get(storageData, path, defaultValue);
    }
    function removeData(path) {
      const storageData = getStorageData();
      unset(storageData, path);
      localStorage.setItem(localStorageKey, JSON.stringify(storageData));
    }
    return {
      addData,
      getData,
      removeData
    };
  }
  const copiedElement = Vue.ref({});
  const copiedElementStyles = Vue.ref(null);
  function useElementActions() {
    const { addData, getData, removeData } = useLocalStorage();
    const copyElement = (element, action = "copy") => {
      copiedElement.value = {
        element,
        action
      };
      if (action === "cut") {
        element.isCut = true;
        removeData("copiedElement");
      } else if (action === "copy") {
        copyElementStyles(element);
        copyElementClasses(element);
        addData("copiedElement", element.toJSON());
      }
    };
    const pasteElement = (element) => {
      let insertElement = element;
      let index2 = -1;
      const elementForPaste = copiedElement.value.element ? copiedElement.value.element.getClone() : getData("copiedElement");
      if (!elementForPaste) {
        return;
      }
      if (element.parent && (!element.isWrapper || elementForPaste.uid === element.uid)) {
        insertElement = element.parent;
        index2 = element.indexInParent + 1;
      }
      if (copiedElement.value.action === "cut" && copiedElement.value.element) {
        if (copiedElement.value.element === element) {
          copiedElement.value.element.isCut = false;
          copiedElement.value = {};
        } else {
          copiedElement.value.element.isCut = false;
          window.zb.run("editor/elements/move", {
            newParent: insertElement,
            element: copiedElement.value.element,
            index: index2
          });
        }
        copiedElement.value = {};
      } else {
        window.zb.run("editor/elements/copy", {
          parent: insertElement,
          copiedElement: elementForPaste,
          index: index2
        });
      }
    };
    const resetCopiedElement = () => {
      if (copiedElement.value && copiedElement.value.element && copiedElement.value.action === "cut") {
        copiedElement.value.element.isCut = false;
      }
      copiedElement.value = {};
    };
    const copyElementStyles = (element) => {
      const dataForSave = {
        styles: cloneDeep(element.options._styles),
        custom_css: get(element, "options._advanced_options._custom_css", "")
      };
      copiedElementStyles.value = dataForSave;
      addData("copiedElementStyles", dataForSave);
    };
    const pasteElementStyles = (element) => {
      const styles = getData("copiedElementStyles");
      if (!styles) {
        return;
      }
      window.zb.run("editor/elements/paste-styles", {
        element,
        styles
      });
    };
    const copyElementClasses = (element) => {
      const dataToSave = cloneDeep(get(element.options, "_styles.wrapper.classes", null));
      addData("copiedElementClasses", dataToSave);
    };
    const pasteElementClasses = (element) => {
      const classes = getData("copiedElementClasses");
      if (classes) {
        window.zb.run("editor/elements/paste-css-classes", {
          element,
          classes
        });
      }
    };
    return {
      copyElement,
      pasteElement,
      resetCopiedElement,
      copiedElement,
      copyElementStyles,
      pasteElementStyles,
      copiedElementStyles,
      copyElementClasses,
      pasteElementClasses
    };
  }
  var COMPOSABLES = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    useUserData,
    useSavePage,
    useKeyBindings,
    useEditorData,
    useElementProvide,
    useWindows,
    useSaveTemplate,
    useElementActions,
    useLocalStorage
  }, Symbol.toStringTag, { value: "Module" }));
  var PseudoDropdownItem_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$1o = {
    name: "PseudoDropdownItem",
    components: {
      ZionLabel
    },
    props: {
      selector: {
        type: Object,
        required: true
      },
      selectorsModel: {
        type: Object,
        required: false
      },
      clearable: {
        tye: Boolean,
        required: false
      }
    },
    data() {
      return {};
    },
    computed: {
      selectorsModelComputed() {
        return this.selectorsModel || {};
      },
      hasChanges() {
        const activeSelectorData = (this.selectorsModelComputed || {})[this.selector.id] || {};
        return Object.keys(activeSelectorData).length > 0;
      }
    },
    methods: {
      onDeleteSelector() {
        this.$emit("delete-selector", this.selector);
        this.$emit("selector-selected", null);
      },
      onSelectorSelected() {
        this.$emit("selector-selected", this.selector);
      }
    }
  };
  const _hoisted_1$17 = { class: "znpb-element-options__pseudo-actions" };
  function _sfc_render$N(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Icon = Vue.resolveComponent("Icon");
    const _component_Tooltip = Vue.resolveComponent("Tooltip");
    const _component_ChangesBullet = Vue.resolveComponent("ChangesBullet");
    const _component_ZionLabel = Vue.resolveComponent("ZionLabel");
    return Vue.openBlock(), Vue.createElementBlock("div", {
      class: "znpb-element-options__media-class-pseudo-selector",
      onClick: _cache[1] || (_cache[1] = Vue.withModifiers((...args) => $options.onSelectorSelected && $options.onSelectorSelected(...args), ["stop"]))
    }, [
      Vue.createTextVNode(Vue.toDisplayString($props.selector.name) + " ", 1),
      Vue.createElementVNode("div", _hoisted_1$17, [
        $props.clearable ? (Vue.openBlock(), Vue.createBlock(_component_Tooltip, {
          key: 0,
          content: "Delete Pseudo Selector",
          tag: "span"
        }, {
          default: Vue.withCtx(() => [
            Vue.createVNode(_component_Icon, {
              icon: "delete",
              onClick: Vue.withModifiers($options.onDeleteSelector, ["stop"])
            }, null, 8, ["onClick"])
          ]),
          _: 1
        })) : Vue.createCommentVNode("", true),
        $options.hasChanges ? (Vue.openBlock(), Vue.createBlock(_component_ChangesBullet, {
          key: 1,
          onRemoveStyles: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("remove-styles", $props.selector.id))
        })) : Vue.createCommentVNode("", true)
      ]),
      $props.selector.label ? (Vue.openBlock(), Vue.createBlock(_component_ZionLabel, {
        key: 0,
        text: $props.selector.label.text,
        type: $props.selector.label.type,
        class: "znpb-label--pro"
      }, null, 8, ["text", "type"])) : Vue.createCommentVNode("", true)
    ]);
  }
  var PseudoDropdownItem = /* @__PURE__ */ _export_sfc(_sfc_main$1o, [["render", _sfc_render$N]]);
  var PseudoSelectors_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$1n = {
    name: "PseudoSelectors",
    components: {
      PseudoDropdownItem
    },
    props: {
      modelValue: {
        type: [Object, Array],
        required: false,
        default: {}
      }
    },
    setup(props, { emit }) {
      const { activeResponsiveDeviceInfo: activeResponsiveDeviceInfo2 } = useResponsiveDevices();
      const { pseudoSelectors: pseudoSelectors2, activePseudoSelector: activePseudoSelector2, setActivePseudoSelector, deleteCustomSelector, addCustomSelector } = usePseudoSelectors();
      const { editorData: editorData2 } = useEditorData();
      const root2 = Vue.ref(null);
      const contentOpen = Vue.ref(false);
      const selectorIsOpen = Vue.ref(false);
      const showContentTooltip = Vue.ref(false);
      const newPseudoName = Vue.ref(false);
      const customPseudoName = Vue.ref("");
      const hasContent = Vue.computed(
        () => activePseudoSelector2.value.id === ":before" || activePseudoSelector2.value.id === ":after"
      );
      const activePseudoSelectors = Vue.computed(
        () => (props.modelValue || {})[activeResponsiveDeviceInfo2.value.id] || {}
      );
      const pseudoStyles = Vue.computed(() => (activePseudoSelectors.value || {})[activePseudoSelector2.value.id] || {});
      const pseudoContentModel = Vue.computed({
        get() {
          return pseudoStyles.value.content || "";
        },
        set(newValue) {
          const cloneModelValue = cloneDeep(props.modelValue);
          const newValues = set(
            cloneModelValue,
            `${activeResponsiveDeviceInfo2.value.id}.${activePseudoSelector2.value.id}.content`,
            newValue
          );
          emit("update:modelValue", newValues);
        }
      });
      const computedPseudoSelectors = Vue.computed(() => {
        const savedSelectors = Object.keys(activePseudoSelectors.value);
        const customSelectors = savedSelectors.filter((selector) => {
          return !find$1(pseudoSelectors2.value, ["id", selector]);
        });
        return [
          ...pseudoSelectors2.value,
          ...customSelectors.map((selector) => {
            return {
              name: selector,
              id: selector,
              canBeDeleted: true
            };
          })
        ];
      });
      function onPseudoSelectorSelected(pseudoConfig) {
        selectorIsOpen.value = false;
        setActivePseudoSelector(pseudoConfig || pseudoSelectors2.value[0]);
        if (activePseudoSelector2.value.id === "custom") {
          newPseudoName.value = true;
        }
        if (pseudoContentModel.value === "" && (activePseudoSelector2.value.id === "before" || activePseudoSelector2.value.id === "after")) {
          showContentTooltip.value = false;
          contentOpen.value = true;
        }
      }
      function createNewPseudoSelector() {
        newPseudoName.value = false;
        let newSel = {
          id: customPseudoName.value,
          name: customPseudoName.value,
          canBeDeleted: true
        };
        addCustomSelector(newSel);
        setActivePseudoSelector(newSel);
      }
      function closePanel(event2) {
        if (!root2.value.contains(event2.target)) {
          contentOpen.value = false;
          selectorIsOpen.value = false;
          newPseudoName.value = false;
        }
      }
      function deleteConfigForPseudoSelector(pseudoSelectorId) {
        const newValues = __spreadProps(__spreadValues({}, props.modelValue), {
          [activeResponsiveDeviceInfo2.value.id]: __spreadValues({}, props.modelValue[activeResponsiveDeviceInfo2.value.id])
        });
        delete newValues[activeResponsiveDeviceInfo2.value.id][pseudoSelectorId];
        if (Object.keys(newValues[activeResponsiveDeviceInfo2.value.id] || {}).length === 0) {
          delete newValues[activeResponsiveDeviceInfo2.value.id];
        }
        emit("update:modelValue", newValues);
      }
      function deletePseudoSelectorAndStyles(selector) {
        deleteConfigForPseudoSelector(selector.id);
        deleteCustomSelector(selector);
      }
      Vue.onBeforeUnmount(() => {
        setActivePseudoSelector(null);
      });
      return {
        root: root2,
        contentOpen,
        selectorIsOpen,
        showContentTooltip,
        newPseudoName,
        customPseudoName,
        activeResponsiveDeviceInfo: activeResponsiveDeviceInfo2,
        computedPseudoSelectors,
        activePseudoSelector: activePseudoSelector2,
        hasContent,
        activePseudoSelectors,
        plugin_info: editorData2.value.plugin_info,
        pseudoContentModel,
        onPseudoSelectorSelected,
        deleteConfigForPseudoSelector,
        createNewPseudoSelector,
        closePanel,
        deletePseudoSelectorAndStyles
      };
    },
    computed: {
      isPro() {
        return this.plugin_info.is_pro_active;
      },
      pseudoSelectors() {
        return this.pseudoSelectors.map((selectorConfig) => {
          const returnedSelector = __spreadProps(__spreadValues({}, selectorConfig), {
            active: true
          });
          if (!["default", ":hover"].includes(selectorConfig.id) && !this.isPro) {
            returnedSelector.active = false;
            returnedSelector.label = {
              text: this.$translate("pro"),
              type: "warning"
            };
          }
          return returnedSelector;
        });
      },
      newPseudoModel: {
        get() {
          return this.customPseudoName;
        },
        set(newVal) {
          this.customPseudoName = newVal.split(" ").join("").toLowerCase();
        }
      }
    },
    watch: {
      hasContent: function(newValue) {
        if (newValue) {
          this.showContentTooltip = true;
          setTimeout(() => {
            this.showContentTooltip = false;
          }, 2e3);
        }
      },
      selectorIsOpen: function(newValue, oldValue) {
        if (newValue) {
          document.addEventListener("click", this.closePanel);
        } else {
          document.removeEventListener("click", this.closePanel);
        }
      },
      contentOpen: function(newValue, oldValue) {
        if (newValue) {
          this.$nextTick(() => this.$refs.pseudoContentInput.focus());
          document.addEventListener("click", this.closePanel);
        } else {
          this.$refs.pseudoContentInput.blur();
          document.removeEventListener("click", this.closePanel);
        }
      },
      newPseudoName: function(newValue, oldValue) {
        if (newValue) {
          this.$nextTick(() => this.$refs.newpseudoInput.focus());
          document.addEventListener("click", this.closePanel);
        } else {
          this.$refs.newpseudoInput.blur();
          document.removeEventListener("click", this.closePanel);
        }
      }
    },
    beforeUnmount() {
      document.removeEventListener("click", this.closePanel);
    }
  };
  const _hoisted_1$16 = { class: "znpb-element-options__media-class-pseudo-name" };
  const _hoisted_2$L = { class: "znpb-element-options__media-class-pseudo-selector-list hg-popper-list" };
  function _sfc_render$M(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Icon = Vue.resolveComponent("Icon");
    const _component_Tooltip = Vue.resolveComponent("Tooltip");
    const _component_PseudoDropdownItem = Vue.resolveComponent("PseudoDropdownItem");
    const _component_BaseInput = Vue.resolveComponent("BaseInput");
    return Vue.openBlock(), Vue.createElementBlock("div", {
      ref: "root",
      class: "znpb-element-options__media-class-pseudo-holder",
      onClick: _cache[6] || (_cache[6] = ($event) => ($setup.selectorIsOpen = !$setup.selectorIsOpen, $setup.contentOpen = false, $setup.newPseudoName = false))
    }, [
      Vue.createElementVNode("span", _hoisted_1$16, Vue.toDisplayString($setup.activePseudoSelector.name), 1),
      $setup.hasContent ? (Vue.openBlock(), Vue.createBlock(_component_Tooltip, {
        key: 0,
        trigger: null,
        show: $setup.showContentTooltip,
        content: _ctx.$translate("add_pseudo_content"),
        placement: "top"
      }, {
        default: Vue.withCtx(() => [
          Vue.createVNode(_component_Icon, {
            icon: "edit",
            size: 12,
            class: "znpb-pseudo-selector__edit",
            onClick: _cache[0] || (_cache[0] = Vue.withModifiers(($event) => ($setup.contentOpen = !$setup.contentOpen, $setup.selectorIsOpen = false), ["stop"]))
          })
        ]),
        _: 1
      }, 8, ["show", "content"])) : Vue.createCommentVNode("", true),
      Vue.createVNode(_component_Tooltip, {
        "show-arrows": false,
        show: $setup.selectorIsOpen,
        trigger: null,
        "append-to": "element",
        placement: "bottom-end",
        "tooltip-class": "hg-popper--no-padding znpb-element-options__media-class-pseudo-selector-dropdown"
      }, {
        content: Vue.withCtx(() => [
          Vue.createElementVNode("div", _hoisted_2$L, [
            (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList($setup.computedPseudoSelectors, (selectorConfig, index2) => {
              return Vue.openBlock(), Vue.createBlock(_component_PseudoDropdownItem, {
                key: index2,
                selector: selectorConfig,
                "selectors-model": $setup.activePseudoSelectors,
                clearable: selectorConfig.canBeDeleted,
                class: "hg-popper-list__item",
                onRemoveStyles: $setup.deleteConfigForPseudoSelector,
                onSelectorSelected: $setup.onPseudoSelectorSelected,
                onDeleteSelector: $setup.deletePseudoSelectorAndStyles
              }, null, 8, ["selector", "selectors-model", "clearable", "onRemoveStyles", "onSelectorSelected", "onDeleteSelector"]);
            }), 128))
          ])
        ]),
        default: Vue.withCtx(() => [
          Vue.createElementVNode("div", {
            class: Vue.normalizeClass(["znpb-element-options__media-class-pseudo-title", {
              "znpb-element-options__media-class-pseudo-title--has-edit": $setup.activePseudoSelector.id === ":before" || $setup.activePseudoSelector.id === ":after"
            }])
          }, [
            Vue.createVNode(_component_Icon, {
              icon: "select",
              rotate: $setup.selectorIsOpen ? 180 : null
            }, null, 8, ["rotate"])
          ], 2)
        ]),
        _: 1
      }, 8, ["show"]),
      $setup.contentOpen ? (Vue.openBlock(), Vue.createElementBlock("div", {
        key: 1,
        class: "znpb-element-options__media-class-pseudo-title__before-after-content",
        onClick: _cache[3] || (_cache[3] = Vue.withModifiers(() => {
        }, ["stop"]))
      }, [
        Vue.createVNode(_component_BaseInput, {
          ref: "pseudoContentInput",
          modelValue: $setup.pseudoContentModel,
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $setup.pseudoContentModel = $event),
          clearable: true,
          placeholder: `Insert text ${$setup.activePseudoSelector.id} content`,
          onKeypress: _cache[2] || (_cache[2] = Vue.withKeys(($event) => $setup.contentOpen = false, ["enter"]))
        }, null, 8, ["modelValue", "placeholder"])
      ])) : Vue.createCommentVNode("", true),
      $setup.newPseudoName ? (Vue.openBlock(), Vue.createElementBlock("div", {
        key: 2,
        class: "znpb-element-options__media-class-pseudo-title__before-after-content",
        onClick: _cache[5] || (_cache[5] = Vue.withModifiers(() => {
        }, ["stop"]))
      }, [
        Vue.createVNode(_component_BaseInput, {
          ref: "newpseudoInput",
          modelValue: $options.newPseudoModel,
          "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => $options.newPseudoModel = $event),
          clearable: true,
          placeholder: _ctx.$translate("new_pseudo"),
          onKeypress: Vue.withKeys($setup.createNewPseudoSelector, ["enter"])
        }, null, 8, ["modelValue", "placeholder", "onKeypress"])
      ])) : Vue.createCommentVNode("", true)
    ], 512);
  }
  var PseudoSelectors = /* @__PURE__ */ _export_sfc(_sfc_main$1n, [["render", _sfc_render$M]]);
  var CssSelector_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$1m = {
    name: "CssSelector",
    props: {
      classConfig: {
        type: Object,
        required: false
      },
      name: {
        type: String,
        required: true
      },
      type: {
        type: String,
        required: true,
        default: "id"
      },
      isSelected: {
        type: Boolean,
        required: false,
        default: false
      },
      showDelete: {
        type: Boolean,
        required: false,
        default: false
      },
      showActions: {
        type: Boolean,
        required: false,
        default: true
      },
      showChangesBullet: {
        type: Boolean,
        required: false,
        default: false
      }
    },
    setup(props, { emit }) {
      const cssClasses = useCSSClassesStore();
      function handleDeleteClass() {
        if (props.showDelete) {
          emit("remove-class", props.classConfig.selector);
        }
      }
      return {
        handleDeleteClass,
        cssClasses
      };
    }
  };
  const _hoisted_1$15 = { class: "znpb-css-class-selector__item-content" };
  const _hoisted_2$K = { class: "znpb-css-class-selector__item-name" };
  const _hoisted_3$x = ["title"];
  function _sfc_render$L(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_ChangesBullet = Vue.resolveComponent("ChangesBullet");
    const _component_Icon = Vue.resolveComponent("Icon");
    const _directive_znpb_tooltip = Vue.resolveDirective("znpb-tooltip");
    return Vue.openBlock(), Vue.createElementBlock("div", {
      class: Vue.normalizeClass(["znpb-css-class-selector__item", { "znpb-css-class-selector__item--selected": $props.isSelected }])
    }, [
      Vue.createElementVNode("div", _hoisted_1$15, [
        Vue.createElementVNode("span", {
          class: Vue.normalizeClass(["znpb-css-class-selector__item-type", { [`znpb-css-class-selector__item-type--${$props.type}`]: $props.type }])
        }, Vue.toDisplayString($props.type), 3),
        Vue.createElementVNode("span", _hoisted_2$K, [
          Vue.createElementVNode("span", { title: $props.name }, Vue.toDisplayString($props.name), 9, _hoisted_3$x)
        ]),
        $props.showChangesBullet ? (Vue.openBlock(), Vue.createBlock(_component_ChangesBullet, {
          key: 0,
          "discard-changes-title": _ctx.$translate("remove_additional_classes"),
          onRemoveStyles: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("remove-extra-classes"))
        }, null, 8, ["discard-changes-title"])) : Vue.createCommentVNode("", true)
      ]),
      $props.showActions ? Vue.withDirectives((Vue.openBlock(), Vue.createBlock(_component_Icon, {
        key: 0,
        icon: "copy",
        class: "znpb-css-class-selector__item-copy",
        onClick: _cache[1] || (_cache[1] = Vue.withModifiers(($event) => _ctx.$emit("copy-styles"), ["stop"]))
      }, null, 512)), [
        [_directive_znpb_tooltip, _ctx.$translate("copy_element_styles")]
      ]) : Vue.createCommentVNode("", true),
      $props.showActions ? Vue.withDirectives((Vue.openBlock(), Vue.createBlock(_component_Icon, {
        key: 1,
        icon: "paste",
        class: Vue.normalizeClass(["znpb-css-class-selector__item-paste", {
          "znpb-css-class-selector__item-paste--disabled": !$setup.cssClasses.copiedStyles
        }]),
        onClick: _cache[2] || (_cache[2] = Vue.withModifiers(($event) => _ctx.$emit("paste-styles"), ["stop"]))
      }, null, 8, ["class"])), [
        [_directive_znpb_tooltip, _ctx.$translate("paste_element_styles")]
      ]) : Vue.createCommentVNode("", true),
      $props.showActions ? Vue.withDirectives((Vue.openBlock(), Vue.createBlock(_component_Icon, {
        key: 2,
        icon: "close",
        class: Vue.normalizeClass(["znpb-css-class-selector__item-close", {
          "znpb-css-class-selector__item-close--disabled": !$props.showDelete
        }]),
        onClick: Vue.withModifiers($setup.handleDeleteClass, ["stop"])
      }, null, 8, ["class", "onClick"])), [
        [_directive_znpb_tooltip, _ctx.$translate("delete_class_tooltip")]
      ]) : Vue.createCommentVNode("", true)
    ], 2);
  }
  var CssSelector = /* @__PURE__ */ _export_sfc(_sfc_main$1m, [["render", _sfc_render$L]]);
  var ClassSelectorDropdown_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$1l = {
    name: "ClassSelectorDropdown",
    components: {
      CssSelector
    },
    props: {
      selector: {
        type: String,
        required: true
      },
      modelValue: {
        type: Array
      },
      title: {
        type: String
      },
      activeClass: {
        type: String,
        required: true
      },
      allow_class_assignments: {
        type: Boolean,
        required: false,
        default: true
      },
      activeModelValue: {
        type: Object,
        required: false,
        default: {}
      }
    },
    setup(props, { emit }) {
      const cssClasses = useCSSClassesStore();
      const showRemoveExtraClasses = Vue.computed(() => {
        return props.modelValue && props.modelValue.length > 0;
      });
      function onCopyStyles(selectorConfig) {
        if (selectorConfig.type === "class") {
          const stylesConfig = cssClasses.getStylesConfig(selectorConfig.selector);
          cssClasses.copyClassStyles(stylesConfig);
        } else {
          cssClasses.copyClassStyles(props.activeModelValue);
        }
      }
      function onPasteStyles(selectorConfig) {
        if (selectorConfig.type === "class") {
          cssClasses.pasteClassStyles(selectorConfig.selector);
        } else {
          emit("paste-style-model");
        }
      }
      return {
        showRemoveExtraClasses,
        cssClasses,
        onCopyStyles,
        onPasteStyles
      };
    },
    data() {
      return {
        dropdownState: false,
        errorMessage: null,
        keyword: "",
        invalidClass: false,
        focusClassIndex: 0
      };
    },
    computed: {
      computedValue: {
        get() {
          return this.modelValue;
        },
        set(newValue) {
          this.$emit("update:modelValue", newValue);
        }
      },
      computedSelectorConfig() {
        return {
          type: "selector",
          selector: this.selector,
          name: this.title,
          deletable: false
        };
      },
      invalidClassReset() {
        return this.keyword.length > 0;
      },
      activeClassConfig() {
        if (this.activeClass !== this.selector) {
          let that = this;
          let className = this.cssClasses.CSSClasses.find(({ id }) => id === that.activeClass);
          return {
            type: "class",
            name: className ? className.name : that.activeClass
          };
        } else {
          return this.computedSelectorConfig;
        }
      },
      filteredClasses() {
        if (this.keyword.length === 0) {
          let extraClasses = [];
          this.computedValue.forEach((selector) => {
            let className = this.cssClasses.CSSClasses.find(({ id }) => id === selector);
            if (className) {
              extraClasses.push({
                type: "class",
                selector,
                name: className ? className.name : selector,
                deletable: true
              });
            }
          });
          return [this.computedSelectorConfig, ...extraClasses];
        } else {
          return this.cssClasses.getClassesByFilter(this.keyword).map((selectorConfig) => {
            return {
              type: "class",
              selector: selectorConfig.id,
              name: selectorConfig.name
            };
          });
        }
      }
    },
    watch: {
      dropdownState: function(newState, oldState) {
        if (newState) {
          document.addEventListener("click", this.closePanel);
          this.$nextTick(() => {
            if (this.$refs.input) {
              setTimeout(() => {
                this.$refs.input.focus();
              }, 50);
            }
          });
          this.keyword = "";
        } else {
          document.removeEventListener("click", this.closePanel);
          this.errorMessage = null;
          this.focusClassIndex = 0;
        }
      }
    },
    beforeUnmount() {
      document.removeEventListener("click", this.closePanel);
    },
    methods: {
      onKeyDown(event2) {
        let nextClass;
        if (this.filteredClasses.length !== 0) {
          this.$refs.input.blur();
          this.$refs.dropDownWrapper.focus();
          if (this.filteredClasses[this.focusClassIndex + 1]) {
            nextClass = this.filteredClasses[this.focusClassIndex + 1].selector;
            this.selectClass(nextClass);
            this.focusClassIndex += 1;
          }
        }
      },
      onKeyUp(event2) {
        let previousClass;
        if (this.filteredClasses.length !== 0) {
          this.$refs.input.blur();
          this.$refs.dropDownWrapper.focus();
          if (this.filteredClasses[this.focusClassIndex - 1]) {
            previousClass = this.filteredClasses[this.focusClassIndex - 1].selector;
            this.selectClass(previousClass);
            this.focusClassIndex -= 1;
          }
        }
      },
      onKeyEnter(event2) {
        this.dropdownState = false;
      },
      closePanel(event2) {
        if (event2.target === document) {
          this.dropdownState = false;
          return;
        }
        if (!this.$el.contains(event2.target) && event2.target.tagName !== "INPUT" && !event2.target.classList.contains("znpb-class-selector__add-class-button") && !this.dragOutside) {
          this.dropdownState = false;
        }
      },
      onRemoveExtraClasses() {
        this.computedValue = [];
        this.selectClass(this.selector);
      },
      removeClass(selector) {
        const classIndex = this.computedValue.indexOf(selector);
        const clonedValue = [...this.computedValue];
        const previousClassIndex = classIndex - 1;
        const previousClassSelector = this.computedValue[previousClassIndex];
        clonedValue.splice(classIndex, 1);
        this.computedValue = clonedValue;
        if (selector === this.activeClass) {
          const newSelector = previousClassSelector || this.selector;
          const newSelectorIndex = clonedValue.indexOf(newSelector);
          this.selectClass(newSelector);
          this.focusClassIndex = newSelectorIndex !== -1 ? newSelectorIndex + 1 : 0;
        }
        this.keyword = "";
        this.errorMessage = null;
      },
      handleClassInput(event2) {
        this.keyword = event2;
        if (!/-?[_a-zA-Z]+[_a-zA-Z0-9-]*/i.test(this.keyword)) {
          this.errorMessage = "Invalid class name, classes must not start with numbers and cannot contain spaces";
          this.invalidClass = true;
        } else {
          this.invalidClass = false;
          this.errorMessage = false;
        }
        if (!this.keyword.length) {
          this.errorMessage = false;
          this.invalidClass = false;
        }
      },
      addNewCssClass(event2) {
        if (!this.invalidClass && this.keyword.length) {
          this.dropdownState = false;
          const existingClass = this.cssClasses.CSSClasses.find((classItem) => {
            return classItem.name.toLowerCase() === this.keyword;
          });
          if (!existingClass) {
            this.cssClasses.addCSSClass({
              id: this.keyword,
              name: this.keyword
            });
          }
          this.selectClass(this.keyword);
          this.keyword = "";
        }
      },
      selectClass(selector) {
        if (selector && selector !== this.selector && this.computedValue.indexOf(selector) === -1) {
          const clonedValue = [...this.computedValue];
          clonedValue.push(selector);
          this.computedValue = clonedValue;
        }
        this.$emit("update:activeClass", selector);
      }
    }
  };
  const _hoisted_1$14 = { class: "znpb-class-selector" };
  const _hoisted_2$J = { key: 0 };
  const _hoisted_3$w = { class: "znpb-search-wrapper" };
  const _hoisted_4$l = {
    key: 1,
    class: "znpb-class-selector-noclass"
  };
  const _hoisted_5$i = {
    key: 2,
    class: "znpb-class-selector-validator"
  };
  function _sfc_render$K(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_BaseInput = Vue.resolveComponent("BaseInput");
    const _component_Button = Vue.resolveComponent("Button");
    const _component_CssSelector = Vue.resolveComponent("CssSelector");
    const _component_Tooltip = Vue.resolveComponent("Tooltip");
    return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$14, [
      Vue.createVNode(_component_Tooltip, {
        trigger: "null",
        show: $data.dropdownState,
        placement: "bottom-start",
        "tooltip-class": "znpb-class-selector__popper",
        "show-arrows": false
      }, {
        content: Vue.withCtx(() => [
          !$props.allow_class_assignments ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_2$J, Vue.toDisplayString(_ctx.$translate("add_class_assignment_not_allowed")), 1)) : (Vue.openBlock(), Vue.createElementBlock("div", {
            key: 1,
            ref: "dropDownWrapper",
            class: "znpb-class-selector-body",
            tabindex: "0",
            onKeydown: [
              _cache[0] || (_cache[0] = Vue.withKeys((...args) => $options.onKeyDown && $options.onKeyDown(...args), ["down"])),
              _cache[1] || (_cache[1] = Vue.withKeys((...args) => $options.onKeyUp && $options.onKeyUp(...args), ["up"])),
              _cache[2] || (_cache[2] = Vue.withKeys((...args) => $options.onKeyEnter && $options.onKeyEnter(...args), ["enter"])),
              _cache[3] || (_cache[3] = Vue.withKeys(Vue.withModifiers(($event) => $data.dropdownState = false, ["stop"]), ["esc"]))
            ]
          }, [
            Vue.createElementVNode("div", _hoisted_3$w, [
              Vue.createVNode(_component_BaseInput, {
                ref: "input",
                modelValue: $data.keyword,
                filterable: true,
                clearable: true,
                placeholder: _ctx.$translate("enter_class_name"),
                "onUpdate:modelValue": $options.handleClassInput,
                onKeydown: Vue.withKeys(Vue.withModifiers($options.addNewCssClass, ["stop"]), ["enter"])
              }, null, 8, ["modelValue", "placeholder", "onUpdate:modelValue", "onKeydown"]),
              Vue.createVNode(_component_Button, {
                type: "line",
                class: "znpb-class-selector__add-class-button",
                onClick: $options.addNewCssClass
              }, {
                default: Vue.withCtx(() => [
                  Vue.createTextVNode(Vue.toDisplayString(_ctx.$translate("add_class")), 1)
                ]),
                _: 1
              }, 8, ["onClick"])
            ]),
            $options.filteredClasses.length > 0 ? (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, { key: 0 }, Vue.renderList($options.filteredClasses, (cssClassItem) => {
              return Vue.openBlock(), Vue.createBlock(_component_CssSelector, {
                key: cssClassItem.selector,
                "class-config": cssClassItem,
                name: cssClassItem.name,
                type: cssClassItem.type,
                "is-selected": cssClassItem.selector === $props.activeClass,
                "show-delete": cssClassItem.deletable,
                onRemoveClass: $options.removeClass,
                onClick: ($event) => ($options.selectClass(cssClassItem.selector), $data.dropdownState = false),
                onCopyStyles: ($event) => $setup.onCopyStyles(cssClassItem),
                onPasteStyles: ($event) => $setup.onPasteStyles(cssClassItem)
              }, null, 8, ["class-config", "name", "type", "is-selected", "show-delete", "onRemoveClass", "onClick", "onCopyStyles", "onPasteStyles"]);
            }), 128)) : Vue.createCommentVNode("", true),
            !$data.errorMessage && $options.filteredClasses.length === 0 ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_4$l, Vue.toDisplayString(_ctx.$translate("no_class_found")), 1)) : Vue.createCommentVNode("", true),
            $data.invalidClass ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_5$i, Vue.toDisplayString($data.errorMessage), 1)) : Vue.createCommentVNode("", true)
          ], 544))
        ]),
        default: Vue.withCtx(() => [
          Vue.createVNode(_component_CssSelector, Vue.mergeProps($options.activeClassConfig, {
            "class-config": $options.activeClassConfig,
            "show-delete": false,
            "show-actions": false,
            class: "znpb-class-selector-trigger",
            "show-changes-bullet": $setup.showRemoveExtraClasses,
            onClick: _cache[4] || (_cache[4] = ($event) => $data.dropdownState = !$data.dropdownState),
            onRemoveExtraClasses: $options.onRemoveExtraClasses
          }), null, 16, ["class-config", "show-changes-bullet", "onRemoveExtraClasses"])
        ]),
        _: 1
      }, 8, ["show"])
    ]);
  }
  var ClassSelectorDropdown = /* @__PURE__ */ _export_sfc(_sfc_main$1l, [["render", _sfc_render$K]]);
  var ElementStyles_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$1k = {
    name: "ElementStyles",
    components: {
      PseudoSelectors,
      ClassSelectorDropdown
    },
    props: {
      modelValue: {
        type: Object,
        default: {}
      },
      title: {
        type: String
      },
      selector: {
        type: String
      },
      allow_class_assignments: {
        type: Boolean,
        required: false,
        default: true
      }
    },
    setup(props, { emit }) {
      const { getSchema } = useOptionsSchemas();
      const cssClasses = useCSSClassesStore();
      const activeClass = Vue.ref(props.selector);
      Vue.watch(
        () => props.selector,
        (newValue) => {
          activeClass.value = newValue;
        }
      );
      function onPasteToSelector() {
        const clonedCopiedStyles = cloneDeep(cssClasses.copiedStyles);
        if (!props.modelValue.styles) {
          updateValues("styles", clonedCopiedStyles);
        } else {
          updateValues("styles", merge$1(props.modelValue.styles, clonedCopiedStyles));
        }
      }
      function updateValues(type, newValue) {
        const clonedValue = __spreadValues({}, props.modelValue);
        if (newValue === null && typeof clonedValue[type]) {
          delete clonedValue[type];
        } else {
          clonedValue[type] = newValue;
        }
        emit("update:modelValue", clonedValue);
      }
      return {
        getSchema,
        cssClasses,
        onPasteToSelector,
        updateValues,
        activeClass
      };
    },
    computed: {
      computedClasses: {
        get() {
          return this.modelValue ? this.modelValue.classes || [] : [];
        },
        set(newValue) {
          this.$emit("update:modelValue", __spreadProps(__spreadValues({}, this.modelValue), {
            classes: newValue
          }));
        }
      },
      computedStyles: {
        get() {
          if (this.activeClass !== this.selector) {
            const activeClassConfig = this.cssClasses.getClassConfig(this.activeClass);
            if (activeClassConfig) {
              return activeClassConfig.styles;
            }
            console.warn(`Class with id ${this.activeClass} not found`);
            return {};
          } else {
            return this.modelValue.styles;
          }
        },
        set(newValues) {
          if (this.activeClass !== this.selector) {
            this.cssClasses.updateCSSClass(this.activeClass, {
              styles: newValues
            });
          } else {
            this.updateValues("styles", newValues);
          }
        }
      }
    }
  };
  const _hoisted_1$13 = { class: "znpb-element-styles__wrapper" };
  const _hoisted_2$I = { class: "znpb-element-styles__media-wrapper" };
  function _sfc_render$J(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_ClassSelectorDropdown = Vue.resolveComponent("ClassSelectorDropdown");
    const _component_PseudoSelectors = Vue.resolveComponent("PseudoSelectors");
    const _component_OptionsForm = Vue.resolveComponent("OptionsForm");
    return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$13, [
      Vue.createElementVNode("div", _hoisted_2$I, [
        Vue.createVNode(_component_ClassSelectorDropdown, {
          modelValue: $options.computedClasses,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $options.computedClasses = $event),
          activeClass: $setup.activeClass,
          "onUpdate:activeClass": _cache[1] || (_cache[1] = ($event) => $setup.activeClass = $event),
          selector: $props.selector,
          title: $props.title,
          allow_class_assignments: $props.allow_class_assignments,
          "active-model-value": $props.modelValue.styles,
          onPasteStyleModel: $setup.onPasteToSelector
        }, null, 8, ["modelValue", "activeClass", "selector", "title", "allow_class_assignments", "active-model-value", "onPasteStyleModel"]),
        Vue.createVNode(_component_PseudoSelectors, {
          modelValue: $options.computedStyles,
          "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $options.computedStyles = $event)
        }, null, 8, ["modelValue"])
      ]),
      Vue.createVNode(_component_OptionsForm, {
        modelValue: $options.computedStyles,
        "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => $options.computedStyles = $event),
        schema: $setup.getSchema("element_styles"),
        class: "znpb-element-styles-option__options-wrapper"
      }, null, 8, ["modelValue", "schema"])
    ]);
  }
  var ElementStyles$1 = /* @__PURE__ */ _export_sfc(_sfc_main$1k, [["render", _sfc_render$J]]);
  var ElementStyles = {
    id: "element_styles",
    component: ElementStyles$1,
    config: {
      barebone: true
    }
  };
  const scriptRel = "modulepreload";
  const seen = {};
  const base = "/";
  const __vitePreload = function preload(baseModule, deps) {
    if (true) {
      return baseModule();
    }
    return Promise.all(deps.map((dep) => {
      dep = `${base}${dep}`;
      if (dep in seen)
        return;
      seen[dep] = true;
      const isCss = dep.endsWith(".css");
      const cssSelector = isCss ? '[rel="stylesheet"]' : "";
      if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
        return;
      }
      const link = document.createElement("link");
      link.rel = isCss ? "stylesheet" : scriptRel;
      if (!isCss) {
        link.as = "script";
        link.crossOrigin = "";
      }
      link.href = dep;
      document.head.appendChild(link);
      if (isCss) {
        return new Promise((res, rej) => {
          link.addEventListener("load", res);
          link.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep}`)));
        });
      }
    })).then(() => baseModule());
  };
  var AddSelector_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$1j = {
    name: "AddSelector",
    props: {
      type: {
        type: String,
        required: false,
        default: "selector"
      }
    },
    setup(props, { emit }) {
      const showAddModal = Vue.ref(false);
      const hasError = Vue.ref(false);
      const schema = Vue.computed(() => {
        return {
          title: {
            type: "text",
            title: props.type === "selector" ? translate("selector_nice_name") : translate("class_nice_name"),
            description: props.type === "selector" ? translate("enter_the_class_nice_name") : translate("enter_the_class_nice_name")
          },
          selector: {
            type: "text",
            title: props.type === "selector" ? translate("css_selector") : translate("css_class"),
            description: props.type === "selector" ? translate("enter_the_css_selector_you_want_to_style") : translate("enter_class_name_without_dot"),
            placeholder: props.type === "selector" ? translate("my_selector") : translate("css_class_placeholder"),
            error: props.type === "class" && hasError.value ? true : false
          }
        };
      });
      const buttonTitle = Vue.computed(() => {
        return props.type == "selector" ? translate("add_child_selector") : translate("add_css_class");
      });
      const formModel = Vue.ref({});
      const computedFormModel = Vue.computed({
        get() {
          return formModel.value;
        },
        set(newValue) {
          if (null === newValue) {
            formModel.value = {};
          } else {
            formModel.value = newValue;
          }
        }
      });
      const canSave = Vue.computed(() => {
        return formModel.value.title && formModel.value.title.length > 0 && formModel.value.selector && formModel.value.selector.length > 0;
      });
      const buttonType = Vue.computed(() => {
        if (!canSave.value) {
          return "disabled";
        }
        return "";
      });
      function openModal() {
        showAddModal.value = true;
      }
      function closeModal() {
        showAddModal.value = false;
      }
      function toggleModal() {
        showAddModal.value = !showAddModal.value;
      }
      function onFormClose() {
        showAddModal.value = false;
        formModel.value = {};
      }
      function add() {
        if (!canSave.value) {
          return;
        }
        if (props.type === "class") {
          if (!/^[a-z_-][a-z\d_-]*$/i.test(formModel.value.selector) || formModel.value.selector.split("")[0] === "-") {
            hasError.value = true;
            setTimeout(() => {
              hasError.value = false;
            }, 500);
            return;
          }
        }
        emit("add-selector", formModel.value);
        showAddModal.value = false;
        formModel.value = {};
      }
      return {
        buttonTitle,
        schema,
        showAddModal,
        computedFormModel,
        buttonType,
        openModal,
        closeModal,
        toggleModal,
        onFormClose,
        add
      };
    }
  };
  const _hoisted_1$12 = { class: "znpb-option-cssSelectorChildActions" };
  function _sfc_render$I(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_OptionsForm = Vue.resolveComponent("OptionsForm");
    const _component_Button = Vue.resolveComponent("Button");
    const _component_Tooltip = Vue.resolveComponent("Tooltip");
    return Vue.openBlock(), Vue.createBlock(_component_Tooltip, {
      show: $setup.showAddModal,
      "onUpdate:show": _cache[2] || (_cache[2] = ($event) => $setup.showAddModal = $event),
      trigger: null,
      placement: "bottom",
      "append-to": "element",
      strategy: "fixed",
      "tooltip-class": "znpb-option-cssSelectorChildActionAddTooltip",
      "close-on-outside-click": true,
      onHide: $setup.onFormClose
    }, {
      content: Vue.withCtx(() => [
        Vue.createElementVNode("div", {
          onClick: _cache[1] || (_cache[1] = Vue.withModifiers(() => {
          }, ["stop"]))
        }, [
          Vue.createVNode(_component_OptionsForm, {
            modelValue: $setup.computedFormModel,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.computedFormModel = $event),
            class: "znpb-option-cssSelectorChildActionAddForm",
            schema: $setup.schema
          }, null, 8, ["modelValue", "schema"]),
          Vue.createVNode(_component_Button, {
            class: "znpb-button--line znpb-option-cssSelectorChildActionAddButton",
            type: $setup.buttonType,
            onClick: $setup.add
          }, {
            default: Vue.withCtx(() => [
              Vue.createTextVNode(Vue.toDisplayString($setup.buttonTitle), 1)
            ]),
            _: 1
          }, 8, ["type", "onClick"])
        ])
      ]),
      default: Vue.withCtx(() => [
        Vue.createElementVNode("div", _hoisted_1$12, [
          Vue.renderSlot(_ctx.$slots, "default", {
            actions: {
              openModal: $setup.openModal,
              closeModal: $setup.closeModal,
              toggleModal: $setup.toggleModal
            }
          })
        ])
      ]),
      _: 3
    }, 8, ["show", "onHide"]);
  }
  var AddSelector = /* @__PURE__ */ _export_sfc(_sfc_main$1j, [["render", _sfc_render$I]]);
  const _sfc_main$1i = {
    name: "AddChildActions",
    components: {
      AddSelector
    },
    props: {
      childSelectors: {
        type: Array,
        default: []
      }
    },
    setup(props, { emit }) {
      const showAddModal = Vue.ref(false);
      return {
        showAddModal
      };
    }
  };
  const _hoisted_1$11 = { class: "znpb-option-cssSelectorChildActions" };
  function _sfc_render$H(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Icon = Vue.resolveComponent("Icon");
    const _component_AddSelector = Vue.resolveComponent("AddSelector");
    const _directive_znpb_tooltip = Vue.resolveDirective("znpb-tooltip");
    return Vue.openBlock(), Vue.createBlock(_component_AddSelector, null, {
      default: Vue.withCtx(({ actions }) => [
        Vue.createElementVNode("div", _hoisted_1$11, [
          $props.childSelectors.length === 0 ? Vue.withDirectives((Vue.openBlock(), Vue.createBlock(_component_Icon, {
            key: 0,
            icon: "child-add",
            onClick: Vue.withModifiers(actions.toggleModal, ["stop"])
          }, null, 8, ["onClick"])), [
            [_directive_znpb_tooltip, "Add new inner selector"]
          ]) : (Vue.openBlock(), Vue.createElementBlock(Vue.Fragment, { key: 1 }, [
            Vue.createElementVNode("span", {
              class: "znpb-option-cssSelectorChildActionsChildNumber",
              onClick: _cache[0] || (_cache[0] = Vue.withModifiers(($event) => (_ctx.showChilds = !_ctx.showChilds, _ctx.$emit("toggle-view-children")), ["stop"]))
            }, [
              Vue.createVNode(_component_Icon, { icon: "child" }),
              Vue.createTextVNode(" " + Vue.toDisplayString($props.childSelectors.length), 1)
            ]),
            Vue.withDirectives(Vue.createVNode(_component_Icon, {
              icon: "plus",
              onClick: Vue.withModifiers(actions.toggleModal, ["stop"])
            }, null, 8, ["onClick"]), [
              [_directive_znpb_tooltip, "Add new inner selector"]
            ])
          ], 64))
        ])
      ]),
      _: 1
    });
  }
  var AddChildActions = /* @__PURE__ */ _export_sfc(_sfc_main$1i, [["render", _sfc_render$H]]);
  var PseudoSelector_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$1h = {
    name: "PseudoSelector",
    props: {
      states: {
        type: Array,
        default: []
      }
    },
    setup(props, { emit }) {
      const { pseudoSelectors: pseudoSelectors2 } = usePseudoSelectors();
      const allPseudoSelectors = Vue.computed(() => {
        const disabledStates = ["custom", ":before", ":after"];
        return pseudoSelectors2.value.filter((state) => !disabledStates.includes(state.id));
      });
      const computedStates = Vue.computed({
        get() {
          return props.states || [];
        },
        set(newStates) {
          emit("update:states", newStates);
        }
      });
      const activePseudo = Vue.computed(() => {
        return computedStates.value.map((state) => allPseudoSelectors.value.find((stateConfig) => stateConfig.id === state));
      });
      const remainingPseudo = Vue.computed(() => {
        return allPseudoSelectors.value.filter((state) => !computedStates.value.includes(state.id));
      });
      function removeState(state) {
        const value = computedStates.value.slice();
        if (value.length === 1) {
          return;
        }
        if (value.includes(state.id)) {
          const index2 = value.indexOf(state.id);
          value.splice(index2, 1);
          computedStates.value = value;
        }
      }
      function addState(state) {
        const value = computedStates.value.slice();
        value.push(state.id);
        computedStates.value = value;
      }
      return {
        computedStates,
        activePseudo,
        remainingPseudo,
        addState,
        removeState
      };
    }
  };
  const _hoisted_1$10 = { class: "znpb-option-cssChildSelectorPseudoSelectorListWrapper" };
  const _hoisted_2$H = { class: "znpb-option-cssChildSelectorPseudoSelectorList" };
  const _hoisted_3$v = /* @__PURE__ */ Vue.createElementVNode("li", { class: "znpb-option-cssChildSelectorPseudoSelectorListTitle" }, "Active states:", -1);
  const _hoisted_4$k = ["onClick"];
  const _hoisted_5$h = { class: "znpb-option-cssChildSelectorPseudoSelectorList" };
  const _hoisted_6$d = /* @__PURE__ */ Vue.createElementVNode("li", { class: "znpb-option-cssChildSelectorPseudoSelectorListTitle" }, "Available states:", -1);
  const _hoisted_7$b = ["onClick"];
  function _sfc_render$G(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Tooltip = Vue.resolveComponent("Tooltip");
    return Vue.openBlock(), Vue.createBlock(_component_Tooltip, {
      "tooltip-class": "hg-popper--no-padding",
      trigger: "click",
      placement: "bottom",
      "append-to": "body",
      strategy: "fixed",
      "close-on-outside-click": true,
      class: "znpb-option-cssChildSelectorPseudoSelector",
      onHide: _cache[0] || (_cache[0] = ($event) => _ctx.showAddModal = false)
    }, {
      content: Vue.withCtx(() => [
        Vue.createElementVNode("div", _hoisted_1$10, [
          Vue.createElementVNode("ul", _hoisted_2$H, [
            _hoisted_3$v,
            (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList($setup.activePseudo, (state) => {
              return Vue.openBlock(), Vue.createElementBlock("li", {
                key: state.id,
                onClick: ($event) => $setup.removeState(state)
              }, Vue.toDisplayString(state.name), 9, _hoisted_4$k);
            }), 128))
          ]),
          Vue.createElementVNode("ul", _hoisted_5$h, [
            _hoisted_6$d,
            (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList($setup.remainingPseudo, (state) => {
              return Vue.openBlock(), Vue.createElementBlock("li", {
                key: state.id,
                onClick: ($event) => $setup.addState(state)
              }, Vue.toDisplayString(state.name), 9, _hoisted_7$b);
            }), 128))
          ])
        ])
      ]),
      default: Vue.withCtx(() => [
        $props.states.length === 1 ? (Vue.openBlock(), Vue.createElementBlock(Vue.Fragment, { key: 0 }, [
          Vue.createTextVNode(Vue.toDisplayString($props.states[0]), 1)
        ], 64)) : Vue.createCommentVNode("", true),
        $props.states.length > 1 ? (Vue.openBlock(), Vue.createElementBlock(Vue.Fragment, { key: 1 }, [
          Vue.createTextVNode(Vue.toDisplayString($props.states.length) + " states ", 1)
        ], 64)) : Vue.createCommentVNode("", true)
      ]),
      _: 1
    });
  }
  var PseudoSelector = /* @__PURE__ */ _export_sfc(_sfc_main$1h, [["render", _sfc_render$G]]);
  var CSSSelector_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$1g = {
    name: "CSSSelector",
    components: {
      AccordionMenu: Vue.defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(function() {
        return AccordionMenu$2;
      }), false ? "__VITE_PRELOAD__" : void 0)),
      AddChildActions,
      PseudoSelector
    },
    props: {
      modelValue: {
        type: Object,
        default: {}
      },
      allow_delete: {
        type: Boolean,
        default: true
      },
      allow_childs: {
        type: Boolean,
        default: true
      },
      isChild: {
        type: Boolean,
        default: false
      },
      allow_class_assignments: {
        type: Boolean,
        default: true
      },
      allow_custom_attributes: {
        type: Boolean,
        default: true
      },
      selector: {
        type: String,
        required: false
      },
      name: {
        type: String,
        required: false
      },
      show_breadcrumbs: {
        type: Boolean,
        default: false
      },
      show_changes: {
        type: Boolean,
        default: true
      },
      allowRename: {
        type: Boolean,
        default: true
      }
    },
    setup(props, { emit }) {
      const cssClassesStore = useCSSClassesStore();
      const showChilds = Vue.ref(false);
      const uid = generateUID();
      const canShow = Vue.ref(false);
      const showClassMenu = Vue.ref(false);
      const classMenuIcon = Vue.ref(null);
      const classActions = Vue.computed(() => {
        return [
          {
            title: translate("copy_element_styles"),
            action: () => {
              cssClassesStore.copyClassStyles(value.value.styles);
            },
            icon: "copy"
          },
          {
            title: translate("paste_element_styles"),
            action: () => {
              const clonedCopiedStyles = cloneDeep(cssClassesStore.copiedStyles);
              if (!value.value.styles) {
                value.value.styles = clonedCopiedStyles;
              } else {
                value.value.styles = merge$1(value.value.styles, clonedCopiedStyles);
              }
            },
            show: !!cssClassesStore.copiedStyles,
            icon: "paste"
          },
          {
            title: translate("delete_selector"),
            action: deleteItem,
            icon: "delete"
          }
        ];
      });
      const title = Vue.computed({
        get() {
          return props.name || props.modelValue.name || props.modelValue.title || props.modelValue.id || props.selector || "New item";
        },
        set(newValue) {
          value.value = __spreadProps(__spreadValues({}, value.value), {
            name: newValue
          });
        }
      });
      const selector = Vue.computed(() => {
        if (props.selector) {
          return props.selector;
        } else if (props.modelValue.id) {
          return `.${props.modelValue.id}`;
        } else if (props.modelValue.selector) {
          return props.modelValue.selector;
        }
      });
      function onMouseOver() {
        const iframe = window.frames["znpb-editor-iframe"];
        if (!iframe) {
          return;
        }
        const domElements = iframe.contentWindow.document.querySelectorAll(selector.value);
        if (domElements.length) {
          domElements.forEach((element) => {
            element.style.outline = "2px solid #14ae5c";
          });
        }
      }
      function onMouseOut() {
        const iframe = window.frames["znpb-editor-iframe"];
        if (!iframe) {
          return;
        }
        const domElements = iframe.contentWindow.document.querySelectorAll(selector.value);
        if (domElements.length) {
          domElements.forEach((element) => {
            element.style.outline = null;
          });
        }
      }
      Vue.onBeforeUnmount(() => onMouseOut());
      const childSelectors = Vue.computed({
        get() {
          return props.modelValue.child_styles || [];
        },
        set(newValue) {
          if (null === newValue || newValue.length === 0) {
            delete value.value.child_styles;
          } else {
            value.value = __spreadProps(__spreadValues({}, value.value), {
              child_styles: newValue
            });
          }
        }
      });
      const pseudoState = Vue.computed({
        get() {
          return value.value.states || ["default"];
        },
        set(newStateValue) {
          value.value.states = newStateValue;
        }
      });
      const schema = Vue.computed(() => {
        const schema2 = {
          styles: {
            type: "element_styles",
            id: "styles",
            is_layout: true,
            selector: selector.value,
            title: title.value,
            allow_class_assignments: props.allow_class_assignments
          }
        };
        if (props.allow_custom_attributes) {
          schema2.attributes = applyFilters("zionbuilder/options/attributes", {
            type: "accordion_menu",
            title: "custom attributes",
            icon: "tags-attributes",
            is_layout: true,
            label: {
              type: translate("pro"),
              text: translate("pro")
            },
            show_title: false,
            child_options: {
              upgrade_message: {
                type: "upgrade_to_pro",
                message_title: translate("meet_custom_attributes"),
                message_description: translate("meet_custom_attributes_desc"),
                info_text: translate("meet_custom_attributes_link")
              }
            }
          });
        }
        return schema2;
      });
      const hasChanges = Vue.computed(
        () => Object.keys(value.value.styles || {}).length > 0 || Object.keys(value.value.attributes || {}).length > 0
      );
      const value = Vue.computed({
        get() {
          return props.modelValue || {};
        },
        set(newValue) {
          emit("update:modelValue", newValue);
        }
      });
      function onChildAdded(childData) {
        childSelectors.value = [...childSelectors.value, childData];
        showChilds.value = true;
      }
      function onChildUpdate(child, newValue) {
        const value2 = childSelectors.value.slice();
        const childIndex = childSelectors.value.indexOf(child);
        if (newValue === null) {
          value2.splice(childIndex, 1);
        } else {
          value2.splice(childIndex, 1, newValue);
        }
        childSelectors.value = value2;
      }
      function deleteItem() {
        emit("update:modelValue", null);
      }
      function resetChanges() {
        emit("update:modelValue", null);
      }
      function onRenameItemClick(event2) {
        if (props.allowRename) {
          event2.stopPropagation();
        }
      }
      return {
        showClassMenu,
        classMenuIcon,
        canShow,
        classActions,
        onChildAdded,
        showChilds,
        title,
        selector,
        childSelectors,
        deleteItem,
        schema,
        value,
        onChildUpdate,
        pseudoState,
        hasChanges,
        resetChanges,
        uid,
        onRenameItemClick,
        onMouseOver,
        onMouseOut
      };
    }
  };
  const _hoisted_1$$ = { class: "znpb-option-cssSelectorWrapper" };
  const _hoisted_2$G = ["title"];
  const _hoisted_3$u = { key: 0 };
  function _sfc_render$F(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_PseudoSelector = Vue.resolveComponent("PseudoSelector");
    const _component_InlineEdit = Vue.resolveComponent("InlineEdit");
    const _component_AddChildActions = Vue.resolveComponent("AddChildActions");
    const _component_ChangesBullet = Vue.resolveComponent("ChangesBullet");
    const _component_HiddenMenu = Vue.resolveComponent("HiddenMenu");
    const _component_OptionsForm = Vue.resolveComponent("OptionsForm");
    const _component_AccordionMenu = Vue.resolveComponent("AccordionMenu");
    const _component_CSSSelector = Vue.resolveComponent("CSSSelector", true);
    const _component_Sortable = Vue.resolveComponent("Sortable");
    return Vue.openBlock(), Vue.createElementBlock("div", {
      class: Vue.normalizeClass(["znpb-option-cssSelectoritem", { "znpb-option-cssSelectoritem--child": $props.isChild }])
    }, [
      Vue.createElementVNode("div", _hoisted_1$$, [
        $props.isChild ? (Vue.openBlock(), Vue.createBlock(_component_PseudoSelector, {
          key: 0,
          states: $setup.pseudoState,
          "onUpdate:states": _cache[0] || (_cache[0] = ($event) => $setup.pseudoState = $event)
        }, null, 8, ["states"])) : Vue.createCommentVNode("", true),
        Vue.createVNode(_component_AccordionMenu, {
          modelValue: $setup.value,
          "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => $setup.value = $event),
          "show-trigger-arrow": true,
          "has-breadcrumbs": $props.show_breadcrumbs,
          title: $setup.title,
          child_options: $setup.schema,
          class: "znpb-option-cssSelectorAccordion"
        }, {
          title: Vue.withCtx(() => [
            Vue.createElementVNode("div", {
              onMouseenter: _cache[2] || (_cache[2] = (...args) => $setup.onMouseOver && $setup.onMouseOver(...args)),
              onMouseleave: _cache[3] || (_cache[3] = (...args) => $setup.onMouseOut && $setup.onMouseOut(...args))
            }, [
              Vue.createVNode(_component_InlineEdit, {
                modelValue: $setup.title,
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $setup.title = $event),
                class: Vue.normalizeClass(["znpb-option-cssSelectorTitle", {
                  "znpb-option-cssSelectorTitle--allowRename": $props.allowRename
                }]),
                enabled: $props.allowRename,
                onClick: $setup.onRenameItemClick
              }, null, 8, ["modelValue", "class", "enabled", "onClick"]),
              Vue.createElementVNode("div", {
                class: "znpb-option-cssSelector",
                title: $setup.selector
              }, Vue.toDisplayString($setup.selector), 9, _hoisted_2$G)
            ], 32)
          ]),
          actions: Vue.withCtx(() => [
            $props.allow_childs ? (Vue.openBlock(), Vue.createBlock(_component_AddChildActions, {
              key: 0,
              "child-selectors": $setup.childSelectors,
              onAddSelector: $setup.onChildAdded,
              onToggleViewChildren: _cache[4] || (_cache[4] = ($event) => $setup.showChilds = !$setup.showChilds)
            }, null, 8, ["child-selectors", "onAddSelector"])) : Vue.createCommentVNode("", true),
            $props.show_changes && $setup.hasChanges ? (Vue.openBlock(), Vue.createBlock(_component_ChangesBullet, {
              key: 1,
              content: _ctx.$translate("discard_changes"),
              onRemoveStyles: $setup.resetChanges
            }, null, 8, ["content", "onRemoveStyles"])) : Vue.createCommentVNode("", true),
            Vue.createVNode(_component_HiddenMenu, { actions: $setup.classActions }, null, 8, ["actions"])
          ]),
          default: Vue.withCtx(() => [
            Vue.createVNode(_component_OptionsForm, {
              modelValue: $setup.value,
              "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => $setup.value = $event),
              schema: $setup.schema,
              class: "znpb-option-cssSelectorForm"
            }, null, 8, ["modelValue", "schema"])
          ]),
          _: 1
        }, 8, ["modelValue", "has-breadcrumbs", "title", "child_options"])
      ]),
      $setup.showChilds && $setup.childSelectors.length > 0 ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_3$u, [
        Vue.createVNode(_component_Sortable, {
          modelValue: $setup.childSelectors,
          "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => $setup.childSelectors = $event),
          class: "znpb-admin-colors__container",
          handle: ".znpb-option-cssSelectorAccordion > .znpb-horizontal-accordion__header",
          "drag-delay": 0,
          "drag-treshold": 10,
          disabled: false,
          revert: true,
          axis: "vertical",
          group: $setup.uid
        }, {
          default: Vue.withCtx(() => [
            (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList($setup.childSelectors, (childSelector, index2) => {
              return Vue.openBlock(), Vue.createBlock(_component_CSSSelector, {
                key: childSelector.title + childSelector.selector + index2,
                class: "znpb-option-cssChildSelectorStyles",
                "model-value": childSelector,
                "is-child": true,
                allow_class_assignments: false,
                allow_custom_attributes: false,
                show_breadcrumbs: $props.show_breadcrumbs,
                "onUpdate:modelValue": ($event) => $setup.onChildUpdate(childSelector, $event)
              }, null, 8, ["model-value", "show_breadcrumbs", "onUpdate:modelValue"]);
            }), 128))
          ]),
          _: 1
        }, 8, ["modelValue", "group"])
      ])) : Vue.createCommentVNode("", true)
    ], 2);
  }
  var CSSSelector$1 = /* @__PURE__ */ _export_sfc(_sfc_main$1g, [["render", _sfc_render$F]]);
  var CSSSelector = {
    id: "css_selector",
    component: CSSSelector$1
  };
  var Gallery_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$_ = { class: "znpb-option__image-gallery" };
  const _hoisted_2$F = ["onClick"];
  const _sfc_main$1f = /* @__PURE__ */ Vue.defineComponent({
    __name: "Gallery",
    props: {
      modelValue: { default() {
        return [];
      } },
      title: { default: "" },
      type: { default: "image" }
    },
    emits: ["update:modelValue"],
    setup(__props, { emit }) {
      const props = __props;
      const { wp: wp2 } = window;
      const sortableModel = Vue.computed({
        get() {
          return props.modelValue || [];
        },
        set(newValue) {
          emit("update:modelValue", newValue);
        }
      });
      let mediaModal = null;
      function openMediaModal() {
        if (mediaModal === null) {
          const args = {
            frame: "select",
            state: "zion-media",
            library: {
              type: "image"
            },
            multiple: true,
            selection: []
          };
          mediaModal = new wp2.media.view.MediaFrame.ZionBuilderFrame(args);
          mediaModal.on("select update insert", selectMedia);
          mediaModal.on("open", setMediaModalSelection);
        }
        mediaModal.open();
      }
      function setMediaModalSelection() {
        if (typeof props.modelValue === "undefined")
          return;
        let imagesUrls = props.modelValue.map((image) => image.image);
        getImageIds({
          images: imagesUrls
        }).then((response) => {
          const imageIds = Object.keys(response.data).map((image) => {
            return response.data[image];
          });
          const selection = mediaModal.state().get("selection");
          imageIds.forEach((imageId) => {
            var attachment = wp2.media.attachment(imageId);
            selection.add(attachment ? [attachment] : []);
          });
        });
      }
      function selectMedia(e) {
        let selection = mediaModal.state().get("selection").toJSON();
        if (typeof e !== "undefined") {
          selection = e;
        }
        const values = selection.map((selectedItem) => {
          return { image: selectedItem.url };
        });
        emit("update:modelValue", values);
      }
      function deleteImage(index2) {
        const values = [...props.modelValue];
        values.splice(index2, 1);
        emit("update:modelValue", values);
      }
      return (_ctx, _cache) => {
        const _component_EmptyList = Vue.resolveComponent("EmptyList");
        const _component_Icon = Vue.resolveComponent("Icon");
        const _component_Sortable = Vue.resolveComponent("Sortable");
        return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$_, [
          !Vue.unref(sortableModel).length ? (Vue.openBlock(), Vue.createBlock(_component_EmptyList, {
            key: 0,
            onClick: openMediaModal
          }, {
            default: Vue.withCtx(() => [
              Vue.createTextVNode(Vue.toDisplayString(Vue.unref(translate)("no_images_selected")), 1)
            ]),
            _: 1
          })) : (Vue.openBlock(), Vue.createBlock(_component_Sortable, {
            key: 1,
            modelValue: Vue.unref(sortableModel),
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => Vue.isRef(sortableModel) ? sortableModel.value = $event : null),
            class: "znpb-option__image-gallery__images-wrapper"
          }, {
            end: Vue.withCtx(() => [
              Vue.createElementVNode("div", {
                class: "znpb-option__image-gallery__images-item--add",
                onClick: openMediaModal
              }, "+")
            ]),
            default: Vue.withCtx(() => [
              (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList(__props.modelValue, (image, index2) => {
                return Vue.openBlock(), Vue.createElementBlock("div", {
                  key: index2,
                  class: "znpb-option__image-gallery__images-item",
                  style: Vue.normalizeStyle({
                    "background-image": `url(${image.image})`,
                    "background-size": "cover",
                    "border-radius": "3px"
                  })
                }, [
                  Vue.createElementVNode("span", {
                    class: "znpb-option__image-gallery__images-item--delete",
                    onClick: ($event) => deleteImage(index2)
                  }, [
                    Vue.createVNode(_component_Icon, {
                      rounded: true,
                      icon: "delete",
                      "bg-size": 30,
                      "bg-color": "#fff"
                    })
                  ], 8, _hoisted_2$F)
                ], 4);
              }), 128))
            ]),
            _: 1
          }, 8, ["modelValue"]))
        ]);
      };
    }
  });
  var Gallery = {
    id: "image_gallery",
    component: _sfc_main$1f
  };
  var GlobalClasses_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$1e = {
    name: "GlobalClasses",
    components: {
      AddSelector
    },
    setup(props) {
      const cssClasses = useCSSClassesStore();
      const keyword = Vue.ref("");
      const activeClass = Vue.ref(null);
      const breadCrumbConfig = Vue.ref({
        title: null,
        previousCallback: closeAccordion
      });
      const horizontalAccordion = Vue.ref([]);
      const parentAccordion = Vue.inject("parentAccordion");
      const filteredClasses = Vue.computed(() => {
        if (keyword.value.length === 0) {
          return cssClasses.CSSClasses;
        } else {
          return cssClasses.getClassesByFilter(keyword.value);
        }
      });
      const schema = Vue.computed(() => {
        const schema2 = {};
        const selectors = filteredClasses.value || [];
        selectors.forEach((cssClassConfig) => {
          const { uid, title } = cssClassConfig;
          schema2[uid] = {
            type: "css_selector",
            title,
            allow_class_assignments: false,
            show_changes: false
          };
        });
        return schema2;
      });
      const value = Vue.computed({
        get() {
          const modelValue = {};
          const existingCSSClasses = cssClasses.CSSClasses;
          existingCSSClasses.forEach((cssClassConfig) => {
            const { uid } = cssClassConfig;
            modelValue[uid] = cssClassConfig;
          });
          return modelValue;
        },
        set(newValue) {
          if (null === newValue) {
            cssClasses.removeAllCssClasses();
          } else {
            const classes = [];
            Object.keys(newValue).forEach((selectorId) => {
              const selectorValue = newValue[selectorId];
              classes.push(selectorValue);
            });
            cssClasses.setCSSClasses(classes);
          }
        }
      });
      function onItemSelected() {
        breadCrumbConfig.value.title = activeClass.value.name;
        parentAccordion.addBreadcrumb(breadCrumbConfig.value);
      }
      function onItemCollapsed() {
        breadCrumbConfig.value.title = null;
        parentAccordion.removeBreadcrumb(breadCrumbConfig.value);
      }
      function deleteClass(classItem) {
        cssClasses.removeCSSClass(classItem);
      }
      function closeAccordion() {
        const activeAccordion = horizontalAccordion.value.find((accordion) => {
          return accordion.localCollapsed;
        });
        if (activeAccordion) {
          activeAccordion.closeAccordion();
        }
      }
      function onSelectorAdd(config) {
        cssClasses.addCSSClass({
          id: config.selector,
          name: config.title
        });
      }
      Vue.onBeforeUnmount(() => {
        if (activeClass.value) {
          parentAccordion.removeBreadcrumb(breadCrumbConfig.value);
        }
      });
      return {
        filteredClasses,
        keyword,
        activeClass,
        horizontalAccordion,
        onItemSelected,
        onItemCollapsed,
        deleteClass,
        schema,
        value,
        onSelectorAdd
      };
    }
  };
  const _hoisted_1$Z = { class: "znpb-global-css-classes__wrapper" };
  const _hoisted_2$E = { class: "znpb-global-css-classes__search" };
  const _hoisted_3$t = {
    key: 1,
    class: "znpb-class-selector-noclass"
  };
  function _sfc_render$E(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_BaseInput = Vue.resolveComponent("BaseInput");
    const _component_OptionsForm = Vue.resolveComponent("OptionsForm");
    const _component_Button = Vue.resolveComponent("Button");
    const _component_AddSelector = Vue.resolveComponent("AddSelector");
    return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$Z, [
      Vue.createElementVNode("div", _hoisted_2$E, [
        Vue.createVNode(_component_BaseInput, {
          ref: "input",
          modelValue: $setup.keyword,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.keyword = $event),
          filterable: true,
          icon: "search",
          clearable: true,
          placeholder: "Search for a class"
        }, null, 8, ["modelValue"])
      ]),
      $setup.filteredClasses.length ? (Vue.openBlock(), Vue.createBlock(_component_OptionsForm, {
        key: 0,
        modelValue: $setup.value,
        "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $setup.value = $event),
        schema: $setup.schema,
        class: "znpb-globalCSSClassesOptionsForm"
      }, null, 8, ["modelValue", "schema"])) : (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_3$t, Vue.toDisplayString(_ctx.$translate("no_global_class_found")), 1)),
      Vue.createVNode(_component_AddSelector, {
        type: "class",
        onAddSelector: $setup.onSelectorAdd
      }, {
        default: Vue.withCtx(({ actions }) => [
          Vue.createVNode(_component_Button, {
            type: "line",
            class: "znpb-class-selectorAddButton",
            onClick: ($event) => actions.toggleModal()
          }, {
            default: Vue.withCtx(() => [
              Vue.createTextVNode(Vue.toDisplayString(_ctx.$translate("add_css_class")), 1)
            ]),
            _: 2
          }, 1032, ["onClick"])
        ]),
        _: 1
      }, 8, ["onAddSelector"])
    ]);
  }
  var GlobalClasses$1 = /* @__PURE__ */ _export_sfc(_sfc_main$1e, [["render", _sfc_render$E]]);
  var GlobalClasses = {
    id: "global_css_classes",
    component: GlobalClasses$1
  };
  var SingleChild_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$1d = {
    name: "SingleChild",
    props: {
      element: {
        type: Object,
        required: true
      },
      itemOptionName: {
        type: String,
        required: false
      },
      showDelete: {
        type: Boolean,
        default: true
      }
    },
    setup(props) {
      const UIStore = useUIStore();
      function onDelete() {
        if (props.showDelete) {
          props.element.delete();
        }
      }
      return {
        UIStore,
        onDelete
      };
    }
  };
  const _hoisted_1$Y = { class: "znpb-options-children__element-inner" };
  const _hoisted_2$D = { class: "znpb-options-children__element-title" };
  const _hoisted_3$s = { class: "znpb-options-children__element-action" };
  function _sfc_render$D(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Icon = Vue.resolveComponent("Icon");
    return Vue.openBlock(), Vue.createElementBlock("div", {
      class: "znpb-options-children__element",
      onClick: _cache[2] || (_cache[2] = Vue.withModifiers(($event) => $setup.UIStore.editElement($props.element), ["stop"]))
    }, [
      Vue.createElementVNode("div", _hoisted_1$Y, [
        Vue.createElementVNode("div", _hoisted_2$D, Vue.toDisplayString($props.element.options[$props.itemOptionName] || "ITEM"), 1),
        Vue.createElementVNode("div", _hoisted_3$s, [
          Vue.createVNode(_component_Icon, {
            icon: "copy",
            onClick: _cache[0] || (_cache[0] = Vue.withModifiers(($event) => $props.element.duplicate(), ["stop"]))
          }),
          Vue.createVNode(_component_Icon, {
            icon: "delete",
            class: Vue.normalizeClass({ "znpb-options-children__element-actionDeleteInactive": !$props.showDelete }),
            onClick: Vue.withModifiers($setup.onDelete, ["stop"])
          }, null, 8, ["class", "onClick"]),
          Vue.createVNode(_component_Icon, {
            icon: "edit",
            onClick: _cache[1] || (_cache[1] = Vue.withModifiers(($event) => $setup.UIStore.editElement($props.element), ["stop"]))
          })
        ])
      ])
    ]);
  }
  var SingleChild = /* @__PURE__ */ _export_sfc(_sfc_main$1d, [["render", _sfc_render$D]]);
  const _hoisted_1$X = { class: "znpb-options-children__wrapper" };
  const __default__ = {
    name: "ChildAdder"
  };
  const _sfc_main$1c = /* @__PURE__ */ Vue.defineComponent(__spreadProps(__spreadValues({}, __default__), {
    props: {
      modelValue: null,
      child_type: null,
      item_name: null,
      min: null,
      add_template: null
    },
    setup(__props) {
      const props = __props;
      const element = Vue.inject("elementInfo");
      const contentStore = useContentStore();
      const canShowDeleteButton = Vue.computed(() => {
        if (props.min && element.value.content.length === props.min) {
          return false;
        }
        return true;
      });
      const elementChildren = Vue.computed(() => {
        return element.value.content.map((elementUID) => {
          return contentStore.getElement(elementUID);
        });
      });
      if (element.value.content.length === 0 && props.modelValue) {
        element.value.addChildren(props.modelValue);
      }
      function addChild() {
        const config = props.add_template ? props.add_template : {
          element_type: props.child_type
        };
        window.zb.run("editor/elements/add", {
          element: config,
          parentUID: element.value.uid,
          index: -1
        });
      }
      return (_ctx, _cache) => {
        const _component_Sortable = Vue.resolveComponent("Sortable");
        const _component_Button = Vue.resolveComponent("Button");
        return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$X, [
          Vue.createVNode(_component_Sortable, {
            modelValue: Vue.unref(element).content,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => Vue.unref(element).content = $event),
            class: "znpb-options-children__items-wrapper"
          }, {
            default: Vue.withCtx(() => [
              (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList(Vue.unref(elementChildren), (childElement) => {
                return Vue.openBlock(), Vue.createBlock(SingleChild, {
                  key: childElement.uid,
                  element: childElement,
                  "item-option-name": __props.item_name,
                  "show-delete": Vue.unref(canShowDeleteButton),
                  onDelete: childElement.delete,
                  onClone: childElement.duplicate
                }, null, 8, ["element", "item-option-name", "show-delete", "onDelete", "onClone"]);
              }), 128))
            ]),
            _: 1
          }, 8, ["modelValue"]),
          Vue.createVNode(_component_Button, {
            class: "znpb-option-repeater__add-button",
            type: "line",
            onClick: addChild
          }, {
            default: Vue.withCtx(() => [
              Vue.createTextVNode(" ADD ")
            ]),
            _: 1
          })
        ]);
      };
    }
  }));
  var ChildAdder = {
    id: "child_adder",
    component: _sfc_main$1c
  };
  var ElementEventButton_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$1b = {
    name: "ElementEventButton",
    props: {
      event: {
        type: String,
        required: true
      },
      button_text: {
        type: String,
        required: true
      }
    },
    setup(props) {
      const { injectElement } = useElementProvide();
      const element = injectElement();
      function onClick() {
        element.trigger(props.event);
      }
      return {
        buttonText: props.button_text,
        onClick
      };
    }
  };
  function _sfc_render$C(_ctx, _cache, $props, $setup, $data, $options) {
    return Vue.openBlock(), Vue.createElementBlock("div", {
      class: "znpb-option__elementEvent",
      onClick: _cache[0] || (_cache[0] = (...args) => $setup.onClick && $setup.onClick(...args))
    }, Vue.toDisplayString($setup.buttonText), 1);
  }
  var ElementEventButton$1 = /* @__PURE__ */ _export_sfc(_sfc_main$1b, [["render", _sfc_render$C]]);
  var ElementEventButton = {
    id: "element_event_button",
    component: ElementEventButton$1
  };
  var ElementSelector_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$1a = {
    name: "ElementSelector",
    props: {
      modelValue: {
        type: String,
        required: false
      },
      use_preview: {
        type: Boolean,
        required: false,
        default: true
      }
    },
    setup(props, { emit }) {
      let activeDoc = document;
      let lastElement = null;
      const valueModel = Vue.computed({
        get() {
          return props.modelValue;
        },
        set(newValue) {
          emit("update:modelValue", newValue);
        }
      });
      function activateSelectorMode() {
        if (props.use_preview) {
          const iframeElement = document.getElementById("znpb-editor-iframe");
          if (!iframeElement) {
            console.error("The iframe preview is missing");
            return;
          }
          activeDoc = iframeElement.contentWindow.document;
        }
        activeDoc.addEventListener("mousemove", onMouseMove);
        activeDoc.body.classList.add("znpb-element-selector--active");
      }
      function onMouseMove(event2) {
        const { clientX, clientY } = event2;
        if (lastElement) {
          lastElement.classList.remove("znpb-element-selector--element-hovered");
        }
        lastElement = activeDoc.elementFromPoint(clientX, clientY);
        lastElement.classList.add("znpb-element-selector--element-hovered");
      }
      return {
        valueModel,
        activateSelectorMode
      };
    }
  };
  const _hoisted_1$W = { class: "znpb-option-element-selector" };
  function _sfc_render$B(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_BaseInput = Vue.resolveComponent("BaseInput");
    return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$W, [
      Vue.createVNode(_component_BaseInput, {
        modelValue: $setup.valueModel,
        "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $setup.valueModel = $event)
      }, {
        append: Vue.withCtx(() => [
          Vue.createElementVNode("span", {
            onClick: _cache[0] || (_cache[0] = (...args) => $setup.activateSelectorMode && $setup.activateSelectorMode(...args))
          }, "Select")
        ]),
        _: 1
      }, 8, ["modelValue"])
    ]);
  }
  var ElementSelector$1 = /* @__PURE__ */ _export_sfc(_sfc_main$1a, [["render", _sfc_render$B]]);
  var ElementSelector = {
    id: "element_selector",
    component: ElementSelector$1
  };
  const registerEditorOptions = () => {
    const { registerOption } = useOptions();
    registerOption(AccordionMenu);
    registerOption(PseudoGroup);
    registerOption(Background);
    registerOption(BackgroundColor);
    registerOption(BackgroundGradient);
    registerOption(Typography);
    registerOption(Group);
    registerOption(PanelAccordion);
    registerOption(ResponsiveGroup);
    registerOption(Link);
    registerOption(ColumnSize);
    registerOption(WPWidget);
    registerOption(TabGroup);
    registerOption(ElementStyles);
    registerOption(CSSSelector);
    registerOption(Gallery);
    registerOption(GlobalClasses);
    registerOption(ChildAdder);
    registerOption(ElementEventButton);
    registerOption(ElementSelector);
  };
  var ElementListItemSVG_vue_vue_type_style_index_0_lang = "";
  const cache = {};
  const _sfc_main$19 = {
    name: "ElementListItemSVG",
    props: ["svg"],
    setup(props) {
      const iconMarkup = Vue.ref("");
      if (cache[props.svg]) {
        iconMarkup.value = cache[props.svg];
      } else {
        fetch(props.svg).then((response) => response.text()).then((data2) => {
          iconMarkup.value = data2;
          cache[props.svg] = data2;
        });
      }
      return () => Vue.h("span", {
        class: "znpb-editor-icon-wrapper znpb-editor-icon-wrapper--isSVG",
        innerHTML: iconMarkup.value
      });
    }
  };
  const _sfc_main$18 = {
    name: "UIElementIcon",
    components: {
      ElementListItemSVG: _sfc_main$19
    },
    props: {
      element: {
        type: Object,
        required: true
      },
      size: {
        type: Number,
        default: 36
      }
    },
    setup(props) {
      const get_element_image = props.element.thumb ? props.element.thumb : null;
      const isSVG = get_element_image ? get_element_image.indexOf(".svg") !== -1 : false;
      const get_element_icon = props.element.icon ? props.element.icon : "element-default";
      return {
        isSVG,
        get_element_image,
        get_element_icon
      };
    }
  };
  const _hoisted_1$V = ["src"];
  function _sfc_render$A(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_ElementListItemSVG = Vue.resolveComponent("ElementListItemSVG");
    const _component_Icon = Vue.resolveComponent("Icon");
    return $setup.isSVG ? (Vue.openBlock(), Vue.createBlock(_component_ElementListItemSVG, {
      key: 0,
      svg: $setup.get_element_image
    }, null, 8, ["svg"])) : $setup.get_element_image ? (Vue.openBlock(), Vue.createElementBlock("img", {
      key: 1,
      src: $setup.get_element_image,
      class: "znpb-element-box__image"
    }, null, 8, _hoisted_1$V)) : (Vue.openBlock(), Vue.createBlock(_component_Icon, {
      key: 2,
      icon: $setup.get_element_icon,
      size: $props.size
    }, null, 8, ["icon", "size"]));
  }
  var UIElementIcon = /* @__PURE__ */ _export_sfc(_sfc_main$18, [["render", _sfc_render$A]]);
  var AddElementIcon_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$17 = /* @__PURE__ */ Vue.defineComponent({
    __name: "AddElementIcon",
    props: {
      element: null,
      placement: { default: "next" },
      position: { default: null },
      index: { default: -1 }
    },
    setup(__props) {
      const props = __props;
      const root2 = Vue.ref(null);
      const UIStore = useUIStore();
      const userStore = useUserStore();
      const positionString = props.placement === "inside" ? translate("insert_inside") : translate("insert_after");
      Vue.onMounted(() => {
        if (root2.value) {
          root2.value.addEventListener("click", onIconClick, true);
        }
      });
      Vue.onBeforeUnmount(() => {
        if (root2.value) {
          root2.value.removeEventListener("click", onIconClick, true);
        }
      });
      function onIconClick(event2) {
        event2.stopPropagation();
        UIStore.showAddElementsPopup(props.element, event2, props.placement);
      }
      return (_ctx, _cache) => {
        const _component_Icon = Vue.resolveComponent("Icon");
        const _directive_znpb_tooltip = Vue.resolveDirective("znpb-tooltip");
        return !Vue.unref(userStore).permissions.only_content ? Vue.withDirectives((Vue.openBlock(), Vue.createElementBlock("div", {
          key: 0,
          ref_key: "root",
          ref: root2,
          class: Vue.normalizeClass(["znpb-element-toolbox__add-element-button", {
            [`znpb-element-toolbox__add-element-button--${__props.position}`]: __props.position,
            [`znpb-element-toolbox__add-element-button--${__props.placement}`]: __props.placement
          }])
        }, [
          Vue.createVNode(_component_Icon, {
            icon: "plus",
            rounded: true
          })
        ], 2)), [
          [_directive_znpb_tooltip, Vue.unref(positionString) + " " + __props.element.name]
        ]) : Vue.createCommentVNode("", true);
      };
    }
  });
  var EmptySortablePlaceholder_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$U = { class: "znpb-empty-placeholder" };
  const _sfc_main$16 = /* @__PURE__ */ Vue.defineComponent({
    __name: "EmptySortablePlaceholder",
    props: {
      element: null
    },
    setup(__props) {
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$U, [
          Vue.createVNode(_sfc_main$17, {
            element: __props.element,
            placement: "inside",
            position: "middle"
          }, null, 8, ["element"])
        ]);
      };
    }
  });
  var SortableHelper_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$15 = {};
  function _sfc_render$z(_ctx, _cache) {
    const _component_Icon = Vue.resolveComponent("Icon");
    return Vue.openBlock(), Vue.createBlock(_component_Icon, {
      icon: "plus",
      "bg-size": 40,
      rounded: true,
      color: "#fff"
    });
  }
  var SortableHelper = /* @__PURE__ */ _export_sfc(_sfc_main$15, [["render", _sfc_render$z]]);
  var SortablePlaceholder_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$14 = {
    name: "SortablePlaceholder"
  };
  const _hoisted_1$T = { class: "znpb-sortable__placeholder-element" };
  function _sfc_render$y(_ctx, _cache, $props, $setup, $data, $options) {
    return Vue.openBlock(), Vue.createElementBlock("span", _hoisted_1$T);
  }
  var SortablePlaceholder = /* @__PURE__ */ _export_sfc(_sfc_main$14, [["render", _sfc_render$y]]);
  const _sfc_main$13 = {
    name: "RenderValue",
    inheritAttrs: false,
    props: {
      option: {
        type: String,
        required: true
      },
      htmlTag: {
        type: String,
        required: false,
        default: "span"
      }
    },
    setup(props) {
      const elementInfo = Vue.inject("elementInfo");
      const elementOptions = Vue.inject("elementOptions");
      const elementOptionsSchema = Vue.computed(() => {
        return elementInfo.elementDefinition.options;
      });
      const optionType = Vue.computed(() => {
        return getOptionSchemaFromPath.value.type;
      });
      const getOptionSchemaFromPath = Vue.computed(() => {
        const paths = props.option.split(".");
        let currentSchema = elementOptionsSchema.value;
        const pathLength = paths.length;
        let returnSchema = null;
        paths.forEach((path, i) => {
          if (i + 1 === pathLength) {
            returnSchema = currentSchema[path];
          } else if (currentSchema[path]) {
            currentSchema = currentSchema[path];
          } else {
            console.error(`schema could not be found for ${this.option}`);
          }
        });
        return returnSchema;
      });
      const isValueDynamic = Vue.computed(() => {
        const paths = props.option.split(".");
        let currentModel = elementInfo.options;
        const pathLength = paths.length;
        let isDynamic = false;
        paths.forEach((path, i) => {
          if (i === pathLength - 1) {
            if (typeof currentModel.__dynamic_content__ === "object") {
              const finalOptionId = paths[paths.length - 1];
              isDynamic = currentModel.__dynamic_content__[finalOptionId];
            }
          } else if (currentModel[path]) {
            currentModel = currentModel[path];
          } else {
            console.error(`model could not be found for ${props.option}`);
          }
        });
        return isDynamic;
      });
      const renderType = Vue.computed(() => {
        if (optionType.value === "editor" && !isValueDynamic.value) {
          if (elementInfo.isDisabled) {
            return "dynamic_html";
          } else {
            return "editor";
          }
        } else if (isValueDynamic.value) {
          return "dynamic_html";
        } else if (optionType.value === "icon_library") {
          return "icon";
        } else if (optionType.value === "image") {
          return "image";
        } else {
          return "default";
        }
      });
      const optionValue2 = Vue.computed({
        get() {
          const schema = getOptionSchemaFromPath.value;
          return get(elementOptions.value, props.option, schema.default);
        },
        set(newValue) {
          window.zb.run("editor/elements/update-element-options", {
            elementUID: elementInfo.uid,
            newValues: newValue,
            path: props.option
          });
        }
      });
      return {
        elementInfo,
        elementOptions,
        renderType,
        optionValue: optionValue2
      };
    }
  };
  const _hoisted_1$S = ["innerHTML"];
  const _hoisted_2$C = ["src"];
  function _sfc_render$x(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_InlineEditor = Vue.resolveComponent("InlineEditor");
    const _component_ElementIcon = Vue.resolveComponent("ElementIcon");
    return $setup.renderType === "editor" ? (Vue.openBlock(), Vue.createBlock(_component_InlineEditor, Vue.mergeProps({
      key: 0,
      modelValue: $setup.optionValue,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.optionValue = $event)
    }, _ctx.$attrs), null, 16, ["modelValue"])) : $setup.renderType === "dynamic_html" ? (Vue.openBlock(), Vue.createElementBlock("span", Vue.mergeProps({ key: 1 }, _ctx.$attrs, { innerHTML: $setup.optionValue }), null, 16, _hoisted_1$S)) : $setup.renderType === "icon" ? (Vue.openBlock(), Vue.createBlock(_component_ElementIcon, Vue.mergeProps({
      key: 2,
      "icon-config": $setup.optionValue
    }, _ctx.$attrs), null, 16, ["icon-config"])) : $setup.renderType === "image" ? (Vue.openBlock(), Vue.createElementBlock("img", Vue.mergeProps({
      key: 3,
      src: $setup.optionValue
    }, _ctx.$attrs), null, 16, _hoisted_2$C)) : (Vue.openBlock(), Vue.createBlock(Vue.resolveDynamicComponent($props.htmlTag), Vue.normalizeProps(Vue.mergeProps({ key: 4 }, _ctx.$attrs)), {
      default: Vue.withCtx(() => [
        Vue.createTextVNode(Vue.toDisplayString($setup.optionValue), 1)
      ]),
      _: 1
    }, 16));
  }
  var RenderValue = /* @__PURE__ */ _export_sfc(_sfc_main$13, [["render", _sfc_render$x]]);
  const _hoisted_1$R = ["data-znpbiconfam", "data-znpbicon"];
  const _sfc_main$12 = /* @__PURE__ */ Vue.defineComponent({
    __name: "ElementIcon",
    props: {
      iconConfig: { default: () => {
        return {
          family: "Font Awesome 5 Brands Regular",
          name: "wordpress-simple",
          unicode: "uf411"
        };
      } }
    },
    setup(__props) {
      const props = __props;
      const iconUnicode = Vue.computed(() => {
        return JSON.parse(`"\\${props.iconConfig.unicode}"`).trim();
      });
      return (_ctx, _cache) => {
        return __props.iconConfig ? (Vue.openBlock(), Vue.createElementBlock("span", {
          key: 0,
          "data-znpbiconfam": __props.iconConfig.family,
          "data-znpbicon": Vue.unref(iconUnicode)
        }, null, 8, _hoisted_1$R)) : Vue.createCommentVNode("", true);
      };
    }
  });
  var PopOver_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$11 = {
    name: "PopOver",
    props: {
      icon: {
        type: String,
        required: false
      },
      isActive: {
        type: Boolean,
        required: false
      },
      fullSize: {
        required: false
      }
    },
    setup(props) {
      const iconElementRef = Vue.ref(null);
      const popperRef = Vue.ref({
        x: 0,
        y: 0,
        left: 0
      });
      const buttonClasses = Vue.computed(() => {
        let classes = [];
        if (typeof props.icon !== "undefined") {
          classes.push("zn_pb_icon");
          classes.push(props.icon);
        }
        if (props.isActive) {
          classes.push("zion-inline-editor-button--active");
        }
        return classes.join(" ");
      });
      const modifiers = [{
        name: "flip",
        options: {
          fallbackPlacements: ["top", "bottom"]
        }
      }];
      if (props.fullSize) {
        modifiers.push({
          name: "test",
          enabled: true,
          phase: "beforeWrite",
          requires: ["computeStyles"],
          fn({ state, instance: instance2 }) {
            const popperSize = state.rects.popper.width;
            const referenceSize = state.rects.reference.width;
            if (popperSize >= referenceSize)
              return;
            state.styles.popper.width = `${referenceSize}px`;
            instance2.update();
          }
        });
      }
      Vue.onMounted(() => {
        const InlineEditor2 = window.document.getElementsByClassName("zion-inline-editor-container")[0];
        popperRef.value = props.fullSize ? InlineEditor2 : iconElementRef.value.$el;
      });
      return {
        buttonClasses,
        modifiers,
        popperRef,
        iconElementRef
      };
    }
  };
  function _sfc_render$w(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Icon = Vue.resolveComponent("Icon");
    const _component_Tooltip = Vue.resolveComponent("Tooltip");
    return Vue.openBlock(), Vue.createBlock(_component_Tooltip, {
      class: "zion-inline-editor-popover-wrapper",
      "tooltip-class": "zion-inline-editor-dropdown hg-popper--no-padding",
      trigger: "click",
      placement: "top",
      "append-to": "element",
      "close-on-outside-click": true,
      "popper-ref": $setup.popperRef,
      modifiers: $setup.modifiers,
      "show-arrows": false
    }, {
      content: Vue.withCtx(() => [
        Vue.renderSlot(_ctx.$slots, "default")
      ]),
      default: Vue.withCtx(() => [
        Vue.createVNode(_component_Icon, {
          icon: $props.icon,
          class: Vue.normalizeClass($setup.buttonClasses),
          ref: "iconElementRef"
        }, null, 8, ["icon", "class"])
      ]),
      _: 3
    }, 8, ["popper-ref", "modifiers"]);
  }
  var PopOver = /* @__PURE__ */ _export_sfc(_sfc_main$11, [["render", _sfc_render$w]]);
  const _sfc_main$10 = {
    props: ["formatter", "icon", "buttontext", "formatterValue"],
    setup(props) {
      const editor = Vue.inject("ZionInlineEditor");
      const isActive = Vue.ref(false);
      const classes = Vue.computed(() => {
        let classes2 = [];
        if (isActive.value) {
          classes2.push("zion-inline-editor-button--active");
        }
        return classes2.join(" ");
      });
      function checkIsActive() {
        isActive.value = editor.editor.formatter.match(...getFormatterArguments());
      }
      function getFormatterArguments() {
        const formatterArguments = [props.formatter];
        if (props.formatterValue) {
          formatterArguments.push({
            value: props.formatterValue
          });
        }
        return formatterArguments;
      }
      function toggleFormatter(event2) {
        event2.preventDefault();
        editor.editor.formatter.toggle(...getFormatterArguments());
      }
      function onNodeChange() {
        checkIsActive();
      }
      Vue.onMounted(() => {
        checkIsActive();
        editor.editor.on("SelectionChange", onNodeChange);
      });
      Vue.onBeforeUnmount(() => {
        editor.editor.off("SelectionChange", onNodeChange);
      });
      return {
        isActive,
        classes,
        toggleFormatter
      };
    }
  };
  function _sfc_render$v(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Icon = Vue.resolveComponent("Icon");
    return $props.icon ? (Vue.openBlock(), Vue.createBlock(_component_Icon, {
      key: 0,
      icon: $props.icon,
      class: Vue.normalizeClass($setup.classes),
      onMousedown: $setup.toggleFormatter
    }, null, 8, ["icon", "class", "onMousedown"])) : (Vue.openBlock(), Vue.createElementBlock("span", {
      key: 1,
      class: Vue.normalizeClass(["zion-inline-editor-button", $setup.classes]),
      onMousedown: _cache[0] || (_cache[0] = (...args) => $setup.toggleFormatter && $setup.toggleFormatter(...args))
    }, Vue.toDisplayString($props.buttontext), 35));
  }
  var InlineEditorButton = /* @__PURE__ */ _export_sfc(_sfc_main$10, [["render", _sfc_render$v]]);
  var ColorPicker_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$$ = {
    setup(props, { emit }) {
      const editor = Vue.inject("ZionInlineEditor");
      const color = Vue.ref(null);
      let justChangeColor = false;
      let changeTimeout = null;
      function onColorChange(newValue) {
        color.value = newValue;
        editor.editor.formatter.apply("forecolor", { value: newValue });
        clearTimeout(changeTimeout);
        changeTimeout = setTimeout(() => {
          justChangeColor = false;
        }, 500);
        justChangeColor = true;
      }
      function onNodeChange(node) {
        if (!justChangeColor) {
          getActiveColor();
        }
      }
      function getActiveColor() {
        color.value = editor.editor.queryCommandValue("forecolor");
      }
      Vue.onMounted(() => {
        getActiveColor();
        editor.editor.on("NodeChange", onNodeChange);
      });
      Vue.onBeforeUnmount(() => {
        editor.editor.off("NodeChange", onNodeChange);
      });
      return {
        color,
        onColorChange
      };
    }
  };
  const _hoisted_1$Q = { class: "zion-inline-editor-panel-color" };
  const _hoisted_2$B = { class: "zion-inline-editor-button" };
  function _sfc_render$u(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_InputColorPicker = Vue.resolveComponent("InputColorPicker");
    return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$Q, [
      Vue.createElementVNode("div", _hoisted_2$B, [
        Vue.createVNode(_component_InputColorPicker, {
          modelValue: $setup.color,
          "onUpdate:modelValue": $setup.onColorChange,
          "show-library": false,
          onOpen: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("open-color-picker", true)),
          onClose: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("close-color-picker", false)),
          type: "simple"
        }, null, 8, ["modelValue", "onUpdate:modelValue"])
      ])
    ]);
  }
  var ColorPicker = /* @__PURE__ */ _export_sfc(_sfc_main$$, [["render", _sfc_render$u]]);
  var FontWeight_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$_ = {
    components: {
      PopOver,
      InlineEditorButton
    },
    props: ["modelValue"],
    setup(props) {
      const editor = Vue.inject("ZionInlineEditor");
      const isActive = Vue.ref(false);
      const fontWeights = [100, 200, 300, 400, 500, 600, 700, 800, 900];
      const classes = Vue.computed(() => {
        let classes2 = [];
        if (isActive.value) {
          classes2.push("zion-inline-editor-button--active");
        }
        return classes2.join(" ");
      });
      function checkIfActive() {
        isActive.value = fontWeights.some((fontWeight) => {
          return editor.editor.formatter.match("fontWeight", { value: fontWeight });
        });
      }
      Vue.onBeforeMount(() => {
        checkIfActive();
        editor.editor.on("NodeChange", checkIfActive);
      });
      Vue.onBeforeUnmount(() => {
        editor.editor.off("NodeChange", checkIfActive);
      });
      return {
        isActive,
        classes,
        fontWeights
      };
    }
  };
  function _sfc_render$t(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_InlineEditorButton = Vue.resolveComponent("InlineEditorButton");
    const _component_PopOver = Vue.resolveComponent("PopOver");
    return Vue.openBlock(), Vue.createBlock(_component_PopOver, {
      icon: "ite-weight",
      "is-active": $setup.isActive,
      "full-size": true
    }, {
      default: Vue.withCtx(() => [
        (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList($setup.fontWeights, (fontWeight) => {
          return Vue.openBlock(), Vue.createBlock(_component_InlineEditorButton, {
            key: fontWeight,
            formatter: "fontWeight",
            "formatter-value": fontWeight,
            buttontext: fontWeight
          }, null, 8, ["formatter-value", "buttontext"]);
        }), 128))
      ]),
      _: 1
    }, 8, ["is-active"]);
  }
  var FontWeight = /* @__PURE__ */ _export_sfc(_sfc_main$_, [["render", _sfc_render$t]]);
  var PanelLink_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$Z = {
    components: {
      PopOver
    },
    props: {
      fullWidth: {
        type: Boolean,
        required: false
      },
      direction: {
        type: String,
        required: false
      },
      visible: {
        type: Boolean
      }
    },
    setup() {
      const editor = Vue.inject("ZionInlineEditor");
      const isPopOverVisible = Vue.ref(false);
      Vue.ref(false);
      const linkTarget = Vue.ref("_self");
      const linkUrl = Vue.ref("");
      const linkTitle = Vue.ref("");
      const selectOptions = [
        {
          id: "_self",
          name: "Self"
        },
        {
          id: "_blank",
          name: "New Window"
        }
      ];
      const hasLink = Vue.ref(false);
      const buttonClasses = Vue.computed(() => {
        let classes = [];
        if (hasLink.value) {
          classes.push("zion-inline-editor-button--active");
        }
        return classes.join(" ");
      });
      function onNodeChange(node) {
        if (node.selectionChange) {
          getLink();
        }
      }
      function getLink() {
        let link = editor.editor.dom.getParent(editor.editor.selection.getStart(), "a[href]");
        if (link) {
          linkTarget.value = link.target || "_self";
          linkUrl.value = link.getAttribute("href");
          linkTitle.value = link.getAttribute("title");
          hasLink.value = true;
        } else {
          linkUrl.value = null;
          linkTitle.value = "";
          hasLink.value = false;
        }
      }
      function addLink(closePopper = true) {
        if (linkUrl.value) {
          editor.editor.formatter.apply("link", {
            href: linkUrl.value,
            target: linkTarget.value,
            title: linkTitle.value
          });
        } else {
          editor.editor.formatter.remove("link");
        }
        if (closePopper) {
          isPopOverVisible.value = false;
        }
      }
      Vue.onMounted(() => {
        getLink();
        editor.editor.on("NodeChange", onNodeChange);
      });
      Vue.onBeforeUnmount(() => {
        editor.editor.off("NodeChange", onNodeChange);
      });
      return {
        isPopOverVisible,
        linkTarget,
        linkUrl,
        linkTitle,
        selectOptions,
        buttonClasses,
        addLink,
        hasLink
      };
    }
  };
  const _hoisted_1$P = { class: "zion-inline-editor-link-wrapper" };
  const _hoisted_2$A = { class: "zion-inline-editor-popover__link-title" };
  function _sfc_render$s(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Icon = Vue.resolveComponent("Icon");
    const _component_BaseInput = Vue.resolveComponent("BaseInput");
    const _component_InputWrapper = Vue.resolveComponent("InputWrapper");
    const _component_InputSelect = Vue.resolveComponent("InputSelect");
    const _component_PopOver = Vue.resolveComponent("PopOver");
    return Vue.openBlock(), Vue.createBlock(_component_PopOver, {
      icon: "ite-link",
      "full-size": true
    }, {
      default: Vue.withCtx(() => [
        Vue.createElementVNode("div", _hoisted_1$P, [
          Vue.createVNode(_component_InputWrapper, {
            title: _ctx.$translate("add_a_link")
          }, {
            default: Vue.withCtx(() => [
              Vue.createVNode(_component_BaseInput, {
                modelValue: $setup.linkUrl,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.linkUrl = $event),
                clearable: true,
                placeholder: "www.address.com",
                onKeyup: Vue.withKeys($setup.addLink, ["enter"])
              }, {
                prepend: Vue.withCtx(() => [
                  Vue.createVNode(_component_Icon, { icon: "link" })
                ]),
                _: 1
              }, 8, ["modelValue", "onKeyup"])
            ]),
            _: 1
          }, 8, ["title"]),
          Vue.createElementVNode("div", _hoisted_2$A, [
            Vue.createVNode(_component_InputWrapper, {
              title: _ctx.$translate("target")
            }, {
              default: Vue.withCtx(() => [
                Vue.createVNode(_component_InputSelect, {
                  options: $setup.selectOptions,
                  modelValue: $setup.linkTarget,
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $setup.linkTarget = $event),
                  placeholder: "Select target"
                }, null, 8, ["options", "modelValue"])
              ]),
              _: 1
            }, 8, ["title"]),
            Vue.createVNode(_component_InputWrapper, {
              title: _ctx.$translate("title")
            }, {
              default: Vue.withCtx(() => [
                Vue.createVNode(_component_BaseInput, {
                  modelValue: $setup.linkTitle,
                  "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $setup.linkTitle = $event),
                  placeholder: "link_title",
                  clearable: true,
                  onKeyup: Vue.withKeys($setup.addLink, ["enter"])
                }, null, 8, ["modelValue", "onKeyup"])
              ]),
              _: 1
            }, 8, ["title"])
          ])
        ])
      ]),
      _: 1
    });
  }
  var PanelLink = /* @__PURE__ */ _export_sfc(_sfc_main$Z, [["render", _sfc_render$s]]);
  const _sfc_main$Y = {
    name: "TextAlign",
    components: {
      InlineEditorButton,
      PopOver
    },
    setup(props) {
      const editor = Vue.inject("ZionInlineEditor");
      const isActive = Vue.ref(false);
      const buttons = [
        {
          formatter: "alignleft",
          icon: "align--left"
        },
        {
          formatter: "aligncenter",
          icon: "align--center"
        },
        {
          formatter: "alignright",
          icon: "align--right"
        },
        {
          formatter: "alignjustify",
          icon: "align--justify"
        }
      ];
      function checkIfActive() {
        isActive.value = editor.editor.formatter.matchAll([
          "alignleft",
          "aligncenter",
          "alignright",
          "alignjustify"
        ]).length > 0;
      }
      Vue.onBeforeMount(() => {
        checkIfActive();
        editor.editor.on("NodeChange", checkIfActive);
      });
      Vue.onBeforeUnmount(() => {
        editor.editor.off("NodeChange", checkIfActive);
      });
      return {
        isActive,
        buttons
      };
    }
  };
  function _sfc_render$r(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_InlineEditorButton = Vue.resolveComponent("InlineEditorButton");
    const _component_PopOver = Vue.resolveComponent("PopOver");
    return Vue.openBlock(), Vue.createBlock(_component_PopOver, {
      icon: "ite-alignment",
      "is-active": $setup.isActive
    }, {
      default: Vue.withCtx(() => [
        (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList($setup.buttons, (button) => {
          return Vue.openBlock(), Vue.createBlock(_component_InlineEditorButton, {
            key: button.formatter,
            formatter: button.formatter,
            icon: button.icon
          }, null, 8, ["formatter", "icon"]);
        }), 128))
      ]),
      _: 1
    }, 8, ["is-active"]);
  }
  var TextAlign = /* @__PURE__ */ _export_sfc(_sfc_main$Y, [["render", _sfc_render$r]]);
  var FontSize_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$X = {
    setup(props, { emit }) {
      const editor = Vue.inject("ZionInlineEditor");
      const unitsExpanded = Vue.ref(false);
      const sliderValue = Vue.ref(null);
      const inputRangeDynamicRef = Vue.ref(null);
      let changeTimeout = null;
      let isCurrentChange = false;
      const options2 = [
        {
          unit: "px",
          min: 6,
          max: 300,
          step: 1,
          shiftStep: 5
        },
        {
          unit: "%",
          min: 1,
          max: 100,
          step: 1,
          shiftStep: 5
        },
        {
          unit: "rem",
          min: 1,
          max: 6,
          step: 1,
          shiftStep: 1
        },
        {
          unit: "pt",
          min: 1,
          max: 60,
          step: 1,
          shiftStep: 1
        },
        {
          unit: "vh",
          min: 1,
          max: 100,
          step: 5,
          shiftStep: 1
        }
      ];
      function onClick(e) {
        emit("units-expanded", inputRangeDynamicRef.value ? inputRangeDynamicRef.value.$refs.InputNumberUnit.expanded : null);
      }
      function onFontChange(newValue) {
        editor.editor.formatter.apply("fontsize", { value: newValue });
        sliderValue.value = newValue;
        emit("started-dragging");
        emit("units-expanded", inputRangeDynamicRef.value ? inputRangeDynamicRef.value.$refs.InputNumberUnit.expanded : null);
        inputRangeDynamicRef.value.$refs.InputNumberUnit.$refs.numberUnitInput.$refs.input.focus();
        clearTimeout(changeTimeout);
        changeTimeout = setTimeout(() => {
          isCurrentChange = false;
        }, 100);
        isCurrentChange = true;
      }
      function onNodeChange(node) {
        if (!isCurrentChange) {
          getFontSize();
        }
      }
      function getFontSize() {
        sliderValue.value = editor.editor.queryCommandValue("FontSize");
      }
      Vue.onMounted(() => {
        getFontSize();
        editor.editor.on("SelectionChange", onNodeChange);
      });
      Vue.onBeforeUnmount(() => {
        editor.editor.off("SelectionChange", onNodeChange);
      });
      return {
        unitsExpanded,
        options: options2,
        sliderValue,
        onClick,
        onFontChange,
        inputRangeDynamicRef
      };
    }
  };
  const _hoisted_1$O = { class: "zion-inline-editor-slider-area" };
  function _sfc_render$q(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_InputRangeDynamic = Vue.resolveComponent("InputRangeDynamic");
    return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$O, [
      Vue.createVNode(_component_InputRangeDynamic, {
        "onUpdate:modelValue": $setup.onFontChange,
        modelValue: $setup.sliderValue,
        options: $setup.options,
        onClick: Vue.withModifiers($setup.onClick, ["stop"]),
        class: "zion-inline-editor-slider-area--slider",
        ref: "inputRangeDynamicRef"
      }, null, 8, ["onUpdate:modelValue", "modelValue", "options", "onClick"])
    ]);
  }
  var fontSize = /* @__PURE__ */ _export_sfc(_sfc_main$X, [["render", _sfc_render$q]]);
  var LineHeight_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$W = {
    setup(props, { emit }) {
      const editor = Vue.inject("ZionInlineEditor");
      const unitsExpanded = Vue.ref(false);
      const sliderValue = Vue.ref(null);
      const inputRangeDynamicRef = Vue.ref(null);
      let changeTimeout = null;
      let isCurrentChange = false;
      let options2 = [
        {
          unit: "px",
          min: 1,
          max: 400,
          step: 1,
          shiftStep: 5
        },
        {
          unit: "em",
          min: 1,
          max: 100,
          step: 1,
          shiftStep: 5
        },
        {
          unit: "%",
          min: 1,
          max: 100,
          step: 1,
          shiftStep: 5
        },
        {
          unit: "normal",
          min: null,
          max: null,
          step: null,
          shiftStep: null
        }
      ];
      function onClick(e) {
        emit("units-expanded", inputRangeDynamicRef.value ? inputRangeDynamicRef.value.$refs.InputNumberUnit.expanded : null);
      }
      function onHeightChange(newValue) {
        editor.editor.formatter.apply("lineHeight", { value: newValue });
        sliderValue.value = newValue;
        emit("started-dragging");
        emit("units-expanded", inputRangeDynamicRef.value ? inputRangeDynamicRef.value.$refs.InputNumberUnit.expanded : null);
        inputRangeDynamicRef.value.$refs.InputNumberUnit.$refs.numberUnitInput.$refs.input.focus();
        clearTimeout(changeTimeout);
        changeTimeout = setTimeout(() => {
          isCurrentChange = false;
        }, 100);
        isCurrentChange = true;
      }
      function onNodeChange(node) {
        if (!isCurrentChange) {
          getLineHeight();
        }
      }
      function getLineHeight() {
        sliderValue.value = window.getComputedStyle(editor.editor.selection.getNode()).getPropertyValue("line-height");
      }
      Vue.onMounted(() => {
        editor.editor.formatter.register("lineHeight", {
          selector: "span,p,h1,h2,h3,h4,h5,h6,td,th,div,ul,ol,li,table,img",
          styles: { "line-height": "%value" }
        });
        getLineHeight();
        editor.editor.on("SelectionChange", onNodeChange);
      });
      Vue.onBeforeUnmount(() => {
        editor.editor.off("SelectionChange", onNodeChange);
      });
      return {
        unitsExpanded,
        options: options2,
        sliderValue,
        onClick,
        inputRangeDynamicRef,
        onHeightChange
      };
    }
  };
  const _hoisted_1$N = { class: "zion-inline-editor-slider-area" };
  function _sfc_render$p(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_InputRangeDynamic = Vue.resolveComponent("InputRangeDynamic");
    return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$N, [
      Vue.createVNode(_component_InputRangeDynamic, {
        "onUpdate:modelValue": $setup.onHeightChange,
        modelValue: $setup.sliderValue,
        options: $setup.options,
        class: "zion-inline-editor-slider-area--slider",
        ref: "inputRangeDynamicRef"
      }, null, 8, ["onUpdate:modelValue", "modelValue", "options"])
    ]);
  }
  var lineHeight = /* @__PURE__ */ _export_sfc(_sfc_main$W, [["render", _sfc_render$p]]);
  var LetterSpacing_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$V = {
    setup(props, { emit }) {
      const editor = Vue.inject("ZionInlineEditor");
      const sliderValue = Vue.ref(null);
      const inputRangeDynamicRef = Vue.ref(null);
      let isCurrentChange = false;
      let changeTimeout = null;
      const options2 = [
        {
          unit: "px",
          min: 0,
          max: 300,
          step: 1,
          shiftStep: 5
        },
        {
          unit: "rem",
          min: 1,
          max: 10,
          step: 1,
          shiftStep: 1
        },
        {
          unit: "normal",
          min: null,
          max: null,
          step: null,
          shiftStep: null
        }
      ];
      function onClick(e) {
        emit("units-expanded", inputRangeDynamicRef.value ? inputRangeDynamicRef.value.$refs.InputNumberUnit.expanded : null);
      }
      function onLetterChange(newValue) {
        editor.editor.formatter.apply("letterSpacing", { value: newValue });
        sliderValue.value = newValue;
        emit("started-dragging");
        emit("units-expanded", inputRangeDynamicRef.value ? inputRangeDynamicRef.value.$refs.InputNumberUnit.expanded : null);
        inputRangeDynamicRef.value.$refs.InputNumberUnit.$refs.numberUnitInput.$refs.input.focus();
        clearTimeout(changeTimeout);
        changeTimeout = setTimeout(() => {
          isCurrentChange = false;
        }, 100);
        isCurrentChange = true;
      }
      function onNodeChange(node) {
        if (!isCurrentChange) {
          getLetterSpacing();
        }
      }
      function getLetterSpacing() {
        let letterSpacing2 = window.getComputedStyle(editor.editor.selection.getNode()).getPropertyValue("letter-spacing");
        sliderValue.value = letterSpacing2;
      }
      Vue.onMounted(() => {
        editor.editor.formatter.register("letterSpacing", {
          selector: "span,p,h1,h2,h3,h4,h5,h6,td,th,div,ul,ol,li,table,img",
          styles: { "letter-spacing": "%value" }
        });
        getLetterSpacing();
        editor.editor.on("SelectionChange", onNodeChange);
      });
      Vue.onBeforeUnmount(() => {
        editor.editor.off("SelectionChange", onNodeChange);
      });
      return {
        onLetterChange,
        sliderValue,
        options: options2,
        onClick,
        inputRangeDynamicRef
      };
    }
  };
  const _hoisted_1$M = { class: "zion-inline-editor-slider-area" };
  function _sfc_render$o(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_InputRangeDynamic = Vue.resolveComponent("InputRangeDynamic");
    return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$M, [
      Vue.createVNode(_component_InputRangeDynamic, {
        "onUpdate:modelValue": $setup.onLetterChange,
        modelValue: $setup.sliderValue,
        options: $setup.options,
        onClick: Vue.withModifiers($setup.onClick, ["stop"]),
        class: "zion-inline-editor-slider-area--slider",
        ref: "inputRangeDynamicRef"
      }, null, 8, ["onUpdate:modelValue", "modelValue", "options", "onClick"])
    ]);
  }
  var letterSpacing = /* @__PURE__ */ _export_sfc(_sfc_main$V, [["render", _sfc_render$o]]);
  var FontsList_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$U = {
    setup(props, { emit }) {
      const editor = Vue.inject("ZionInlineEditor");
      const { fontsListForOption } = useDataSetsStore();
      const activeFont = Vue.ref(null);
      function isActive(fontName) {
        return activeFont.value === fontName ? "zion-inline-editor__font-list-item--active" : "";
      }
      function onNodeChange(node) {
        getFontName();
      }
      function changeFont(font, event2) {
        activeFont.value = font;
        editor.editor.formatter.toggle("fontname", {
          value: font
        });
      }
      function getFontName() {
        activeFont.value = editor.editor.queryCommandValue("fontname");
      }
      Vue.onMounted(() => {
        getFontName();
        editor.editor.on("SelectionChange", onNodeChange);
      });
      Vue.onBeforeUnmount(() => {
        editor.editor.off("SelectionChange", onNodeChange);
      });
      return {
        fontsListForOption,
        isActive,
        changeFont
      };
    }
  };
  const _hoisted_1$L = { class: "" };
  const _hoisted_2$z = { class: "zion-inline-editor__font-panel znpb-fancy-scrollbar" };
  const _hoisted_3$r = ["onClick"];
  function _sfc_render$n(_ctx, _cache, $props, $setup, $data, $options) {
    return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$L, [
      Vue.createElementVNode("ul", _hoisted_2$z, [
        (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList($setup.fontsListForOption, (font, i) => {
          return Vue.openBlock(), Vue.createElementBlock("li", {
            key: i,
            class: Vue.normalizeClass(["zion-inline-editor__font-list-item", { "zion-inline-editor__font-list-item--active": $setup.isActive(font.id) }]),
            onClick: ($event) => $setup.changeFont(font.id, $event)
          }, Vue.toDisplayString(font.name), 11, _hoisted_3$r);
        }), 128))
      ])
    ]);
  }
  var FontList = /* @__PURE__ */ _export_sfc(_sfc_main$U, [["render", _sfc_render$n]]);
  var FontStyles_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$T = {
    name: "FontStyles",
    components: {
      "zion-inline-editor-font-size": fontSize,
      "zion-inline-editor-line-height": lineHeight,
      "zion-inline-editor-letter-spacing": letterSpacing,
      "zion-inline-editor-button": InlineEditorButton,
      FontList,
      PopOver
    },
    setup() {
      const isOpen = Vue.ref(false);
      const buttonClasses = Vue.computed(() => {
        let classes = [];
        if (isOpen.value) {
          classes.push("zion-inline-editor-button--active");
        }
        return classes.join(" ");
      });
      return {
        isOpen,
        buttonClasses
      };
    }
  };
  const _hoisted_1$K = { class: "zion-inline-editor-group" };
  function _sfc_render$m(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_FontList = Vue.resolveComponent("FontList");
    const _component_Tab = Vue.resolveComponent("Tab");
    const _component_zion_inline_editor_button = Vue.resolveComponent("zion-inline-editor-button");
    const _component_zion_inline_editor_font_size = Vue.resolveComponent("zion-inline-editor-font-size");
    const _component_zion_inline_editor_line_height = Vue.resolveComponent("zion-inline-editor-line-height");
    const _component_zion_inline_editor_letter_spacing = Vue.resolveComponent("zion-inline-editor-letter-spacing");
    const _component_Tabs = Vue.resolveComponent("Tabs");
    const _component_PopOver = Vue.resolveComponent("PopOver");
    return Vue.openBlock(), Vue.createBlock(_component_PopOver, {
      icon: "ite-font",
      "full-size": true
    }, {
      default: Vue.withCtx(() => [
        Vue.createElementVNode("div", _hoisted_1$K, [
          Vue.createVNode(_component_Tabs, { "tab-style": "minimal" }, {
            default: Vue.withCtx(() => [
              Vue.createVNode(_component_Tab, {
                name: _ctx.$translate("family")
              }, {
                default: Vue.withCtx(() => [
                  Vue.createVNode(_component_FontList)
                ]),
                _: 1
              }, 8, ["name"]),
              Vue.createVNode(_component_Tab, {
                name: _ctx.$translate("heading"),
                class: "zion-inline-editor-group__heading"
              }, {
                default: Vue.withCtx(() => [
                  Vue.createElementVNode("div", null, [
                    Vue.createVNode(_component_zion_inline_editor_button, {
                      formatter: "h1",
                      buttontext: "H1"
                    }),
                    Vue.createVNode(_component_zion_inline_editor_button, {
                      formatter: "h2",
                      buttontext: "H2"
                    }),
                    Vue.createVNode(_component_zion_inline_editor_button, {
                      formatter: "h3",
                      buttontext: "H3"
                    }),
                    Vue.createVNode(_component_zion_inline_editor_button, {
                      formatter: "h4",
                      buttontext: "H4"
                    }),
                    Vue.createVNode(_component_zion_inline_editor_button, {
                      formatter: "h5",
                      buttontext: "H5"
                    }),
                    Vue.createVNode(_component_zion_inline_editor_button, {
                      formatter: "h6",
                      buttontext: "H6"
                    })
                  ])
                ]),
                _: 1
              }, 8, ["name"]),
              Vue.createVNode(_component_Tab, {
                name: _ctx.$translate("font_size")
              }, {
                default: Vue.withCtx(() => [
                  Vue.createVNode(_component_zion_inline_editor_font_size)
                ]),
                _: 1
              }, 8, ["name"]),
              Vue.createVNode(_component_Tab, {
                name: _ctx.$translate("line_height")
              }, {
                default: Vue.withCtx(() => [
                  Vue.createVNode(_component_zion_inline_editor_line_height)
                ]),
                _: 1
              }, 8, ["name"]),
              Vue.createVNode(_component_Tab, {
                name: _ctx.$translate("letter_spacing")
              }, {
                default: Vue.withCtx(() => [
                  Vue.createVNode(_component_zion_inline_editor_letter_spacing)
                ]),
                _: 1
              }, 8, ["name"])
            ]),
            _: 1
          })
        ])
      ]),
      _: 1
    });
  }
  var FontStyle = /* @__PURE__ */ _export_sfc(_sfc_main$T, [["render", _sfc_render$m]]);
  var InlineEditor_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$S = {
    name: "InlineEditor",
    components: {
      InlineEditorButton,
      ColorPicker,
      FontWeight,
      PopOver,
      PanelLink,
      TextAlign,
      FontStyle
    },
    props: {
      modelValue: {
        type: String,
        required: false
      },
      forcedRootNode: {
        type: [Boolean, String],
        default: ""
      }
    },
    setup(props, { emit }) {
      let TinyMCEEditor = {
        editor: null
      };
      const UIStore = useUIStore();
      const { modelValue } = Vue.toRefs(props);
      const inlineEditorRef = Vue.ref(null);
      const tooltipContentRef = Vue.ref(null);
      const tinyMceReady = Vue.ref(false);
      const showEditor = Vue.ref(false);
      const isDragging = Vue.ref(false);
      const dragButtonOnScreen = Vue.ref(true);
      const unitsExpanded = Vue.ref(false);
      const isSliderDragging = Vue.ref(false);
      const initialPosition = Vue.ref({});
      const lastPositionX = Vue.ref(0);
      const lastPositionY = Vue.ref(0);
      const yOffset = Vue.ref(0);
      const position = Vue.ref({
        offsetY: 75,
        offsetX: null,
        posX: null,
        posY: null
      });
      Vue.provide("ZionInlineEditor", TinyMCEEditor);
      const barStyles = Vue.computed(() => {
        return {
          transform: `translate(${position.value.posX}px, ${position.value.posY}px)`
        };
      });
      function saveContent() {
        emit("update:modelValue", TinyMCEEditor.editor.getContent());
      }
      function initWatcher() {
        Vue.watch(modelValue, (newValue, oldValue) => {
          if (TinyMCEEditor.editor && typeof newValue === "string" && newValue !== oldValue && newValue !== TinyMCEEditor.editor.getContent()) {
            TinyMCEEditor.editor.setContent(newValue);
          }
        });
      }
      function getConfig() {
        return {
          target: inlineEditorRef.value,
          entity_encoding: "raw",
          toolbar: false,
          menubar: false,
          selection_toolbar: false,
          inline: true,
          object_resizing: false,
          setup: (editor) => {
            editor.on("init", (e) => {
              tinyMceReady.value = true;
              TinyMCEEditor.editor = editor;
              editor.setContent(props.modelValue);
              initWatcher();
            });
            editor.on("change input undo redo", saveContent);
          },
          forced_root_block: "",
          formats: {
            fontSize: {
              selector: "span,p,h1,h2,h3,h4,h5,h6,td,th,div,ul,ol,li,table,img",
              classes: "znpb-fontsize",
              styles: { fontSize: "%value" }
            },
            fontWeight: {
              inline: "span",
              selector: "span,p,h1,h2,h3,h4,h5,h6,td,th,div,ul,ol,li,table,img",
              classes: "znpb-fontweight",
              styles: { fontWeight: "%value" }
            },
            uppercase: {
              selector: "span,p,h1,h2,h3,h4,h5,h6,td,th,div,ul,ol,li,table,img",
              classes: "znpb-uppercase",
              styles: { textTransform: "uppercase" }
            },
            blockquote: {
              block: "blockquote",
              wrapper: true,
              classes: "znpb-blockquote",
              exact: true
            },
            italic: { inline: "i", exact: true }
          }
        };
      }
      function onColorPickerOpen() {
        inlineEditorRef.value.classList.add("mce-content-body--selection-transparent");
      }
      function onColorPickerClose() {
        inlineEditorRef.value.classList.remove("mce-content-body--selection-transparent");
      }
      function onUnitsExpanded(event2) {
        unitsExpanded.value = event2;
      }
      function onStartedSliderDragging() {
        document.addEventListener("mouseup", onDraggingInput);
        isSliderDragging.value = true;
      }
      function onDraggingInput() {
        setTimeout(() => {
          isSliderDragging.value = false;
        }, 300);
      }
      function startDrag(event2) {
        window.addEventListener("mouseup", stopDrag);
        window.addEventListener("mousemove", onDragMove);
        document.body.style.userSelect = "none";
        initialPosition.value = {
          posX: event2.clientX,
          posY: event2.clientY
        };
        isDragging.value = true;
        yOffset.value = window.pageYOffset;
      }
      function onDragMove(event2) {
        position.value = {
          posX: lastPositionX.value + event2.pageX - initialPosition.value.posX,
          posY: lastPositionY.value + event2.pageY - initialPosition.value.posY - yOffset.value
        };
      }
      function stopDrag(event2) {
        lastPositionX.value = position.value.posX;
        lastPositionY.value = position.value.posY;
        checkDragButtonOnScreen();
        document.body.style.userSelect = null;
        window.removeEventListener("mouseup", stopDrag);
        window.removeEventListener("mousemove", onDragMove);
        isDragging.value = false;
      }
      function checkDragButtonOnScreen() {
        dragButtonOnScreen.value = !isDragButtonOutOfBounds();
      }
      function isDragButtonOutOfBounds() {
        let inlineEditorPosition = getInlineEditorRect();
        if (inlineEditorPosition) {
          return inlineEditorPosition.x < 40;
        }
      }
      function getInlineEditorRect() {
        if (tooltipContentRef.value) {
          return tooltipContentRef.value.getBoundingClientRect();
        }
      }
      function hideEditorOnEscapeKey(event2) {
        if (event2.keyCode === 27) {
          hideEditor();
          event2.stopImmediatePropagation();
        }
      }
      function hideEditor() {
        showEditor.value = false;
      }
      Vue.watch(showEditor, (newValue) => {
        if (newValue) {
          setTimeout(() => {
            document.addEventListener("keydown", hideEditorOnEscapeKey, true);
            document.addEventListener("scroll", hideEditor);
          }, 10);
        } else {
          document.removeEventListener("keydown", hideEditorOnEscapeKey, true);
          document.removeEventListener("scroll", hideEditor, true);
        }
      });
      function checkTextSelection() {
        if (window.getSelection().toString().length > 0) {
          showEditor.value = true;
        }
      }
      Vue.onMounted(() => {
        if (typeof window.tinyMCE !== "undefined") {
          window.tinyMCE.init(getConfig());
        }
      });
      Vue.onBeforeUnmount(() => {
        if (typeof window.tinyMCE !== "undefined" && TinyMCEEditor.editor) {
          window.tinyMCE.remove(TinyMCEEditor.editor);
        }
      });
      return {
        UIStore,
        inlineEditorRef,
        tooltipContentRef,
        showEditor,
        tinyMceReady,
        isDragging,
        dragButtonOnScreen,
        barStyles,
        onColorPickerOpen,
        onColorPickerClose,
        onUnitsExpanded,
        onStartedSliderDragging,
        startDrag,
        checkTextSelection
      };
    }
  };
  const _hoisted_1$J = ["contenteditable"];
  function _sfc_render$l(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Icon = Vue.resolveComponent("Icon");
    const _component_FontStyle = Vue.resolveComponent("FontStyle");
    const _component_FontWeight = Vue.resolveComponent("FontWeight");
    const _component_InlineEditorButton = Vue.resolveComponent("InlineEditorButton");
    const _component_PanelLink = Vue.resolveComponent("PanelLink");
    const _component_ColorPicker = Vue.resolveComponent("ColorPicker");
    const _component_TextAlign = Vue.resolveComponent("TextAlign");
    const _component_Tooltip = Vue.resolveComponent("Tooltip");
    return Vue.openBlock(), Vue.createBlock(_component_Tooltip, {
      ref: "inlineEditorWrapper",
      class: "znpb-inline-editor__wrapper_all",
      "tooltip-class": "znpb-inline-editor__wrapper hg-popper--no-padding hg-popper--no-bg",
      trigger: null,
      placement: "top",
      "append-to": "body",
      "show-arrows": false,
      show: $setup.showEditor,
      strategy: "fixed",
      "close-on-outside-click": true,
      "hide-on-escape": true,
      onHide: _cache[6] || (_cache[6] = ($event) => $setup.showEditor = false)
    }, {
      content: Vue.withCtx(() => [
        !$setup.UIStore.isPreviewMode && $setup.tinyMceReady ? (Vue.openBlock(), Vue.createElementBlock("div", {
          key: 0,
          ref: "tooltipContentRef",
          class: Vue.normalizeClass(["zion-inline-editor zion-inline-editor-container", { "zion-inline-editor--dragging": $setup.isDragging }]),
          style: Vue.normalizeStyle($setup.barStyles),
          onMousedown: _cache[2] || (_cache[2] = Vue.withModifiers(() => {
          }, ["stop"]))
        }, [
          $setup.dragButtonOnScreen ? (Vue.openBlock(), Vue.createElementBlock("div", {
            key: 0,
            ref: "dragButton",
            class: "zion-inline-editor-dragbutton",
            onMousedown: _cache[0] || (_cache[0] = Vue.withModifiers((...args) => $setup.startDrag && $setup.startDrag(...args), ["stop"]))
          }, [
            Vue.createVNode(_component_Icon, { icon: "ite-move" })
          ], 544)) : Vue.createCommentVNode("", true),
          Vue.createVNode(_component_FontStyle),
          Vue.createVNode(_component_FontWeight),
          Vue.createVNode(_component_InlineEditorButton, {
            formatter: "italic",
            icon: "ite-italic"
          }),
          Vue.createVNode(_component_InlineEditorButton, {
            formatter: "underline",
            icon: "ite-underline"
          }),
          Vue.createVNode(_component_InlineEditorButton, {
            formatter: "uppercase",
            icon: "ite-uppercase"
          }),
          Vue.createVNode(_component_PanelLink),
          Vue.createVNode(_component_InlineEditorButton, {
            formatter: "blockquote",
            icon: "ite-quote"
          }),
          Vue.createVNode(_component_ColorPicker, {
            onCloseColorPicker: $setup.onColorPickerClose,
            onOpenColorPicker: $setup.onColorPickerOpen
          }, null, 8, ["onCloseColorPicker", "onOpenColorPicker"]),
          Vue.createVNode(_component_TextAlign),
          !$setup.dragButtonOnScreen ? (Vue.openBlock(), Vue.createElementBlock("div", {
            key: 1,
            class: "zion-inline-editor-dragbutton",
            onMousedown: _cache[1] || (_cache[1] = Vue.withModifiers((...args) => $setup.startDrag && $setup.startDrag(...args), ["stop"]))
          }, [
            Vue.createVNode(_component_Icon, {
              icon: "more",
              rotate: 90
            })
          ], 32)) : Vue.createCommentVNode("", true)
        ], 38)) : Vue.createCommentVNode("", true)
      ]),
      default: Vue.withCtx(() => [
        Vue.createElementVNode("div", {
          ref: "inlineEditorRef",
          class: Vue.normalizeClass(["znpb-inline-text-editor", { "znpb-inline-text-editor--preview": $setup.UIStore.isPreviewMode }]),
          contenteditable: !$setup.UIStore.isPreviewMode,
          onMouseup: _cache[3] || (_cache[3] = (...args) => $setup.checkTextSelection && $setup.checkTextSelection(...args)),
          onDblclick: _cache[4] || (_cache[4] = Vue.withModifiers(($event) => $setup.showEditor = true, ["stop"])),
          onKeydown: _cache[5] || (_cache[5] = Vue.withModifiers(() => {
          }, ["stop"]))
        }, null, 42, _hoisted_1$J)
      ]),
      _: 1
    }, 8, ["show"]);
  }
  var InlineEditor = /* @__PURE__ */ _export_sfc(_sfc_main$S, [["render", _sfc_render$l]]);
  var ToolboxTitle_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$R = {
    name: "ToolboxTitle",
    props: {
      element: {
        type: Object,
        required: true
      }
    },
    setup(props) {
      const root2 = Vue.ref(null);
      const UIStore = useUIStore();
      const parents = Vue.computed(() => {
        let parents2 = [];
        let activeElement2 = props.element;
        while (activeElement2) {
          parents2.push(activeElement2);
          activeElement2 = activeElement2.parent && activeElement2.parent.element_type !== "contentRoot" ? activeElement2.parent : null;
        }
        return parents2.reverse();
      });
      function editElement(element) {
        UIStore.editElement(element);
      }
      Vue.onMounted(checkReposition);
      const exitsTop = Vue.ref(false);
      const exitsRight = Vue.ref(false);
      function checkReposition() {
        const boundingClientRect = root2.value.getBoundingClientRect();
        exitsTop.value = boundingClientRect.top + window.scrollY < 0;
        exitsRight.value = boundingClientRect.right > (window.innerWidth || document.documentElement.clientWidth);
      }
      function showElementMenu(event2, element) {
        event2.preventDefault();
        event2.stopPropagation();
        UIStore.showElementMenuFromEvent(element, event2);
      }
      return {
        parents,
        root: root2,
        exitsTop,
        exitsRight,
        UIStore,
        editElement,
        showElementMenu
      };
    }
  };
  const _hoisted_1$I = { class: "znpb-element-toolbox__titleWrapper" };
  const _hoisted_2$y = ["onClick", "onContextmenu"];
  const _hoisted_3$q = { class: "znpb-element-toolbox__title" };
  const _hoisted_4$j = { key: 0 };
  const _hoisted_5$g = { key: 1 };
  function _sfc_render$k(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Icon = Vue.resolveComponent("Icon");
    return Vue.openBlock(), Vue.createElementBlock("div", {
      ref: "root",
      class: Vue.normalizeClass(["znpb-element-toolbox__titleFakeWrapper", {
        "znpb-element-toolbox__titleFakeWrapper--bottom": $setup.exitsTop,
        "znpb-element-toolbox__titleFakeWrapper--left": $setup.exitsRight
      }])
    }, [
      Vue.createElementVNode("div", _hoisted_1$I, [
        (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList($setup.parents, (parent2) => {
          return Vue.openBlock(), Vue.createElementBlock("span", {
            key: parent2.uid,
            class: Vue.normalizeClass(["znpb-element-toolbox__titleContainer", { "znpb-element-toolbox__titleContainer--active": parent2 === $setup.UIStore.editedElement }]),
            onClick: Vue.withModifiers(($event) => $setup.editElement(parent2), ["stop"]),
            onContextmenu: ($event) => $setup.showElementMenu($event, parent2)
          }, [
            Vue.createVNode(_component_Icon, {
              icon: "select",
              class: "znpb-element-toolbox__icon",
              size: 9
            }),
            Vue.createElementVNode("span", _hoisted_3$q, [
              parent2.isRepeaterProvider ? (Vue.openBlock(), Vue.createElementBlock("span", _hoisted_4$j, "P")) : Vue.createCommentVNode("", true),
              parent2.isRepeaterConsumer ? (Vue.openBlock(), Vue.createElementBlock("span", _hoisted_5$g, "C")) : Vue.createCommentVNode("", true),
              Vue.createTextVNode(" " + Vue.toDisplayString(parent2.name), 1)
            ])
          ], 42, _hoisted_2$y);
        }), 128))
      ])
    ], 2);
  }
  var ToolboxTitle = /* @__PURE__ */ _export_sfc(_sfc_main$R, [["render", _sfc_render$k]]);
  var ElementToolbox_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$Q = {
    name: "ElementToolbox",
    components: {
      ToolboxTitle
    },
    props: {
      element: Object,
      canHideToolbox: {
        type: Boolean,
        required: false,
        default: true
      }
    },
    setup(props) {
      const UIStore = useUIStore();
      const showColumnTemplates = Vue.ref(false);
      const { activeResponsiveDeviceInfo: activeResponsiveDeviceInfo2 } = useResponsiveDevices();
      const { addEventListener, removeEventListener } = window.zb.editor.useWindows();
      const isToolboxDragging = Vue.ref(false);
      const isActiveElementEdit = Vue.computed(() => {
        return props.element === UIStore.editedElement;
      });
      return {
        showColumnTemplates,
        activeResponsiveDeviceInfo: activeResponsiveDeviceInfo2,
        UIStore,
        addEventListener,
        removeEventListener,
        isActiveElementEdit,
        isToolboxDragging
      };
    },
    data() {
      return {
        computedStyle: null,
        startClientX: null,
        startClientY: null,
        activeDragPosition: null,
        activeDragType: null,
        reversedPosition: null,
        initialSizeValue: null,
        positions2: {
          padding: ["paddingTop", "paddingBottom", "paddingLeft", "paddingRight"],
          margin: ["marginTop", "marginBottom", "marginLeft", "marginRight"]
        },
        styleMap: {
          paddingTop: "padding-top",
          paddingRight: "padding-right",
          paddingBottom: "padding-bottom",
          paddingLeft: "padding-left",
          marginTop: "margin-top",
          marginRight: "margin-right",
          marginBottom: "margin-bottom",
          marginLeft: "margin-left",
          width: "width",
          height: "height"
        },
        positions: {
          top: "Top",
          bottom: "Bottom",
          right: "Right",
          left: "Left"
        },
        popperRefValues: {
          clientX: 0,
          clientY: 0
        },
        popperRef: {
          getBoundingClientRect: () => ({
            top: this.popperRefValues.clientY,
            right: this.popperRefValues.clientX,
            bottom: this.popperRefValues.clientY,
            left: this.popperRefValues.clientX,
            width: 0,
            height: 0
          })
        },
        newValues: null,
        settingEvenPaddingDimensions: null,
        settingEvenMarginsDimensions: null,
        isTopBarOpen: null
      };
    },
    computed: {
      computedSavedValues() {
        const savedValues = get(
          this.element.options,
          `_styles.wrapper.styles.${this.activeResponsiveDeviceInfo.id}.default`,
          {}
        );
        return {
          paddingTop: savedValues[this.styleMap.paddingTop] || this.computedStyle.paddingTop,
          paddingRight: savedValues[this.styleMap.paddingRight] || this.computedStyle.paddingRight,
          paddingBottom: savedValues[this.styleMap.paddingBottom] || this.computedStyle.paddingBottom,
          paddingLeft: savedValues[this.styleMap.paddingLeft] || this.computedStyle.paddingLeft,
          marginTop: savedValues[this.styleMap.marginTop] || this.computedStyle.marginTop,
          marginRight: savedValues[this.styleMap.marginRight] || this.computedStyle.marginRight,
          marginBottom: savedValues[this.styleMap.marginBottom] || this.computedStyle.marginBottom,
          marginLeft: savedValues[this.styleMap.marginLeft] || this.computedStyle.marginLeft,
          height: savedValues[this.styleMap.height] || this.computedStyle.height,
          width: savedValues[this.styleMap.width] || this.computedStyle.width
        };
      },
      computedHelpersStyle() {
        const _a3 = this.styleMap, { height, width } = _a3, remainingProperties = __objRest(_a3, ["height", "width"]);
        const styles = {};
        Object.keys(remainingProperties).forEach((propertyId) => {
          const direction = propertyId.indexOf("Top") !== -1 || propertyId.indexOf("Bottom") !== -1 ? "vertical" : "horizontal";
          const sizeProperty = direction === "vertical" ? "height" : "width";
          const sizeValue = Math.abs(parseInt(this.computedSavedValues[propertyId]));
          styles[propertyId] = {
            [sizeProperty]: `${sizeValue}px`
          };
        });
        return styles;
      },
      getPopperPlacement() {
        if (this.activeDragPosition === "Right") {
          return "left";
        } else if (this.activeDragPosition === "Top") {
          return "bottom";
        } else if (this.activeDragPosition === "Bottom") {
          return "top";
        } else
          return "right";
      },
      isAnyDragging() {
        return this.UIStore.isElementDragging || this.isToolboxDragging;
      },
      dragDimension() {
        if (this.activeDragPosition === "Top" || this.activeDragPosition === "Bottom") {
          return "vertical";
        }
        return "horizontal";
      }
    },
    beforeUnmount() {
      this.removeEvents();
    },
    created() {
      this.setComputedStyle();
    },
    methods: {
      startSpacingDrag({ event: event2, type, position }) {
        const { clientX, clientY } = event2;
        const controlKey = Environment.isMac ? "metaKey" : "ctrlKey";
        document.body.style.userSelect = "none";
        this.$emit("update:canHideToolbox", false);
        this.$emit("update:isToolboxDragging", true);
        const startClientX = clientX;
        const startClientY = clientY;
        this.activeDragType = type;
        this.activeDragPosition = position;
        this.isToolboxDragging = true;
        const activeDragValue = this.computedSavedValues[position];
        const match = typeof activeDragValue === "string" && activeDragValue ? activeDragValue.match(/^([+-]?[0-9]+([.][0-9]*)?|[.][0-9]+)(\D+)$/) : null;
        const initialValue = match && match[1] ? parseInt(match[1]) : 0;
        const initialUnit = match ? match[3] : "";
        this.onMouseMoveDebounced = rafSchd$1((event3) => {
          let { direction, distance } = this.getDragInfo({
            event: event3,
            type,
            position,
            startClientX,
            startClientY
          });
          if (["padding", "margin"].includes(type) && position.indexOf("Right") !== -1) {
            distance = distance * -1;
          }
          let updatedValue = initialUnit === "%" ? initialValue + distance * 0.1 : initialValue + distance;
          if (event3.shiftKey) {
            updatedValue = Math.round(updatedValue / 5) * 5;
          }
          if (type === "padding") {
            updatedValue = Math.max(updatedValue, 0);
          }
          updatedValue = Math.round(updatedValue * 10) / 10;
          if (initialValue === updatedValue) {
            return;
          }
          this.updateElementStyle({
            newValue: `${updatedValue}${initialUnit}`,
            type,
            position,
            even: event3[controlKey],
            reversedPosition: event3[controlKey] ? this.getReversedPosition(position) : null
          });
          this.setComputedStyle();
        });
        this.addEventListener("mousemove", this.onMouseMoveDebounced);
        this.addEventListener("mouseup", this.onMouseUp);
      },
      getReversedPosition(position) {
        const typeAndPosition = position.split(/(?=[A-Z])/);
        const positionLocation = typeAndPosition[1];
        let reversePositionLocation;
        switch (positionLocation) {
          case "Top":
            reversePositionLocation = "Bottom";
            break;
          case "Bottom":
            reversePositionLocation = "Top";
            break;
          case "Left":
            reversePositionLocation = "Right";
            break;
          case "Right":
            reversePositionLocation = "Left";
            break;
        }
        return `${typeAndPosition[0]}${reversePositionLocation}`;
      },
      updateElementStyle({ newValue, type, position, even, reversedPosition }) {
        const activeDragCssProperty = this.styleMap[position];
        window.zb.run("editor/elements/update-element-options", {
          elementUID: this.element.uid,
          newValues: newValue,
          path: `_styles.wrapper.styles.${this.activeResponsiveDeviceInfo.id}.default.${activeDragCssProperty}`
        });
        if (even) {
          const activeDragReversedCssProperty = this.styleMap[reversedPosition];
          window.zb.run("editor/elements/update-element-options", {
            elementUID: this.element.uid,
            newValues: newValue,
            path: `_styles.wrapper.styles.${this.activeResponsiveDeviceInfo.id}.default.${activeDragReversedCssProperty}`
          });
        }
      },
      getDragInfo({ event: event2, type, position, startClientX, startClientY }) {
        const direction = position.indexOf("Top") !== -1 || position.indexOf("Bottom") !== -1 ? "vertical" : "horizontal";
        let distance = direction === "vertical" ? event2.clientY - startClientY : event2.clientX - startClientX;
        return {
          direction,
          distance
        };
      },
      onMouseUp() {
        this.onMouseMoveDebounced.cancel();
        this.removeEventListener("mousemove", this.onMouseMoveDebounced);
        this.removeEventListener("mouseup", this.onMouseUp);
        this.onMouseMoveDebounced = null;
        this.activeDragType = null;
        this.activeDragPosition = null;
        this.isToolboxDragging = false;
        document.body.style.userSelect = null;
        this.$emit("update:canHideToolbox", true);
        this.$emit("update:isToolboxDragging", false);
      },
      setTopBarDisplay(event2) {
        this.isTopBarOpen = event2;
      },
      getNumberFromString(string) {
        return parseInt(string.match(/\d+/)[0]);
      },
      setComputedStyle() {
        if (this.$parent.$el) {
          this.computedStyle = window.getComputedStyle(this.$parent.$el);
        }
      },
      removeEvents() {
        this.removeEventListener("mousemove", this.changeSizeDebounced);
        this.removeEventListener("mousemove", this.changePaddingWidth);
        this.removeEventListener("mousemove", this.changeMarginWidth);
        this.removeEventListener("mouseup", this.endDragging);
      },
      getSizeChangePropertyFromPosition(position) {
        let propertyToChange = null;
        if (position === "Top" || position === "Bottom") {
          propertyToChange = "min-height";
        } else {
          propertyToChange = "width";
        }
        return propertyToChange;
      },
      startSizeDrag(event2, position, positionIndex) {
        const { clientX, clientY } = event2;
        this.$emit("update:canHideToolbox", false);
        this.$emit("update:isToolboxDragging", true);
        this.startClientX = clientX;
        this.startClientY = clientY;
        this.popperRefValues = { clientX, clientY };
        this.activeDragPosition = position;
        this.activeDragType = "size";
        const property2 = this.getSizeChangePropertyFromPosition(position);
        document.body.style.userSelect = "none";
        this.initialSizeValue = parseInt(this.getSizeValue(property2));
        this.changeSizeDebounced = rafSchd$1(this.changeSize);
        this.addEventListener("mousemove", this.changeSizeDebounced);
        this.addEventListener("mouseup", this.endDragging);
      },
      getSizeValue(type) {
        let value = this.element.getOptionValue(
          `_styles.wrapper.styles.${this.activeResponsiveDeviceInfo.id}.default.${type}`
        );
        if (value !== null) {
          return value;
        }
        const alternativeType = type === "min-height" ? "height" : "width";
        const sizeValue = this.computedStyle.getPropertyValue(alternativeType);
        return this.getNumberFromString(sizeValue) || 0;
      },
      changeSize(event2) {
        const { clientX, clientY } = event2;
        if (!this.activeDragPosition) {
          return;
        }
        let newValue = null;
        const property2 = this.getSizeChangePropertyFromPosition(this.activeDragPosition);
        const direction = this.dragDimension === "vertical" ? "vertical" : "horizontal";
        if (direction === "vertical") {
          const distance = clientY - this.startClientY;
          newValue = this.activeDragPosition === "Top" ? this.initialSizeValue - distance : this.initialSizeValue + distance;
        } else {
          if (this.activeDragPosition === "Right") {
            const distance = clientX - this.startClientX;
            newValue = distance + this.initialSizeValue;
          } else {
            const distance = this.startClientX - clientX;
            newValue = distance + this.initialSizeValue;
          }
        }
        if (newValue < 0) {
          newValue = 0;
        }
        this.newValues = newValue;
        window.zb.run("editor/elements/update-element-options", {
          elementUID: this.element.uid,
          newValues: `${newValue}px`,
          path: `_styles.wrapper.styles.${this.activeResponsiveDeviceInfo.id}.default.${property2}`
        });
        if (this.$refs[`sizeDrag--${this.activeDragPosition}`]) {
          const { bottom: bottom2, left: left2, top: top2, right: right2 } = this.$refs.rectangle.getBoundingClientRect();
          if (this.activeDragPosition === "Top") {
            this.popperRefValues.clientY = top2;
          } else if (this.activeDragPosition === "Right") {
            this.popperRefValues.clientX = right2;
          } else if (this.activeDragPosition === "Bottom") {
            this.popperRefValues.clientY = bottom2;
          } else
            this.popperRefValues.clientX = left2;
          this.$refs[`sizeDrag--${this.activeDragPosition}`][0].scheduleUpdate();
        }
      },
      endDragging() {
        document.body.style.userSelect = null;
        this.startClientX = null;
        this.startClientY = null;
        this.activeDragPosition = null;
        this.popperRef = null;
        this.$emit("update:canHideToolbox", true);
        this.$emit("update:isToolboxDragging", false);
        this.settingEvenPaddingDimensions = false;
        this.removeEvents();
      }
    }
  };
  const _hoisted_1$H = ["onMousedown"];
  const _hoisted_2$x = /* @__PURE__ */ Vue.createElementVNode("span", { class: "znpb-element-toolbox__resize-width-bg" }, null, -1);
  const _hoisted_3$p = [
    _hoisted_2$x
  ];
  const _hoisted_4$i = ["onMousedown"];
  function _sfc_render$j(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_ToolboxTitle = Vue.resolveComponent("ToolboxTitle");
    const _component_Tooltip = Vue.resolveComponent("Tooltip");
    const _component_AddElementIcon = Vue.resolveComponent("AddElementIcon");
    return Vue.openBlock(), Vue.createElementBlock("div", {
      ref: "rectangle",
      class: Vue.normalizeClass(["znpb-element-toolbox", {
        "znpb-element-toolbox--dragging": $options.isAnyDragging,
        "znpb-element-toolbox--loopProvider": $props.element.isRepeaterProvider,
        "znpb-element-toolbox--loopConsumer": $props.element.isRepeaterConsumer,
        [`znpb-element-toolbox__resize-${$data.activeDragType}-${$data.activeDragPosition}--dragging`]: $setup.isToolboxDragging
      }])
    }, [
      Vue.createVNode(_component_ToolboxTitle, { element: $props.element }, null, 8, ["element"]),
      $data.computedStyle && $setup.isActiveElementEdit ? (Vue.openBlock(), Vue.createElementBlock(Vue.Fragment, { key: 0 }, [
        (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList($data.positions, (position, positionIndex) => {
          return Vue.openBlock(), Vue.createBlock(_component_Tooltip, {
            ref_for: true,
            ref: `sizeDrag--${position}`,
            key: `size-${position}`,
            "tooltip-class": "hg-popper--big-arrows znpb-sizing-label",
            placement: $options.getPopperPlacement,
            "append-to": "body",
            trigger: "null",
            "show-arrows": false,
            show: $data.activeDragType === "size" && $data.activeDragPosition === position && $data.newValues != void 0,
            "popper-ref": $data.popperRef,
            onMousedown: Vue.withModifiers(($event) => $options.startSizeDrag($event, position), ["left", "stop"])
          }, {
            content: Vue.withCtx(() => [
              Vue.createElementVNode("span", null, Vue.toDisplayString($data.newValues !== void 0 ? $data.newValues + "px" : ""), 1)
            ]),
            default: Vue.withCtx(() => [
              Vue.createElementVNode("div", {
                class: Vue.normalizeClass(["znpb-element-toolbox__resize-width znpb-element-toolbox__resize-dimensions", {
                  [`znpb-element-toolbox__resize-width--${positionIndex}`]: true,
                  [`znpb-element-toolbox__resize-dimensions--${positionIndex === "top" || positionIndex === "bottom" ? "height" : "width"}`]: true
                }]),
                onMousedown: Vue.withModifiers(($event) => $options.startSizeDrag($event, position), ["left", "stop"])
              }, _hoisted_3$p, 42, _hoisted_1$H)
            ]),
            _: 2
          }, 1032, ["placement", "show", "popper-ref", "onMousedown"]);
        }), 128)),
        (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList($data.positions2, (positions, type) => {
          return Vue.openBlock(), Vue.createElementBlock(Vue.Fragment, null, [
            (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList(positions, (position) => {
              return Vue.openBlock(), Vue.createElementBlock("div", {
                key: `${type}-${position}`,
                class: Vue.normalizeClass({
                  [`znpb-element-toolbox__resize`]: true,
                  [`znpb-element-toolbox__resize-${type}`]: true,
                  [`znpb-element-toolbox__resize--${position}`]: true,
                  ["znpb-element-toolbox__resize--dragging"]: $data.activeDragType === type && ($data.activeDragPosition === position || $data.reversedPosition === position)
                }),
                onMousedown: Vue.withModifiers(($event) => $options.startSpacingDrag({ event: $event, type, position }), ["left", "stop"])
              }, [
                Vue.createElementVNode("div", {
                  class: "znpb-element-toolbox__resize-value",
                  style: Vue.normalizeStyle($options.computedHelpersStyle[position])
                }, [
                  Vue.createElementVNode("span", null, Vue.toDisplayString($options.computedSavedValues[position]), 1)
                ], 4)
              ], 42, _hoisted_4$i);
            }), 128))
          ], 64);
        }), 256))
      ], 64)) : Vue.createCommentVNode("", true),
      Vue.createVNode(_component_AddElementIcon, {
        element: $props.element,
        placement: "next",
        position: "middle"
      }, null, 8, ["element"])
    ], 2);
  }
  var ElementToolbox = /* @__PURE__ */ _export_sfc(_sfc_main$Q, [["render", _sfc_render$j]]);
  const _sfc_main$P = /* @__PURE__ */ Vue.defineComponent({
    __name: "ElementStyles",
    props: {
      styles: null
    },
    setup(__props) {
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createBlock(Vue.resolveDynamicComponent("style"), null, {
          default: Vue.withCtx(() => [
            Vue.createTextVNode(Vue.toDisplayString(__props.styles), 1)
          ]),
          _: 1
        });
      };
    }
  });
  var ElementLoading_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$G = { class: "znpb-preview__element-loading" };
  const _hoisted_2$w = ["src"];
  const _sfc_main$O = /* @__PURE__ */ Vue.defineComponent({
    __name: "ElementLoading",
    setup(__props) {
      const imageSrc = window.ZnPbInitialData.urls.loader;
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$G, [
          Vue.createElementVNode("img", { src: Vue.unref(imageSrc) }, null, 8, _hoisted_2$w)
        ]);
      };
    }
  });
  const _sfc_main$N = {
    name: "VideoBackground",
    props: {
      videoConfig: {
        type: Object,
        required: false,
        default: () => {
          return {};
        }
      }
    },
    computed: {
      getVideoSettings() {
        return JSON.stringify(this.videoConfig);
      },
      hasVideoSource() {
        const videoSource = this.videoConfig && this.videoConfig.videoSource ? this.videoConfig.videoSource : "local";
        if (videoSource === "youtube" && this.videoConfig.youtubeURL) {
          return true;
        } else if (videoSource === "vimeo" && this.videoConfig.vimeoURL) {
          return true;
        } else if (videoSource === "local" && this.videoConfig.mp4) {
          return true;
        }
        return false;
      }
    },
    watch: {
      videoConfig(newValue, oldValue) {
        if (!this.hasVideoSource) {
          return;
        }
        if (!isEqual$1(newValue, oldValue)) {
          if (this.videoInstance) {
            this.videoInstance.destroy();
          }
          this.$nextTick(() => {
            this.videoInstance = new window.frames[0].ZBVideoBg(this.$el, this.videoConfig);
          });
        }
      }
    },
    mounted() {
      if (!this.hasVideoSource) {
        return;
      }
      if (Object.keys(this.videoConfig).length > 0) {
        this.videoInstance = new window.frames[0].ZBVideoBg(this.$el, this.videoConfig);
      }
    }
  };
  const _hoisted_1$F = ["data-zion-video-background"];
  function _sfc_render$i(_ctx, _cache, $props, $setup, $data, $options) {
    return $options.hasVideoSource ? (Vue.openBlock(), Vue.createElementBlock("div", {
      key: 0,
      class: "zb__videoBackground-wrapper",
      "data-zion-video-background": $options.getVideoSettings
    }, null, 8, _hoisted_1$F)) : Vue.createCommentVNode("", true);
  }
  var VideoBackground = /* @__PURE__ */ _export_sfc(_sfc_main$N, [["render", _sfc_render$i]]);
  let scripts = {};
  let loaded = false;
  let loadedScripts;
  let loadedStyles;
  const ScriptsLoader = (window2) => {
    const getAvailableScripts = () => {
      const allScripts = window2.document.getElementsByTagName("script");
      Array.from(allScripts).forEach((domNode) => {
        if (domNode.src) {
          scripts[domNode.src] = "done";
        }
      });
      return scripts;
    };
    function reset() {
      scripts = {};
      loaded = false;
      loadedScripts = {};
      loadedStyles = {};
    }
    const getAvailableStyles = () => {
      let styles = {};
      const allStyles = window2.document.getElementsByTagName("link");
      Array.from(allStyles).forEach((domNode) => {
        if (domNode.rel === "stylesheet") {
          styles[domNode.href] = "done";
        }
      });
      return styles;
    };
    if (!loaded) {
      loadedScripts = getAvailableScripts();
      loadedStyles = getAvailableStyles();
      loaded = true;
    }
    const loadScript = (scriptConfig) => {
      const scriptType = scriptConfig.src.indexOf(".js") !== -1 || scriptConfig.src.indexOf(".ts") !== -1 ? "javascript" : scriptConfig.src.indexOf(".css") !== -1 ? "css" : false;
      if (scriptType === "javascript") {
        if (scriptConfig.data) {
          addInlineJavascript(scriptConfig.data);
        }
        if (scriptConfig.before) {
          addInlineJavascript(scriptConfig.before);
        }
        return loadJavaScriptFile(scriptConfig.src).then(() => {
          if (scriptConfig.after) {
            addInlineJavascript(scriptConfig.after);
          }
        }).catch((err) => console.error(err));
      } else if (scriptType === "css") {
        return loadCssFile(scriptConfig.src).catch((err) => console.error(err));
      }
    };
    const addInlineJavascript = (code) => {
      const javascriptTag = window2.document.createElement("script");
      javascriptTag.type = "text/javascript";
      const inlineScript = window2.document.createTextNode(code);
      javascriptTag.appendChild(inlineScript);
      window2.document.body.appendChild(javascriptTag);
    };
    const loadJavaScriptFile = (url) => {
      if (typeof loadedScripts[url] === "object") {
        return loadedScripts[url];
      } else if (loadedScripts[url] === "done") {
        return Promise.resolve(url);
      } else if (loadedScripts[url] === "error") {
        return Promise.reject(url);
      }
      const promise = new Promise((resolve, reject) => {
        const javascriptTag = window2.document.createElement("script");
        javascriptTag.src = url;
        if (url.indexOf("http://127.0.0.1") === 0) {
          javascriptTag.type = "module";
        }
        javascriptTag.onload = () => {
          loadedScripts[url] = "done";
          resolve(window2.document);
        };
        javascriptTag.onerror = () => {
          loadedScripts[url] = "error";
          reject(window2.document);
        };
        window2.document.body.appendChild(javascriptTag);
      });
      loadedScripts[url] = promise;
      return promise;
    };
    const loadCssFile = (url) => {
      if (typeof loadedStyles[url] === "object") {
        return loadedStyles[url];
      } else if (loadedStyles[url] === "done") {
        return Promise.resolve(url);
      } else if (loadedStyles[url] === "error") {
        return Promise.reject(url);
      }
      const promise = new Promise((resolve, reject) => {
        const styleLink = window2.document.createElement("link");
        styleLink.type = "text/css";
        styleLink.rel = "stylesheet";
        styleLink.href = url;
        styleLink.onload = () => {
          loadedStyles[url] = "done";
          resolve(window2.document);
        };
        styleLink.onerror = () => {
          reject(window2.document);
          loadedStyles[url] = "error";
        };
        window2.document.getElementsByTagName("head")[0].appendChild(styleLink);
      });
      loadedStyles[url] = promise;
      return promise;
    };
    return {
      getAvailableScripts,
      getAvailableStyles,
      loadScript,
      addInlineJavascript,
      loadJavaScriptFile,
      loadCssFile,
      reset,
      scripts,
      loadedScripts,
      loadedStyles
    };
  };
  var ServerComponent_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$M = {
    name: "ServerComponent",
    props: {
      element: {
        type: Object,
        required: true
      },
      options: {
        type: Object
      },
      api: {
        type: Object
      }
    },
    setup(props) {
      const logoUrl = window.ZnPbInitialData.urls.logo;
      const elementContentRef = Vue.ref(null);
      const elementContent = Vue.ref("");
      const loading = Vue.ref(true);
      const elementNotSelectable = Vue.ref(false);
      const elementDataForRender = Vue.computed(() => {
        const elementOptions = props.element.elementDefinition.options;
        if (!elementOptions) {
          return {};
        }
        let _a3 = props.options, { _styles: newMedia, _advanced_options: newAdvanced } = _a3, remainingNewProperties = __objRest(_a3, ["_styles", "_advanced_options"]);
        let optionsThatRequireServerRequest = {};
        Object.keys(remainingNewProperties).forEach((optionID) => {
          const optionSchema = elementOptions[optionID];
          if (typeof optionSchema !== "undefined") {
            if (!optionSchema.css_style || optionSchema.rerender) {
              optionsThatRequireServerRequest[optionID] = remainingNewProperties[optionID];
            }
          } else {
            optionsThatRequireServerRequest[optionID] = remainingNewProperties[optionID];
          }
        });
        return JSON.stringify(optionsThatRequireServerRequest);
      });
      Vue.watch(elementDataForRender, (newValue, oldValue) => {
        if (newValue !== oldValue) {
          debouncedGetElementFromServer();
        }
      });
      function setInnerHTML(content) {
        const elm = elementContentRef.value;
        elm.innerHTML = content;
        Array.from(elm.querySelectorAll("script")).forEach((oldScript) => {
          const newScript = document.createElement("script");
          Array.from(oldScript.attributes).forEach((attr) => newScript.setAttribute(attr.name, attr.value));
          newScript.appendChild(document.createTextNode(oldScript.innerHTML));
          oldScript.parentNode.replaceChild(newScript, oldScript);
        });
        elm.addEventListener("load", checkElementHeight);
      }
      const serverComponentRenderData = applyFilters("zionbuilder/server_component/data", {
        element_data: props.element
      });
      function loadScripts(scripts2) {
        const { loadScript } = ScriptsLoader(window.frames[0]);
        return new Promise((resolve, reject) => {
          Object.keys(scripts2).map((scriptHandle) => {
            const scriptConfig = scripts2[scriptHandle];
            scriptConfig.handle = scriptConfig.handle ? scriptConfig.handle : scriptHandle;
            if (scriptConfig.src) {
              return loadScript(scriptConfig);
            }
          });
          resolve();
        });
      }
      function getElementFromServer() {
        loading.value = true;
        props.element.serverRequester.request(
          {
            type: "render_element",
            config: serverComponentRenderData
          },
          (response) => {
            elementContent.value = response.data.element;
            setInnerHTML(elementContent.value);
            setBodyClasses(response.data.body_classes);
            loadScripts(response.data.scripts).then(() => {
              loading.value = false;
              Vue.nextTick(() => {
                setTimeout(() => {
                  checkForContentHeight();
                  doAction(
                    "zionbuilder/server_component/rendered",
                    elementContentRef.value,
                    props.element,
                    props.options
                  );
                }, 20);
              });
            });
          },
          function(message) {
            loading.value = false;
            console.log("server Request fail", message);
          }
        );
      }
      const debouncedGetElementFromServer = debounce$1(function() {
        getElementFromServer();
      }, 500);
      function setBodyClasses(classes) {
        classes.forEach((cssClass) => {
          const body = window.frames["znpb-editor-iframe"].contentDocument.body;
          body.classList.add(cssClass);
        });
      }
      function checkForContentHeight() {
        const loadableElements = elementContentRef.value.querySelectorAll("img, iframe, video");
        let loadableElementsCount = loadableElements.length;
        const loadCallback = () => {
          loadableElementsCount--;
          if (loadableElementsCount === 0) {
            checkElementHeight();
          }
        };
        if (loadableElementsCount > 0) {
          loadableElements.forEach((element) => {
            element.addEventListener("load", loadCallback);
            element.addEventListener("error", loadCallback);
          });
        } else {
          checkElementHeight();
        }
      }
      function checkElementHeight() {
        const { height } = elementContentRef.value.getBoundingClientRect();
        elementNotSelectable.value = height < 2;
      }
      Vue.onMounted(() => {
        getElementFromServer();
      });
      addAction("zionbuilder/server_component/refresh", debouncedGetElementFromServer);
      Vue.onBeforeUnmount(() => {
        removeAction("zionbuilder/server_component/refresh", debouncedGetElementFromServer);
      });
      return {
        logoUrl,
        elementContentRef,
        elementContent,
        loading,
        elementNotSelectable
      };
    }
  };
  const _hoisted_1$E = {
    key: 0,
    class: "znpb__server-element--empty"
  };
  const _hoisted_2$v = ["src"];
  const _hoisted_3$o = {
    key: 1,
    class: "znpb__server-element-loader--loading"
  };
  function _sfc_render$h(_ctx, _cache, $props, $setup, $data, $options) {
    return Vue.openBlock(), Vue.createElementBlock("div", null, [
      Vue.renderSlot(_ctx.$slots, "start"),
      Vue.createElementVNode("div", {
        ref: "elementContentRef",
        class: Vue.normalizeClass({ "znpb__server-element--loading": $setup.loading })
      }, null, 2),
      !$setup.loading && $setup.elementContent.length === 0 ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$E, [
        Vue.createElementVNode("img", { src: $setup.logoUrl }, null, 8, _hoisted_2$v)
      ])) : Vue.createCommentVNode("", true),
      $setup.loading ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_3$o)) : Vue.createCommentVNode("", true),
      Vue.renderSlot(_ctx.$slots, "end")
    ]);
  }
  var ServerComponent = /* @__PURE__ */ _export_sfc(_sfc_main$M, [["render", _sfc_render$h]]);
  var InvalidElement_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$D = { class: "znpb-element--not-found" };
  const _sfc_main$L = /* @__PURE__ */ Vue.defineComponent({
    __name: "InvalidElement",
    setup(__props) {
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$D, [
          Vue.renderSlot(_ctx.$slots, "start"),
          Vue.createTextVNode(" " + Vue.toDisplayString(Vue.unref(translate)("element_not_found")) + " ", 1),
          Vue.renderSlot(_ctx.$slots, "end")
        ]);
      };
    }
  });
  function useElementComponent(element) {
    const elementComponent = Vue.shallowRef(null);
    const elementsDefinitionStore = useElementDefinitionsStore();
    const elementType = elementsDefinitionStore.getElementDefinition(element.element_type);
    const fetchElementComponent = () => {
      loadElementAssets().then(() => {
        let component;
        if (elementType.element_type === "invalid") {
          component = _sfc_main$L;
        } else if (elementType.component) {
          component = elementType.component;
        } else {
          component = ServerComponent;
        }
        elementComponent.value = applyFilters("zionbuilder/element/component", component, element);
      });
    };
    const loadElementAssets = () => {
      const { loadScript } = ScriptsLoader(window.frames[0]);
      return Promise.all([
        ...Object.keys(elementType.scripts).map((scriptHandle) => {
          const scriptConfig = elementType.scripts[scriptHandle];
          scriptConfig.handle = scriptConfig.handle ? scriptConfig.handle : scriptHandle;
          if (scriptConfig.src) {
            return loadScript(scriptConfig);
          }
        }),
        ...Object.keys(elementType.styles).map((scriptHandle) => {
          const scriptConfig = elementType.styles[scriptHandle];
          scriptConfig.handle = scriptConfig.handle ? scriptConfig.handle : scriptHandle;
          if (scriptConfig.src) {
            return loadScript(scriptConfig);
          }
        })
      ]);
    };
    return {
      elementComponent,
      fetchElementComponent
    };
  }
  class Options {
    constructor(schema, model, selector, options2, element = null) {
      this.model = JSON.parse(JSON.stringify(model));
      this.schema = schema;
      this.selector = selector;
      this.options = options2;
      this.element = element;
      this.serverRequester = element ? element.serverRequester : window.zb.editor.serverRequest;
      const { responsiveDevicesAsIdWidth: responsiveDevicesAsIdWidth2 } = useResponsiveDevices();
      const devices = {};
      Object.keys(responsiveDevicesAsIdWidth2.value).forEach((device) => {
        devices[device] = {};
      });
      this.customCSS = devices;
      this.renderAttributes = {};
    }
    startLoading() {
      if (typeof this.options.onLoadingStart === "function") {
        this.options.onLoadingStart();
      }
    }
    endLoading() {
      if (typeof this.options.onLoadingEnd === "function") {
        this.options.onLoadingEnd();
      }
    }
    parseData() {
      const options2 = this.model;
      this.parseOptions(this.schema, options2);
      return {
        options: applyFilters("zionbuilder/options/model", options2, this),
        renderAttributes: this.renderAttributes,
        customCSS: this.getCustomCSS()
      };
    }
    parseOptions(schema, model, index2 = null) {
      model = null === model ? {} : model;
      Object.keys(schema).forEach((optionId) => {
        const singleOptionSchema = schema[optionId];
        const dependencyPassed = this.checkDependency(singleOptionSchema, model);
        if (!dependencyPassed) {
          return false;
        }
        if (typeof singleOptionSchema.is_layout !== "undefined" && singleOptionSchema.is_layout) {
          if (singleOptionSchema.child_options) {
            this.parseOptions(singleOptionSchema.child_options, model);
          }
        } else {
          if (typeof model[optionId] !== "undefined") {
            this.setPropperImage(optionId, singleOptionSchema, model);
            this.setRenderAttributes(singleOptionSchema, model[optionId], index2);
            this.setCustomCSS(singleOptionSchema, model[optionId], index2);
          } else if (typeof singleOptionSchema.default !== "undefined") {
            model[optionId] = cloneDeep(singleOptionSchema.default);
          }
          if (singleOptionSchema.child_options) {
            if (singleOptionSchema.type === "repeater") {
              if (typeof model[optionId] !== "undefined" && Array.isArray(model[optionId])) {
                model[optionId].forEach((optionValue2, index22) => {
                  this.parseOptions(singleOptionSchema.child_options, optionValue2, index22);
                });
              }
            } else {
              const savedValue = typeof model[optionId] !== "undefined" && model[optionId] !== null ? model[optionId] : {};
              this.parseOptions(singleOptionSchema.child_options, savedValue);
              if (Object.keys(savedValue).length > 0) {
                model[optionId] = savedValue;
              }
            }
          }
        }
      });
      return model;
    }
    setPropperImage(optionId, schema, model) {
      if (schema.type === "image" && schema.show_size === true && model[optionId]) {
        const imageConfig = model[optionId];
        if (imageConfig && imageConfig.image && imageConfig.image_size && imageConfig.image_size !== "full") {
          this.startLoading();
          getImage(model[optionId], this.serverRequester).then((image) => {
            if (image) {
              this.setImage(model, optionId, image);
            }
          }).finally(() => {
            this.endLoading();
          });
        }
      }
    }
    setImage(optionsModel, optionId, newValue) {
      const oldImage = (optionsModel[optionId] || {}).image;
      if (oldImage === newValue) {
        return;
      }
      const newValues = __spreadProps(__spreadValues({}, optionsModel[optionId]), {
        image: newValue
      });
      optionsModel[optionId] = newValues;
    }
    addRenderAttribute(tagId, attribute, value, replace = false) {
      if (!this.renderAttributes[tagId]) {
        this.renderAttributes[tagId] = {};
      }
      const currentAttributes = this.renderAttributes[tagId];
      if (!currentAttributes[attribute]) {
        currentAttributes[attribute] = [];
      }
      if (replace) {
        currentAttributes[attribute] = [value];
      } else {
        currentAttributes[attribute].push(value);
      }
    }
    setRenderAttributes(schema, model, index2 = null) {
      const CSSDeviceMap = {
        default: "",
        laptop: "--lg",
        tablet: "--md",
        mobile: "--sm"
      };
      if (schema.render_attribute) {
        schema.render_attribute.forEach((config) => {
          let tagId = config.tag_id || "wrapper";
          tagId = index2 === null ? tagId : `${tagId}${index2}`;
          const attribute = config.attribute || "class";
          let attributeValue = config.value || "";
          if (schema.responsive_options && model !== null) {
            if (model && typeof model !== "object") {
              model = {
                default: model
              };
            }
            Object.keys(model).forEach((deviceId) => {
              if (!model[deviceId] || typeof CSSDeviceMap[deviceId] === "undefined") {
                return;
              }
              const deviceSavedValue = model[deviceId];
              attributeValue = config.value || "";
              attributeValue = attributeValue.replace("{{RESPONSIVE_DEVICE_CSS}}", CSSDeviceMap[deviceId]);
              attributeValue = attributeValue.replace("{{VALUE}}", deviceSavedValue) || deviceSavedValue;
              this.addRenderAttribute(tagId, attribute, attributeValue);
            });
          } else {
            if (!model) {
              return;
            }
            attributeValue = attributeValue.replace("{{VALUE}}", model) || model;
            this.addRenderAttribute(tagId, attribute, attributeValue);
          }
        });
      }
    }
    setCustomCSS(schema, model, index2 = null) {
      if (schema.css_style && Array.isArray(schema.css_style)) {
        schema.css_style.forEach((cssStyleConfig) => {
          if (schema.responsive_options && typeof model === "object" && model !== null) {
            this.extractResponsiveCSSRules(schema.type, cssStyleConfig, model, index2);
          } else {
            this.extractCSSRule("default", schema.type, cssStyleConfig, model, index2);
          }
        });
      } else {
        if (schema.type === "shape_dividers") {
          if (typeof model === "object") {
            forEach(model, (maskConfig, position) => {
              let { shape, height } = maskConfig;
              if (shape && height) {
                const selector = `zb-mask-pos--${position}`;
                if (typeof height === "string") {
                  height = {
                    default: height
                  };
                }
                this.extractResponsiveCSSRules(
                  schema.type,
                  {
                    selector: `${this.selector} .${selector}`,
                    value: "height: {{VALUE}}"
                  },
                  height,
                  index2
                );
              }
            });
          }
        }
      }
    }
    extractResponsiveCSSRules(optionType, cssStyleConfig, model, index2) {
      if (typeof model !== "object" || model === null) {
        return "";
      }
      Object.keys(model).forEach((device) => {
        const deviceValue = model[device];
        this.extractCSSRule(device, optionType, cssStyleConfig, deviceValue, index2);
      });
    }
    extractCSSRule(device, optionType, cssStyleConfig, model, index2) {
      let { selector, value } = cssStyleConfig;
      if (!selector || !value) {
        return;
      }
      selector = selector.replace("{{ELEMENT}}", this.selector);
      value = value.replace("{{VALUE}}", model);
      if (index2 !== null) {
        selector = selector.replace("{{INDEX}}", index2);
      }
      if (optionType === "element_styles") {
        const mediaStyles = optionValue.styles || {};
        const styles = getStyles(formattedSelector, mediaStyles);
        if (styles) {
          this.addCustomCSS(device, selector, styles);
        }
      } else {
        if (model !== false) {
          this.addCustomCSS(device, selector, value);
        }
      }
    }
    addCustomCSS(device, selector, css) {
      if (typeof this.customCSS[device] === "undefined") {
        return;
      }
      this.customCSS[device][selector] = this.customCSS[device][selector] || [];
      this.customCSS[device][selector].push(css);
    }
    getCustomCSS() {
      const { responsiveDevicesAsIdWidth: responsiveDevicesAsIdWidth2 } = useResponsiveDevices();
      let returnedCSS = "";
      Object.keys(this.customCSS).forEach((device) => {
        const deviceSelectors = this.customCSS[device];
        const extractedCSS = this.extractStyles(deviceSelectors);
        if (extractedCSS.length === 0) {
          return;
        }
        if (device === "default") {
          returnedCSS += extractedCSS;
        } else {
          if (!responsiveDevicesAsIdWidth2.value[device]) {
            return;
          }
          const deviceWidth = responsiveDevicesAsIdWidth2.value[device];
          returnedCSS += `@media(max-width: ${deviceWidth}px) { ${extractedCSS} } `;
        }
      });
      return returnedCSS;
    }
    extractStyles(stylesData) {
      let returnedStyles = "";
      if (typeof stylesData === "object" && stylesData !== null) {
        Object.keys(stylesData).forEach((selector) => {
          const styleCSSArray = stylesData[selector];
          returnedStyles += `${selector} { ${styleCSSArray.join(";")} } `;
        });
      }
      return returnedStyles;
    }
    checkDependency(optionSchema, model) {
      let passedDependency = true;
      if (optionSchema.dependency) {
        optionSchema.dependency.forEach((dependencyConfig) => {
          if (!passedDependency) {
            return;
          }
          passedDependency = this.checkSingleDependency(dependencyConfig, model);
        });
      }
      return passedDependency;
    }
    checkSingleDependency(dependencyConfig, model) {
      const { type = "includes", option, option_path: optionPath, value: searchValue } = dependencyConfig;
      let optionValue2 = null;
      if (option) {
        optionValue2 = typeof model[option] !== "undefined" ? model[option] : null;
      } else if (optionPath) {
        optionValue2 = get(this.model, optionPath);
      }
      if (type === "includes" && searchValue.includes(optionValue2)) {
        return true;
      } else if (type === "not_in" && !searchValue.includes(optionValue2)) {
        return true;
      }
      return false;
    }
    getValue(optionPath, defaultValue) {
      return get(this.model, optionPath, defaultValue);
    }
  }
  var ElementWrapper_vue_vue_type_style_index_0_lang = "";
  let clickHandled = false;
  const _sfc_main$K = {
    name: "ElementWrapper",
    components: {
      ElementToolbox,
      VideoBackground,
      ElementLoading: _sfc_main$O,
      ElementStyles: _sfc_main$P
    },
    props: ["element"],
    setup(props) {
      const root2 = Vue.ref(null);
      const UIStore = useUIStore();
      const { elementComponent, fetchElementComponent } = useElementComponent(props.element);
      const { getSchema } = useOptionsSchemas();
      const { activePseudoSelector: activePseudoSelector2 } = usePseudoSelectors();
      const isVisible = Vue.computed(() => get(props.element.options, "_isVisible", true));
      let toolboxWatcher = null;
      let optionsInstance = null;
      const localLoading = Vue.ref(false);
      const loading = Vue.computed(() => props.element.loading || localLoading.value);
      const showToolbox = Vue.ref(false);
      const canHideToolbox = Vue.ref(true);
      const isToolboxDragging = Vue.ref(false);
      const registeredEvents = Vue.ref({});
      const isElementEdited = Vue.ref(false);
      const isHoverState = Vue.ref(false);
      const advancedSchema = {
        _advanced_options: {
          type: "group",
          child_options: getSchema("element_advanced")
        }
      };
      const elementOptionsSchema = Object.assign({}, props.element.elementDefinition.options || {}, advancedSchema);
      const parsedData = Vue.computed(() => {
        const cssSelector = `#${props.element.elementCssId}`;
        optionsInstance = new Options(
          elementOptionsSchema,
          props.element.options,
          cssSelector,
          {
            onLoadingStart: () => localLoading.value = true,
            onLoadingEnd: () => localLoading.value = false
          },
          props.element
        );
        return optionsInstance.parseData();
      });
      const options2 = Vue.computed(() => Vue.readonly(parsedData.value.options || {}));
      Vue.watch(
        () => UIStore.editedElement,
        (newValue, oldValue) => {
          if (newValue === props.element) {
            isElementEdited.value = true;
          } else if (oldValue === props.element) {
            isElementEdited.value = false;
          }
        }
      );
      Vue.watch(activePseudoSelector2, (newValue) => {
        if (newValue.id === ":hover") {
          isHoverState.value = true;
        } else {
          isHoverState.value = false;
        }
      });
      const shouldGenerateHoverStyles = Vue.computed(() => {
        return isElementEdited.value && isHoverState.value;
      });
      const customCSS = Vue.computed(() => {
        let customCSS2 = "";
        const elementStyleConfig = props.element.elementDefinition.style_elements || {};
        Object.keys(elementStyleConfig).forEach((styleId) => {
          if (options2.value._styles && options2.value._styles[styleId]) {
            const styleConfig = elementStyleConfig[styleId];
            const cssSelector = applyFilters(
              "zionbuilder/element/css_selector",
              `#${props.element.elementCssId}`,
              optionsInstance,
              props.element
            );
            const formattedSelector2 = styleConfig.selector.replace("{{ELEMENT}}", cssSelector);
            const stylesSavedValues = applyFilters(
              "zionbuilder/element/styles_model",
              options2.value._styles[styleId],
              optionsInstance,
              props.element
            );
            customCSS2 += window.zb.editor.getCssFromSelector([formattedSelector2], stylesSavedValues);
            if (shouldGenerateHoverStyles.value) {
              customCSS2 += window.zb.editor.getCssFromSelector([formattedSelector2], stylesSavedValues, {
                forcehoverState: true
              });
            }
          }
        });
        customCSS2 += parsedData.value.customCSS;
        customCSS2 = applyFilters("zionbuilder/element/custom_css", customCSS2, optionsInstance, props.element);
        return customCSS2;
      });
      const stylesConfig = Vue.computed(() => options2.value._styles || {});
      const canShowToolbox = Vue.computed(() => {
        return (UIStore.editedElement === props.element || props.element.isHighlighted) && props.element.isVisible && !props.element.elementDefinition.is_child && !UIStore.isPreviewMode;
      });
      const canShowElement = Vue.computed(() => UIStore.isPreviewMode ? !(options2.value._isVisible === false) : true);
      const videoConfig = Vue.computed(
        () => get(options2.value, "_styles.wrapper.styles.default.default.background-video", {})
      );
      const renderAttributes = Vue.computed(() => {
        const optionsAttributes = parsedData.value.renderAttributes;
        const additionalAttributes = {};
        if (stylesConfig.value) {
          forEach(stylesConfig.value, (styleData, styleID) => {
            if (styleData.attributes) {
              forEach(styleData.attributes, (attributeValue) => {
                if (attributeValue.attribute_name) {
                  additionalAttributes[styleID] = additionalAttributes[styleID] || {};
                  let cleanAttrName = attributeValue.attribute_name;
                  let cleanAttrValue = escape$1(attributeValue.attribute_value);
                  additionalAttributes[styleID][cleanAttrName] = cleanAttrValue;
                }
              });
            }
          });
        }
        const elementStyleConfig = props.element.elementDefinition.style_elements;
        if (elementStyleConfig) {
          Object.keys(elementStyleConfig).forEach((styleId) => {
            if (options2.value._styles && options2.value._styles[styleId] && options2.value._styles[styleId].classes) {
              const styleConfig = elementStyleConfig[styleId];
              const renderTag = styleConfig.render_tag;
              if (renderTag) {
                options2.value._styles[styleId].classes.forEach((cssClass) => {
                  if (!additionalAttributes[renderTag]) {
                    additionalAttributes[renderTag] = {};
                  }
                  additionalAttributes[renderTag]["class"] = [
                    ...additionalAttributes[renderTag]["class"] || [],
                    cssClass
                  ];
                });
              }
            }
          });
        }
        return mergeWith$1({}, optionsAttributes, additionalAttributes, (a, b) => {
          if (isArray$1(a)) {
            return b.concat(a);
          }
        });
      });
      const getExtraAttributes = Vue.computed(() => {
        const wrapperAttributes = renderAttributes.value.wrapper || {};
        const elementClass = camelCase$1(props.element.element_type);
        const classes = applyFilters(
          "zionbuilder/element/css_classes",
          {
            [`zb-el-${elementClass}`]: true,
            [`znpb-element__wrapper--toolbox-dragging`]: isToolboxDragging.value,
            "znpb-element__wrapper--cutted": props.element.isCut,
            "znpb-element--loading": loading.value
          },
          optionsInstance,
          props.element
        );
        if (stylesConfig.value.wrapper) {
          const wrapperConfig = stylesConfig.value.wrapper;
          if (wrapperConfig.classes) {
            wrapperConfig.classes.forEach((classSelector) => {
              classes[classSelector] = true;
            });
          }
        }
        const wrapperClasses = typeof wrapperAttributes.class !== "undefined" ? wrapperAttributes.class : [];
        wrapperClasses.forEach((cssClass) => {
          classes[cssClass] = true;
        });
        return __spreadProps(__spreadValues({}, wrapperAttributes), {
          class: classes,
          api: {
            getStyleClasses,
            getAttributesForTag
          }
        });
      });
      fetchElementComponent();
      function getAttributesForTag(tagID, extraArgs = {}, index2 = null) {
        tagID = index2 !== null ? `${tagID}${index2}` : tagID;
        return Object.assign(renderAttributes.value[tagID] || {}, extraArgs);
      }
      const showElementMenu = function(event2) {
        event2.preventDefault();
        event2.stopPropagation();
        UIStore.showElementMenuFromEvent(props.element, event2);
      };
      const onElementClick = () => {
        if (clickHandled) {
          return;
        }
        if (!UIStore.isPreviewMode) {
          UIStore.editElement(props.element);
        }
        clickHandled = true;
        setTimeout(() => {
          clickHandled = false;
        }, 50);
      };
      const getStyleClasses = (styleId, extraClasses = {}) => {
        const classes = {};
        if (stylesConfig.value[styleId]) {
          const elementStylesClasses = stylesConfig.value[styleId];
          if (elementStylesClasses.classes) {
            elementStylesClasses.classes.forEach((classSelector) => {
              classes[classSelector] = true;
            });
          }
        }
        return classes;
      };
      Vue.provide("elementInfo", props.element);
      Vue.provide("elementOptions", options2);
      function onMouseEnter() {
        props.element.highlight();
        if (props.element.parent) {
          let parent2 = props.element.parent;
          while (parent2) {
            parent2.unHighlight();
            parent2 = parent2.parent;
          }
        }
      }
      function onMouseLeave() {
        props.element.unHighlight();
        if (props.element.parent) {
          props.element.parent.highlight();
          parent = parent.parent;
        }
      }
      Vue.watch(
        () => props.element.scrollTo,
        (newValue) => {
          const iframe = window.frames["znpb-editor-iframe"];
          if (!iframe) {
            return;
          }
          const domNode = iframe.contentWindow.document.getElementById(props.element.elementCssId);
          if (newValue && domNode) {
            if (typeof domNode.scrollIntoView === "function") {
              domNode.scrollIntoView({
                behavior: "smooth",
                block: "center"
              });
            }
            setTimeout(() => {
              props.element.scrollTo = false;
            }, 1e3);
          }
        }
      );
      return {
        root: root2,
        stylesConfig,
        canShowToolbox,
        canShowElement,
        videoConfig,
        getExtraAttributes,
        elementComponent,
        showElementMenu,
        onElementClick,
        options: options2,
        customCSS,
        loading,
        canHideToolbox,
        isToolboxDragging,
        toolboxWatcher,
        registeredEvents,
        showToolbox,
        UIStore,
        onMouseEnter,
        onMouseLeave,
        isVisible
      };
    },
    methods: {
      debounceUpdate: debounce$1(function() {
        this.$nextTick(() => {
          this.trigger("updated");
        });
      }),
      on(eventType, callback) {
        if (typeof this.registeredEvents[eventType] === "undefined") {
          this.registeredEvents[eventType] = [];
        }
        this.registeredEvents[eventType].push(callback);
      },
      off(eventType, callback) {
        if (typeof this.registeredEvents[eventType] === "undefined" && this.registeredEvents[eventType].includes(callback)) {
          const callbackIndex = this.registeredEvents[eventType].indexOf(callback);
          if (callbackIndex !== -1) {
            this.registeredEvents[eventType].splice(callbackIndex, 1);
          }
        }
      },
      offAll() {
        this.registeredEvents = {};
      },
      getDefaultEventResponse() {
        return {
          elementType: this.element.element_type,
          element: this.$el,
          options: this.options || {},
          elementUid: this.element.uid,
          on: this.on,
          off: this.off,
          offAll: this.offAll
        };
      },
      trigger(eventType, data2) {
        const defaultData = this.getDefaultEventResponse();
        if (typeof this.registeredEvents[eventType] !== "undefined") {
          this.registeredEvents[eventType].forEach((callbackFunction) => {
            callbackFunction(__spreadValues(__spreadValues({}, defaultData), data2));
          });
        }
      }
    }
  };
  const _hoisted_1$C = {
    key: 0,
    class: "znpb-hidden-element-container"
  };
  const _hoisted_2$u = { class: "znpb-hidden-element-placeholder" };
  function _sfc_render$g(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_ElementLoading = Vue.resolveComponent("ElementLoading");
    const _component_ElementToolbox = Vue.resolveComponent("ElementToolbox");
    const _component_VideoBackground = Vue.resolveComponent("VideoBackground");
    const _component_ElementStyles = Vue.resolveComponent("ElementStyles");
    const _component_Icon = Vue.resolveComponent("Icon");
    return $setup.loading ? (Vue.openBlock(), Vue.createBlock(_component_ElementLoading, { key: 0 })) : $setup.elementComponent && !($props.element.isVisible === false && $setup.UIStore.isPreviewMode) ? (Vue.openBlock(), Vue.createBlock(Vue.resolveDynamicComponent($setup.elementComponent), Vue.mergeProps({
      key: 1,
      id: `${$props.element.elementCssId}`,
      ref: "root",
      class: "znpb-element__wrapper zb-element",
      element: $props.element,
      options: $setup.options
    }, $setup.getExtraAttributes, {
      onMouseenter: $setup.onMouseEnter,
      onMouseleave: $setup.onMouseLeave,
      onClick: $setup.onElementClick,
      onContextmenu: $setup.showElementMenu
    }), {
      start: Vue.withCtx(() => [
        $setup.canShowToolbox ? (Vue.openBlock(), Vue.createBlock(_component_ElementToolbox, {
          key: 0,
          element: $props.element
        }, null, 8, ["element"])) : Vue.createCommentVNode("", true),
        $setup.videoConfig ? (Vue.openBlock(), Vue.createBlock(_component_VideoBackground, {
          key: 1,
          "video-config": $setup.videoConfig
        }, null, 8, ["video-config"])) : Vue.createCommentVNode("", true),
        Vue.createVNode(_component_ElementStyles, { styles: $setup.customCSS }, null, 8, ["styles"])
      ]),
      end: Vue.withCtx(() => [
        !$setup.isVisible ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$C, [
          Vue.createElementVNode("div", _hoisted_2$u, [
            Vue.createVNode(_component_Icon, {
              icon: "eye",
              onClick: _cache[0] || (_cache[0] = Vue.withModifiers(($event) => $props.element.toggleVisibility(), ["stop"]))
            })
          ])
        ])) : Vue.createCommentVNode("", true)
      ]),
      _: 1
    }, 16, ["id", "element", "options", "onMouseenter", "onMouseleave", "onClick", "onContextmenu"])) : Vue.createCommentVNode("", true);
  }
  var ElementWrapper = /* @__PURE__ */ _export_sfc(_sfc_main$K, [["render", _sfc_render$g]]);
  const _sfc_main$J = /* @__PURE__ */ Vue.defineComponent({
    __name: "Element",
    props: {
      element: null
    },
    setup(__props) {
      const props = __props;
      doAction("zionbuilder/preview/element/setup", props.element);
      const elementWrapperComponent = Vue.computed(() => {
        return applyFilters("zionbuilder/preview/element/wrapper_component", "ElementWrapper", props.element);
      });
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createBlock(Vue.resolveDynamicComponent(Vue.unref(elementWrapperComponent)), { element: __props.element }, null, 8, ["element"]);
      };
    }
  });
  var SortableContent_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$I = /* @__PURE__ */ Vue.defineComponent({
    __name: "SortableContent",
    props: {
      element: null,
      group: { default: () => {
        return {};
      } },
      allowElementsAdd: { type: Boolean, default: true },
      emptyPlaceholderText: { default: "" },
      disabled: { type: Boolean, default: false }
    },
    setup(__props) {
      const props = __props;
      const UIStore = useUIStore();
      const contentStore = useContentStore();
      const UserStore = useUserStore();
      const children = Vue.computed(() => props.element.content.map((childUID) => contentStore.getElement(childUID)));
      const defaultSortableGroup = {
        name: "elements"
      };
      const isDisabled = Vue.computed(() => {
        return UIStore.isPreviewMode || props.disabled || !UserStore.userCanEditContent;
      });
      const groupInfo = Vue.computed(() => props.group || defaultSortableGroup);
      const getSortableAxis = Vue.computed(() => {
        let orientation = "horizontal";
        if (props.element.element_type === "contentRoot") {
          return "vertical";
        }
        orientation = props.element.elementDefinition.content_orientation;
        if (props.element.options.inner_content_layout) {
          orientation = props.element.options.inner_content_layout;
        }
        const mediaOrientation = get(props.element.options, "_styles.wrapper.styles.default.default.flex-direction");
        if (mediaOrientation) {
          orientation = mediaOrientation === "row" ? "horizontal" : "vertical";
        }
        return orientation;
      });
      function onSortableStart() {
        UIStore.hideAddElementsPopup();
        UIStore.setElementDragging(true);
      }
      function onSortableEnd() {
        UIStore.setElementDragging(false);
      }
      function onSortableDrop(event2) {
        const { item, to, newIndex, duplicateItem, placeBefore } = event2.data;
        const movedElement = contentStore.getElement(item.dataset.zionElementUid);
        if (duplicateItem) {
          const elementForInsert = movedElement.getClone();
          window.zb.run("editor/elements/add", {
            parentUID: to.dataset.zionElementUid,
            element: elementForInsert,
            index: placeBefore ? newIndex : newIndex + 1
          });
        } else {
          window.zb.run("editor/elements/move", {
            newParent: contentStore.getElement(to.dataset.zionElementUid),
            element: contentStore.getElement(item.dataset.zionElementUid),
            index: newIndex
          });
        }
      }
      return (_ctx, _cache) => {
        const _component_Sortable = Vue.resolveComponent("Sortable");
        return Vue.openBlock(), Vue.createBlock(_component_Sortable, Vue.mergeProps({
          "model-value": Vue.unref(children),
          group: Vue.unref(groupInfo),
          disabled: Vue.unref(isDisabled),
          "allow-duplicate": true
        }, _ctx.$attrs, {
          class: {
            [`znpb__sortable-container--${Vue.unref(getSortableAxis)}`]: Vue.unref(UIStore).isElementDragging,
            [`znpb__sortable-container--disabled`]: Vue.unref(isDisabled)
          },
          axis: Vue.unref(getSortableAxis),
          "data-zion-element-uid": __props.element.uid,
          onStart: onSortableStart,
          onEnd: onSortableEnd,
          onDrop: onSortableDrop
        }), {
          start: Vue.withCtx(() => [
            Vue.renderSlot(_ctx.$slots, "start")
          ]),
          helper: Vue.withCtx(() => [
            Vue.createVNode(SortableHelper)
          ]),
          placeholder: Vue.withCtx(() => [
            Vue.createVNode(SortablePlaceholder)
          ]),
          end: Vue.withCtx(() => [
            __props.element.content.length === 0 && __props.allowElementsAdd && !Vue.unref(UIStore).isPreviewMode ? (Vue.openBlock(), Vue.createBlock(_sfc_main$16, {
              key: 0,
              element: __props.element
            }, null, 8, ["element"])) : Vue.createCommentVNode("", true),
            Vue.renderSlot(_ctx.$slots, "end")
          ]),
          default: Vue.withCtx(() => [
            (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList(Vue.unref(children), (childElement) => {
              return Vue.openBlock(), Vue.createBlock(_sfc_main$J, {
                key: childElement.uid,
                element: childElement,
                "data-zion-element-uid": childElement.uid
              }, null, 8, ["element", "data-zion-element-uid"]);
            }), 128))
          ]),
          _: 3
        }, 16, ["model-value", "group", "disabled", "class", "axis", "data-zion-element-uid"]);
      };
    }
  });
  class HeartBeat {
    constructor() {
      const userStore = useUserStore();
      window.jQuery(document).on({
        "heartbeat-tick.refresh-lock": (event2, response) => {
          if (!userStore.isPostLocked && response["wp-refresh-post-lock"]) {
            const { lock_error: LockError } = response["wp-refresh-post-lock"];
            if (LockError) {
              userStore.setPostLock({
                message: LockError.text,
                avatar: LockError.avatar_src
              });
            }
          }
        }
      });
      window.jQuery(document).on({
        "heartbeat-send": (event2, data2) => {
          data2["wp-refresh-post-lock"] = {
            post_id: window.ZnPbInitialData.page_id
          };
        }
      });
      window.jQuery(document).on({
        "heartbeat-tick.wp-refresh-nonces": (event2, response) => {
          const { rest_nonce: restNonce, heartbeat_nonce: heartbeatNonce } = response;
          if (restNonce) {
            window.ZnRestConfig.nonce = restNonce;
          }
          if (heartbeatNonce) {
            window.heartbeatSettings.nonce = heartbeatNonce;
          }
        }
      });
    }
  }
  var domToImage = { exports: {} };
  (function(module2) {
    (function(global2) {
      var util = newUtil();
      var inliner = newInliner();
      var fontFaces = newFontFaces();
      var images = newImages();
      var defaultOptions2 = {
        imagePlaceholder: void 0,
        cacheBust: false
      };
      var domtoimage2 = {
        toSvg,
        toPng,
        toJpeg,
        toBlob,
        toPixelData,
        impl: {
          fontFaces,
          images,
          util,
          inliner,
          options: {}
        }
      };
      module2.exports = domtoimage2;
      function toSvg(node, options2) {
        options2 = options2 || {};
        copyOptions(options2);
        return Promise.resolve(node).then(function(node2) {
          return cloneNode(node2, options2.filter, true);
        }).then(embedFonts).then(inlineImages).then(applyOptions).then(function(clone) {
          return makeSvgDataUri(
            clone,
            options2.width || util.width(node),
            options2.height || util.height(node)
          );
        });
        function applyOptions(clone) {
          if (options2.bgcolor)
            clone.style.backgroundColor = options2.bgcolor;
          if (options2.width)
            clone.style.width = options2.width + "px";
          if (options2.height)
            clone.style.height = options2.height + "px";
          if (options2.style)
            Object.keys(options2.style).forEach(function(property2) {
              clone.style[property2] = options2.style[property2];
            });
          return clone;
        }
      }
      function toPixelData(node, options2) {
        return draw(node, options2 || {}).then(function(canvas) {
          return canvas.getContext("2d").getImageData(
            0,
            0,
            util.width(node),
            util.height(node)
          ).data;
        });
      }
      function toPng(node, options2) {
        return draw(node, options2 || {}).then(function(canvas) {
          return canvas.toDataURL();
        });
      }
      function toJpeg(node, options2) {
        options2 = options2 || {};
        return draw(node, options2).then(function(canvas) {
          return canvas.toDataURL("image/jpeg", options2.quality || 1);
        });
      }
      function toBlob(node, options2) {
        return draw(node, options2 || {}).then(util.canvasToBlob);
      }
      function copyOptions(options2) {
        if (typeof options2.imagePlaceholder === "undefined") {
          domtoimage2.impl.options.imagePlaceholder = defaultOptions2.imagePlaceholder;
        } else {
          domtoimage2.impl.options.imagePlaceholder = options2.imagePlaceholder;
        }
        if (typeof options2.cacheBust === "undefined") {
          domtoimage2.impl.options.cacheBust = defaultOptions2.cacheBust;
        } else {
          domtoimage2.impl.options.cacheBust = options2.cacheBust;
        }
      }
      function draw(domNode, options2) {
        return toSvg(domNode, options2).then(util.makeImage).then(util.delay(100)).then(function(image) {
          var canvas = newCanvas(domNode);
          canvas.getContext("2d").drawImage(image, 0, 0);
          return canvas;
        });
        function newCanvas(domNode2) {
          var canvas = document.createElement("canvas");
          canvas.width = options2.width || util.width(domNode2);
          canvas.height = options2.height || util.height(domNode2);
          if (options2.bgcolor) {
            var ctx = canvas.getContext("2d");
            ctx.fillStyle = options2.bgcolor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
          }
          return canvas;
        }
      }
      function cloneNode(node, filter2, root2) {
        if (!root2 && filter2 && !filter2(node))
          return Promise.resolve();
        return Promise.resolve(node).then(makeNodeCopy).then(function(clone) {
          return cloneChildren(node, clone, filter2);
        }).then(function(clone) {
          return processClone(node, clone);
        });
        function makeNodeCopy(node2) {
          if (node2 instanceof HTMLCanvasElement)
            return util.makeImage(node2.toDataURL());
          return node2.cloneNode(false);
        }
        function cloneChildren(original, clone, filter3) {
          var children = original.childNodes;
          if (children.length === 0)
            return Promise.resolve(clone);
          return cloneChildrenInOrder(clone, util.asArray(children), filter3).then(function() {
            return clone;
          });
          function cloneChildrenInOrder(parent2, children2, filter4) {
            var done = Promise.resolve();
            children2.forEach(function(child) {
              done = done.then(function() {
                return cloneNode(child, filter4);
              }).then(function(childClone) {
                if (childClone)
                  parent2.appendChild(childClone);
              });
            });
            return done;
          }
        }
        function processClone(original, clone) {
          if (!(clone instanceof Element))
            return clone;
          return Promise.resolve().then(cloneStyle).then(clonePseudoElements).then(copyUserInput).then(fixSvg).then(function() {
            return clone;
          });
          function cloneStyle() {
            copyStyle(window.getComputedStyle(original), clone.style);
            function copyStyle(source, target) {
              if (source.cssText)
                target.cssText = source.cssText;
              else
                copyProperties(source, target);
              function copyProperties(source2, target2) {
                util.asArray(source2).forEach(function(name) {
                  target2.setProperty(
                    name,
                    source2.getPropertyValue(name),
                    source2.getPropertyPriority(name)
                  );
                });
              }
            }
          }
          function clonePseudoElements() {
            [":before", ":after"].forEach(function(element) {
              clonePseudoElement(element);
            });
            function clonePseudoElement(element) {
              var style = window.getComputedStyle(original, element);
              var content = style.getPropertyValue("content");
              if (content === "" || content === "none")
                return;
              var className = util.uid();
              clone.className = clone.className + " " + className;
              var styleElement = document.createElement("style");
              styleElement.appendChild(formatPseudoElementStyle(className, element, style));
              clone.appendChild(styleElement);
              function formatPseudoElementStyle(className2, element2, style2) {
                var selector = "." + className2 + ":" + element2;
                var cssText = style2.cssText ? formatCssText(style2) : formatCssProperties(style2);
                return document.createTextNode(selector + "{" + cssText + "}");
                function formatCssText(style3) {
                  var content2 = style3.getPropertyValue("content");
                  return style3.cssText + " content: " + content2 + ";";
                }
                function formatCssProperties(style3) {
                  return util.asArray(style3).map(formatProperty).join("; ") + ";";
                  function formatProperty(name) {
                    return name + ": " + style3.getPropertyValue(name) + (style3.getPropertyPriority(name) ? " !important" : "");
                  }
                }
              }
            }
          }
          function copyUserInput() {
            if (original instanceof HTMLTextAreaElement)
              clone.innerHTML = original.value;
            if (original instanceof HTMLInputElement)
              clone.setAttribute("value", original.value);
          }
          function fixSvg() {
            if (!(clone instanceof SVGElement))
              return;
            clone.setAttribute("xmlns", "http://www.w3.org/2000/svg");
            if (!(clone instanceof SVGRectElement))
              return;
            ["width", "height"].forEach(function(attribute) {
              var value = clone.getAttribute(attribute);
              if (!value)
                return;
              clone.style.setProperty(attribute, value);
            });
          }
        }
      }
      function embedFonts(node) {
        return fontFaces.resolveAll().then(function(cssText) {
          var styleNode = document.createElement("style");
          node.appendChild(styleNode);
          styleNode.appendChild(document.createTextNode(cssText));
          return node;
        });
      }
      function inlineImages(node) {
        return images.inlineAll(node).then(function() {
          return node;
        });
      }
      function makeSvgDataUri(node, width, height) {
        return Promise.resolve(node).then(function(node2) {
          node2.setAttribute("xmlns", "http://www.w3.org/1999/xhtml");
          return new XMLSerializer().serializeToString(node2);
        }).then(util.escapeXhtml).then(function(xhtml) {
          return '<foreignObject x="0" y="0" width="100%" height="100%">' + xhtml + "</foreignObject>";
        }).then(function(foreignObject) {
          return '<svg xmlns="http://www.w3.org/2000/svg" width="' + width + '" height="' + height + '">' + foreignObject + "</svg>";
        }).then(function(svg) {
          return "data:image/svg+xml;charset=utf-8," + svg;
        });
      }
      function newUtil() {
        return {
          escape: escape2,
          parseExtension,
          mimeType,
          dataAsUrl,
          isDataUrl,
          canvasToBlob,
          resolveUrl,
          getAndEncode,
          uid: uid(),
          delay,
          asArray,
          escapeXhtml,
          makeImage,
          width,
          height
        };
        function mimes() {
          var WOFF = "application/font-woff";
          var JPEG = "image/jpeg";
          return {
            "woff": WOFF,
            "woff2": WOFF,
            "ttf": "application/font-truetype",
            "eot": "application/vnd.ms-fontobject",
            "png": "image/png",
            "jpg": JPEG,
            "jpeg": JPEG,
            "gif": "image/gif",
            "tiff": "image/tiff",
            "svg": "image/svg+xml"
          };
        }
        function parseExtension(url) {
          var match = /\.([^\.\/]*?)$/g.exec(url);
          if (match)
            return match[1];
          else
            return "";
        }
        function mimeType(url) {
          var extension = parseExtension(url).toLowerCase();
          return mimes()[extension] || "";
        }
        function isDataUrl(url) {
          return url.search(/^(data:)/) !== -1;
        }
        function toBlob2(canvas) {
          return new Promise(function(resolve) {
            var binaryString = window.atob(canvas.toDataURL().split(",")[1]);
            var length = binaryString.length;
            var binaryArray = new Uint8Array(length);
            for (var i = 0; i < length; i++)
              binaryArray[i] = binaryString.charCodeAt(i);
            resolve(new Blob([binaryArray], {
              type: "image/png"
            }));
          });
        }
        function canvasToBlob(canvas) {
          if (canvas.toBlob)
            return new Promise(function(resolve) {
              canvas.toBlob(resolve);
            });
          return toBlob2(canvas);
        }
        function resolveUrl(url, baseUrl) {
          var doc = document.implementation.createHTMLDocument();
          var base2 = doc.createElement("base");
          doc.head.appendChild(base2);
          var a = doc.createElement("a");
          doc.body.appendChild(a);
          base2.href = baseUrl;
          a.href = url;
          return a.href;
        }
        function uid() {
          var index2 = 0;
          return function() {
            return "u" + fourRandomChars() + index2++;
            function fourRandomChars() {
              return ("0000" + (Math.random() * Math.pow(36, 4) << 0).toString(36)).slice(-4);
            }
          };
        }
        function makeImage(uri) {
          return new Promise(function(resolve, reject) {
            var image = new Image();
            image.onload = function() {
              resolve(image);
            };
            image.onerror = reject;
            image.src = uri;
          });
        }
        function getAndEncode(url) {
          var TIMEOUT = 3e4;
          if (domtoimage2.impl.options.cacheBust) {
            url += (/\?/.test(url) ? "&" : "?") + new Date().getTime();
          }
          return new Promise(function(resolve) {
            var request = new XMLHttpRequest();
            request.onreadystatechange = done;
            request.ontimeout = timeout;
            request.responseType = "blob";
            request.timeout = TIMEOUT;
            request.open("GET", url, true);
            request.send();
            var placeholder;
            if (domtoimage2.impl.options.imagePlaceholder) {
              var split = domtoimage2.impl.options.imagePlaceholder.split(/,/);
              if (split && split[1]) {
                placeholder = split[1];
              }
            }
            function done() {
              if (request.readyState !== 4)
                return;
              if (request.status !== 200) {
                if (placeholder) {
                  resolve(placeholder);
                } else {
                  fail("cannot fetch resource: " + url + ", status: " + request.status);
                }
                return;
              }
              var encoder = new FileReader();
              encoder.onloadend = function() {
                var content = encoder.result.split(/,/)[1];
                resolve(content);
              };
              encoder.readAsDataURL(request.response);
            }
            function timeout() {
              if (placeholder) {
                resolve(placeholder);
              } else {
                fail("timeout of " + TIMEOUT + "ms occured while fetching resource: " + url);
              }
            }
            function fail(message) {
              console.error(message);
              resolve("");
            }
          });
        }
        function dataAsUrl(content, type) {
          return "data:" + type + ";base64," + content;
        }
        function escape2(string) {
          return string.replace(/([.*+?^${}()|\[\]\/\\])/g, "\\$1");
        }
        function delay(ms) {
          return function(arg) {
            return new Promise(function(resolve) {
              setTimeout(function() {
                resolve(arg);
              }, ms);
            });
          };
        }
        function asArray(arrayLike) {
          var array = [];
          var length = arrayLike.length;
          for (var i = 0; i < length; i++)
            array.push(arrayLike[i]);
          return array;
        }
        function escapeXhtml(string) {
          return string.replace(/#/g, "%23").replace(/\n/g, "%0A");
        }
        function width(node) {
          var leftBorder = px(node, "border-left-width");
          var rightBorder = px(node, "border-right-width");
          return node.scrollWidth + leftBorder + rightBorder;
        }
        function height(node) {
          var topBorder = px(node, "border-top-width");
          var bottomBorder = px(node, "border-bottom-width");
          return node.scrollHeight + topBorder + bottomBorder;
        }
        function px(node, styleProperty) {
          var value = window.getComputedStyle(node).getPropertyValue(styleProperty);
          return parseFloat(value.replace("px", ""));
        }
      }
      function newInliner() {
        var URL_REGEX = /url\(['"]?([^'"]+?)['"]?\)/g;
        return {
          inlineAll,
          shouldProcess,
          impl: {
            readUrls,
            inline
          }
        };
        function shouldProcess(string) {
          return string.search(URL_REGEX) !== -1;
        }
        function readUrls(string) {
          var result = [];
          var match;
          while ((match = URL_REGEX.exec(string)) !== null) {
            result.push(match[1]);
          }
          return result.filter(function(url) {
            return !util.isDataUrl(url);
          });
        }
        function inline(string, url, baseUrl, get2) {
          return Promise.resolve(url).then(function(url2) {
            return baseUrl ? util.resolveUrl(url2, baseUrl) : url2;
          }).then(get2 || util.getAndEncode).then(function(data2) {
            return util.dataAsUrl(data2, util.mimeType(url));
          }).then(function(dataUrl) {
            return string.replace(urlAsRegex(url), "$1" + dataUrl + "$3");
          });
          function urlAsRegex(url2) {
            return new RegExp(`(url\\(['"]?)(` + util.escape(url2) + `)(['"]?\\))`, "g");
          }
        }
        function inlineAll(string, baseUrl, get2) {
          if (nothingToInline())
            return Promise.resolve(string);
          return Promise.resolve(string).then(readUrls).then(function(urls) {
            var done = Promise.resolve(string);
            urls.forEach(function(url) {
              done = done.then(function(string2) {
                return inline(string2, url, baseUrl, get2);
              });
            });
            return done;
          });
          function nothingToInline() {
            return !shouldProcess(string);
          }
        }
      }
      function newFontFaces() {
        return {
          resolveAll,
          impl: {
            readAll
          }
        };
        function resolveAll() {
          return readAll().then(function(webFonts) {
            return Promise.all(
              webFonts.map(function(webFont) {
                return webFont.resolve();
              })
            );
          }).then(function(cssStrings) {
            return cssStrings.join("\n");
          });
        }
        function readAll() {
          return Promise.resolve(util.asArray(document.styleSheets)).then(getCssRules).then(selectWebFontRules).then(function(rules) {
            return rules.map(newWebFont);
          });
          function selectWebFontRules(cssRules) {
            return cssRules.filter(function(rule) {
              return rule.type === CSSRule.FONT_FACE_RULE;
            }).filter(function(rule) {
              return inliner.shouldProcess(rule.style.getPropertyValue("src"));
            });
          }
          function getCssRules(styleSheets) {
            var cssRules = [];
            styleSheets.forEach(function(sheet) {
              try {
                util.asArray(sheet.cssRules || []).forEach(cssRules.push.bind(cssRules));
              } catch (e) {
                console.log("Error while reading CSS rules from " + sheet.href, e.toString());
              }
            });
            return cssRules;
          }
          function newWebFont(webFontRule) {
            return {
              resolve: function resolve() {
                var baseUrl = (webFontRule.parentStyleSheet || {}).href;
                return inliner.inlineAll(webFontRule.cssText, baseUrl);
              },
              src: function() {
                return webFontRule.style.getPropertyValue("src");
              }
            };
          }
        }
      }
      function newImages() {
        return {
          inlineAll,
          impl: {
            newImage
          }
        };
        function newImage(element) {
          return {
            inline
          };
          function inline(get2) {
            if (util.isDataUrl(element.src))
              return Promise.resolve();
            return Promise.resolve(element.src).then(get2 || util.getAndEncode).then(function(data2) {
              return util.dataAsUrl(data2, util.mimeType(element.src));
            }).then(function(dataUrl) {
              return new Promise(function(resolve, reject) {
                element.onload = resolve;
                element.onerror = reject;
                element.src = dataUrl;
              });
            });
          }
        }
        function inlineAll(node) {
          if (!(node instanceof Element))
            return Promise.resolve(node);
          return inlineBackground(node).then(function() {
            if (node instanceof HTMLImageElement)
              return newImage(node).inline();
            else
              return Promise.all(
                util.asArray(node.childNodes).map(function(child) {
                  return inlineAll(child);
                })
              );
          });
          function inlineBackground(node2) {
            var background = node2.style.getPropertyValue("background");
            if (!background)
              return Promise.resolve(node2);
            return inliner.inlineAll(background).then(function(inlined) {
              node2.style.setProperty(
                "background",
                inlined,
                node2.style.getPropertyPriority("background")
              );
            }).then(function() {
              return node2;
            });
          }
        }
      }
    })();
  })(domToImage);
  var domtoimage = domToImage.exports;
  function useTreeViewItem(element) {
    const UIStore = useUIStore();
    const elementOptionsRef = Vue.ref(null);
    const isActiveItem = Vue.computed(() => UIStore.editedElement === element);
    const elementsDefinitionStore = useElementDefinitionsStore();
    const elementModel = elementsDefinitionStore.getElementDefinition(element);
    const showElementMenu = function() {
      if (UIStore.activeElementMenu && UIStore.activeElementMenu.elementUID === element.uid) {
        UIStore.hideElementMenu();
      } else {
        UIStore.showElementMenu(element, elementOptionsRef.value);
      }
    };
    return {
      elementOptionsRef,
      isActiveItem,
      elementModel,
      showElementMenu
    };
  }
  var ElementSectionView_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$B = { key: 0 };
  const _hoisted_2$t = { key: 0 };
  const _hoisted_3$n = ["src"];
  const _hoisted_4$h = { class: "znpb-section-view-item__header-left" };
  const _hoisted_5$f = {
    key: 0,
    class: "znpb-tree-view__itemLooperIcon"
  };
  const _hoisted_6$c = {
    key: 1,
    class: "znpb-tree-view__itemLooperIcon"
  };
  const _sfc_main$H = /* @__PURE__ */ Vue.defineComponent({
    __name: "ElementSectionView",
    props: {
      element: null
    },
    setup(__props) {
      const props = __props;
      const { showElementMenu, elementOptionsRef, isActiveItem, editElement, elementModel } = useTreeViewItem(props.element);
      const imageSrc = Vue.ref(null);
      const error = Vue.ref(null);
      const loading = Vue.ref(true);
      Vue.onMounted(() => {
        setTimeout(() => {
          const domElement = window.frames["znpb-editor-iframe"].contentDocument.getElementById(props.element.elementCssId);
          if (!domElement) {
            console.warn(`Element with id "${props.element.elementCssId}" could not be found in page`);
            return;
          }
          function filter2(node) {
            if (node && node.classList) {
              if (node.classList.contains("znpb-empty-placeholder")) {
                return false;
              }
              if (node.classList.contains("znpb-element-toolbox")) {
                return false;
              }
            }
            return true;
          }
          domtoimage.toPng(domElement, {
            style: {
              width: "100%",
              margin: 0
            },
            filter: filter2
          }).then((dataUrl) => {
            imageSrc.value = dataUrl;
          }).catch((error2) => {
            error2 = true;
            console.error(translate("oops_something_wrong"), error2);
          }).finally(() => {
            loading.value = false;
          });
        }, 100);
      });
      const elementName = Vue.computed({
        get: () => props.element.name,
        set(newValue) {
          props.element.name = newValue;
        }
      });
      return (_ctx, _cache) => {
        const _component_Loader = Vue.resolveComponent("Loader");
        const _component_UIElementIcon = Vue.resolveComponent("UIElementIcon");
        const _component_InlineEdit = Vue.resolveComponent("InlineEdit");
        const _component_Icon = Vue.resolveComponent("Icon");
        const _directive_znpb_tooltip = Vue.resolveDirective("znpb-tooltip");
        return Vue.openBlock(), Vue.createElementBlock("li", {
          class: Vue.normalizeClass(["znpb-section-view-item", {
            "znpb-section-view-item--hidden": !__props.element.isVisible,
            "znpb-section-view-item--loopProvider": __props.element.isRepeaterProvider,
            "znpb-section-view-item--loopConsumer": __props.element.isRepeaterConsumer
          }]),
          onContextmenu: _cache[3] || (_cache[3] = Vue.withModifiers(
            (...args) => Vue.unref(showElementMenu) && Vue.unref(showElementMenu)(...args),
            ["stop", "prevent"]
          )),
          onMouseover: _cache[4] || (_cache[4] = Vue.withModifiers(
            (...args) => __props.element.highlight && __props.element.highlight(...args),
            ["stop"]
          )),
          onMouseout: _cache[5] || (_cache[5] = Vue.withModifiers(
            (...args) => __props.element.unHighlight && __props.element.unHighlight(...args),
            ["stop"]
          )),
          onClick: _cache[6] || (_cache[6] = Vue.withModifiers(
            (...args) => Vue.unref(editElement) && Vue.unref(editElement)(...args),
            ["stop", "left"]
          ))
        }, [
          loading.value || error.value ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$B, [
            Vue.createVNode(_component_Loader, { size: 16 }),
            error.value ? (Vue.openBlock(), Vue.createElementBlock("span", _hoisted_2$t, Vue.toDisplayString(_ctx.$translate("preview_not_available")), 1)) : Vue.createCommentVNode("", true)
          ])) : Vue.createCommentVNode("", true),
          Vue.createElementVNode("img", { src: imageSrc.value }, null, 8, _hoisted_3$n),
          Vue.createElementVNode("div", {
            class: Vue.normalizeClass(["znpb-section-view-item__header", { "znpb-panel-item--active": Vue.unref(isActiveItem) }])
          }, [
            Vue.createVNode(_component_UIElementIcon, {
              element: Vue.unref(elementModel),
              class: "znpb-tree-view__itemIcon znpb-utility__cursor--move",
              size: 24
            }, null, 8, ["element"]),
            Vue.createElementVNode("div", _hoisted_4$h, [
              __props.element.isRepeaterProvider ? Vue.withDirectives((Vue.openBlock(), Vue.createElementBlock("span", _hoisted_5$f, [
                Vue.createTextVNode("P")
              ])), [
                [_directive_znpb_tooltip, _ctx.$translate("repeater_provider")]
              ]) : Vue.createCommentVNode("", true),
              __props.element.isRepeaterConsumer ? Vue.withDirectives((Vue.openBlock(), Vue.createElementBlock("span", _hoisted_6$c, [
                Vue.createTextVNode("C")
              ])), [
                [_directive_znpb_tooltip, _ctx.$translate("repeater_consumer")]
              ]) : Vue.createCommentVNode("", true),
              Vue.createVNode(_component_InlineEdit, {
                modelValue: Vue.unref(elementName),
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => Vue.isRef(elementName) ? elementName.value = $event : null),
                class: "znpb-section-view-item__header-title"
              }, null, 8, ["modelValue"])
            ]),
            !__props.element.isVisible ? Vue.withDirectives((Vue.openBlock(), Vue.createBlock(_component_Icon, {
              key: 0,
              icon: "visibility-hidden",
              class: "znpb-editor-icon-wrapper--show-element znpb-tree-view__item-enable-visible",
              onClick: _cache[1] || (_cache[1] = Vue.withModifiers(($event) => __props.element.isVisible = !__props.element.isVisible, ["stop"]))
            }, null, 512)), [
              [_directive_znpb_tooltip, _ctx.$translate("enable_hidden_element")]
            ]) : Vue.createCommentVNode("", true),
            Vue.createElementVNode("div", {
              ref_key: "elementOptionsRef",
              ref: elementOptionsRef,
              class: "znpb-element-options__container",
              onClick: _cache[2] || (_cache[2] = Vue.withModifiers(
                (...args) => Vue.unref(showElementMenu) && Vue.unref(showElementMenu)(...args),
                ["stop"]
              ))
            }, [
              Vue.createVNode(_component_Icon, {
                class: "znpb-element-options__dropdown-icon znpb-utility__cursor--pointer",
                icon: "more"
              })
            ], 512)
          ], 2)
        ], 34);
      };
    }
  });
  function useTreeViewList() {
    const elementOptionsRef = Vue.ref(null);
    const UIStore = useUIStore();
    const contentStore = useContentStore();
    function sortableStart() {
      UIStore.setElementDragging(true);
    }
    function sortableEnd() {
      UIStore.setElementDragging(false);
    }
    function onSortableDrop(event2) {
      const { item, to, newIndex, duplicateItem, placeBefore } = event2.data;
      const movedElement = contentStore.getElement(item.dataset.zionElementUid);
      if (duplicateItem) {
        const elementForInsert = movedElement.getClone();
        window.zb.run("editor/elements/add", {
          parentUID: to.dataset.zionElementUid,
          element: elementForInsert,
          index: placeBefore ? newIndex : newIndex + 1
        });
      } else {
        window.zb.run("editor/elements/move", {
          newParent: contentStore.getElement(to.dataset.zionElementUid),
          element: contentStore.getElement(item.dataset.zionElementUid),
          index: newIndex
        });
      }
    }
    return {
      elementOptionsRef,
      sortableStart,
      sortableEnd,
      onSortableDrop
    };
  }
  var SectionViewPanel_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$A = {
    id: "znpb-section-view",
    class: "znpb-tree-view-container znpb-fancy-scrollbar znpb-panel-view-wrapper"
  };
  const _hoisted_2$s = {
    key: 0,
    class: "znpb-tree-view__view__ListAddButtonInside"
  };
  const _sfc_main$G = /* @__PURE__ */ Vue.defineComponent({
    __name: "SectionViewPanel",
    props: {
      element: null
    },
    setup(__props) {
      const props = __props;
      const { sortableStart, sortableEnd, onSortableDrop } = useTreeViewList();
      const contentStore = useContentStore();
      const children = Vue.computed(() => {
        return props.element.content.map((childUID) => contentStore.getElement(childUID));
      });
      return (_ctx, _cache) => {
        const _component_AddElementIcon = Vue.resolveComponent("AddElementIcon");
        const _component_Sortable = Vue.resolveComponent("Sortable");
        return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$A, [
          Vue.createVNode(_component_Sortable, {
            modelValue: Vue.unref(children),
            class: "znpb-section-view-wrapper",
            tag: "ul",
            group: "pagebuilder-sectionview-elements",
            "data-zion-element-uid": __props.element.uid,
            onStart: Vue.unref(sortableStart),
            onEnd: Vue.unref(sortableEnd),
            onDrop: Vue.unref(onSortableDrop)
          }, {
            helper: Vue.withCtx(() => [
              Vue.createVNode(SortableHelper)
            ]),
            placeholder: Vue.withCtx(() => [
              Vue.createVNode(SortablePlaceholder)
            ]),
            end: Vue.withCtx(() => [
              Vue.unref(children).length === 0 ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_2$s, [
                Vue.createVNode(_component_AddElementIcon, {
                  element: __props.element,
                  placement: "inside"
                }, null, 8, ["element"])
              ])) : Vue.createCommentVNode("", true)
            ]),
            default: Vue.withCtx(() => [
              (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList(Vue.unref(children), (childElement) => {
                return Vue.openBlock(), Vue.createBlock(_sfc_main$H, {
                  key: childElement.uid,
                  element: childElement,
                  "data-zion-element-uid": childElement.uid
                }, null, 8, ["element", "data-zion-element-uid"]);
              }), 128))
            ]),
            _: 1
          }, 8, ["modelValue", "data-zion-element-uid", "onStart", "onEnd", "onDrop"])
        ]);
      };
    }
  });
  var TreeViewListItem_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$z = ["id", "onClick"];
  const _hoisted_2$r = {
    key: 1,
    class: "znpb-tree-view__itemLooperIcon"
  };
  const _hoisted_3$m = {
    key: 2,
    class: "znpb-tree-view__itemLooperIcon"
  };
  const _sfc_main$F = /* @__PURE__ */ Vue.defineComponent({
    __name: "TreeViewListItem",
    props: {
      element: null
    },
    setup(__props) {
      const props = __props;
      const UIStore = useUIStore();
      const listItem = Vue.ref(null);
      const elementName = Vue.computed({
        get: () => props.element.name,
        set(newValue) {
          props.element.name = newValue;
        }
      });
      const justAdded = Vue.ref(false);
      const { showElementMenu, elementOptionsRef, isActiveItem } = useTreeViewItem(props.element);
      let clickedElement = false;
      function onItemsClick() {
        props.element.scrollTo = true;
        clickedElement = true;
        UIStore.editElement(props.element);
        Vue.nextTick(() => {
          clickedElement = false;
        });
      }
      if (UIStore.contentTimestamp) {
        justAdded.value = props.element.addedTime > UIStore.contentTimestamp ? Date.now() - props.element.addedTime < 1e3 : false;
        if (justAdded.value) {
          setTimeout(() => {
            justAdded.value = false;
          }, 1e3);
        }
      }
      Vue.watch(
        () => UIStore.editedElement,
        (newValue, oldValue) => {
          if (!clickedElement && newValue !== oldValue && newValue === props.element) {
            if (listItem.value) {
              listItem.value.scrollIntoView({
                behavior: "smooth",
                block: "center"
              });
            }
          }
        }
      );
      const expandedItems = Vue.inject("treeViewExpandedItems");
      const treeViewExpandStatus = Vue.inject("treeViewExpandStatus");
      const expanded = Vue.ref(treeViewExpandStatus.value || expandedItems.value.includes(props.element.uid) || false);
      Vue.watch(treeViewExpandStatus, (newValue) => {
        expanded.value = newValue;
      });
      Vue.watch(expandedItems, (newValue) => {
        if (expandedItems.value.includes(props.element.uid)) {
          expanded.value = true;
        }
      });
      return (_ctx, _cache) => {
        const _component_Icon = Vue.resolveComponent("Icon");
        const _component_UIElementIcon = Vue.resolveComponent("UIElementIcon");
        const _component_InlineEdit = Vue.resolveComponent("InlineEdit");
        const _component_AddElementIcon = Vue.resolveComponent("AddElementIcon");
        const _directive_znpb_tooltip = Vue.resolveDirective("znpb-tooltip");
        return Vue.openBlock(), Vue.createElementBlock("li", {
          id: __props.element.uid,
          ref_key: "listItem",
          ref: listItem,
          class: Vue.normalizeClass(["znpb-tree-view__item", {
            "znpb-tree-view__item--hidden": !__props.element.isVisible,
            "znpb-tree-view__item--justAdded": justAdded.value,
            "znpb-tree-view__item--loopProvider": __props.element.isRepeaterProvider,
            "znpb-tree-view__item--loopConsumer": __props.element.isRepeaterConsumer
          }]),
          onMouseenter: _cache[4] || (_cache[4] = (...args) => __props.element.highlight && __props.element.highlight(...args)),
          onMouseleave: _cache[5] || (_cache[5] = (...args) => __props.element.unHighlight && __props.element.unHighlight(...args)),
          onClick: Vue.withModifiers(onItemsClick, ["stop", "left"]),
          onContextmenu: _cache[6] || (_cache[6] = Vue.withModifiers(
            (...args) => Vue.unref(showElementMenu) && Vue.unref(showElementMenu)(...args),
            ["stop", "prevent"]
          ))
        }, [
          Vue.createElementVNode("div", {
            class: Vue.normalizeClass(["znpb-tree-view__item-header", { "znpb-panel-item--active": Vue.unref(isActiveItem) }])
          }, [
            __props.element.isWrapper ? (Vue.openBlock(), Vue.createBlock(_component_Icon, {
              key: 0,
              icon: "select",
              class: Vue.normalizeClass(["znpb-tree-view__item-header-item znpb-tree-view__item-header-expand", {
                "znpb-tree-view__item-header-expand--expanded": expanded.value
              }]),
              onClick: _cache[0] || (_cache[0] = Vue.withModifiers(($event) => expanded.value = !expanded.value, ["stop"]))
            }, null, 8, ["class"])) : Vue.createCommentVNode("", true),
            Vue.createVNode(_component_UIElementIcon, {
              element: __props.element.elementDefinition,
              class: "znpb-tree-view__itemIcon znpb-utility__cursor--move",
              size: 24
            }, null, 8, ["element"]),
            __props.element.isRepeaterProvider ? Vue.withDirectives((Vue.openBlock(), Vue.createElementBlock("span", _hoisted_2$r, [
              Vue.createTextVNode("P")
            ])), [
              [_directive_znpb_tooltip, _ctx.$translate("repeater_provider")]
            ]) : Vue.createCommentVNode("", true),
            __props.element.isRepeaterConsumer ? Vue.withDirectives((Vue.openBlock(), Vue.createElementBlock("span", _hoisted_3$m, [
              Vue.createTextVNode("C")
            ])), [
              [_directive_znpb_tooltip, _ctx.$translate("repeater_consumer")]
            ]) : Vue.createCommentVNode("", true),
            Vue.createVNode(_component_InlineEdit, {
              modelValue: Vue.unref(elementName),
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => Vue.isRef(elementName) ? elementName.value = $event : null),
              class: "znpb-tree-view__item-header-item znpb-tree-view__item-header-rename"
            }, null, 8, ["modelValue"]),
            !__props.element.isVisible ? Vue.withDirectives((Vue.openBlock(), Vue.createBlock(_component_Icon, {
              key: 3,
              icon: "visibility-hidden",
              class: "znpb-editor-icon-wrapper--show-element znpb-tree-view__item-enable-visible",
              onClick: _cache[2] || (_cache[2] = Vue.withModifiers(($event) => __props.element.isVisible = !__props.element.isVisible, ["stop"]))
            }, null, 512)), [
              [_directive_znpb_tooltip, Vue.unref(translate)("enable_hidden_element")]
            ]) : Vue.createCommentVNode("", true),
            Vue.createElementVNode("div", {
              ref_key: "elementOptionsRef",
              ref: elementOptionsRef,
              class: "znpb-element-options__container",
              onClick: _cache[3] || (_cache[3] = Vue.withModifiers(
                (...args) => Vue.unref(showElementMenu) && Vue.unref(showElementMenu)(...args),
                ["stop"]
              ))
            }, [
              Vue.createVNode(_component_Icon, {
                class: "znpb-element-options__dropdown-icon znpb-utility__cursor--pointer",
                icon: "more"
              })
            ], 512),
            Vue.createVNode(_component_AddElementIcon, {
              element: __props.element,
              class: "znpb-tree-view__itemAddButton",
              position: "centered-bottom"
            }, null, 8, ["element"])
          ], 2),
          expanded.value ? (Vue.openBlock(), Vue.createBlock(_sfc_main$E, {
            key: 0,
            element: __props.element
          }, null, 8, ["element"])) : Vue.createCommentVNode("", true)
        ], 42, _hoisted_1$z);
      };
    }
  });
  var TreeViewList_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$y = {
    key: 0,
    class: "znpb-tree-view__view__ListAddButtonInside"
  };
  const _sfc_main$E = /* @__PURE__ */ Vue.defineComponent({
    __name: "TreeViewList",
    props: {
      element: null
    },
    setup(__props) {
      const props = __props;
      const contentStore = useContentStore();
      const children = Vue.computed(() => {
        return props.element.content.map((childUID) => contentStore.getElement(childUID));
      });
      const { sortableStart, sortableEnd, onSortableDrop } = useTreeViewList();
      return (_ctx, _cache) => {
        const _component_AddElementIcon = Vue.resolveComponent("AddElementIcon");
        const _component_Sortable = Vue.resolveComponent("Sortable");
        return Vue.openBlock(), Vue.createBlock(_component_Sortable, {
          modelValue: Vue.unref(children),
          tag: "ul",
          class: "znpb-tree-view-wrapper",
          group: "pagebuilder-treview-elements",
          handle: ".znpb-tree-view__item-header",
          "data-zion-element-uid": __props.element.uid,
          onStart: Vue.unref(sortableStart),
          onEnd: Vue.unref(sortableEnd),
          onDrop: Vue.unref(onSortableDrop)
        }, {
          end: Vue.withCtx(() => [
            Vue.unref(children).length === 0 && __props.element.isWrapper ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$y, [
              Vue.createVNode(_component_AddElementIcon, {
                element: __props.element,
                placement: "inside",
                index: -1
              }, null, 8, ["element"])
            ])) : Vue.createCommentVNode("", true)
          ]),
          helper: Vue.withCtx(() => [
            Vue.createVNode(SortableHelper)
          ]),
          placeholder: Vue.withCtx(() => [
            Vue.createVNode(SortablePlaceholder)
          ]),
          default: Vue.withCtx(() => [
            (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList(Vue.unref(children), (childElement) => {
              return Vue.openBlock(), Vue.createBlock(_sfc_main$F, {
                key: childElement.uid,
                element: childElement,
                "data-zion-element-uid": childElement.uid
              }, null, 8, ["element", "data-zion-element-uid"]);
            }), 128))
          ]),
          _: 1
        }, 8, ["modelValue", "data-zion-element-uid", "onStart", "onEnd", "onDrop"]);
      };
    }
  });
  var TreeViewPanel_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$x = { class: "znpb-tree-viewWrapper" };
  const _hoisted_2$q = { class: "znpb-tree-viewExpandContainer" };
  const _hoisted_3$l = { class: "znpb-tree-view znpb-fancy-scrollbar znpb-panel-view-wrapper" };
  const _sfc_main$D = /* @__PURE__ */ Vue.defineComponent({
    __name: "TreeViewPanel",
    props: {
      element: null
    },
    setup(__props) {
      const props = __props;
      const UIStore = useUIStore();
      const userStore = useUserStore();
      const treeViewExpanded = Vue.ref(false);
      const showModalConfirm = Vue.ref(false);
      const expandedItems = Vue.ref([]);
      const canRemove = Vue.computed(() => {
        return props.element.content.length === 0;
      });
      Vue.provide("treeViewExpandStatus", treeViewExpanded);
      Vue.watch(
        () => UIStore.editedElement,
        (newElement, oldElement) => {
          if (newElement && newElement !== oldElement) {
            let parentUIDS = [newElement.uid];
            while (newElement.parent && newElement.parent.element_type !== "contentRoot") {
              parentUIDS.push(newElement.parent.uid);
              newElement = newElement.parent;
            }
            expandedItems.value = parentUIDS;
          }
        }
      );
      function removeAllElements() {
        window.zb.run("editor/elements/remove_all", {
          areaID: props.element.uid
        });
        showModalConfirm.value = false;
      }
      Vue.provide("treeViewExpandedItems", expandedItems);
      return (_ctx, _cache) => {
        const _component_ModalConfirm = Vue.resolveComponent("ModalConfirm");
        const _component_Icon = Vue.resolveComponent("Icon");
        return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$x, [
          Vue.createElementVNode("div", _hoisted_2$q, [
            showModalConfirm.value ? (Vue.openBlock(), Vue.createBlock(_component_ModalConfirm, {
              key: 0,
              width: 530,
              "confirm-text": Vue.unref(translate)("yes_delete_elements"),
              "cancel-text": Vue.unref(translate)("cancel"),
              onConfirm: removeAllElements,
              onCancel: _cache[0] || (_cache[0] = ($event) => showModalConfirm.value = false)
            }, {
              default: Vue.withCtx(() => [
                Vue.createTextVNode(Vue.toDisplayString(Vue.unref(translate)("are_you_sure_delete_elements")), 1)
              ]),
              _: 1
            }, 8, ["confirm-text", "cancel-text"])) : Vue.createCommentVNode("", true),
            !Vue.unref(userStore).permissions.only_content ? (Vue.openBlock(), Vue.createElementBlock("a", {
              key: 1,
              href: "#",
              class: Vue.normalizeClass(["znpb-tree-viewRemoveButton", {
                "znpb-tree-viewRemoveButton--disabled": Vue.unref(canRemove)
              }]),
              onClick: _cache[1] || (_cache[1] = ($event) => showModalConfirm.value = true)
            }, [
              Vue.createTextVNode(Vue.toDisplayString(Vue.unref(translate)("remove_all")) + " ", 1),
              Vue.createVNode(_component_Icon, {
                icon: "delete",
                size: 10
              })
            ], 2)) : Vue.createCommentVNode("", true),
            Vue.createElementVNode("a", {
              href: "#",
              onClick: _cache[2] || (_cache[2] = ($event) => (treeViewExpanded.value = !treeViewExpanded.value, expandedItems.value = []))
            }, [
              !treeViewExpanded.value ? (Vue.openBlock(), Vue.createElementBlock(Vue.Fragment, { key: 0 }, [
                Vue.createTextVNode(Vue.toDisplayString(Vue.unref(translate)("expand_all")) + " ", 1),
                Vue.createVNode(_component_Icon, {
                  icon: "long-arrow-down",
                  size: 10
                })
              ], 64)) : (Vue.openBlock(), Vue.createElementBlock(Vue.Fragment, { key: 1 }, [
                Vue.createTextVNode(Vue.toDisplayString(Vue.unref(translate)("collapse_all")) + " ", 1),
                Vue.createVNode(_component_Icon, {
                  icon: "long-arrow-up",
                  size: 10
                })
              ], 64))
            ])
          ]),
          Vue.createElementVNode("div", _hoisted_3$l, [
            Vue.createVNode(_sfc_main$E, { element: __props.element }, null, 8, ["element"])
          ])
        ]);
      };
    }
  });
  var WireframeListItem_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$w = { class: "znpb-wireframe-item__header" };
  const _hoisted_2$p = { class: "znpb-wireframe-item__header-area znpb-wireframe-item__header-area--left" };
  const _hoisted_3$k = {
    key: 1,
    class: "znpb-tree-view__itemLooperIcon"
  };
  const _hoisted_4$g = {
    key: 2,
    class: "znpb-tree-view__itemLooperIcon"
  };
  const _hoisted_5$e = { class: "znpb-wireframe-item__header-area znpb-wireframe-item__header-area--right" };
  const _sfc_main$C = /* @__PURE__ */ Vue.defineComponent({
    __name: "WireframeListItem",
    props: {
      element: null
    },
    setup(__props) {
      const props = __props;
      const expanded = Vue.ref(true);
      const { showElementMenu, elementOptionsRef } = useTreeViewItem(props.element);
      const columnSize = Vue.computed(() => props.element.options.column_size);
      const elementsDefinitionsStore = useElementDefinitionsStore();
      const elementModel = elementsDefinitionsStore.getElementDefinition(props.element.element_type);
      const elementName = Vue.computed({
        get: () => props.element.name,
        set(newValue) {
          props.element.name = newValue;
        }
      });
      const hasFlexDirection = Vue.computed(() => {
        let orientation = "column";
        let mediaOrientation = get(props.element.options, "_styles.wrapper.styles.default.default.flex-direction");
        if (props.element.element_type === "zion_section") {
          mediaOrientation = get(
            props.element.options,
            "_styles.inner_content_styles.styles.default.default.flex-direction",
            "row"
          );
        }
        if (mediaOrientation) {
          orientation = mediaOrientation;
        }
        return orientation;
      });
      const getClasses = Vue.computed(() => {
        let cssClass = {
          [`znpb-wireframe-item--item--hidden`]: !props.element.isVisible,
          [`znpb-wireframe-item--${props.element.element_type}`]: props.element.element_type,
          [`znpb-wireframe-item__empty`]: !props.element.content.length,
          "znpb-wireframe-item--loopProvider": props.element.isRepeaterProvider,
          "znpb-wireframe-item--loopConsumer": props.element.isRepeaterConsumer
        };
        if (columnSize.value) {
          Object.keys(columnSize.value).forEach((key) => {
            let responsivePrefix = getColumnResponsivePrefix(key);
            cssClass[`zb-column--${responsivePrefix}${columnSize.value[key]}`] = !!columnSize.value[key];
          });
        }
        return cssClass;
      });
      function getColumnResponsivePrefix(responsiveMediaId) {
        const devices = {
          default: "",
          laptop: "lg--",
          tablet: "md--",
          mobile: "sm--"
        };
        return devices[responsiveMediaId];
      }
      return (_ctx, _cache) => {
        const _component_Icon = Vue.resolveComponent("Icon");
        const _component_UIElementIcon = Vue.resolveComponent("UIElementIcon");
        const _component_InlineEdit = Vue.resolveComponent("InlineEdit");
        const _directive_znpb_tooltip = Vue.resolveDirective("znpb-tooltip");
        return Vue.openBlock(), Vue.createElementBlock("li", {
          class: Vue.normalizeClass(["znpb-wireframe-item", Vue.unref(getClasses)]),
          onClick: _cache[4] || (_cache[4] = Vue.withModifiers(
            (...args) => __props.element.focus && __props.element.focus(...args),
            ["stop"]
          )),
          onContextmenu: _cache[5] || (_cache[5] = Vue.withModifiers(
            (...args) => Vue.unref(showElementMenu) && Vue.unref(showElementMenu)(...args),
            ["stop", "prevent"]
          ))
        }, [
          Vue.createElementVNode("div", _hoisted_1$w, [
            Vue.createElementVNode("div", _hoisted_2$p, [
              __props.element.isWrapper ? (Vue.openBlock(), Vue.createBlock(_component_Icon, {
                key: 0,
                class: "znpb-wireframe-item__header-item znpb-wireframe-item__header-button znpb-wireframe-item__header-more znpb-utility__cursor--pointer",
                icon: "select",
                rotate: expanded.value ? "180" : false,
                onClick: _cache[0] || (_cache[0] = ($event) => expanded.value = !expanded.value)
              }, null, 8, ["rotate"])) : Vue.createCommentVNode("", true),
              Vue.createVNode(_component_UIElementIcon, {
                element: Vue.unref(elementModel),
                class: "znpb-tree-view__itemIcon",
                size: 24
              }, null, 8, ["element"]),
              __props.element.isRepeaterProvider ? Vue.withDirectives((Vue.openBlock(), Vue.createElementBlock("span", _hoisted_3$k, [
                Vue.createTextVNode("P")
              ])), [
                [_directive_znpb_tooltip, _ctx.$translate("repeater_provider")]
              ]) : Vue.createCommentVNode("", true),
              __props.element.isRepeaterConsumer ? Vue.withDirectives((Vue.openBlock(), Vue.createElementBlock("span", _hoisted_4$g, [
                Vue.createTextVNode("C")
              ])), [
                [_directive_znpb_tooltip, _ctx.$translate("repeater_consumer")]
              ]) : Vue.createCommentVNode("", true),
              Vue.createVNode(_component_InlineEdit, {
                modelValue: Vue.unref(elementName),
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => Vue.isRef(elementName) ? elementName.value = $event : null),
                class: "znpb-wireframe-item__header-title znpb-wireframe-item__header-item"
              }, null, 8, ["modelValue"])
            ]),
            Vue.createElementVNode("div", _hoisted_5$e, [
              !__props.element.isVisible ? Vue.withDirectives((Vue.openBlock(), Vue.createBlock(_component_Icon, {
                key: 0,
                icon: "visibility-hidden",
                class: "znpb-editor-icon-wrapper--show-element znpb-tree-view__item-enable-visible znpb-wireframe-item__header-area--visibility-icon",
                onClick: _cache[2] || (_cache[2] = Vue.withModifiers(($event) => __props.element.isVisible = !__props.element.isVisible, ["stop"]))
              }, null, 512)), [
                [_directive_znpb_tooltip, Vue.unref(translate)("enable_hidden_element")]
              ]) : Vue.createCommentVNode("", true),
              Vue.createElementVNode("div", {
                ref_key: "elementOptionsRef",
                ref: elementOptionsRef,
                class: "znpb-element-options__container",
                onClick: _cache[3] || (_cache[3] = Vue.withModifiers(
                  (...args) => Vue.unref(showElementMenu) && Vue.unref(showElementMenu)(...args),
                  ["stop"]
                ))
              }, [
                Vue.createVNode(_component_Icon, {
                  class: "znpb-element-options__dropdown-icon znpb-utility__cursor--pointer",
                  icon: "more"
                })
              ], 512)
            ])
          ]),
          expanded.value && __props.element.isWrapper ? (Vue.openBlock(), Vue.createBlock(_sfc_main$B, {
            key: 0,
            element: __props.element,
            class: Vue.normalizeClass(["znpb-wireframe-item__content", { [`znpb-flex--${Vue.unref(hasFlexDirection)}`]: Vue.unref(hasFlexDirection) }])
          }, null, 8, ["element", "class"])) : Vue.createCommentVNode("", true)
        ], 34);
      };
    }
  });
  const _sfc_main$B = /* @__PURE__ */ Vue.defineComponent({
    __name: "WireframeList",
    props: {
      element: null,
      showAdd: { type: Boolean, default: true }
    },
    setup(__props) {
      const props = __props;
      const UIStore = useUIStore();
      const contentStore = useContentStore();
      const children = Vue.computed(() => {
        return props.element.content.map((childUID) => contentStore.getElement(childUID));
      });
      const { sortableStart, sortableEnd, onSortableDrop } = useTreeViewList();
      const getSortableAxis = Vue.computed(() => {
        if (props.element.element_type === "contentRoot") {
          return "vertical";
        }
        let orientation = props.element.element_type === "zion_column" ? "vertical" : "horizontal";
        if (props.element.options.inner_content_layout) {
          orientation = props.element.options.inner_content_layout;
        }
        const mediaOrientation = get(props.element.options, "_styles.wrapper.styles.default.default.flex-direction");
        if (mediaOrientation) {
          orientation = mediaOrientation === "row" ? "horizontal" : "vertical";
        }
        return orientation;
      });
      return (_ctx, _cache) => {
        const _component_AddElementIcon = Vue.resolveComponent("AddElementIcon");
        const _component_Sortable = Vue.resolveComponent("Sortable");
        return Vue.openBlock(), Vue.createBlock(_component_Sortable, {
          modelValue: Vue.unref(children),
          tag: "ul",
          class: Vue.normalizeClass(["znpb-wireframe-view-wrapper", {
            [`znpb__sortable-container--${Vue.unref(getSortableAxis)}`]: Vue.unref(UIStore).isElementDragging
          }]),
          group: "pagebuilder-wireframe-elements",
          axis: Vue.unref(getSortableAxis),
          "allow-duplicate": true,
          "data-zion-element-uid": __props.element.uid,
          onStart: Vue.unref(sortableStart),
          onEnd: Vue.unref(sortableEnd),
          onDrop: Vue.unref(onSortableDrop)
        }, {
          helper: Vue.withCtx(() => [
            Vue.createVNode(SortableHelper)
          ]),
          placeholder: Vue.withCtx(() => [
            Vue.createVNode(SortablePlaceholder)
          ]),
          end: Vue.withCtx(() => [
            !__props.element.content.length && __props.element.isWrapper ? (Vue.openBlock(), Vue.createBlock(_sfc_main$16, {
              key: 0,
              element: __props.element
            }, null, 8, ["element"])) : Vue.createCommentVNode("", true),
            Vue.createVNode(_component_AddElementIcon, {
              element: __props.element,
              class: "znpb-tree-view__ListAddButton",
              placement: "next"
            }, null, 8, ["element"])
          ]),
          default: Vue.withCtx(() => [
            (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList(Vue.unref(children), (childElement) => {
              return Vue.openBlock(), Vue.createBlock(_sfc_main$C, {
                key: childElement.uid,
                element: childElement,
                "data-zion-element-uid": childElement.uid
              }, null, 8, ["element", "data-zion-element-uid"]);
            }), 128))
          ]),
          _: 1
        }, 8, ["modelValue", "class", "axis", "data-zion-element-uid", "onStart", "onEnd", "onDrop"]);
      };
    }
  });
  var WireframePanel_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$A = {
    name: "WireframePanel",
    components: {
      WireframeList: _sfc_main$B
    },
    props: {
      element: {
        type: Object,
        required: true
      }
    }
  };
  const _hoisted_1$v = {
    id: "znpb-wireframe-panel",
    class: "znpb-tree-view-bar znpb-wireframe-container znpb-fancy-scrollbar znpb-panel-view-wrapper"
  };
  function _sfc_render$f(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_WireframeList = Vue.resolveComponent("WireframeList");
    return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$v, [
      Vue.createVNode(_component_WireframeList, {
        element: $props.element,
        "show-add": false
      }, null, 8, ["element"])
    ]);
  }
  var WireframeView = /* @__PURE__ */ _export_sfc(_sfc_main$A, [["render", _sfc_render$f]]);
  var BasePanel_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$u = ["id"];
  const _hoisted_2$o = {
    key: 0,
    class: "znpb-panel__header-name"
  };
  const _hoisted_3$j = { class: "znpb-panel__content_wrapper" };
  const _sfc_main$z = /* @__PURE__ */ Vue.defineComponent({
    __name: "BasePanel",
    props: {
      cssClass: { default: "" },
      panelName: { default: "" },
      panelId: null,
      expanded: { type: Boolean, default: false },
      showHeader: { type: Boolean, default: true },
      showClose: { type: Boolean, default: true },
      allowHorizontalResize: { type: Boolean, default: true },
      allowVerticalResize: { type: Boolean, default: true },
      closeOnEscape: { type: Boolean, default: true },
      panel: null
    },
    emits: ["close-panel"],
    setup(__props, { expose, emit }) {
      const props = __props;
      const slots = Vue.useSlots();
      const UIStore = useUIStore();
      const { addEventListener, removeEventListener } = useWindows();
      let boundingClientRect = null;
      const root2 = Vue.ref(null);
      const panelOffset = Vue.ref(null);
      const initialPosition = Vue.ref({
        posY: 0,
        posX: 0
      });
      const dragginMoved = Vue.ref({
        x: null,
        y: null
      });
      const getCssClass = Vue.computed(() => {
        let classes = "";
        classes += props.panel.isDetached ? " znpb-editor-panel--detached" : " znpb-editor-panel--attached";
        classes += props.cssClass ? props.cssClass : "";
        classes += props.panel.isDragging ? " znpb-editor-panel--dragging" : "";
        if (!props.panel.isDetached) {
          classes += UIStore.getPanelPlacement(props.panel.id) === "right" ? " znpb-editor-panel--right" : " znpb-editor-panel--left";
        }
        return classes;
      });
      const panelStyles = Vue.computed(() => {
        const cssStyles = {
          width: props.panel.width + "px",
          height: props.panel.isDetached ? props.panel.height ? props.panel.height + "px" : "90%" : "100%",
          order: UIStore.getPanelOrder(props.panel.id),
          top: !props.panel.isDragging && props.panel.isDetached && props.panel.offsets.posY !== 0 ? props.panel.offsets.posY + "px" : null,
          left: !props.panel.isDragging && props.panel.isDetached ? props.panel.offsets.posX + "px" : null,
          position: props.panel.isDetached ? "fixed" : "relative",
          transform: props.panel.isDragging ? `translate3d(${dragginMoved.value.x}px, ${dragginMoved.value.y}px, 0)` : null,
          zIndex: props.panel.isDragging ? 99 : null
        };
        return cssStyles;
      });
      const hasHeaderSlot = Vue.computed(() => {
        return !!slots.header;
      });
      let initialMovePosition = {
        posX: null,
        posY: null
      };
      let availableStickElements = [];
      let oldIndex = null;
      let newIndex = null;
      function onMouseDown(event2) {
        UIStore.setIframePointerEvents(true);
        document.body.style.userSelect = "none";
        const { clientX, clientY } = event2;
        oldIndex = UIStore.getPanelIndex(props.panel.id);
        boundingClientRect = root2.value.getBoundingClientRect();
        const parentClientRect = root2.value.parentNode.getBoundingClientRect();
        initialMovePosition = {
          posX: clientX,
          posY: clientY,
          startPanelRect: boundingClientRect,
          parentClientRect,
          oldTop: boundingClientRect.top,
          oldLeft: boundingClientRect.left
        };
        dragginMoved.value = {
          x: boundingClientRect.left - parentClientRect.left,
          y: boundingClientRect.top - parentClientRect.top
        };
        window.addEventListener("mousemove", rafMovePanel);
        window.addEventListener("mouseup", onMouseUp);
      }
      function movePanel(event2) {
        const { posX, posY, oldTop, oldLeft, parentClientRect } = initialMovePosition;
        const { height: parentHeight, width: parentWidth } = parentClientRect;
        const { clientY, clientX } = event2;
        if (!props.panel.isDragging) {
          const xMoved = Math.abs(posX - clientX);
          const yMoved = Math.abs(posY - clientY);
          const dragThreshold = 5;
          if (xMoved > dragThreshold || yMoved > dragThreshold) {
            UIStore.updatePanel(props.panel.id, "isDetached", true);
            UIStore.updatePanel(props.panel.id, "isDragging", true);
            Vue.nextTick(() => {
              boundingClientRect = root2.value.getBoundingClientRect();
              UIStore.openPanels.forEach((panel) => {
                if (panel.isDetached || panel.id === props.panel.id) {
                  return;
                }
                const boundingClient = document.getElementById(panel.id).getBoundingClientRect();
                availableStickElements.push({
                  panel,
                  boundingClient
                });
              });
            });
          }
        } else {
          if (!boundingClientRect) {
            return;
          }
          const maxBottom = parentHeight - boundingClientRect.height;
          const newPositionY = oldTop + clientY - posY - parentClientRect.top;
          const newTop = newPositionY < 0 ? 0 : newPositionY;
          const MinMaxTop = newTop > maxBottom ? maxBottom : newTop;
          const movedAmmount = oldLeft + clientX - posX;
          const MinMaxLeft = movedAmmount - parentClientRect.left;
          dragginMoved.value = {
            x: MinMaxLeft,
            y: MinMaxTop
          };
          availableStickElements.forEach((availableStickLocation) => {
            const { boundingClient, panel: possibleHoverPanel } = availableStickLocation;
            const realLeft = boundingClient.left;
            const realRight = boundingClient.left + boundingClient.width;
            if (MinMaxLeft >= boundingClient.left && MinMaxLeft <= boundingClient.left + boundingClient.width) {
              if (MinMaxLeft < realLeft + 50) {
                UIStore.setPanelPlaceholder({
                  visibility: true,
                  left: realLeft,
                  placeBefore: true,
                  panel: possibleHoverPanel
                });
                newIndex = UIStore.getPanelIndex(possibleHoverPanel.id);
              } else if (movedAmmount + boundingClientRect.width > boundingClient.left + boundingClient.width - 50) {
                const left2 = boundingClient.left + boundingClient.width >= window.innerWidth ? boundingClient.left + boundingClient.width - 5 : realRight;
                UIStore.setPanelPlaceholder({
                  visibility: true,
                  left: left2,
                  placeBefore: false,
                  panel: possibleHoverPanel
                });
                newIndex = UIStore.getPanelIndex(possibleHoverPanel.id) + 1;
              } else {
                UIStore.setPanelPlaceholder({
                  visibility: false,
                  left: null,
                  placeBefore: null,
                  panel: null
                });
                newIndex = null;
              }
            }
          });
        }
      }
      const rafMovePanel = rafSchd$1(movePanel);
      function updatePosition(oldIndex2, newIndex2) {
        const list = [...UIStore.panelsOrder];
        if (oldIndex2 >= newIndex2) {
          list.splice(newIndex2, 0, list.splice(oldIndex2, 1)[0]);
        } else {
          list.splice(newIndex2 - 1, 0, list.splice(oldIndex2, 1)[0]);
        }
        UIStore.panelsOrder = list;
      }
      function onMouseUp() {
        document.body.style.userSelect = null;
        UIStore.setIframePointerEvents(false);
        availableStickElements = [];
        rafMovePanel.cancel();
        props.panel.isDragging = false;
        dragginMoved.value = {
          x: null,
          y: null
        };
        window.removeEventListener("mousemove", rafMovePanel);
        window.removeEventListener("mouseup", onMouseUp);
        panelOffset.value = root2.value.getBoundingClientRect();
        props.panel.offsets = {
          posX: panelOffset.value.left,
          posY: panelOffset.value.top
        };
        initialPosition.value = {
          posX: panelOffset.value.left,
          posY: panelOffset.value.top
        };
        if (null !== oldIndex && null !== newIndex) {
          UIStore.updatePanel(props.panel.id, "isDetached", false);
          updatePosition(oldIndex, newIndex);
        }
        UIStore.saveUI();
        UIStore.setPanelPlaceholder({
          visibility: false,
          panel: null
        });
      }
      const rafResizeHorizontal = rafSchd$1(resizeHorizontal);
      let initialHMouseX = null;
      let initialWidth = null;
      function activateHorizontalResize(event2) {
        UIStore.setIframePointerEvents(true);
        document.body.style.userSelect = "none";
        document.body.style.cursor = "w-resize";
        initialHMouseX = event2.clientX;
        initialWidth = props.panel.width;
        window.addEventListener("mousemove", rafResizeHorizontal);
        window.addEventListener("mouseup", deactivateHorizontal);
      }
      function resizeHorizontal(event2) {
        const draggedHorizontal = event2.clientX - initialHMouseX;
        const width = UIStore.getPanelPlacement(props.panel.id) === "left" || props.panel.isDetached ? draggedHorizontal + initialWidth : -draggedHorizontal + initialWidth;
        UIStore.updatePanel(props.panel.id, "width", width < 360 ? 360 : width);
      }
      function deactivateHorizontal() {
        UIStore.setIframePointerEvents(false);
        document.body.style.userSelect = null;
        document.body.style.cursor = null;
        window.removeEventListener("mousemove", rafResizeHorizontal);
        window.removeEventListener("mouseup", deactivateHorizontal);
        UIStore.saveUI();
      }
      const rafResizeVertical = rafSchd$1(resizeVertical);
      let initialVMouseY = null;
      let initialHeight = null;
      function activateVerticalResize(event2) {
        UIStore.setIframePointerEvents(true);
        document.body.style.userSelect = "none";
        document.body.style.cursor = "n-resize";
        initialHeight = root2.value.clientHeight;
        initialVMouseY = event2.clientY;
        window.addEventListener("mousemove", rafResizeVertical);
        window.addEventListener("mouseup", deactivateVertical);
      }
      function resizeVertical(event2) {
        UIStore.updatePanel(props.panel.id, "isDetached", true);
        const draggedVertical = event2.clientY - initialVMouseY;
        const newHeightValue = initialHeight + draggedVertical;
        if (event2.clientY < window.innerHeight) {
          UIStore.updatePanel(
            props.panel.id,
            "height",
            newHeightValue > root2.value.parentNode.clientHeight ? root2.value.parentNode.clientHeight : newHeightValue
          );
        }
      }
      function deactivateVertical() {
        UIStore.setIframePointerEvents(false);
        document.body.style.userSelect = null;
        document.body.style.cursor = null;
        window.removeEventListener("mousemove", rafResizeVertical);
        window.removeEventListener("mouseup", deactivateVertical);
        UIStore.saveUI();
      }
      function onKeyDown(event2) {
        if (event2.which === 27) {
          closePanel();
          event2.stopImmediatePropagation();
        }
      }
      Vue.onMounted(() => {
        if (props.closeOnEscape) {
          addEventListener("keydown", onKeyDown);
        }
        panelOffset.value = root2.value.getBoundingClientRect();
        props.panel.offsets = {
          posX: panelOffset.value.left,
          posY: panelOffset.value.top
        };
        initialPosition.value = {
          posX: panelOffset.value.left,
          posY: panelOffset.value.top
        };
      });
      function closePanel() {
        UIStore.closePanel(props.panel.id);
        emit("close-panel");
      }
      Vue.onBeforeUnmount(() => {
        window.removeEventListener("mousemove", rafResizeHorizontal);
        window.removeEventListener("mouseup", deactivateHorizontal);
        window.removeEventListener("mousemove", rafResizeVertical);
        window.removeEventListener("mouseup", deactivateVertical);
        removeEventListener("keydown", onKeyDown);
        document.body.style.cursor = null;
        document.body.style.userSelect = null;
      });
      expose({
        panel: props.panel
      });
      return (_ctx, _cache) => {
        const _component_Icon = Vue.resolveComponent("Icon");
        return Vue.openBlock(), Vue.createElementBlock("div", {
          id: __props.panelId,
          ref_key: "root",
          ref: root2,
          class: Vue.normalizeClass([Vue.unref(getCssClass), "znpb-editor-panel"]),
          style: Vue.normalizeStyle(Vue.unref(panelStyles))
        }, [
          Vue.renderSlot(_ctx.$slots, "before-header"),
          __props.showHeader ? (Vue.openBlock(), Vue.createElementBlock("div", {
            key: 0,
            ref: "panelHeader",
            class: "znpb-panel__header",
            onMousedown: onMouseDown
          }, [
            !Vue.unref(hasHeaderSlot) ? (Vue.openBlock(), Vue.createElementBlock("h4", _hoisted_2$o, Vue.toDisplayString(__props.panelName), 1)) : Vue.createCommentVNode("", true),
            Vue.renderSlot(_ctx.$slots, "header"),
            __props.showClose ? (Vue.openBlock(), Vue.createBlock(_component_Icon, {
              key: 1,
              icon: "close",
              size: 14,
              class: "znpb-panel__header-icon-close",
              onClick: Vue.withModifiers(closePanel, ["stop"])
            }, null, 8, ["onClick"])) : Vue.createCommentVNode("", true),
            Vue.renderSlot(_ctx.$slots, "header-suffix")
          ], 544)) : Vue.createCommentVNode("", true),
          Vue.renderSlot(_ctx.$slots, "after-header"),
          Vue.createElementVNode("div", _hoisted_3$j, [
            Vue.renderSlot(_ctx.$slots, "default")
          ]),
          !Vue.unref(UIStore).isAnyPanelDragging && __props.allowHorizontalResize ? (Vue.openBlock(), Vue.createElementBlock("div", {
            key: 1,
            class: "znpb-editor-panel__resize znpb-editor-panel__resize--horizontal",
            onMousedown: activateHorizontalResize
          }, null, 32)) : Vue.createCommentVNode("", true),
          __props.panel.isDetached && !Vue.unref(UIStore).isAnyPanelDragging && __props.allowVerticalResize ? (Vue.openBlock(), Vue.createElementBlock("div", {
            key: 2,
            class: "znpb-editor-panel__resize znpb-editor-panel__resize--vertical",
            onMousedown: activateVerticalResize
          }, null, 32)) : Vue.createCommentVNode("", true)
        ], 14, _hoisted_1$u);
      };
    }
  });
  var PanelTree_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$t = { class: "znpb-tree-view__header-icon" };
  const _hoisted_2$n = {
    key: 0,
    class: "znpb-tree-view__type_wrapper"
  };
  const _sfc_main$y = /* @__PURE__ */ Vue.defineComponent({
    __name: "PanelTree",
    props: {
      panel: null
    },
    setup(__props) {
      const props = __props;
      const UIStore = useUIStore();
      const contentStore = useContentStore();
      const element = Vue.computed(() => contentStore.getElement(window.ZnPbInitialData.page_id));
      const treeViewTypes = [
        {
          name: translate("tree_view"),
          id: "TreeView",
          component: _sfc_main$D,
          icon: "treeview"
        },
        {
          name: translate("section_view"),
          id: "SectionView",
          component: _sfc_main$G,
          icon: "structure"
        },
        {
          name: translate("wireframe_view"),
          id: "WireframeView",
          component: WireframeView,
          icon: "layout",
          basePanelCssClass: " znpb-editor-panel__container--wireframe",
          expandMainPanel: true,
          showBasePanelHeader: false
        }
      ];
      const activeTreeViewId = Vue.ref(treeViewTypes[0].id);
      const activeTreeViewPanel = Vue.computed(
        () => treeViewTypes.find((treeType) => treeType.id === activeTreeViewId.value) || treeViewTypes[0]
      );
      const basePanel = Vue.ref(null);
      const panelDetachedState = Vue.ref(null);
      Vue.watch(activeTreeViewId, (newValue) => {
        if (newValue === "WireframeView") {
          if (basePanel.value) {
            panelDetachedState.value = basePanel.value.panel.isDetached;
            UIStore.updatePanel(props.panel.id, "isDetached", false);
          }
        } else {
          if (panelDetachedState.value) {
            UIStore.updatePanel(props.panel.id, "isDetached", panelDetachedState.value);
            panelDetachedState.value = null;
          }
        }
      });
      const closeWireframe = () => {
        UIStore.closePanel(props.panel.id);
      };
      return (_ctx, _cache) => {
        const _component_Loader = Vue.resolveComponent("Loader");
        const _component_Icon = Vue.resolveComponent("Icon");
        const _component_Tab = Vue.resolveComponent("Tab");
        const _component_Tabs = Vue.resolveComponent("Tabs");
        const _directive_znpb_tooltip = Vue.resolveDirective("znpb-tooltip");
        return Vue.openBlock(), Vue.createBlock(_sfc_main$z, {
          ref_key: "basePanel",
          ref: basePanel,
          "panel-name": Vue.unref(translate)("tree_view_panel"),
          "panel-id": "panel-tree",
          "css-class": Vue.unref(activeTreeViewPanel).basePanelCssClass,
          expanded: Vue.unref(activeTreeViewPanel).expandMainPanel,
          "show-header": Vue.unref(activeTreeViewPanel).showBasePanelHeader,
          "show-expand": false,
          panel: __props.panel
        }, {
          default: Vue.withCtx(() => [
            Vue.unref(UIStore).isPreviewLoading ? (Vue.openBlock(), Vue.createBlock(_component_Loader, { key: 0 })) : (Vue.openBlock(), Vue.createBlock(_component_Tabs, {
              key: 1,
              activeTab: activeTreeViewId.value,
              "onUpdate:activeTab": _cache[0] || (_cache[0] = ($event) => activeTreeViewId.value = $event),
              "tab-style": "panel",
              class: "znpb-tree-view__tabs"
            }, {
              default: Vue.withCtx(() => [
                (Vue.openBlock(), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList(treeViewTypes, (treeType) => {
                  return Vue.createVNode(_component_Tab, {
                    id: treeType.id,
                    key: treeType.id
                  }, {
                    title: Vue.withCtx(() => [
                      Vue.withDirectives((Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$t, [
                        Vue.createVNode(_component_Icon, {
                          class: "znpb-tree-view__header-menu-item-icon",
                          icon: treeType.icon,
                          size: 16
                        }, null, 8, ["icon"])
                      ])), [
                        [_directive_znpb_tooltip, treeType.name]
                      ])
                    ]),
                    default: Vue.withCtx(() => [
                      activeTreeViewId.value === treeType.id ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_2$n, [
                        (Vue.openBlock(), Vue.createBlock(Vue.resolveDynamicComponent(treeType.component), { element: Vue.unref(element) }, null, 8, ["element"]))
                      ])) : Vue.createCommentVNode("", true)
                    ]),
                    _: 2
                  }, 1032, ["id"]);
                }), 64))
              ]),
              _: 1
            }, 8, ["activeTab"])),
            activeTreeViewId.value === "WireframeView" ? (Vue.openBlock(), Vue.createBlock(_component_Icon, {
              key: 2,
              class: "znpb-tree-view__header-menu-close-icon",
              icon: "close",
              onClick: closeWireframe
            })) : Vue.createCommentVNode("", true)
          ]),
          _: 1
        }, 8, ["panel-name", "css-class", "expanded", "show-header", "panel"]);
      };
    }
  });
  var PanelGlobalSettings_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$x = {
    name: "PanelGlobalSettings",
    components: {
      BasePanel: _sfc_main$z
    },
    setup() {
      const UIStore = useUIStore();
      const pageSettings = usePageSettingsStore();
      const { getSchema } = useOptionsSchemas();
      const savedValues = Vue.computed({
        get() {
          return pageSettings.settings;
        },
        set(newValues) {
          pageSettings.updatePageSettings(newValues);
        }
      });
      const cssClassesSchema = {
        global_css: {
          type: "accordion_menu",
          title: translate("global_css_classes"),
          child_options: {
            global_css_classes: {
              type: "global_css_classes"
            }
          }
        }
      };
      const optionsSchema = Object.assign({}, getSchema("pageSettingsSchema"), cssClassesSchema);
      return {
        savedValues,
        UIStore,
        optionsSchema
      };
    }
  };
  const _hoisted_1$s = { class: "znpb-accordions-wrapper znpb-fancy-scrollbar" };
  function _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_OptionsForm = Vue.resolveComponent("OptionsForm");
    const _component_BasePanel = Vue.resolveComponent("BasePanel");
    return Vue.openBlock(), Vue.createBlock(_component_BasePanel, {
      "panel-name": _ctx.$translate("global_settings_panel"),
      "panel-id": "panel-global-settings",
      class: "znpb-general-options-panel-wrapper"
    }, {
      default: Vue.withCtx(() => [
        Vue.createElementVNode("div", _hoisted_1$s, [
          Vue.createVNode(_component_OptionsForm, {
            modelValue: $setup.savedValues,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.savedValues = $event),
            schema: $setup.optionsSchema,
            "show-changes": false
          }, null, 8, ["modelValue", "schema"])
        ])
      ]),
      _: 1
    }, 8, ["panel-name"]);
  }
  var PanelGlobalSettings = /* @__PURE__ */ _export_sfc(_sfc_main$x, [["render", _sfc_render$e]]);
  var PanelHistory_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$r = { class: "znpb-panel__history_panel_wrapper" };
  const _hoisted_2$m = {
    key: 0,
    class: "znpb-panel__history_panel_wrapper--noItemsContainer"
  };
  const _hoisted_3$i = /* @__PURE__ */ Vue.createElementVNode("svg", {
    viewBox: "0 0 72 72",
    fill: "black",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    /* @__PURE__ */ Vue.createElementVNode("path", { d: "M43.7 40.9L36.35 48.25L32.15 44.05L37.7 38.5V25.9H43.7V40.9ZM38 13C31.1 13 24.8 16 20.3 20.8L16.4 16.9L14 31.9L29.15 29.5L24.65 25C27.95 21.25 32.75 19 38 19C47.9 19 56 27.1 56 37C56 46.9 47.9 55 38 55C32.75 55 27.95 52.75 24.65 49L20.15 53.05C24.65 57.85 30.95 61 38 61C51.2 61 62 50.2 62 37C62 23.8 51.2 13 38 13Z" }),
    /* @__PURE__ */ Vue.createElementVNode("path", {
      d: "M72 15C72 16.6569 70.6569 18 69 18C67.3431 18 66 16.6569 66 15C66 13.3431 67.3431 12 69 12C70.6569 12 72 13.3431 72 15Z",
      opacity: "0.6"
    }),
    /* @__PURE__ */ Vue.createElementVNode("path", {
      d: "M4 51.5C4 52.3284 3.32843 53 2.5 53C1.67157 53 1 52.3284 1 51.5C1 50.6716 1.67157 50 2.5 50C3.32843 50 4 50.6716 4 51.5Z",
      opacity: "0.6"
    }),
    /* @__PURE__ */ Vue.createElementVNode("path", {
      d: "M4.99683 16.1946C4.27812 16.002 3.53938 16.4285 3.3468 17.1472L3.17241 17.798L2.52177 17.6237C1.80306 17.4311 1.06432 17.8576 0.871741 18.5763C0.679164 19.2951 1.10568 20.0338 1.82439 20.2264L2.47503 20.4007L2.30072 21.0512C2.10815 21.7699 2.53466 22.5087 3.25337 22.7012C3.97208 22.8938 4.71082 22.4673 4.9034 21.7486L5.0777 21.0981L5.7284 21.2725C6.44711 21.465 7.18586 21.0385 7.37843 20.3198C7.57101 19.6011 7.1445 18.8624 6.42579 18.6698L5.77509 18.4954L5.94948 17.8446C6.14206 17.1259 5.71554 16.3871 4.99683 16.1946Z",
      opacity: "0.6"
    }),
    /* @__PURE__ */ Vue.createElementVNode("path", {
      d: "M65.7664 52.8525C66.1566 52.9231 66.5302 52.6641 66.6008 52.2738L66.6648 51.9206L67.018 51.9845C67.4083 52.0552 67.7819 51.7961 67.8525 51.4058C67.9231 51.0156 67.664 50.642 67.2738 50.5714L66.9205 50.5075L66.9844 50.1541C67.055 49.7639 66.7959 49.3903 66.4057 49.3197C66.0155 49.2491 65.6419 49.5082 65.5713 49.8984L65.5073 50.2518L65.1541 50.1878C64.7638 50.1172 64.3903 50.3763 64.3196 50.7665C64.249 51.1568 64.5081 51.5303 64.8983 51.601L65.2516 51.6649L65.1877 52.0181C65.1171 52.4083 65.3762 52.7819 65.7664 52.8525Z",
      opacity: "0.6"
    })
  ], -1);
  const _hoisted_4$f = { class: "znpb-panel__history_panel-emptyTitle" };
  const _hoisted_5$d = { class: "znpb-panel__history_panel-emptyDesc" };
  const _hoisted_6$b = {
    key: 1,
    class: "znpb-history-actions"
  };
  const _hoisted_7$a = ["title", "onClick"];
  const _hoisted_8$8 = { class: "znpb-action-element" };
  const _hoisted_9$7 = { class: "znpb-action-subtitle" };
  const _hoisted_10$6 = { class: "znpb-action-name" };
  const _hoisted_11$5 = {
    key: 0,
    class: "znpb-action-active"
  };
  const _hoisted_12$4 = { class: "znpb-history__action-wrapper" };
  const _sfc_main$w = /* @__PURE__ */ Vue.defineComponent({
    __name: "PanelHistory",
    props: {
      panel: null
    },
    setup(__props) {
      const historyPanelWrapper = Vue.ref(null);
      const historyStore = useHistoryStore();
      Vue.watch(historyStore.state, (newValue) => {
        Vue.nextTick(() => {
          historyPanelWrapper.value.scrollTop = 0;
        });
      });
      function doUndo() {
        if (historyStore.canUndo) {
          historyStore.undo();
        }
      }
      function doRedo() {
        if (historyStore.canRedo) {
          historyStore.redo();
        }
      }
      return (_ctx, _cache) => {
        const _component_Icon = Vue.resolveComponent("Icon");
        return Vue.openBlock(), Vue.createBlock(_sfc_main$z, {
          "panel-name": Vue.unref(translate)("history_panel"),
          "panel-id": "panel-history",
          "show-expand": false,
          panel: __props.panel
        }, {
          default: Vue.withCtx(() => [
            Vue.createElementVNode("div", _hoisted_1$r, [
              Vue.createElementVNode("div", {
                ref_key: "historyPanelWrapper",
                ref: historyPanelWrapper,
                class: "znpb-history-wrapper znpb-fancy-scrollbar"
              }, [
                Vue.unref(historyStore).state.length === 0 ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_2$m, [
                  _hoisted_3$i,
                  Vue.createElementVNode("div", _hoisted_4$f, Vue.toDisplayString(Vue.unref(translate)("history_panel_empty_title")), 1),
                  Vue.createElementVNode("div", _hoisted_5$d, Vue.toDisplayString(Vue.unref(translate)("history_panel_empty_desc")), 1)
                ])) : (Vue.openBlock(), Vue.createElementBlock("ul", _hoisted_6$b, [
                  (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList(Vue.unref(historyStore).state, (item, index2) => {
                    return Vue.openBlock(), Vue.createElementBlock("li", {
                      key: index2,
                      title: item.title,
                      class: Vue.normalizeClass({ "znpb-history-action--active": Vue.unref(historyStore).activeHistoryIndex === index2 }),
                      onClick: ($event) => Vue.unref(historyStore).restoreHistoryToIndex(index2)
                    }, [
                      Vue.createElementVNode("span", _hoisted_8$8, Vue.toDisplayString(item.title), 1),
                      Vue.createElementVNode("span", _hoisted_9$7, Vue.toDisplayString(item.subtitle), 1),
                      Vue.createElementVNode("span", _hoisted_10$6, Vue.toDisplayString(item.action), 1),
                      Vue.unref(historyStore).activeHistoryIndex === index2 ? (Vue.openBlock(), Vue.createElementBlock("span", _hoisted_11$5, Vue.toDisplayString(Vue.unref(translate)("history_now")), 1)) : (Vue.openBlock(), Vue.createBlock(_component_Icon, {
                        key: 1,
                        icon: "history"
                      }))
                    ], 10, _hoisted_7$a);
                  }), 128))
                ]))
              ], 512),
              Vue.createElementVNode("div", _hoisted_12$4, [
                Vue.createElementVNode("div", {
                  class: Vue.normalizeClass(["znpb-history__action", { "znpb-history__action--inactive": !Vue.unref(historyStore).canUndo }]),
                  onClick: doUndo
                }, [
                  Vue.createVNode(_component_Icon, { icon: "undo" })
                ], 2),
                Vue.createElementVNode("div", {
                  class: Vue.normalizeClass(["znpb-history__action", { "znpb-history__action--inactive": !Vue.unref(historyStore).canRedo }]),
                  onClick: doRedo
                }, [
                  Vue.createVNode(_component_Icon, { icon: "redo" })
                ], 2)
              ])
            ])
          ]),
          _: 1
        }, 8, ["panel-name", "panel"]);
      };
    }
  });
  var keyShortcutsItem_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$v = {
    name: "keyShortcutsItem",
    props: {
      keyshortcut: {
        type: Array,
        required: true
      },
      description: {
        type: String,
        requires: true
      }
    }
  };
  const _hoisted_1$q = { class: "znpb-key-shortcuts-wrapper" };
  const _hoisted_2$l = { class: "znpb-key-shortcuts" };
  const _hoisted_3$h = { class: "znpb-key-shortcuts__keys-wrapper" };
  const _hoisted_4$e = { class: "znpb-key-shortcuts__key-item" };
  const _hoisted_5$c = /* @__PURE__ */ Vue.createElementVNode("span", { class: "znpb-key-shortcuts__plus" }, "+", -1);
  const _hoisted_6$a = /* @__PURE__ */ Vue.createElementVNode("span", { class: "znpb-key-shortcuts__separator" }, null, -1);
  const _hoisted_7$9 = { class: "znpb-key-shortcuts__description" };
  function _sfc_render$d(_ctx, _cache, $props, $setup, $data, $options) {
    return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$q, [
      Vue.renderSlot(_ctx.$slots, "default"),
      Vue.createElementVNode("div", _hoisted_2$l, [
        Vue.createElementVNode("div", _hoisted_3$h, [
          (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList($props.keyshortcut, (key, index2) => {
            return Vue.openBlock(), Vue.createElementBlock("div", {
              key: index2,
              class: "znpb-key-shortcuts__key"
            }, [
              Vue.createElementVNode("div", _hoisted_4$e, Vue.toDisplayString(key), 1),
              _hoisted_5$c
            ]);
          }), 128))
        ]),
        _hoisted_6$a,
        Vue.createElementVNode("div", _hoisted_7$9, Vue.toDisplayString($props.description), 1)
      ])
    ]);
  }
  var keyShortcutsItem = /* @__PURE__ */ _export_sfc(_sfc_main$v, [["render", _sfc_render$d]]);
  var keyShortcuts_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$u = {
    name: "KeyShortcutsModal",
    components: {
      keyShortcutsItem
    },
    data() {
      const controlKey = Environment.isMac ? "\u2318" : "\u2303";
      return {
        schemaDescriptionFirst: [
          {
            keyshortcut: [controlKey, "S"],
            description: this.$translate("save_changes")
          },
          {
            keyshortcut: [controlKey, "C"],
            description: this.$translate("copy_element")
          },
          {
            keyshortcut: [controlKey, "V"],
            description: this.$translate("paste_element")
          },
          {
            keyshortcut: [controlKey, "X"],
            description: this.$translate("cut_element")
          },
          {
            keyshortcut: [controlKey, "D"],
            description: this.$translate("duplicate_element")
          },
          {
            keyshortcut: [controlKey, "\u21E7", "C"],
            description: this.$translate("copy_element_styles")
          },
          {
            keyshortcut: [controlKey, "\u21E7", "V"],
            description: this.$translate("paste_element_styles")
          },
          {
            keyshortcut: [controlKey, "Z"],
            description: this.$translate("undo")
          },
          {
            keyshortcut: [controlKey, "Y"],
            description: this.$translate("redo")
          },
          {
            keyshortcut: [controlKey, "\u21E7", "Y"],
            description: this.$translate("redo")
          },
          {
            keyshortcut: [controlKey, "H"],
            description: this.$translate("hide_element")
          },
          {
            keyshortcut: [controlKey, "P"],
            description: this.$translate("toggle_preview")
          },
          {
            keyshortcut: ["\u21E7", "T"],
            description: this.$translate("toggle_tree_view_panel")
          },
          {
            keyshortcut: ["\u21E7", "L"],
            description: this.$translate("toggle_library")
          },
          {
            keyshortcut: ["\u21E7", "O"],
            description: this.$translate("toggle_page_options")
          },
          {
            keyshortcut: ["DRAG", controlKey],
            description: this.$translate("duplicate_element_in_place"),
            details: this.$translate("when_dragging_element")
          },
          {
            keyshortcut: [controlKey, "DRAG"],
            description: this.$translate("set_even_values"),
            details: this.$translate("when_dragging_toolbox")
          },
          {
            keyshortcut: [controlKey, "\u21E7", "DRAG"],
            description: this.$translate("set_even_incremental_value")
          },
          {
            keyshortcut: [controlKey, "\u21E7", "D"],
            description: this.$translate("back_to_wp_dashboard")
          },
          {
            keyshortcut: ["\u21E7", "DRAG"],
            description: this.$translate("set_incremental_value"),
            details: this.$translate("when_dragging_input_number")
          },
          {
            keyshortcut: ["\u21E7", "ARROWS"],
            description: this.$translate("set_incremental_value")
          },
          {
            keyshortcut: ["ALT"],
            description: "Toggle Link",
            details: this.$translate("on_input_number_link")
          }
        ]
      };
    }
  };
  const _hoisted_1$p = { class: "znpb-key-shortcuts-modal znpb-fancy-scrollbar" };
  const _hoisted_2$k = { class: "znpb-key-shortcuts-modal__content" };
  const _hoisted_3$g = {
    key: 0,
    class: "znpb-key-shortcuts-modal__item-details"
  };
  function _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_keyShortcutsItem = Vue.resolveComponent("keyShortcutsItem");
    return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$p, [
      Vue.createElementVNode("div", _hoisted_2$k, [
        (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList($data.schemaDescriptionFirst, (schema, i) => {
          return Vue.openBlock(), Vue.createBlock(_component_keyShortcutsItem, {
            key: i + schema.description,
            keyshortcut: schema.keyshortcut,
            description: schema.description
          }, {
            default: Vue.withCtx(() => [
              schema.details ? (Vue.openBlock(), Vue.createElementBlock("pre", _hoisted_3$g, Vue.toDisplayString(schema.details), 1)) : Vue.createCommentVNode("", true)
            ]),
            _: 2
          }, 1032, ["keyshortcut", "description"]);
        }), 128))
      ])
    ]);
  }
  var keyShortcuts = /* @__PURE__ */ _export_sfc(_sfc_main$u, [["render", _sfc_render$c]]);
  var pluginCard_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$t = {
    name: "PluginCard",
    props: {
      isPro: {
        type: Boolean,
        required: false
      },
      isProActive: {
        type: Boolean,
        required: false
      },
      version: {
        type: String,
        required: false
      },
      updateVersion: {
        type: String,
        required: false
      }
    },
    setup(props) {
      const { editorData: editorData2 } = useEditorData();
      return {
        urls: editorData2.value.urls
      };
    },
    methods: {
      openWindow(link) {
        window.open(link);
      }
    }
  };
  const _hoisted_1$o = {
    key: 0,
    class: "znpb-pro-item"
  };
  const _hoisted_2$j = { class: "znpb-about-modal__plugin-title" };
  const _hoisted_3$f = { key: 0 };
  const _hoisted_4$d = { key: 1 };
  const _hoisted_5$b = { class: "znpb-about-modal-text-wrapper" };
  const _hoisted_6$9 = ["href"];
  const _hoisted_7$8 = { key: 0 };
  const _hoisted_8$7 = ["href"];
  const _hoisted_9$6 = ["href"];
  const _hoisted_10$5 = {
    key: 1,
    class: "znpb-about-modal-text-wrapper__up-to-date"
  };
  const _hoisted_11$4 = ["href"];
  const _hoisted_12$3 = {
    key: 0,
    class: "znpb-about-modal-text-wrapper__up-to-date"
  };
  const _hoisted_13$3 = ["href"];
  function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Icon = Vue.resolveComponent("Icon");
    return Vue.openBlock(), Vue.createElementBlock("div", {
      class: Vue.normalizeClass(["znpb-about-modal__version-card", { "znpb-about-modal__version-card--active": !$props.isPro || $props.isProActive }])
    }, [
      Vue.createVNode(_component_Icon, { icon: "zion-icon-logo" }),
      $props.isPro ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$o, Vue.toDisplayString(_ctx.$translate("pro")), 1)) : Vue.createCommentVNode("", true),
      Vue.createElementVNode("span", _hoisted_2$j, [
        Vue.createTextVNode(Vue.toDisplayString(_ctx.$translate("zion_builder")) + " ", 1),
        $props.isPro ? (Vue.openBlock(), Vue.createElementBlock("span", _hoisted_3$f, Vue.toDisplayString(_ctx.$translate("pro")), 1)) : (Vue.openBlock(), Vue.createElementBlock("span", _hoisted_4$d, Vue.toDisplayString(_ctx.$translate("free")), 1))
      ]),
      Vue.createElementVNode("div", _hoisted_5$b, [
        !$props.isPro ? (Vue.openBlock(), Vue.createElementBlock(Vue.Fragment, { key: 0 }, [
          $props.version !== null && $props.updateVersion !== null ? (Vue.openBlock(), Vue.createElementBlock(Vue.Fragment, { key: 0 }, [
            Vue.createElementVNode("span", null, Vue.toDisplayString($props.version), 1),
            Vue.createElementVNode("a", {
              href: $setup.urls.free_changelog,
              target: "_blank",
              title: "changelog",
              class: "znpb-about-modal__help",
              onClick: _cache[0] || (_cache[0] = ($event) => $options.openWindow($setup.urls.free_changelog))
            }, Vue.toDisplayString(_ctx.$translate("view_changelog")), 9, _hoisted_6$9)
          ], 64)) : Vue.createCommentVNode("", true)
        ], 64)) : (Vue.openBlock(), Vue.createElementBlock(Vue.Fragment, { key: 1 }, [
          !$props.isProActive && $props.isPro ? (Vue.openBlock(), Vue.createElementBlock("span", _hoisted_7$8, Vue.toDisplayString(_ctx.$translate("not_installed")), 1)) : Vue.createCommentVNode("", true),
          $props.version !== null && $props.updateVersion !== null ? (Vue.openBlock(), Vue.createElementBlock(Vue.Fragment, { key: 1 }, [
            Vue.createElementVNode("span", null, Vue.toDisplayString($props.version), 1),
            Vue.createElementVNode("a", {
              href: $setup.urls.pro_changelog,
              target: "_blank",
              title: "changelog",
              class: "znpb-about-modal__help",
              onClick: _cache[1] || (_cache[1] = ($event) => $options.openWindow($setup.urls.pro_changelog))
            }, Vue.toDisplayString(_ctx.$translate("view_changelog")), 9, _hoisted_8$7)
          ], 64)) : Vue.createCommentVNode("", true)
        ], 64))
      ]),
      !$props.isPro ? (Vue.openBlock(), Vue.createElementBlock(Vue.Fragment, { key: 1 }, [
        $props.updateVersion !== void 0 && $props.updateVersion !== $props.version && $props.version !== null ? (Vue.openBlock(), Vue.createElementBlock("a", {
          key: 0,
          href: $setup.urls.updates_page,
          target: "_blank",
          class: "znpb-button znpb-about-modal__version-card-button",
          onClick: _cache[2] || (_cache[2] = ($event) => $options.openWindow($setup.urls.updates_page))
        }, Vue.toDisplayString(_ctx.$translate("update_to_version")) + " " + Vue.toDisplayString($props.updateVersion), 9, _hoisted_9$6)) : (Vue.openBlock(), Vue.createElementBlock("span", _hoisted_10$5, Vue.toDisplayString(_ctx.$translate("you_are_upto_date")), 1))
      ], 64)) : (Vue.openBlock(), Vue.createElementBlock(Vue.Fragment, { key: 2 }, [
        !$props.isProActive ? (Vue.openBlock(), Vue.createElementBlock("a", {
          key: 0,
          href: $setup.urls.purchase_url,
          target: "_blank",
          title: "purchase",
          class: "znpb-button znpb-button--secondary",
          onClick: _cache[3] || (_cache[3] = ($event) => $options.openWindow($setup.urls.purchase_url))
        }, Vue.toDisplayString(_ctx.$translate("buy_pro")), 9, _hoisted_11$4)) : (Vue.openBlock(), Vue.createElementBlock(Vue.Fragment, { key: 1 }, [
          $props.updateVersion === void 0 || $props.version === null || $props.updateVersion === $props.version ? (Vue.openBlock(), Vue.createElementBlock("span", _hoisted_12$3, Vue.toDisplayString(_ctx.$translate("you_are_upto_date")), 1)) : (Vue.openBlock(), Vue.createElementBlock("a", {
            key: 1,
            href: $setup.urls.updates_page,
            title: "updates",
            target: "_blank",
            class: "znpb-button znpb-about-modal__version-card-button",
            onClick: _cache[4] || (_cache[4] = ($event) => $options.openWindow($setup.urls.updates_page))
          }, Vue.toDisplayString(_ctx.$translate("update_to_version")) + " " + Vue.toDisplayString($props.updateVersion), 9, _hoisted_13$3))
        ], 64))
      ], 64))
    ], 2);
  }
  var pluginCard = /* @__PURE__ */ _export_sfc(_sfc_main$t, [["render", _sfc_render$b]]);
  var aboutModal_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$s = {
    name: "AboutModal",
    components: {
      pluginCard
    },
    setup() {
      const { editorData: editorData2 } = useEditorData();
      return {
        urls: editorData2.value.urls
      };
    },
    computed: {
      pluginInfo() {
        return window.ZnPbInitialData.plugin_info;
      },
      pluginProUpdate() {
        return this.pluginInfo.pro_plugin_update || {};
      },
      IsPro() {
        return this.pluginInfo.is_pro_active;
      },
      pluginFreeUpdate() {
        return this.pluginInfo.free_plugin_update || {};
      }
    },
    methods: {
      openWindow(link) {
        window.open(link);
      }
    }
  };
  const _hoisted_1$n = { class: "znpb-about-modal znpb-fancy-scrollbar" };
  const _hoisted_2$i = { class: "znpb-about-modal__content" };
  const _hoisted_3$e = ["innerHTML"];
  const _hoisted_4$c = { class: "znpb-about-modal__card-wrapper" };
  const _hoisted_5$a = ["href"];
  function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_pluginCard = Vue.resolveComponent("pluginCard");
    return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$n, [
      Vue.createElementVNode("div", _hoisted_2$i, [
        Vue.createElementVNode("p", {
          class: "znpb-about-modal__description",
          innerHTML: _ctx.$translate("about_zion_description")
        }, null, 8, _hoisted_3$e),
        Vue.createElementVNode("div", _hoisted_4$c, [
          Vue.createVNode(_component_pluginCard, {
            "is-pro": false,
            version: $options.pluginInfo.free_version,
            "update-version": $options.pluginFreeUpdate.new_version
          }, null, 8, ["version", "update-version"]),
          Vue.createVNode(_component_pluginCard, {
            "is-pro": true,
            "is-pro-active": $options.IsPro,
            version: $options.pluginInfo.pro_version,
            "update-version": $options.pluginProUpdate.new_version
          }, null, 8, ["is-pro-active", "version", "update-version"])
        ]),
        Vue.createElementVNode("a", {
          href: $setup.urls.documentation_url,
          class: "znpb-about-modal__help",
          target: "_blank",
          title: "documentation",
          onClick: _cache[0] || (_cache[0] = ($event) => $options.openWindow($setup.urls.documentation_url))
        }, Vue.toDisplayString(_ctx.$translate("need_help")), 9, _hoisted_5$a)
      ])
    ]);
  }
  var aboutModal = /* @__PURE__ */ _export_sfc(_sfc_main$s, [["render", _sfc_render$a]]);
  var DeviceElement_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$m = ["onClick"];
  const _hoisted_2$h = { class: "znpb-device__item-content" };
  const _hoisted_3$d = { class: "znpb-device__item-name" };
  const _hoisted_4$b = { class: "znpb-device__itemValue" };
  const _hoisted_5$9 = {
    key: 0,
    class: "znpb-device__itemValue-inner"
  };
  const _hoisted_6$8 = ["value", "onKeydown"];
  const _hoisted_7$7 = {
    key: 1,
    class: "znpb-device__item-actions"
  };
  const _sfc_main$r = /* @__PURE__ */ Vue.defineComponent({
    __name: "DeviceElement",
    props: {
      deviceConfig: null,
      allowEdit: { type: Boolean },
      editedBreakpoint: { default: () => {
        return null;
      } }
    },
    emits: ["edit-breakpoint"],
    setup(__props, { emit }) {
      const props = __props;
      const {
        activeResponsiveDeviceInfo: activeResponsiveDeviceInfo2,
        setActiveResponsiveDeviceId,
        getActiveResponsiveOptions,
        deleteBreakpoint,
        updateBreakpoint
      } = useResponsiveDevices();
      const isEdited = Vue.computed(() => {
        return props.editedBreakpoint === props.deviceConfig;
      });
      const widthInput = Vue.ref(null);
      const discardChangesTitle = Vue.computed(() => {
        return translate("discard_changes_for") + " " + props.deviceConfig.name;
      });
      const isActiveDevice = Vue.computed(() => {
        return props.deviceConfig.id === activeResponsiveDeviceInfo2.value.id;
      });
      const hasChanges = Vue.computed(() => {
        const activeDeviceConfig = getActiveResponsiveOptions();
        if (!activeDeviceConfig) {
          return false;
        }
        const modelValue = activeDeviceConfig.modelValue;
        return modelValue && modelValue && modelValue[props.deviceConfig.id] || false;
      });
      function changeDevice() {
        if (activeResponsiveDeviceInfo2.value.id !== props.deviceConfig.id) {
          setActiveResponsiveDeviceId(props.deviceConfig.id);
        }
      }
      function removeStylesGroup() {
        const activeDeviceConfig = getActiveResponsiveOptions();
        if (activeDeviceConfig) {
          activeDeviceConfig.removeDeviceStyles(props.deviceConfig.id);
        }
      }
      Vue.watch(isEdited, (newValue) => {
        if (newValue) {
          Vue.nextTick(() => {
            if (widthInput.value) {
              widthInput.value.focus();
              widthInput.value.select();
            }
          });
        }
      });
      function updateWidth() {
        const oldValue = props.deviceConfig.width;
        if (!widthInput.value) {
          return;
        }
        const newValue = parseInt(widthInput.value.value) < 240 ? 240 : parseInt(widthInput.value.value);
        updateBreakpoint(props.deviceConfig, newValue);
        emit("edit-breakpoint", null);
        doAction("zionbuilder/responsive/change_device_width", props.deviceConfig, newValue, oldValue);
      }
      return (_ctx, _cache) => {
        const _component_Icon = Vue.resolveComponent("Icon");
        const _component_ChangesBullet = Vue.resolveComponent("ChangesBullet");
        const _directive_znpb_tooltip = Vue.resolveDirective("znpb-tooltip");
        return Vue.openBlock(), Vue.createElementBlock("a", {
          class: Vue.normalizeClass(["znpb-device__item", { "znpb-device__item--active": Vue.unref(isActiveDevice) }]),
          onClick: Vue.withModifiers(changeDevice, ["stop"]),
          onMousedown: _cache[3] || (_cache[3] = Vue.withModifiers(() => {
          }, ["stop"]))
        }, [
          Vue.createElementVNode("div", _hoisted_2$h, [
            Vue.createVNode(_component_Icon, {
              icon: __props.deviceConfig.icon,
              class: "znpb-device__item-icon"
            }, null, 8, ["icon"]),
            Vue.createElementVNode("span", _hoisted_3$d, [
              __props.deviceConfig.name ? (Vue.openBlock(), Vue.createElementBlock(Vue.Fragment, { key: 0 }, [
                Vue.createTextVNode(Vue.toDisplayString(__props.deviceConfig.name) + " - ", 1)
              ], 64)) : Vue.createCommentVNode("", true),
              __props.deviceConfig.id === "default" ? (Vue.openBlock(), Vue.createElementBlock(Vue.Fragment, { key: 1 }, [
                Vue.createTextVNode(" (" + Vue.toDisplayString(Vue.unref(translate)("all_devices")) + ") ", 1)
              ], 64)) : (Vue.openBlock(), Vue.createElementBlock(Vue.Fragment, { key: 2 }, [
                Vue.createTextVNode(Vue.toDisplayString(Vue.unref(translate)("max")) + " ", 1),
                Vue.createElementVNode("span", _hoisted_4$b, [
                  Vue.unref(isEdited) ? (Vue.openBlock(), Vue.createElementBlock("span", _hoisted_5$9, [
                    Vue.createElementVNode("input", {
                      ref_key: "widthInput",
                      ref: widthInput,
                      type: "number",
                      class: "znpb-device__itemValueInput",
                      value: __props.deviceConfig.width,
                      onKeydown: Vue.withKeys(updateWidth, ["enter"]),
                      onBlur: updateWidth
                    }, null, 40, _hoisted_6$8),
                    Vue.createTextVNode(" px ")
                  ])) : (Vue.openBlock(), Vue.createElementBlock(Vue.Fragment, { key: 1 }, [
                    Vue.createTextVNode(Vue.toDisplayString(__props.deviceConfig.width) + "px ", 1)
                  ], 64))
                ])
              ], 64))
            ]),
            Vue.unref(hasChanges) && !__props.allowEdit ? (Vue.openBlock(), Vue.createBlock(_component_ChangesBullet, {
              key: 0,
              "discard-changes-title": Vue.unref(discardChangesTitle),
              onRemoveStyles: removeStylesGroup
            }, null, 8, ["discard-changes-title"])) : Vue.createCommentVNode("", true),
            __props.allowEdit ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_7$7, [
              Vue.unref(isEdited) ? (Vue.openBlock(), Vue.createElementBlock(Vue.Fragment, { key: 0 }, [
                Vue.withDirectives(Vue.createVNode(_component_Icon, {
                  icon: "check",
                  class: "znpb-device__item-action",
                  onClick: Vue.withModifiers(updateWidth, ["stop"])
                }, null, 8, ["onClick"]), [
                  [_directive_znpb_tooltip, Vue.unref(translate)("save")]
                ]),
                Vue.withDirectives(Vue.createVNode(_component_Icon, {
                  icon: "close",
                  class: "znpb-device__item-action",
                  onClick: _cache[0] || (_cache[0] = Vue.withModifiers(($event) => _ctx.$emit("edit-breakpoint", null), ["stop"]))
                }, null, 512), [
                  [_directive_znpb_tooltip, Vue.unref(translate)("cancel")]
                ])
              ], 64)) : (Vue.openBlock(), Vue.createElementBlock(Vue.Fragment, { key: 1 }, [
                !__props.deviceConfig.isDefault ? Vue.withDirectives((Vue.openBlock(), Vue.createBlock(_component_Icon, {
                  key: 0,
                  icon: "edit",
                  class: "znpb-device__item-action",
                  onClick: _cache[1] || (_cache[1] = Vue.withModifiers(($event) => _ctx.$emit("edit-breakpoint", __props.deviceConfig), ["stop"]))
                }, null, 512)), [
                  [_directive_znpb_tooltip, Vue.unref(translate)("edit_breakpoint")]
                ]) : Vue.createCommentVNode("", true),
                !__props.deviceConfig.builtIn ? Vue.withDirectives((Vue.openBlock(), Vue.createBlock(_component_Icon, {
                  key: 1,
                  icon: "delete",
                  class: "znpb-device__item-action",
                  onClick: _cache[2] || (_cache[2] = Vue.withModifiers(($event) => Vue.unref(deleteBreakpoint)(__props.deviceConfig.id), ["stop"]))
                }, null, 512)), [
                  [_directive_znpb_tooltip, Vue.unref(translate)("delete_breakpoint")]
                ]) : Vue.createCommentVNode("", true)
              ], 64))
            ])) : Vue.createCommentVNode("", true)
          ])
        ], 42, _hoisted_1$m);
      };
    }
  });
  var FlyoutWrapper_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$l = ["onMouseover", "onMouseleave"];
  const _hoisted_2$g = { class: "znpb-editor-header__menu_button" };
  const _sfc_main$q = {
    __name: "FlyoutWrapper",
    props: {
      items: {
        type: Array,
        required: false,
        default() {
          return [];
        }
      },
      preventClose: {
        type: Boolean,
        required: false,
        default: false
      }
    },
    emits: ["show", "hide"],
    setup(__props, { emit }) {
      const props = __props;
      const showflyout = Vue.ref(false);
      const listContainer = Vue.ref(null);
      const negativeMargin = Vue.ref(0);
      const root2 = Vue.ref(null);
      const computedStyles = Vue.computed(() => {
        let styles = {};
        if (negativeMargin.value !== 0) {
          styles.transform = `translateY(${negativeMargin.value}px)`;
        }
        return styles;
      });
      function onMouseOver() {
        showflyout.value = true;
      }
      function onMouseOut() {
        if (!props.preventClose) {
          showflyout.value = false;
        }
      }
      Vue.watch(showflyout, (newValue) => {
        if (newValue) {
          Vue.nextTick(() => {
            positionDropdown();
            resizeObserver.observe(listContainer.value);
          });
          emit("show");
        } else {
          negativeMargin.value = 0;
          resizeObserver.unobserve(listContainer.value);
          emit("hide");
        }
      });
      Vue.watch(
        () => props.preventClose,
        (newValue) => {
          if (newValue) {
            window.addEventListener("click", onOutsideClick);
          }
        }
      );
      Vue.onBeforeUnmount(() => {
        window.removeEventListener("click", onOutsideClick);
      });
      function onOutsideClick(event2) {
        if (!root2.value.contains(event2.target)) {
          showflyout.value = false;
        }
      }
      function positionDropdown() {
        negativeMargin.value = 0;
        Vue.nextTick(() => {
          const { bottom: bottom2 } = listContainer.value.getBoundingClientRect();
          if (bottom2 > window.innerHeight) {
            negativeMargin.value = (bottom2 - window.innerHeight) * -1;
          }
        });
      }
      const resizeObserver = new ResizeObserver((entries) => {
        for (let entry of entries) {
          Vue.nextTick(() => {
            positionDropdown();
          });
        }
      });
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", {
          ref_key: "root",
          ref: root2,
          class: "znpb-editor-header-flyout",
          onMouseover: Vue.withModifiers(onMouseOver, ["stop"]),
          onMouseleave: Vue.withModifiers(onMouseOut, ["stop"])
        }, [
          Vue.createElementVNode("div", _hoisted_2$g, [
            Vue.renderSlot(_ctx.$slots, "panel-icon")
          ]),
          showflyout.value ? (Vue.openBlock(), Vue.createElementBlock("ul", {
            key: 0,
            ref_key: "listContainer",
            ref: listContainer,
            class: "znpb-editor-header-flyout-hidden-items znpb-editor-header__menu-list",
            style: Vue.normalizeStyle(Vue.unref(computedStyles))
          }, [
            Vue.renderSlot(_ctx.$slots, "default")
          ], 4)) : Vue.createCommentVNode("", true)
        ], 40, _hoisted_1$l);
      };
    }
  };
  const _sfc_main$p = {
    name: "flyout-menu-item"
  };
  const _hoisted_1$k = { name: "menu-items" };
  function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
    return Vue.openBlock(), Vue.createElementBlock("li", _hoisted_1$k, [
      Vue.renderSlot(_ctx.$slots, "default")
    ]);
  }
  var FlyoutMenuItem = /* @__PURE__ */ _export_sfc(_sfc_main$p, [["render", _sfc_render$9]]);
  var ResponsiveDevices_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$j = { class: "znpb-responsiveDeviceHeader" };
  const _hoisted_2$f = { class: "znpb-responsiveDeviceHeader__item" };
  const _hoisted_3$c = {
    for: "znpb-responsive__iframeWidth",
    class: "znpb-responsiveDeviceHeader__iconIndicator"
  };
  const _hoisted_4$a = ["value", "onKeydown"];
  const _hoisted_5$8 = { class: "znpb-responsiveDeviceHeader__item" };
  const _hoisted_6$7 = {
    for: "znpb-responsive__iframeScale",
    class: "znpb-responsiveDeviceHeader__iconIndicator"
  };
  const _hoisted_7$6 = ["value", "disabled", "onKeydown"];
  const _hoisted_8$6 = {
    key: 0,
    class: "menu-items znpb-device__addBreakpointForm"
  };
  const _hoisted_9$5 = { class: "znpb-device__item" };
  const _hoisted_10$4 = { class: "znpb-device__item-content" };
  const _hoisted_11$3 = { class: "znpb-device__item-name" };
  const _hoisted_12$2 = { class: "znpb-device__itemValue" };
  const _hoisted_13$2 = { class: "znpb-device__itemValue-inner" };
  const _hoisted_14$1 = ["onKeydown"];
  const _hoisted_15 = { class: "znpb-device__item-actions" };
  const _hoisted_16 = {
    key: 1,
    class: "znpb-device__addBreakpointWrapper"
  };
  const _hoisted_17 = {
    key: 2,
    class: "znpb-responsiveDeviceFooter"
  };
  const _sfc_main$o = {
    __name: "ResponsiveDevices",
    setup(__props) {
      const {
        activeResponsiveDeviceInfo: activeResponsiveDeviceInfo2,
        orderedResponsiveDevices: orderedResponsiveDevices2,
        iframeWidth: iframeWidth2,
        setCustomIframeWidth,
        scaleValue: scaleValue2,
        setCustomScale,
        autoScaleActive: autoScaleActive2,
        setAutoScale,
        deviceSizesConfig: deviceSizesConfig2,
        addCustomBreakpoint
      } = useResponsiveDevices();
      const userStore = useUserStore();
      const preventClose = Vue.ref(false);
      const enabledAddBreakpoint = Vue.ref(false);
      const newBreakpointValue = Vue.ref(500);
      const devicesList = Vue.ref(null);
      const widthInput = Vue.ref(null);
      const addBreakpointDeviceIcon = Vue.computed(() => {
        let deviceIcon2 = "desktop";
        const currentValue = newBreakpointValue.value;
        deviceSizesConfig2.forEach((device) => {
          if (currentValue < device.width) {
            deviceIcon2 = device.icon;
          }
        });
        return deviceIcon2;
      });
      function disableEditBreakpoints() {
        preventClose.value = true;
        setTimeout(() => {
          preventClose.value = false;
        }, 30);
        editBreakpoints.value = !editBreakpoints.value;
      }
      function enableAddNewDevice() {
        enabledAddBreakpoint.value = true;
        Vue.nextTick(() => {
          widthInput.value.focus();
          widthInput.value.select();
        });
      }
      function addNewBreakpoint() {
        const newValue = newBreakpointValue.value < 240 ? 240 : newBreakpointValue.value;
        const addedDevice = addCustomBreakpoint({
          width: newValue,
          icon: addBreakpointDeviceIcon.value
        });
        cancelNewBreakpointAdd();
        const { id } = addedDevice;
        Vue.nextTick(() => {
          const addedDevice2 = document.querySelector(`.znpb-deviceItem--${id}`);
          if (addedDevice2) {
            addedDevice2.scrollIntoView({ block: "nearest", inline: "nearest" });
            addedDevice2.classList.add("znpb-deviceItem--new");
            setTimeout(() => {
              addedDevice2.classList.remove("znpb-deviceItem--new");
            }, 300);
          }
        });
      }
      function cancelNewBreakpointAdd() {
        enabledAddBreakpoint.value = false;
        newBreakpointValue.value = 500;
      }
      const deviceIcon = Vue.computed(() => {
        return activeResponsiveDeviceInfo2.value.icon;
      });
      const editBreakpoints = Vue.ref(false);
      const editedBreakpoint = Vue.ref(null);
      function onWidthKeyDown(event2) {
        setCustomIframeWidth(event2.target.value, true);
        preventClose.value = false;
      }
      function onScaleKeyDown(event2) {
        setCustomScale(event2.target.value);
        preventClose.value = false;
      }
      Vue.watch([editedBreakpoint, enabledAddBreakpoint], ([newValue, newValue2]) => {
        if (newValue || newValue2) {
          preventClose.value = true;
        } else if (!newValue && !newValue2) {
          preventClose.value = false;
        }
      });
      function onFlyoutHide() {
        cancelNewBreakpointAdd();
        editBreakpoints.value = false;
        editedBreakpoint.value = null;
      }
      return (_ctx, _cache) => {
        const _component_Icon = Vue.resolveComponent("Icon");
        const _directive_znpb_tooltip = Vue.resolveDirective("znpb-tooltip");
        return Vue.openBlock(), Vue.createBlock(_sfc_main$q, {
          "prevent-close": preventClose.value,
          onMousedown: _cache[5] || (_cache[5] = Vue.withModifiers(() => {
          }, ["stop"])),
          onHide: onFlyoutHide
        }, {
          "panel-icon": Vue.withCtx(() => [
            Vue.createVNode(_component_Icon, { icon: Vue.unref(deviceIcon) }, null, 8, ["icon"])
          ]),
          default: Vue.withCtx(() => [
            Vue.createElementVNode("div", _hoisted_1$j, [
              Vue.createElementVNode("div", _hoisted_2$f, [
                Vue.createElementVNode("label", _hoisted_3$c, [
                  Vue.createVNode(_component_Icon, { icon: "width" })
                ]),
                Vue.withDirectives(Vue.createElementVNode("input", {
                  id: "znpb-responsive__iframeWidth",
                  type: "number",
                  value: Vue.unref(iframeWidth2),
                  onKeydown: Vue.withKeys(onWidthKeyDown, ["enter"]),
                  onBlur: onWidthKeyDown,
                  onFocus: _cache[0] || (_cache[0] = ($event) => preventClose.value = true)
                }, null, 40, _hoisted_4$a), [
                  [_directive_znpb_tooltip, _ctx.$translate("preview_width")]
                ])
              ]),
              Vue.createElementVNode("div", _hoisted_5$8, [
                Vue.createElementVNode("label", _hoisted_6$7, [
                  Vue.createVNode(_component_Icon, { icon: "zoom" })
                ]),
                Vue.withDirectives(Vue.createElementVNode("input", {
                  id: "znpb-responsive__iframeScale",
                  type: "number",
                  value: Math.round(Vue.unref(scaleValue2)),
                  disabled: Vue.unref(autoScaleActive2),
                  onKeydown: Vue.withKeys(onScaleKeyDown, ["enter"]),
                  onBlur: onScaleKeyDown,
                  onFocus: _cache[1] || (_cache[1] = ($event) => preventClose.value = true)
                }, null, 40, _hoisted_7$6), [
                  [_directive_znpb_tooltip, _ctx.$translate("preview_scale")]
                ]),
                Vue.withDirectives(Vue.createVNode(_component_Icon, {
                  icon: Vue.unref(autoScaleActive2) ? "lock" : "unlock",
                  class: Vue.normalizeClass(["znpb-responsiveDeviceHeader__iconLock", {
                    "znpb-responsiveDeviceHeader__iconLock--locked": Vue.unref(autoScaleActive2)
                  }]),
                  onClick: _cache[2] || (_cache[2] = Vue.withModifiers(($event) => Vue.unref(setAutoScale)(!Vue.unref(autoScaleActive2)), ["stop"]))
                }, null, 8, ["icon", "class"]), [
                  [_directive_znpb_tooltip, Vue.unref(autoScaleActive2) ? _ctx.$translate("disable_autoscale") : _ctx.$translate("enable_autoscale")]
                ])
              ])
            ]),
            Vue.createElementVNode("div", {
              ref_key: "devicesList",
              ref: devicesList,
              class: "znpb-fancy-scrollbar znpb-responsiveDevicesWrapper"
            }, [
              (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList(Vue.unref(orderedResponsiveDevices2), (deviceConfig, i) => {
                return Vue.openBlock(), Vue.createBlock(FlyoutMenuItem, {
                  key: i,
                  class: Vue.normalizeClass({
                    [`znpb-deviceItem--${deviceConfig.id}`]: deviceConfig.id
                  })
                }, {
                  default: Vue.withCtx(() => [
                    Vue.createVNode(_sfc_main$r, {
                      "device-config": deviceConfig,
                      "allow-edit": editBreakpoints.value,
                      "edited-breakpoint": editedBreakpoint.value,
                      onEditBreakpoint: _cache[3] || (_cache[3] = (breakpoint) => editedBreakpoint.value = breakpoint)
                    }, null, 8, ["device-config", "allow-edit", "edited-breakpoint"])
                  ]),
                  _: 2
                }, 1032, ["class"]);
              }), 128))
            ], 512),
            enabledAddBreakpoint.value && editBreakpoints.value ? (Vue.openBlock(), Vue.createElementBlock("li", _hoisted_8$6, [
              Vue.createElementVNode("a", _hoisted_9$5, [
                Vue.createElementVNode("div", _hoisted_10$4, [
                  Vue.createVNode(_component_Icon, {
                    icon: Vue.unref(addBreakpointDeviceIcon),
                    class: "znpb-device__item-icon"
                  }, null, 8, ["icon"]),
                  Vue.createElementVNode("span", _hoisted_11$3, [
                    Vue.createTextVNode(Vue.toDisplayString(_ctx.$translate("max")) + " ", 1),
                    Vue.createElementVNode("span", _hoisted_12$2, [
                      Vue.createElementVNode("span", _hoisted_13$2, [
                        Vue.withDirectives(Vue.createElementVNode("input", {
                          ref_key: "widthInput",
                          ref: widthInput,
                          "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => newBreakpointValue.value = $event),
                          type: "number",
                          class: "znpb-device__itemValueInput",
                          min: "240",
                          onKeydown: Vue.withKeys(addNewBreakpoint, ["enter"])
                        }, null, 40, _hoisted_14$1), [
                          [Vue.vModelText, newBreakpointValue.value]
                        ]),
                        Vue.createTextVNode(" px ")
                      ])
                    ])
                  ]),
                  Vue.createElementVNode("div", _hoisted_15, [
                    Vue.withDirectives(Vue.createVNode(_component_Icon, {
                      icon: "check",
                      class: "znpb-device__item-action",
                      onClick: Vue.withModifiers(addNewBreakpoint, ["stop"])
                    }, null, 8, ["onClick"]), [
                      [_directive_znpb_tooltip, _ctx.$translate("save")]
                    ]),
                    Vue.withDirectives(Vue.createVNode(_component_Icon, {
                      icon: "close",
                      class: "znpb-device__item-action",
                      onClick: cancelNewBreakpointAdd
                    }, null, 512), [
                      [_directive_znpb_tooltip, _ctx.$translate("cancel")]
                    ])
                  ])
                ])
              ])
            ])) : Vue.createCommentVNode("", true),
            editBreakpoints.value ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_16, [
              Vue.createElementVNode("div", {
                class: "znpb-device__addBreakpoint",
                onClick: enableAddNewDevice
              }, [
                Vue.createVNode(_component_Icon, { icon: "plus" }),
                Vue.createTextVNode(" " + Vue.toDisplayString(_ctx.$translate("add_breakpoint")), 1)
              ])
            ])) : Vue.createCommentVNode("", true),
            !Vue.unref(userStore).permissions.only_content ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_17, [
              Vue.createElementVNode("div", {
                class: "znpb-responsiveDeviceEditButton",
                onClick: disableEditBreakpoints
              }, [
                !editBreakpoints.value ? (Vue.openBlock(), Vue.createElementBlock(Vue.Fragment, { key: 0 }, [
                  Vue.createVNode(_component_Icon, { icon: "edit" }),
                  Vue.createTextVNode(" " + Vue.toDisplayString(_ctx.$translate("edit_breakpoints")), 1)
                ], 64)) : (Vue.openBlock(), Vue.createElementBlock(Vue.Fragment, { key: 1 }, [
                  Vue.createVNode(_component_Icon, { icon: "close" }),
                  Vue.createTextVNode(" " + Vue.toDisplayString(_ctx.$translate("disable_edit_breakpoints")), 1)
                ], 64))
              ])
            ])) : Vue.createCommentVNode("", true)
          ]),
          _: 1
        }, 8, ["prevent-close"]);
      };
    }
  };
  var mainPanel_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$n = {
    name: "ZnpbPanelMain",
    components: {
      FlyoutWrapper: _sfc_main$q,
      FlyoutMenuItem,
      keyShortcuts,
      aboutModal,
      ResponsiveDevices: _sfc_main$o
    },
    setup() {
      const UIStore = useUIStore();
      const userStore = useUserStore();
      const { saveDraft, savePage: savePage2, isSavePageLoading: isSavePageLoading2, openPreviewPage } = useSavePage();
      const { editorData: editorData2 } = useEditorData();
      const { showSaveElement } = useSaveTemplate();
      const { getOptionValue } = useBuilderOptionsStore();
      const editorHeaderRef = Vue.ref(null);
      const showGettingStartedVideo = Vue.ref(false);
      const aboutModalVisibility = Vue.ref(false);
      const shortcutsModalVisibility = Vue.ref(false);
      const top2 = Vue.ref(null);
      const left2 = Vue.ref(null);
      const draggingPosition = Vue.ref(null);
      const userSel = Vue.ref(null);
      const gettingStartedVideoURL = window.ZnPbInitialData.urls.getting_started_video;
      const tooltipsPosition = Vue.computed(() => {
        if (UIStore.mainBar.position === "top") {
          return "bottom";
        } else if (UIStore.mainBar.position === "left") {
          return "right";
        } else if (UIStore.mainBar.position === "right") {
          return "left";
        } else if (UIStore.mainBar.position === "bottom") {
          return "top";
        }
        return "top";
      });
      let isPro = editorData2.value.plugin_info.is_pro_active;
      const hasWhiteLabel = Vue.computed(() => {
        return isPro && getOptionValue("white_label") !== null && getOptionValue("white_label").plugin_title ? true : false;
      });
      const helpMenuItems = Vue.computed(() => {
        let helpArray = [
          {
            title: translate("tour"),
            action: doShowGettingStartedVideo,
            canShow: isPro && gettingStartedVideoURL.length > 0
          },
          {
            title: translate("key_shortcuts"),
            action: () => shortcutsModalVisibility.value = true
          },
          {
            title: translate("about_zion_builder"),
            action: () => aboutModalVisibility.value = true,
            canShow: !hasWhiteLabel.value
          },
          {
            title: translate("back_to_zion_dashboard"),
            url: editorData2.value.urls.zion_admin,
            action: () => {
            }
          },
          {
            title: translate("back_to_wp_dashboard"),
            url: editorData2.value.urls.edit_page,
            action: () => {
            }
          },
          {
            title: translate("view_post"),
            action: openPreviewPage
          }
        ];
        return helpArray.filter((item) => item.canShow !== false);
      });
      const panelStyles = Vue.computed(() => {
        return {
          userSelect: userSel.value,
          pointerEvents: UIStore.mainBar.isDragging || UIStore.mainBar.pointerEvents ? "none" : null
        };
      });
      function saveTemplate() {
        showSaveElement(null);
      }
      const saveActions = [
        {
          icon: "save-template",
          title: translate("save_template"),
          action: saveTemplate
        },
        {
          icon: "save-draft",
          title: translate("save_draft"),
          action: saveDraft
        },
        {
          icon: "save-page",
          title: translate("save_page"),
          action: savePage2
        }
      ];
      if (null === localStorage.getItem("zion_builder_guided_tour_done")) {
        doShowGettingStartedVideo();
      }
      function doShowGettingStartedVideo() {
        showGettingStartedVideo.value = true;
        localStorage.setItem("zion_builder_guided_tour_done", true);
      }
      function startBarDrag() {
        window.addEventListener("mousemove", movePanel);
        window.addEventListener("mouseup", disablePanelMove);
      }
      function movePanel(event2) {
        document.body.style.cursor = "grabbing";
        let newLeft = event2.clientX - 30;
        let newTop = event2.clientY;
        UIStore.mainBarDraggingPlaceholder.top = event2.clientY;
        UIStore.mainBarDraggingPlaceholder.left = event2.clientX;
        if (!UIStore.mainBar.isDragging) {
          UIStore.mainBar.isDragging = true;
        }
        UIStore.setIframePointerEvents(true);
        userSel.value = "none";
        const maxLeft = window.innerWidth - 60;
        newLeft = newLeft <= 0 ? 0 : newLeft;
        left2.value = newLeft > maxLeft ? maxLeft : newLeft;
        top2.value = newTop;
        const positions = {
          top: window.innerHeight * 30 / 100 - event2.clientY,
          right: event2.clientX - window.innerWidth * 70 / 100,
          bottom: event2.clientY - window.innerHeight * 70 / 100,
          left: window.innerWidth * 30 / 100 - event2.clientX
        };
        const availablePositions = Object.keys(positions).filter((position) => {
          return positions[position] > 0;
        });
        if (availablePositions.length === 0) {
          return;
        }
        const closestPosition = availablePositions.reduce((highest, current) => {
          return positions[highest] > positions[current] ? highest : current;
        });
        if (closestPosition) {
          draggingPosition.value = closestPosition;
          UIStore.mainBar.draggingPosition = closestPosition;
        }
      }
      function disablePanelMove() {
        window.removeEventListener("mousemove", movePanel);
        window.removeEventListener("mouseup", disablePanelMove);
        if (draggingPosition.value) {
          UIStore.setMainBarPosition(draggingPosition.value);
          draggingPosition.value = null;
        }
        UIStore.setIframePointerEvents(false);
        userSel.value = null;
        document.body.style.cursor = null;
        UIStore.mainBar.isDragging = false;
      }
      function onAfterLeave() {
        const el = document.querySelector("iframe");
        el.style.transform = "translateZ(0)";
      }
      function onAfterEnter() {
        const el = document.querySelector("iframe");
        el.style.transform = null;
      }
      Vue.onBeforeUnmount(() => {
        window.removeEventListener("mousemove", movePanel);
        window.removeEventListener("mouseup", disablePanelMove);
      });
      return {
        gettingStartedVideoURL,
        showGettingStartedVideo,
        editorHeaderRef,
        aboutModalVisibility,
        shortcutsModalVisibility,
        draggingPosition,
        UIStore,
        userStore,
        helpMenuItems,
        panelStyles,
        tooltipsPosition,
        saveActions,
        isSavePageLoading: isSavePageLoading2,
        savePage: savePage2,
        startBarDrag,
        onAfterLeave,
        onAfterEnter
      };
    }
  };
  const _hoisted_1$i = { class: "znpb-editor-header__first" };
  const _hoisted_2$e = { class: "znpb-editor-header__last" };
  const _hoisted_3$b = ["href", "target", "onMousedown"];
  const _hoisted_4$9 = ["src"];
  const _hoisted_5$7 = ["onMousedown"];
  function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Icon = Vue.resolveComponent("Icon");
    const _component_ResponsiveDevices = Vue.resolveComponent("ResponsiveDevices");
    const _component_FlyoutMenuItem = Vue.resolveComponent("FlyoutMenuItem");
    const _component_FlyoutWrapper = Vue.resolveComponent("FlyoutWrapper");
    const _component_Modal = Vue.resolveComponent("Modal");
    const _component_keyShortcuts = Vue.resolveComponent("keyShortcuts");
    const _component_aboutModal = Vue.resolveComponent("aboutModal");
    const _component_Loader = Vue.resolveComponent("Loader");
    const _directive_znpb_tooltip = Vue.resolveDirective("znpb-tooltip");
    return Vue.openBlock(), Vue.createElementBlock("div", {
      ref: "editorHeaderRef",
      class: Vue.normalizeClass(["znpb-editor-header", {
        "znpb-editor-panel__container--dragging": $setup.UIStore.mainBar.isDragging,
        [`znpb-editor-header--${$setup.UIStore.mainBar.position}`]: $setup.UIStore.mainBar.position,
        [`znpb-editor-header--hide-${$setup.UIStore.mainBar.position}`]: $setup.UIStore.isPreviewMode
      }]),
      style: Vue.normalizeStyle($setup.panelStyles),
      onMousedown: _cache[7] || (_cache[7] = Vue.withModifiers((...args) => $setup.startBarDrag && $setup.startBarDrag(...args), ["stop"]))
    }, [
      Vue.createElementVNode("div", _hoisted_1$i, [
        Vue.withDirectives((Vue.openBlock(), Vue.createElementBlock("div", {
          class: Vue.normalizeClass(["znpb-editor-header__menu_button znpb-editor-header__menu_button--treeview", {
            active: $setup.UIStore.openPanelsIDs.includes("panel-tree")
          }]),
          onMousedown: _cache[0] || (_cache[0] = Vue.withModifiers(($event) => $setup.UIStore.togglePanel("panel-tree"), ["stop", "prevent"]))
        }, [
          Vue.createVNode(_component_Icon, { icon: "layout" })
        ], 34)), [
          [_directive_znpb_tooltip, _ctx.$translate("tree_view"), $setup.tooltipsPosition]
        ]),
        !$setup.userStore.permissions.only_content ? Vue.withDirectives((Vue.openBlock(), Vue.createElementBlock("div", {
          key: 0,
          class: Vue.normalizeClass([{
            active: $setup.UIStore.isLibraryOpen
          }, "znpb-editor-header__menu_button"]),
          onMousedown: _cache[1] || (_cache[1] = Vue.withModifiers((...args) => $setup.UIStore.toggleLibrary && $setup.UIStore.toggleLibrary(...args), ["stop"]))
        }, [
          Vue.createVNode(_component_Icon, { icon: "lib" })
        ], 34)), [
          [_directive_znpb_tooltip, _ctx.$translate("library"), $setup.tooltipsPosition]
        ]) : Vue.createCommentVNode("", true),
        Vue.withDirectives((Vue.openBlock(), Vue.createElementBlock("div", {
          class: Vue.normalizeClass(["znpb-editor-header__menu_button znpb-editor-header__menu_button--history", {
            active: $setup.UIStore.openPanelsIDs.includes("panel-history")
          }]),
          onMousedown: _cache[2] || (_cache[2] = Vue.withModifiers(($event) => $setup.UIStore.togglePanel("panel-history"), ["stop", "prevent"]))
        }, [
          Vue.createVNode(_component_Icon, { icon: "history" })
        ], 34)), [
          [_directive_znpb_tooltip, _ctx.$translate("history_panel"), $setup.tooltipsPosition]
        ])
      ]),
      Vue.createElementVNode("div", _hoisted_2$e, [
        Vue.createVNode(_component_ResponsiveDevices),
        !$setup.userStore.permissions.only_content ? Vue.withDirectives((Vue.openBlock(), Vue.createElementBlock("div", {
          key: 0,
          class: Vue.normalizeClass(["znpb-editor-header__menu_button", {
            active: $setup.UIStore.openPanelsIDs.includes("panel-global-settings")
          }]),
          onMousedown: _cache[3] || (_cache[3] = Vue.withModifiers(($event) => $setup.UIStore.togglePanel("panel-global-settings"), ["stop"]))
        }, [
          Vue.createVNode(_component_Icon, { icon: "sliders" })
        ], 34)), [
          [_directive_znpb_tooltip, _ctx.$translate("page_options"), $setup.tooltipsPosition]
        ]) : Vue.createCommentVNode("", true),
        Vue.createVNode(_component_FlyoutWrapper, { class: "znpb-editor-header__page-save-wrapper" }, {
          "panel-icon": Vue.withCtx(() => [
            Vue.createVNode(_component_Icon, { icon: "info" })
          ]),
          default: Vue.withCtx(() => [
            (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList($setup.helpMenuItems, (menuItem, i) => {
              return Vue.openBlock(), Vue.createBlock(_component_FlyoutMenuItem, { key: i }, {
                default: Vue.withCtx(() => [
                  Vue.createElementVNode("a", {
                    href: menuItem.url,
                    target: menuItem.target,
                    onMousedown: Vue.withModifiers(menuItem.action, ["prevent", "stop"])
                  }, [
                    Vue.createElementVNode("span", null, Vue.toDisplayString(menuItem.title), 1)
                  ], 40, _hoisted_3$b)
                ]),
                _: 2
              }, 1024);
            }), 128))
          ]),
          _: 1
        }),
        $setup.showGettingStartedVideo && $setup.gettingStartedVideoURL ? (Vue.openBlock(), Vue.createBlock(_component_Modal, {
          key: 1,
          show: $setup.showGettingStartedVideo,
          "onUpdate:show": _cache[4] || (_cache[4] = ($event) => $setup.showGettingStartedVideo = $event),
          width: 840,
          title: _ctx.$translate("getting_started"),
          "append-to": "#znpb-main-wrapper",
          class: "znpb-helpmodal-wrapper"
        }, {
          default: Vue.withCtx(() => [
            Vue.createElementVNode("iframe", {
              width: "840",
              height: "100%",
              src: $setup.gettingStartedVideoURL,
              frameborder: "0",
              allow: "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture",
              allowfullscreen: ""
            }, null, 8, _hoisted_4$9)
          ]),
          _: 1
        }, 8, ["show", "title"])) : Vue.createCommentVNode("", true),
        $setup.shortcutsModalVisibility ? (Vue.openBlock(), Vue.createBlock(_component_Modal, {
          key: 2,
          show: $setup.shortcutsModalVisibility,
          "onUpdate:show": _cache[5] || (_cache[5] = ($event) => $setup.shortcutsModalVisibility = $event),
          width: 560,
          title: _ctx.$translate("key_shortcuts"),
          "append-to": "#znpb-main-wrapper"
        }, {
          default: Vue.withCtx(() => [
            Vue.createVNode(_component_keyShortcuts)
          ]),
          _: 1
        }, 8, ["show", "title"])) : Vue.createCommentVNode("", true),
        $setup.aboutModalVisibility ? (Vue.openBlock(), Vue.createBlock(_component_Modal, {
          key: 3,
          show: $setup.aboutModalVisibility,
          "onUpdate:show": _cache[6] || (_cache[6] = ($event) => $setup.aboutModalVisibility = $event),
          width: 580,
          title: _ctx.$translate("about_zion_builder"),
          "show-maximize": false,
          "append-to": "#znpb-main-wrapper"
        }, {
          default: Vue.withCtx(() => [
            Vue.createVNode(_component_aboutModal)
          ]),
          _: 1
        }, 8, ["show", "title"])) : Vue.createCommentVNode("", true),
        Vue.createVNode(_component_FlyoutWrapper, {
          class: "znpb-editor-header__page-save-wrapper znpb-editor-header__page-save-wrapper--save",
          onMousedown: $setup.savePage
        }, {
          "panel-icon": Vue.withCtx(() => [
            !$setup.isSavePageLoading ? (Vue.openBlock(), Vue.createBlock(_component_Icon, {
              key: 0,
              icon: "check",
              onMousedown: Vue.withModifiers($setup.savePage, ["stop"])
            }, null, 8, ["onMousedown"])) : (Vue.openBlock(), Vue.createBlock(_component_Loader, {
              key: 1,
              size: 12
            }))
          ]),
          default: Vue.withCtx(() => [
            (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList($setup.saveActions, (menuItem, i) => {
              return Vue.openBlock(), Vue.createBlock(_component_FlyoutMenuItem, { key: i }, {
                default: Vue.withCtx(() => [
                  Vue.createElementVNode("a", {
                    href: "#",
                    onMousedown: Vue.withModifiers(menuItem.action, ["stop"])
                  }, [
                    Vue.createElementVNode("span", null, Vue.toDisplayString(menuItem.title), 1)
                  ], 40, _hoisted_5$7)
                ]),
                _: 2
              }, 1024);
            }), 128))
          ]),
          _: 1
        }, 8, ["onMousedown"])
      ])
    ], 38);
  }
  var MainPanel = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["render", _sfc_render$8]]);
  const _sfc_main$m = {
    name: "PageStyles",
    props: {
      cssClasses: {
        type: [Object, Array]
      },
      pageSettingsModel: {
        type: Object
      },
      pageSettingsSchema: {
        type: Object
      }
    },
    setup(props) {
      const { getSchema } = useOptionsSchemas();
      const optionsSchema = getSchema("styles");
      return () => {
        const { activePseudoSelector: activePseudoSelector2 } = usePseudoSelectors();
        const returnVnodes = [];
        const createVnode = function(styles) {
          return Vue.h(_sfc_main$P, {
            styles
          });
        };
        const pageSettingsOptionsInstance = new Options(props.pageSettingsSchema, props.pageSettingsModel);
        const { customCSS: pageSettingsCustomCSS } = pageSettingsOptionsInstance.parseData();
        returnVnodes.push(createVnode(pageSettingsCustomCSS));
        if (typeof props.cssClasses === "object" && props.cssClasses !== null) {
          Object.keys(props.cssClasses).forEach((cssClassId) => {
            const styleData = props.cssClasses[cssClassId];
            const optionsInstance = new Options(optionsSchema, styleData, [`.zb .${styleData.id}`]);
            const parsedOptions = optionsInstance.parseData();
            let customCSS = window.zb.editor.getCssFromSelector([`.zb .${styleData.id}`], parsedOptions.options);
            if (activePseudoSelector2.value && activePseudoSelector2.value.id === ":hover") {
              const optionsInstance2 = new Options(optionsSchema, styleData, [`.zb .${styleData.id}`]);
              const parsedOptions2 = optionsInstance2.parseData();
              customCSS += window.zb.editor.getCssFromSelector([`.zb .${styleData.id}`], parsedOptions2.options, {
                forcehoverState: true
              });
            }
            returnVnodes.push(createVnode(customCSS));
          });
        }
        return returnVnodes;
      };
    }
  };
  var PreviewApp_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$l = /* @__PURE__ */ Vue.defineComponent({
    __name: "PreviewApp",
    setup(__props) {
      const { getSchema } = useOptionsSchemas();
      const cssClasses = useCSSClassesStore();
      const UIStore = useUIStore();
      const elementsStore = useContentStore();
      const pageSettings = usePageSettingsStore();
      const element = Vue.computed(() => {
        return elementsStore.getElement(window.ZnPbInitialData.page_id);
      });
      Vue.watch(
        () => UIStore.isPreviewMode,
        (newValue) => {
          if (newValue) {
            window.document.body.classList.add("znpb-editor-preview--active");
          } else {
            window.document.body.classList.remove("znpb-editor-preview--active");
          }
        }
      );
      doAction("zionbuilder/preview/app/setup");
      const previewAppClasses = Vue.computed(() => {
        var _a3;
        return applyFilters("zionbuilder/preview/app/css_classes", (_a3 = window.ZnPbInitialData) == null ? void 0 : _a3.preview_app_css_classes);
      });
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", {
          class: Vue.normalizeClass(["zb", Vue.unref(previewAppClasses)])
        }, [
          Vue.unref(element) ? (Vue.openBlock(), Vue.createBlock(_sfc_main$I, {
            key: 0,
            class: "znpb-preview-page-wrapper",
            element: Vue.unref(element)
          }, null, 8, ["element"])) : Vue.createCommentVNode("", true),
          Vue.createVNode(_sfc_main$m, {
            "css-classes": Vue.unref(cssClasses).CSSClasses,
            "page-settings-model": Vue.unref(pageSettings).settings,
            "page-settings-schema": Vue.unref(getSchema)("pageSettingsSchema")
          }, null, 8, ["css-classes", "page-settings-model", "page-settings-schema"]),
          Vue.createVNode(_sfc_main$P, {
            styles: Vue.unref(pageSettings).settings._custom_css || ""
          }, null, 8, ["styles"])
        ], 2);
      };
    }
  });
  var PreviewIframe_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$k = {
    name: "PreviewIframe",
    components: {
      PreviewApp: _sfc_main$l
    },
    setup() {
      const {
        activeResponsiveDeviceInfo: activeResponsiveDeviceInfo2,
        iframeWidth: iframeWidth2,
        setCustomIframeWidth,
        scaleValue: scaleValue2,
        autoScaleActive: autoScaleActive2,
        activeResponsiveDeviceId: activeResponsiveDeviceId2,
        ignoreWidthChangeFlag: ignoreWidthChangeFlag2,
        setCustomScale
      } = useResponsiveDevices();
      const { applyShortcuts } = useKeyBindings();
      const { saveAutosave } = useSavePage();
      const { editorData: editorData2 } = useEditorData();
      const UIStore = useUIStore();
      const contentStore = useContentStore();
      const elementsDefinitionsStore = useElementDefinitionsStore();
      const { addWindow, addEventListener, removeEventListener, getWindows, removeWindow } = useWindows();
      const iframeAPP = Vue.ref(null);
      const root2 = Vue.ref(null);
      const iframe = Vue.ref(null);
      const containerSize = Vue.ref({
        width: 0,
        height: 0
      });
      const iframeSize = Vue.ref({
        width: 0,
        height: 0
      });
      const getWrapperClasses = Vue.computed(() => {
        const { width: containerWidth } = containerSize.value;
        const { width: iframeWidth3 } = iframeSize.value;
        return {
          [`znpb-editor-iframe-wrapper--${activeResponsiveDeviceInfo2.value.id}`]: true,
          "znpb-editor-iframe--isAutoscale": autoScaleActive2.value,
          "znpb-editor-iframe--alignStart": Math.round(scaleValue2.value / 100 * iframeWidth3) > containerWidth,
          "znpb-editor-iframe--hideOverflow": Math.round(scaleValue2.value / 100 * iframeWidth3) <= containerWidth
        };
      });
      const deviceStyle = Vue.computed(() => {
        let styles = {};
        return styles;
      });
      addAction("zionbuilder/responsive/change_device_width", (device, newValue, oldValue) => {
        if (device.id === activeResponsiveDeviceId2.value && newValue !== oldValue) {
          setCustomIframeWidth(newValue);
        }
      });
      const iframeStyles = Vue.computed(() => {
        const styles = {};
        if (root2.value) {
          const { height: containerHeight } = containerSize.value;
          let height = 0;
          if (activeResponsiveDeviceInfo2.value && activeResponsiveDeviceInfo2.value.height) {
            height = activeResponsiveDeviceInfo2.value.height;
          } else {
            height = containerHeight;
          }
          if (iframeWidth2.value) {
            styles.width = `${iframeWidth2.value}px`;
          }
          const scale = scaleValue2.value / 100;
          styles.transform = `scale(${scale})`;
          styles.height = `${100 / scaleValue2.value * height}px`;
          styles.maxHeight = `${100 / scaleValue2.value * containerHeight}px`;
        }
        return styles;
      });
      Vue.watch(
        () => UIStore.isPreviewMode,
        (newValue) => {
          if (newValue && activeResponsiveDeviceInfo2.value.id === "default") {
            console.log("new Value");
            Vue.nextTick(() => {
              iframeWidth2.value = null;
            });
          }
        }
      );
      Vue.watch([containerSize, iframeSize], ([containerNewSize, iframeNewSize]) => {
        if (autoScaleActive2.value) {
          let scale = containerNewSize.width / iframeNewSize.width * 100;
          scale = scale > 100 ? 100 : scale;
          setCustomScale(scale);
        }
      });
      const containerResizeObserver = new ResizeObserver((entries) => {
        for (let entry of entries) {
          if (entry.contentBoxSize) {
            const contentBoxSize = Array.isArray(entry.contentBoxSize) ? entry.contentBoxSize[0] : entry.contentBoxSize;
            containerSize.value = {
              width: contentBoxSize.inlineSize,
              height: contentBoxSize.blockSize
            };
          } else {
            containerSize.value = {
              width: entry.contentRect.width,
              height: entry.contentRect.width
            };
          }
        }
      });
      const iframeResizeObserver = new ResizeObserver((entries) => {
        for (let entry of entries) {
          if (entry.contentBoxSize) {
            const contentBoxSize = Array.isArray(entry.contentBoxSize) ? entry.contentBoxSize[0] : entry.contentBoxSize;
            iframeSize.value = {
              width: contentBoxSize.inlineSize,
              height: contentBoxSize.blockSize
            };
          } else {
            iframeSize.value = {
              width: entry.contentRect.width,
              height: entry.contentRect.width
            };
          }
        }
      });
      Vue.watch(activeResponsiveDeviceId2, () => {
        if (ignoreWidthChangeFlag2.value) {
          ignoreWidthChangeFlag2.value = false;
          return;
        }
        if (activeResponsiveDeviceInfo2.value.width) {
          setCustomIframeWidth(activeResponsiveDeviceInfo2.value.width);
        } else if (activeResponsiveDeviceInfo2.value.id === "default") {
          setCustomIframeWidth(containerSize.value.width < 1200 ? 1200 : containerSize.value.width);
        }
      });
      Vue.watch(autoScaleActive2, (newValue) => {
        if (newValue) {
          root2.value.scrollLeft = 0;
        } else {
          setCustomScale(100);
        }
      });
      Vue.onMounted(() => {
        const { width, height } = root2.value.getBoundingClientRect();
        containerSize.value = {
          width,
          height
        };
        const { width: iframeWidth3 } = iframe.value.getBoundingClientRect();
        iframeSize.value = {
          width,
          height
        };
        setCustomIframeWidth(iframeWidth3 < 1200 ? 1200 : iframeWidth3);
        containerResizeObserver.observe(root2.value);
        iframeResizeObserver.observe(iframe.value);
      });
      Vue.onBeforeUnmount(() => {
        containerResizeObserver.unobserve(root2.value);
        containerResizeObserver.observe(iframe.value);
      });
      const pointerEvents = Vue.computed(() => {
        let style = {};
        if (UIStore.iFrame.pointerEvents) {
          style.pointerEvents = "none";
        }
        style.order = UIStore.getPanelOrder("preview-iframe");
        return style;
      });
      return {
        iframeAPP,
        activeResponsiveDeviceInfo: activeResponsiveDeviceInfo2,
        applyShortcuts,
        saveAutosave,
        pageId: editorData2.value.page_id,
        urls: editorData2.value.urls,
        addWindow,
        getWindows,
        addEventListener,
        removeEventListener,
        removeWindow,
        root: root2,
        iframe,
        deviceStyle,
        getWrapperClasses,
        iframeStyles,
        pointerEvents,
        iframeWidth: iframeWidth2,
        contentStore,
        UIStore,
        elementsDefinitionsStore
      };
    },
    data() {
      return {
        ignoreNextReload: false,
        localStoragePageData: {},
        iframeLoaded: false
      };
    },
    beforeUnmount() {
      if (this.getWindows("preview")) {
        this.getWindows("preview").removeEventListener("keydown", this.applyShortcuts);
        this.getWindows("preview").removeEventListener("click", this.preventClicks, true);
        this.getWindows("preview").removeEventListener("beforeunload", this.onBeforeUnloadIframe);
        this.getWindows("preview").removeEventListener("click", this.onIframeClick, true);
      }
      removeAction("refreshIframe", this.refreshIframe);
    },
    mounted() {
      addAction("refreshIframe", this.refreshIframe);
    },
    methods: {
      setPageContent(areas) {
        forEach(areas, (areaContent, id) => {
          this.contentStore.registerArea(
            {
              name: id,
              id
            },
            areaContent
          );
        });
        this.UIStore.setContentTimestamp();
      },
      onIframeClick(event2) {
        this.root.click();
      },
      onIframeLoaded() {
        this.iframeLoaded = true;
        const iframeWindow = this.$refs.iframe.contentWindow;
        const elementDefinitionsStore2 = useElementDefinitionsStore();
        elementDefinitionsStore2.setCategories(iframeWindow.ZnPbInitialData.elements_categories);
        elementDefinitionsStore2.addElements(iframeWindow.ZnPbInitialData.elements_data);
        this.addWindow("preview", iframeWindow);
        this.attachIframeEvents();
        const renderElement = iframeWindow.document.getElementById(`znpb-preview-${window.ZnPbInitialData.page_id}-area`);
        if (renderElement) {
          this.iframeAPP = iframeWindow.document.getElementById(`znpb-preview-${window.ZnPbInitialData.page_id}-area`);
        } else {
          console.log("preview element not found");
        }
        if (!this.ignoreNextReload) {
          this.setPageContent(iframeWindow.ZnPbInitialData.page_content);
        }
        this.ignoreNextReload = false;
        this.UIStore.setPreviewLoading(false);
        this.UIStore.setLoadTimestamp();
      },
      attachIframeEvents() {
        this.getWindows("preview").addEventListener("click", this.preventClicks, true);
        this.getWindows("preview").addEventListener("keydown", this.applyShortcuts);
        this.getWindows("preview").addEventListener("beforeunload", this.onBeforeUnloadIframe, { capture: true });
        this.getWindows("preview").addEventListener("click", this.onIframeClick, true);
      },
      preventClicks(event2) {
        const e = window.e || event2;
        if (e.target.tagName === "a" || !e.target.classList.contains("znpb-allow-click")) {
          e.preventDefault();
        }
      },
      onBeforeUnloadIframe(event2) {
        const historyStore = useHistoryStore();
        if (historyStore.isDirty) {
          event2.preventDefault();
          event2.returnValue = "Do you want to leave this site? Changes you made may not be saved.";
        } else {
          this.UIStore.setPreviewLoading(true);
        }
      },
      refreshIframe() {
        this.saveAutosave().then(() => {
          window.location.reload();
        });
      },
      checkIframeLoading() {
        if (this.$refs.iframe && this.$refs.iframe.contentDocument) {
          if (this.$refs.iframe.contentDocument.readyState === "complete") {
            this.onIframeLoaded();
          } else {
            setTimeout(this.checkIframeLoading, 100);
          }
        } else {
          setTimeout(this.checkIframeLoading, 100);
        }
      }
    }
  };
  const _hoisted_1$h = ["src"];
  function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_PreviewApp = Vue.resolveComponent("PreviewApp");
    return Vue.openBlock(), Vue.createElementBlock("div", {
      id: "preview-iframe",
      ref: "root",
      class: Vue.normalizeClass(["znpb-editor-iframe-wrapper", $setup.getWrapperClasses]),
      style: Vue.normalizeStyle($setup.pointerEvents)
    }, [
      $setup.urls.preview_frame_url ? (Vue.openBlock(), Vue.createElementBlock("iframe", {
        key: 0,
        id: "znpb-editor-iframe",
        ref: "iframe",
        src: $setup.urls.preview_frame_url,
        style: Vue.normalizeStyle($setup.iframeStyles),
        onLoad: _cache[0] || (_cache[0] = (...args) => $options.checkIframeLoading && $options.checkIframeLoading(...args))
      }, null, 44, _hoisted_1$h)) : Vue.createCommentVNode("", true),
      $setup.iframeAPP ? (Vue.openBlock(), Vue.createBlock(Vue.Teleport, {
        key: 1,
        to: $setup.iframeAPP
      }, [
        Vue.createVNode(_component_PreviewApp)
      ], 8, ["to"])) : Vue.createCommentVNode("", true)
    ], 6);
  }
  var PreviewIframe = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["render", _sfc_render$7]]);
  const _sfc_main$j = /* @__PURE__ */ Vue.defineComponent({
    __name: "BreadcrumbsItem",
    props: {
      item: null
    },
    setup(__props) {
      const UIStore = useUIStore();
      const contentStore = useContentStore();
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", {
          class: Vue.normalizeClass(["znpb-element-options__vertical-breadcrumbs-item", { "znpb-element-options__vertical-breadcrumbs-item--active": __props.item.active }]),
          onMouseenterCapture: _cache[0] || (_cache[0] = (...args) => __props.item.element.highlight && __props.item.element.highlight(...args)),
          onMouseleave: _cache[1] || (_cache[1] = (...args) => __props.item.element.unHighlight && __props.item.element.unHighlight(...args)),
          onClick: _cache[2] || (_cache[2] = Vue.withModifiers(($event) => Vue.unref(UIStore).editElement(__props.item.element), ["stop"]))
        }, [
          Vue.createElementVNode("span", null, Vue.toDisplayString(Vue.unref(contentStore).getElementName(__props.item.element)), 1),
          __props.item.children.length > 0 ? (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, { key: 0 }, Vue.renderList(__props.item.children, (child) => {
            return Vue.openBlock(), Vue.createBlock(_sfc_main$i, {
              key: child.element.uid,
              class: "znpb-element-options__vertical-breadcrumbs-wrapper--inner",
              item: child
            }, null, 8, ["item"]);
          }), 128)) : Vue.createCommentVNode("", true)
        ], 34);
      };
    }
  });
  var Breadcrumbs_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$g = { class: "znpb-element-options__vertical-breadcrumbs-wrapper" };
  const _sfc_main$i = /* @__PURE__ */ Vue.defineComponent({
    __name: "Breadcrumbs",
    props: {
      item: null
    },
    setup(__props) {
      const UIStore = useUIStore();
      const contentStore = useContentStore();
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$g, [
          Vue.createElementVNode("div", {
            class: Vue.normalizeClass(["znpb-element-options__vertical-breadcrumbs-item znpb-element-options__vertical-breadcrumbs-item--first", { "znpb-element-options__vertical-breadcrumbs-item--active": __props.item.active }]),
            onMouseenterCapture: _cache[0] || (_cache[0] = (...args) => __props.item.element.highlight && __props.item.element.highlight(...args)),
            onMouseleave: _cache[1] || (_cache[1] = (...args) => __props.item.element.unHighlight && __props.item.element.unHighlight(...args)),
            onClick: _cache[2] || (_cache[2] = Vue.withModifiers(($event) => Vue.unref(UIStore).editElement(__props.item.element), ["stop"]))
          }, [
            Vue.createElementVNode("span", null, Vue.toDisplayString(Vue.unref(contentStore).getElementName(__props.item.element)), 1)
          ], 34),
          __props.item.children.length > 0 ? (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, { key: 0 }, Vue.renderList(__props.item.children, (child) => {
            return Vue.openBlock(), Vue.createBlock(_sfc_main$j, {
              key: child.element.uid,
              item: child
            }, null, 8, ["item"]);
          }), 128)) : Vue.createCommentVNode("", true)
        ]);
      };
    }
  });
  const _hoisted_1$f = { class: "znpb-element-options__breadcrumbs znpb-fancy-scrollbar" };
  const _hoisted_2$d = { key: 1 };
  const _sfc_main$h = /* @__PURE__ */ Vue.defineComponent({
    __name: "BreadcrumbsWrapper",
    props: {
      element: null
    },
    setup(__props) {
      const props = __props;
      const contentStore = useContentStore();
      const getChildren = function(element) {
        const children = {
          element,
          children: [],
          active: props.element.uid === element.uid
        };
        if (element.content) {
          element.content.forEach((childElementUID) => {
            const childElement = contentStore.getElement(childElementUID);
            children.children.push(getChildren(childElement));
          });
        }
        return children;
      };
      const breadcrumbsItem = Vue.computed(() => {
        let parentStructure = getChildren(props.element);
        let element = props.element;
        while (element.parent && element.parent.elementDefinition.element_type !== "contentRoot") {
          parentStructure = {
            element: element.parent,
            children: [parentStructure],
            active: props.element === element.parent
          };
          element = element.parent;
        }
        return parentStructure;
      });
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$f, [
          Vue.unref(breadcrumbsItem).children.length > 0 ? (Vue.openBlock(), Vue.createBlock(_sfc_main$i, {
            key: 0,
            item: Vue.unref(breadcrumbsItem)
          }, null, 8, ["item"])) : (Vue.openBlock(), Vue.createElementBlock("span", _hoisted_2$d, "This element has no children"))
        ]);
      };
    }
  });
  var PanelElementOptions_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$e = { class: "znpb-element-options__header" };
  const _hoisted_2$c = { class: "znpb-element-options-content-wrapper" };
  const _hoisted_3$a = {
    key: 1,
    class: "znpb-element-options-no-option-message"
  };
  const _hoisted_4$8 = ["onClick"];
  const _hoisted_5$6 = {
    key: 0,
    class: "znpb-element-options-default-message"
  };
  const _hoisted_6$6 = {
    key: 1,
    class: "znpb-element-options-no-option-message"
  };
  const _sfc_main$g = /* @__PURE__ */ Vue.defineComponent({
    __name: "PanelElementOptions",
    props: {
      panel: null
    },
    setup(__props) {
      const props = __props;
      const UIStore = useUIStore();
      const contentStore = useContentStore();
      const UserStore = useUserStore();
      const isPanelHidden = Vue.ref(false);
      const searchInput = Vue.ref(null);
      const showBreadcrumbs = Vue.ref(false);
      const lastTab = Vue.ref(null);
      const defaultMessage = Vue.ref(translate("element_options_default_message"));
      const { provideElement } = useElementProvide();
      const { getSchema } = useOptionsSchemas();
      const activeKeyTab = Vue.ref(null);
      const searchActive = Vue.ref(false);
      const optionsFilterKeyword = Vue.ref("");
      const panelStyles = Vue.computed(() => {
        return {
          "--optionsPanelWidth": `-${props.panel.width}px`
        };
      });
      const elementOptions = Vue.computed({
        get() {
          return UIStore.editedElement ? UIStore.editedElement.options : {};
        },
        set(newValues) {
          if (UIStore.editedElement) {
            window.zb.run("editor/elements/update-element-options", {
              elementUID: UIStore.editedElement.uid,
              newValues: newValues === null ? {} : newValues
            });
          }
        }
      });
      const advancedOptionsModel = Vue.computed({
        get() {
          return elementOptions.value._advanced_options || {};
        },
        set(newValues) {
          if (newValues === null) {
            const oldValues = __spreadValues({}, elementOptions.value);
            delete oldValues._advanced_options;
            elementOptions.value = oldValues;
          } else {
            elementOptions.value = __spreadProps(__spreadValues({}, elementOptions.value), {
              _advanced_options: newValues
            });
          }
        }
      });
      const searchIcon = Vue.computed(() => {
        return searchActive.value ? "close" : "search";
      });
      provideElement(UIStore.editedElement);
      Vue.provide(
        "elementInfo",
        Vue.computed(() => UIStore.editedElement)
      );
      Vue.provide("OptionsFormTopModelValue", elementOptions);
      const computedStyleOptionsSchema = Vue.computed(() => {
        const schema = {};
        let styledElements = UIStore.editedElement.elementDefinition.style_elements;
        const elementHTMLID = UIStore.editedElement.elementCssId;
        Object.keys(styledElements).forEach((styleId) => {
          const config = styledElements[styleId];
          schema[styleId] = {
            type: "css_selector",
            name: config.title,
            icon: "brush",
            allow_class_assignments: typeof config.allow_class_assignments !== "undefined" ? config.allow_class_assignments : true,
            selector: config.selector.replace("{{ELEMENT}}", `#${elementHTMLID}`),
            allow_delete: false,
            show_breadcrumbs: true,
            allow_custom_attributes: typeof config.allow_custom_attributes === "undefined" || config.allow_custom_attributes === true,
            allowRename: false
          };
        });
        return {
          _styles: {
            id: "styles",
            child_options: schema,
            optionsLayout: "full",
            type: "group"
          }
        };
      });
      const allOptionsSchema = Vue.computed(() => {
        var _a3;
        const elementOptionsSchema = ((_a3 = UIStore.editedElement) == null ? void 0 : _a3.elementDefinition.options) ? UIStore.editedElement.elementDefinition.options : {};
        const optionsSchema = __spreadValues(__spreadValues(__spreadValues({}, elementOptionsSchema), computedStyleOptionsSchema.value), getSchema("element_advanced"));
        return optionsSchema;
      });
      const computedStyleOptions = Vue.computed({
        get() {
          return elementOptions.value || {};
        },
        set(newValue) {
          if (newValue === null) {
            const oldValues = __spreadValues({}, elementOptions.value);
            delete oldValues._styles;
            elementOptions.value = oldValues;
          } else {
            elementOptions.value = newValue;
          }
        }
      });
      const filteredOptions = Vue.computed(() => {
        const keyword = optionsFilterKeyword.value;
        if (keyword.length > 2) {
          return filterOptions(keyword, allOptionsSchema.value);
        }
        return {};
      });
      Vue.watch(searchActive, (newValue) => {
        if (newValue) {
          Vue.nextTick(() => {
            if (searchInput.value) {
              searchInput.value.focus();
            }
          });
        }
      });
      addAction("change-tab-styling", changeTabByEvent());
      Vue.onBeforeUnmount(() => {
        removeAction("change-tab-styling", changeTab());
      });
      const optionsReplacements = [
        {
          search: /%%ELEMENT_TYPE%%/g,
          replacement: () => {
            var _a3;
            const elementsDefinitionsStore = useElementDefinitionsStore();
            return elementsDefinitionsStore.getElementDefinition((_a3 = UIStore.editedElement) == null ? void 0 : _a3.element_type).name;
          }
        },
        {
          search: /%%ELEMENT_UID%%/g,
          replacement: () => {
            return UIStore.editedElement.elementCssId;
          }
        }
      ];
      function onBackButtonClick() {
        if (UIStore.editedElement.parent && UIStore.editedElement.parent.elementDefinition.element_type !== "contentRoot") {
          UIStore.editElement(UIStore.editedElement.parent);
        }
      }
      function changeTabByEvent(event2) {
        if (event2 !== void 0) {
          if (tabId !== "search") {
            lastTab.value = activeKeyTab.value;
            optionsFilterKeyword.value = "";
          }
          activeKeyTab.value.value = event2.detail;
        }
      }
      function filterOptions(keyword, optionsSchema, currentId, currentName) {
        let lowercaseKeyword = keyword.toLowerCase();
        let foundOptions = {};
        Object.keys(optionsSchema).forEach((optionId) => {
          const optionConfig = optionsSchema[optionId];
          let syncValue = [];
          let syncValueName = [];
          if (!optionConfig.sync) {
            if (currentId) {
              syncValue.push(...currentId);
            }
            if (currentName) {
              let name = getInnerStyleName(currentName[currentName.length - 1]);
              currentName[currentName.length - 1] = name;
              syncValueName.push(...currentName);
            }
            if (optionId === "animation-group" || optionId === "custom-css-group" || optionId === "general-group") {
              syncValueName.push(translate("advanced"));
            }
            if (!optionConfig.is_layout) {
              syncValue.push(optionId);
            }
            if (optionConfig.type === "element_styles" || optionConfig.type === "css_selector") {
              syncValue.push("styles");
              syncValueName.push(translate("styles"), optionConfig.name);
            }
            if (optionConfig.type === "responsive_group") {
              syncValue.push("%%RESPONSIVE_DEVICE%%");
            }
            if (optionConfig.type === "pseudo_group") {
              syncValue.push("%%PSEUDO_SELECTOR%%");
            }
            syncValueName.push(optionId);
          }
          let searchOptions = optionConfig.search_tags ? [...optionConfig.search_tags] : [];
          if (optionConfig.title) {
            searchOptions.push(optionConfig.title);
          }
          if (optionConfig.id) {
            searchOptions.push(optionConfig.id);
          }
          if (optionConfig.description) {
            searchOptions.push(optionConfig.description);
          }
          if (optionConfig.label) {
            searchOptions.push(optionConfig.label);
          }
          if (optionConfig.type !== "accordion_menu" && optionConfig.type !== "element_styles") {
            if (searchOptions.join(" ").toLowerCase().indexOf(lowercaseKeyword) !== -1) {
              let filteredBreadcrumbs = [];
              if (currentName) {
                filteredBreadcrumbs = currentName.filter(function(value) {
                  return value !== void 0;
                });
              }
              foundOptions[syncValue.join(".")] = __spreadProps(__spreadValues({}, optionConfig), {
                id: syncValue.join("."),
                sync: optionConfig.sync || syncValue.join("."),
                breadcrumbs: filteredBreadcrumbs
              });
            }
          }
          if (optionConfig.type === "repeater") {
            return;
          }
          if (optionConfig.type === "element_styles" || optionConfig.type === "css_selector") {
            const childOptions = filterOptions(keyword, getSchema("element_styles"), syncValue, syncValueName);
            foundOptions = __spreadValues(__spreadValues({}, foundOptions), childOptions);
          }
          if (optionConfig.child_options && Object.keys(optionConfig.child_options).length > 0) {
            const childOptions = filterOptions(keyword, optionConfig.child_options, syncValue, syncValueName);
            foundOptions = __spreadValues(__spreadValues({}, foundOptions), childOptions);
          }
        });
        return foundOptions;
      }
      function getInnerStyleName(id) {
        if (id === "pseudo_selectors") {
          return void 0;
        }
        return computedStyleOptionsSchema.value._styles.child_options[id] !== void 0 ? computedStyleOptionsSchema.value._styles.child_options[id].title : allOptionsSchema.value[id] !== void 0 ? allOptionsSchema.value[id].title : void 0;
      }
      function toggleSearchIcon() {
        searchActive.value = !searchActive.value;
        if (!searchActive.value) {
          changeTab("general");
        } else {
          changeTab("search");
        }
        optionsFilterKeyword.value = "";
      }
      function changeTab(tabId2) {
        activeKeyTab.value = tabId2;
        if (tabId2 !== "search") {
          lastTab.value = activeKeyTab.value;
          optionsFilterKeyword.value = "";
        }
      }
      function closeOptionsPanel() {
        UIStore.closePanel(props.panel.id);
        UIStore.unEditElement();
      }
      return (_ctx, _cache) => {
        const _component_Icon = Vue.resolveComponent("Icon");
        const _component_OptionsForm = Vue.resolveComponent("OptionsForm");
        const _component_Tab = Vue.resolveComponent("Tab");
        const _component_BaseInput = Vue.resolveComponent("BaseInput");
        const _component_Tabs = Vue.resolveComponent("Tabs");
        return Vue.unref(UIStore).editedElement ? (Vue.openBlock(), Vue.createBlock(_sfc_main$z, {
          key: 0,
          class: Vue.normalizeClass(["znpb-element-options__panel-wrapper", {
            "znpb-element-options__panel-wrapper--hidden": isPanelHidden.value
          }]),
          "panel-id": __props.panel.id,
          "show-expand": false,
          "allow-horizontal-resize": !isPanelHidden.value,
          "allow-vertical-resize": !isPanelHidden.value,
          panel: __props.panel,
          style: Vue.normalizeStyle(Vue.unref(panelStyles)),
          onClosePanel: closeOptionsPanel
        }, {
          "before-header": Vue.withCtx(() => [
            Vue.createElementVNode("div", {
              class: "znpb-element-options__hide",
              onClick: _cache[0] || (_cache[0] = Vue.withModifiers(($event) => isPanelHidden.value = !isPanelHidden.value, ["stop"]))
            }, [
              Vue.createVNode(_component_Icon, {
                icon: "select",
                class: Vue.normalizeClass(["znpb-element-options__hideIcon", {
                  "znpb-element-options__hide--hidden": isPanelHidden.value
                }])
              }, null, 8, ["class"])
            ])
          ]),
          header: Vue.withCtx(() => {
            var _a3;
            return [
              Vue.createElementVNode("div", _hoisted_1$e, [
                ((_a3 = Vue.unref(UIStore).editedElement) == null ? void 0 : _a3.elementDefinition.is_child) ? (Vue.openBlock(), Vue.createElementBlock("div", {
                  key: 0,
                  class: "znpb-element-options__header-back",
                  onClick: onBackButtonClick
                }, [
                  Vue.createVNode(_component_Icon, {
                    class: "znpb-element-options__header-back-icon",
                    icon: "select"
                  })
                ])) : Vue.createCommentVNode("", true),
                Vue.createElementVNode("h4", {
                  class: "znpb-panel__header-name",
                  onClick: onBackButtonClick,
                  onMouseenter: _cache[1] || (_cache[1] = ($event) => showBreadcrumbs.value = true),
                  onMouseleave: _cache[2] || (_cache[2] = ($event) => showBreadcrumbs.value = false)
                }, [
                  Vue.createTextVNode(Vue.toDisplayString(`${Vue.unref(contentStore).getElementName(Vue.unref(UIStore).editedElement)} ${Vue.unref(translate)("options")}`) + " ", 1),
                  Vue.createVNode(_component_Icon, { icon: "select" }),
                  showBreadcrumbs.value ? (Vue.openBlock(), Vue.createBlock(_sfc_main$h, {
                    key: 0,
                    element: Vue.unref(UIStore).editedElement
                  }, null, 8, ["element"])) : Vue.createCommentVNode("", true)
                ], 32)
              ])
            ];
          }),
          default: Vue.withCtx(() => [
            Vue.createElementVNode("div", _hoisted_2$c, [
              Vue.createVNode(_component_Tabs, {
                activeTab: activeKeyTab.value,
                "onUpdate:activeTab": _cache[8] || (_cache[8] = ($event) => activeKeyTab.value = $event),
                "has-scroll": ["general", "advanced"],
                class: "znpb-element-options__tabs-wrapper"
              }, {
                default: Vue.withCtx(() => [
                  Vue.createVNode(_component_Tab, { name: "General" }, {
                    default: Vue.withCtx(() => [
                      Vue.unref(UIStore).editedElement.elementDefinition.options && Object.keys(Vue.unref(UIStore).editedElement.elementDefinition.options).length > 0 ? (Vue.openBlock(), Vue.createBlock(_component_OptionsForm, {
                        key: 0,
                        modelValue: Vue.unref(elementOptions),
                        "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => Vue.isRef(elementOptions) ? elementOptions.value = $event : null),
                        class: "znpb-element-options-content-form znpb-fancy-scrollbar",
                        schema: Vue.unref(UIStore).editedElement.elementDefinition.options,
                        replacements: optionsReplacements
                      }, null, 8, ["modelValue", "schema"])) : (Vue.openBlock(), Vue.createElementBlock("p", _hoisted_3$a, Vue.toDisplayString(Vue.unref(translate)("element_has_no_specific_options")), 1))
                    ]),
                    _: 1
                  }),
                  Vue.unref(UserStore).userCanEditContent ? (Vue.openBlock(), Vue.createBlock(_component_Tab, {
                    key: 0,
                    name: "Styling"
                  }, {
                    default: Vue.withCtx(() => [
                      Vue.createVNode(_component_OptionsForm, {
                        modelValue: Vue.unref(computedStyleOptions),
                        "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => Vue.isRef(computedStyleOptions) ? computedStyleOptions.value = $event : null),
                        class: "znpb-fancy-scrollbar",
                        schema: Vue.unref(computedStyleOptionsSchema),
                        replacements: optionsReplacements
                      }, null, 8, ["modelValue", "schema"])
                    ]),
                    _: 1
                  })) : Vue.createCommentVNode("", true),
                  Vue.unref(UserStore).userCanEditContent ? (Vue.openBlock(), Vue.createBlock(_component_Tab, {
                    key: 1,
                    name: "Advanced"
                  }, {
                    default: Vue.withCtx(() => [
                      Vue.createVNode(_component_OptionsForm, {
                        modelValue: Vue.unref(advancedOptionsModel),
                        "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => Vue.isRef(advancedOptionsModel) ? advancedOptionsModel.value = $event : null),
                        class: "znpb-element-options-content-form znpb-fancy-scrollbar",
                        schema: Vue.unref(getSchema)("element_advanced"),
                        replacements: optionsReplacements
                      }, null, 8, ["modelValue", "schema"])
                    ]),
                    _: 1
                  })) : Vue.createCommentVNode("", true),
                  Vue.unref(UserStore).userCanEditContent ? (Vue.openBlock(), Vue.createBlock(_component_Tab, {
                    key: 2,
                    name: "Search"
                  }, {
                    title: Vue.withCtx(() => [
                      Vue.createElementVNode("div", {
                        class: "znpb-element-options__search-tab-title",
                        onClick: Vue.withModifiers(toggleSearchIcon, ["stop"])
                      }, [
                        Vue.createVNode(_component_Icon, { icon: Vue.unref(searchIcon) }, null, 8, ["icon"])
                      ], 8, _hoisted_4$8),
                      searchActive.value ? (Vue.openBlock(), Vue.createBlock(_component_BaseInput, {
                        key: 0,
                        ref_key: "searchInput",
                        ref: searchInput,
                        modelValue: optionsFilterKeyword.value,
                        "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => optionsFilterKeyword.value = $event),
                        filterable: true,
                        placeholder: "Search option",
                        class: "znpb-tabs__header-item-search-options"
                      }, null, 8, ["modelValue"])) : Vue.createCommentVNode("", true)
                    ]),
                    default: Vue.withCtx(() => [
                      optionsFilterKeyword.value.length > 2 && Object.keys(Vue.unref(filteredOptions)).length === 0 ? (Vue.openBlock(), Vue.createElementBlock("p", _hoisted_5$6, Vue.toDisplayString(Vue.unref(translate)("no_options_found")), 1)) : Vue.createCommentVNode("", true),
                      optionsFilterKeyword.value.length < 3 ? (Vue.openBlock(), Vue.createElementBlock("p", _hoisted_6$6, Vue.toDisplayString(defaultMessage.value), 1)) : Vue.createCommentVNode("", true),
                      Vue.createVNode(_component_OptionsForm, {
                        modelValue: Vue.unref(elementOptions),
                        "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => Vue.isRef(elementOptions) ? elementOptions.value = $event : null),
                        class: "znpb-element-options-content-form znpb-fancy-scrollbar",
                        schema: Vue.unref(filteredOptions)
                      }, null, 8, ["modelValue", "schema"])
                    ]),
                    _: 1
                  })) : Vue.createCommentVNode("", true)
                ]),
                _: 1
              }, 8, ["activeTab"])
            ])
          ]),
          _: 1
        }, 8, ["class", "panel-id", "allow-horizontal-resize", "allow-vertical-resize", "panel", "style"])) : Vue.createCommentVNode("", true);
      };
    }
  });
  var CategoriesLibraryItem_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$d = ["innerHTML"];
  const _hoisted_2$b = {
    key: 0,
    class: "znpb-editor-library-modal-category__number"
  };
  const _sfc_main$f = /* @__PURE__ */ Vue.defineComponent({
    __name: "CategoriesLibraryItem",
    props: {
      category: null,
      isActive: { type: Boolean },
      showCount: { type: Boolean },
      onCategoryActivate: null
    },
    setup(__props) {
      const props = __props;
      const hasSubcategories = Vue.computed(() => {
        return props.category.subcategories && props.category.subcategories.length > 0;
      });
      const activeDropdown = Vue.ref(props.isActive);
      Vue.watch(
        () => props.isActive,
        (newValue) => {
          activeDropdown.value = newValue;
        }
      );
      return (_ctx, _cache) => {
        const _component_Icon = Vue.resolveComponent("Icon");
        return Vue.openBlock(), Vue.createElementBlock("li", {
          class: Vue.normalizeClass(["znpb-editor-library-modal-category__item", { "znpb-editor-library-modal-category__item--active": __props.category.isActive }])
        }, [
          Vue.createElementVNode("div", {
            class: "znpb-editor-library-modal-category__header",
            onClick: _cache[1] || (_cache[1] = ($event) => __props.onCategoryActivate(__props.category))
          }, [
            Vue.createElementVNode("h6", {
              class: "znpb-editor-library-modal-category__title",
              innerHTML: __props.category.name
            }, null, 8, _hoisted_1$d),
            __props.showCount ? (Vue.openBlock(), Vue.createElementBlock("span", _hoisted_2$b, Vue.toDisplayString(__props.category.count), 1)) : Vue.createCommentVNode("", true),
            Vue.unref(hasSubcategories) ? (Vue.openBlock(), Vue.createBlock(_component_Icon, {
              key: 1,
              icon: "select",
              rotate: activeDropdown.value ? "180" : "0",
              class: "znpb-editor-library-modal-category__header-icon",
              onClick: _cache[0] || (_cache[0] = Vue.withModifiers(($event) => activeDropdown.value = !activeDropdown.value, ["stop"]))
            }, null, 8, ["rotate"])) : Vue.createCommentVNode("", true)
          ]),
          Vue.unref(hasSubcategories) && activeDropdown.value ? (Vue.openBlock(), Vue.createBlock(_sfc_main$e, {
            key: 0,
            categories: __props.category.subcategories,
            "on-category-activate": __props.onCategoryActivate
          }, null, 8, ["categories", "on-category-activate"])) : Vue.createCommentVNode("", true)
        ], 2);
      };
    }
  });
  var CategoriesLibrary_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$c = { class: "znpb-editor-library-modal-category-list znpb-fancy-scrollbar" };
  const _sfc_main$e = /* @__PURE__ */ Vue.defineComponent({
    __name: "CategoriesLibrary",
    props: {
      categories: null,
      onCategoryActivate: null
    },
    setup(__props) {
      const props = __props;
      function activateCategory(category) {
        props.onCategoryActivate(category);
      }
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("ul", _hoisted_1$c, [
          (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList(__props.categories, (category) => {
            return Vue.openBlock(), Vue.createBlock(_sfc_main$f, {
              key: category.term_id,
              category,
              "is-active": category.isActive,
              "on-category-activate": __props.onCategoryActivate,
              onActivateSubcategory: activateCategory
            }, null, 8, ["category", "is-active", "on-category-activate"]);
          }), 128))
        ]);
      };
    }
  });
  let queue = [];
  let processing = false;
  const failTime = 1e4;
  function useThumbnailGeneration() {
    function generateScreenshot(item) {
      item.loadingThumbnail = true;
      addToQueue(item);
      if (processing) {
        return;
      }
      processing = true;
      let iframe = generateIframe(item);
      iframe.contentWindow.addEventListener("message", onMessageReceived);
      const failTimeout = setTimeout(() => {
        finish(item);
      }, failTime);
      function onMessageReceived(event2) {
        if (event2.data && event2.data.type === "zionbuilder-screenshot") {
          const {
            success,
            thumbnail
          } = event2.data;
          if (success) {
            item.thumbnail = thumbnail;
          } else {
            item.thumbnail_load_failed = true;
          }
          item.saveThumbnailData(event2.data);
          finish(item);
        }
      }
      function finish(item2) {
        item2.loadingThumbnail = false;
        iframe.contentWindow.removeEventListener("message", onMessageReceived);
        iframe.parentNode.removeChild(iframe);
        iframe = null;
        processing = false;
        clearTimeout(failTimeout);
        removeFromQueue(item2);
        if (typeof queue[0] !== "undefined") {
          generateScreenshot(queue[0]);
        }
      }
    }
    function addToQueue(item) {
      const itemIndex = queue.indexOf(item);
      if (itemIndex === -1) {
        queue.push(item);
      }
    }
    function removeFromQueue(item) {
      const itemIndex = queue.indexOf(item);
      if (itemIndex !== -1) {
        queue.splice(itemIndex, 1);
      }
    }
    function generateIframe(item) {
      const iframeElement = document.createElement("iframe");
      iframeElement.src = item.urls.screenshot_generation_url;
      iframeElement.width = 1920;
      iframeElement.height = 1080;
      iframeElement.style = "visibility: hidden;";
      document.body.appendChild(iframeElement);
      return iframeElement;
    }
    return {
      generateScreenshot,
      removeFromQueue
    };
  }
  var LibraryItem_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$d = {
    name: "LibraryItem",
    props: {
      item: {
        type: Object,
        required: false
      },
      favorite: {
        type: Boolean,
        required: false
      },
      inView: {
        type: Boolean,
        required: false,
        default: false
      }
    },
    setup(props, { emit }) {
      const Library = Vue.inject("Library");
      const { editorData: editorData2 } = useEditorData();
      const isProActive = editorData2.value.plugin_info.is_pro_active;
      const isProInstalled = editorData2.value.plugin_info.is_pro_installed;
      const dashboardURL = Vue.ref("");
      const purchaseURL = Vue.ref("");
      const imageHolder = Vue.ref(null);
      const root2 = Vue.ref(null);
      dashboardURL.value = `${editorData2.value.urls.zion_admin}#/pro-license`;
      purchaseURL.value = editorData2.value.urls.purchase_url;
      const iObserver = new IntersectionObserver(onItemInView);
      const image = Vue.computed(() => {
        return props.item.thumbnail;
      });
      if (props.item.librarySource.type === "local" && props.item.thumbnail.length === 0 && !props.item.thumbnail_failed) {
        const { generateScreenshot, removeFromQueue } = useThumbnailGeneration();
        generateScreenshot(props.item);
        Vue.onBeforeUnmount(() => {
          removeFromQueue(props.item);
        });
      }
      function onItemInView(entries) {
        entries.forEach(({ isIntersecting }) => {
          if (!isIntersecting) {
            return;
          }
          if (props.item.thumbnail) {
            imageHolder.value.src = imageHolder.value.getAttribute("data-zbg");
          }
          iObserver.unobserve(root2.value);
        });
      }
      Vue.watch(
        () => props.item.thumbnail,
        (newValue) => {
          iObserver.observe(root2.value);
        }
      );
      Vue.onMounted(() => {
        iObserver.observe(root2.value);
      });
      Vue.onBeforeUnmount(() => {
        if (root2.value) {
          iObserver.unobserve(root2.value);
        }
      });
      const itemMenuActions = Vue.computed(() => {
        if (!props.item.librarySource.id === "local_library") {
          return [];
        }
        return [
          {
            title: translate("edit_template"),
            action: () => {
              return window.open(props.item.urls.edit_url, "_blank").focus();
            },
            icon: "edit"
          },
          {
            title: translate("export_template"),
            action: () => {
              props.item.export();
            },
            icon: "export"
          },
          {
            title: translate("regenerate_screenshot"),
            action: () => {
              const { generateScreenshot } = useThumbnailGeneration();
              generateScreenshot(props.item);
            },
            icon: "export"
          },
          {
            title: translate("delete_template"),
            action: () => {
              props.item.delete();
            },
            icon: "delete"
          }
        ];
      });
      function onMouseOver(event2) {
        const { height } = event2.target.getBoundingClientRect();
        if (height > 200) {
          const newTop = height - 200;
          event2.target.style.top = `-${newTop}px`;
        }
      }
      function onMouseOut(event2) {
        event2.target.style.top = null;
      }
      return {
        imageHolder,
        root: root2,
        purchaseURL,
        dashboardURL,
        isProInstalled,
        isProActive,
        Library,
        image,
        itemMenuActions,
        onMouseOver,
        onMouseOut
      };
    },
    data() {
      return {
        insertItemLoading: false
      };
    },
    methods: {
      insertLibraryItem() {
        this.insertItemLoading = true;
        this.Library.insertItem(this.item).then(() => {
        }).finally(() => {
          this.insertItemLoading = false;
        });
      }
    }
  };
  const _hoisted_1$b = { class: "znpb-editor-library-modal__itemInner" };
  const _hoisted_2$a = ["data-zbg"];
  const _hoisted_3$9 = {
    key: 0,
    class: "znpb-editor-library-modal__item-pro"
  };
  const _hoisted_4$7 = { class: "znpb-editor-library-modal__item-bottom" };
  const _hoisted_5$5 = ["title"];
  const _hoisted_6$5 = {
    key: 0,
    class: "znpb-editor-library-modal__item-actions"
  };
  const _hoisted_7$5 = ["href"];
  const _hoisted_8$5 = ["href"];
  const _hoisted_9$4 = {
    key: 1,
    class: "znpb-editor-library-modal__item-bottom-multiple"
  };
  function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Loader = Vue.resolveComponent("Loader");
    const _component_Icon = Vue.resolveComponent("Icon");
    const _component_HiddenMenu = Vue.resolveComponent("HiddenMenu");
    const _directive_znpb_tooltip = Vue.resolveDirective("znpb-tooltip");
    return Vue.openBlock(), Vue.createElementBlock("li", {
      ref: "root",
      class: Vue.normalizeClass(["znpb-editor-library-modal__item", { "znpb-editor-library-modal__item--favorite": $props.favorite }])
    }, [
      Vue.createElementVNode("div", _hoisted_1$b, [
        Vue.createElementVNode("div", {
          class: Vue.normalizeClass(["znpb-editor-library-modal__item-image", { ["--no-image"]: !$props.item.thumbnail && !$props.item.loadingThumbnail }]),
          onClick: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("activate-item", $props.item))
        }, [
          $props.item.loadingThumbnail ? (Vue.openBlock(), Vue.createBlock(_component_Loader, { key: 0 })) : $props.item.thumbnail ? (Vue.openBlock(), Vue.createElementBlock("img", {
            key: 1,
            ref: "imageHolder",
            class: "znpb-editor-library-modal__item-imageTag",
            src: "",
            "data-zbg": $setup.image,
            onMouseover: _cache[0] || (_cache[0] = (...args) => $setup.onMouseOver && $setup.onMouseOver(...args)),
            onMouseout: _cache[1] || (_cache[1] = (...args) => $setup.onMouseOut && $setup.onMouseOut(...args))
          }, null, 40, _hoisted_2$a)) : Vue.createCommentVNode("", true)
        ], 2),
        $props.item.pro ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_3$9, Vue.toDisplayString(_ctx.$translate("pro")), 1)) : Vue.createCommentVNode("", true),
        Vue.createElementVNode("div", _hoisted_4$7, [
          Vue.createElementVNode("h4", {
            class: "znpb-editor-library-modal__item-title",
            title: $props.item.name
          }, Vue.toDisplayString($props.item.name), 9, _hoisted_5$5),
          !$data.insertItemLoading && !$props.item.loading ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_6$5, [
            $setup.isProInstalled && !$setup.isProActive && $props.item.pro ? (Vue.openBlock(), Vue.createElementBlock("a", {
              key: 0,
              class: "znpb-button znpb-button--line",
              target: "_blank",
              href: $setup.dashboardURL
            }, Vue.toDisplayString(_ctx.$translate("activate_pro")), 9, _hoisted_7$5)) : !$setup.isProInstalled && $props.item.pro ? (Vue.openBlock(), Vue.createElementBlock("a", {
              key: 1,
              class: "znpb-button znpb-button--line",
              href: $setup.purchaseURL,
              target: "_blank"
            }, Vue.toDisplayString(_ctx.$translate("buy_pro")), 9, _hoisted_8$5)) : Vue.withDirectives((Vue.openBlock(), Vue.createElementBlock("span", {
              key: 2,
              class: "znpb-button znpb-button--line znpb-editor-library-modal__item-action",
              onClick: _cache[3] || (_cache[3] = Vue.withModifiers((...args) => $options.insertLibraryItem && $options.insertLibraryItem(...args), ["stop"]))
            }, [
              Vue.createTextVNode(Vue.toDisplayString(_ctx.$translate("library_insert")), 1)
            ])), [
              [_directive_znpb_tooltip, _ctx.$translate("library_insert_tooltip")]
            ]),
            Vue.withDirectives(Vue.createVNode(_component_Icon, {
              icon: "eye",
              class: "znpb-editor-library-modal__item-action",
              onClick: _cache[4] || (_cache[4] = ($event) => _ctx.$emit("activate-item", $props.item))
            }, null, 512), [
              [_directive_znpb_tooltip, _ctx.$translate("library_click_preview_tooltip")]
            ]),
            $props.item.librarySource.id === "local_library" ? (Vue.openBlock(), Vue.createBlock(_component_HiddenMenu, {
              key: 3,
              class: "znpb-editor-library-modal__item-action",
              actions: $setup.itemMenuActions
            }, null, 8, ["actions"])) : Vue.createCommentVNode("", true)
          ])) : (Vue.openBlock(), Vue.createBlock(_component_Loader, {
            key: 1,
            size: 12
          }))
        ]),
        $props.item.type === "multiple" ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_9$4)) : Vue.createCommentVNode("", true)
      ])
    ], 2);
  }
  var LibraryItem = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["render", _sfc_render$6]]);
  var LibraryPanel_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$c = {
    name: "LibraryPanel",
    components: {
      CategoriesLibrary: _sfc_main$e,
      LibraryItem
    },
    props: {
      previewOpen: {
        type: Boolean,
        required: false
      },
      libraryConfig: {
        type: Object,
        required: true
      }
    },
    setup(props, { emit }) {
      const allCategoyConfig = {
        name: translate("all"),
        slug: "zion-category-all",
        term_id: "3211329987745",
        isActive: true
      };
      const searchInput = Vue.ref(null);
      const libraryItems = Vue.computed(() => props.libraryConfig.items.sort((a, b) => new Date(b.date) - new Date(a.date)));
      const libraryCategories = Vue.computed(() => props.libraryConfig.categories);
      const activeCategory = Vue.ref(allCategoyConfig);
      const sortAscending = Vue.ref(false);
      const searchKeyword = Vue.ref("");
      const activeItem = Vue.ref(null);
      const computedAllCategories = Vue.computed(() => {
        const categories = [];
        categories.push(allCategoyConfig);
        categories.push(...libraryCategories.value);
        return categories;
      });
      const computedLibraryCategories = Vue.computed(() => {
        const categories = [];
        let filteredCategories = computedAllCategories.value;
        if (searchKeyword.value.length > 0) {
          filteredCategories = computedAllCategories.value.filter((category) => {
            return category.term_id === allCategoyConfig.term_id || filteredItemsCategories.value.includes(category.term_id);
          });
        }
        filteredCategories.forEach((category) => {
          if (!category.parent) {
            categories.push(createNestedCategories(category, filteredCategories));
          }
        });
        return categories;
      });
      function createNestedCategories(categoryConfig, allCategories) {
        const subcategories = [];
        allCategories.forEach((subcategory) => {
          if (subcategory.parent && subcategory.parent === categoryConfig.term_id) {
            subcategories.push(createNestedCategories(subcategory, allCategories));
          }
        });
        if (subcategories.length > 0) {
          categoryConfig.subcategories = subcategories;
        }
        return categoryConfig;
      }
      const numberOfElements = Vue.computed(() => {
        return `(${filteredItems.value.length})`;
      });
      const libraryTitle = Vue.computed(() => {
        return activeCategory.value.name;
      });
      const filteredItemsBySearchKeyword = Vue.computed(() => {
        let items2 = libraryItems.value;
        if (searchKeyword.value.length > 0) {
          items2 = libraryItems.value.filter((item) => {
            let name = item.name.toLowerCase();
            if (name.includes(searchKeyword.value.toLowerCase())) {
              return true;
            } else {
              item.tags.forEach(function(tag, index2) {
                if (tag.includes(searchKeyword.value.toLowerCase())) {
                  return true;
                }
              });
            }
            return false;
          });
        }
        return items2;
      });
      const filteredItems = Vue.computed(() => {
        let items2 = filteredItemsBySearchKeyword.value.filter((item) => {
          return activeCategory.value.term_id === allCategoyConfig.term_id || item.category.includes(activeCategory.value.term_id);
        });
        if (sortAscending.value) {
          items2 = [...items2].reverse();
        }
        return items2;
      });
      const filteredItemsCategories = Vue.computed(() => {
        const activeCategories = [];
        filteredItemsBySearchKeyword.value.forEach((item) => {
          activeCategories.push(...item.category);
        });
        return uniq(activeCategories);
      });
      Vue.watchEffect(() => {
        if (props.libraryConfig.loading === false) {
          Vue.nextTick(() => {
            searchInput.value.focus();
          });
        }
      });
      Vue.watch(searchKeyword, (newValue) => {
        if (newValue.length > 0) {
          const activeCategoryValid = computedLibraryCategories.value.find(
            (category) => category.term_id === activeCategory.value.term_id
          );
          if (!activeCategoryValid) {
            onCategoryActivate(allCategoyConfig);
          }
        }
      });
      function onCategoryActivate(category) {
        computedAllCategories.value.forEach((item) => item.isActive = false);
        category.isActive = true;
        let currentCategory = category;
        while (currentCategory && currentCategory.parent) {
          const parentCategory = computedAllCategories.value.find(
            (category2) => category2.term_id === currentCategory.parent
          );
          if (parentCategory) {
            parentCategory.isActive = true;
            currentCategory = parentCategory;
          }
        }
        activeCategory.value = category;
      }
      return {
        searchInput,
        libraryItems,
        activeCategory,
        sortAscending,
        searchKeyword,
        activeItem,
        computedLibraryCategories,
        numberOfElements,
        filteredItems,
        libraryTitle,
        onCategoryActivate
      };
    }
  };
  const _hoisted_1$a = {
    key: 1,
    class: "znpb-editor-library-modal"
  };
  const _hoisted_2$9 = { class: "znpb-editor-library-modal-sidebar" };
  const _hoisted_3$8 = { class: "znpb-editor-library-modal-sidebar-search" };
  const _hoisted_4$6 = { class: "znpb-editor-library-modal-body" };
  const _hoisted_5$4 = { class: "znpb-editor-library-modal-subheader" };
  const _hoisted_6$4 = { class: "znpb-editor-library-modal-subheader__left" };
  const _hoisted_7$4 = { class: "znpb-editor-library-modal-subheader__left-title" };
  const _hoisted_8$4 = { class: "znpb-editor-library-modal-subheader__left-number" };
  const _hoisted_9$3 = { class: "znpb-editor-library-modal-subheader__right" };
  const _hoisted_10$3 = { class: "znpb-editor-library-modal-column-wrapper znpb-fancy-scrollbar" };
  const _hoisted_11$2 = { class: "znpb-editor-library-modal-item-list" };
  const _hoisted_12$1 = {
    key: 0,
    class: "znpb-editor-library-modal-no-more"
  };
  const _hoisted_13$1 = {
    key: 0,
    class: "znpb-editor-library-modal-preview znpb-fancy-scrollbar"
  };
  const _hoisted_14 = ["src"];
  function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Loader = Vue.resolveComponent("Loader");
    const _component_BaseInput = Vue.resolveComponent("BaseInput");
    const _component_CategoriesLibrary = Vue.resolveComponent("CategoriesLibrary");
    const _component_Icon = Vue.resolveComponent("Icon");
    const _component_LibraryItem = Vue.resolveComponent("LibraryItem");
    return $props.libraryConfig.loading ? (Vue.openBlock(), Vue.createBlock(_component_Loader, {
      key: 0,
      class: "znpb-editor-library-modal-loader"
    })) : (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$a, [
      Vue.createElementVNode("div", _hoisted_2$9, [
        Vue.createElementVNode("div", _hoisted_3$8, [
          Vue.createVNode(_component_BaseInput, {
            ref: "searchInput",
            modelValue: $setup.searchKeyword,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.searchKeyword = $event),
            icon: "search",
            clearable: true,
            placeholder: _ctx.$translate("search_library")
          }, null, 8, ["modelValue", "placeholder"])
        ]),
        Vue.createVNode(_component_CategoriesLibrary, {
          categories: $setup.computedLibraryCategories,
          "on-category-activate": $setup.onCategoryActivate
        }, null, 8, ["categories", "on-category-activate"])
      ]),
      Vue.createElementVNode("div", _hoisted_4$6, [
        Vue.createElementVNode("div", _hoisted_5$4, [
          Vue.createElementVNode("div", _hoisted_6$4, [
            Vue.createElementVNode("h3", _hoisted_7$4, Vue.toDisplayString($setup.libraryTitle), 1),
            Vue.createElementVNode("span", _hoisted_8$4, Vue.toDisplayString($setup.numberOfElements), 1)
          ]),
          Vue.createElementVNode("div", _hoisted_9$3, [
            Vue.createElementVNode("div", {
              class: "znpb-editor-library-modal-subheader__action-title",
              onClick: _cache[1] || (_cache[1] = ($event) => $setup.sortAscending = !$setup.sortAscending)
            }, [
              Vue.createVNode(_component_Icon, { icon: "reverse-y" }),
              Vue.createTextVNode(Vue.toDisplayString(_ctx.$translate("sort")), 1)
            ])
          ])
        ]),
        Vue.createElementVNode("div", _hoisted_10$3, [
          Vue.createElementVNode("ul", _hoisted_11$2, [
            (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList($setup.filteredItems, (item) => {
              return Vue.openBlock(), Vue.createBlock(_component_LibraryItem, {
                key: item.id,
                item,
                onActivateItem: ($event) => (_ctx.$emit("activate-preview", item), $setup.activeItem = item)
              }, null, 8, ["item", "onActivateItem"]);
            }), 128))
          ]),
          $setup.searchKeyword.length > 0 && $setup.filteredItems.length === 0 ? (Vue.openBlock(), Vue.createElementBlock("p", _hoisted_12$1, Vue.toDisplayString(_ctx.$translate("no_more_to_show")), 1)) : Vue.createCommentVNode("", true)
        ])
      ]),
      Vue.createVNode(Vue.Transition, { name: "slide-preview" }, {
        default: Vue.withCtx(() => [
          $props.previewOpen && $setup.activeItem ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_13$1, [
            Vue.createElementVNode("iframe", {
              id: "znpb-editor-library-modal-preview-iframe",
              frameborder: "0",
              src: $setup.activeItem.urls.preview_url
            }, "\n				", 8, _hoisted_14)
          ])) : Vue.createCommentVNode("", true)
        ]),
        _: 1
      })
    ]));
  }
  var LibraryPanel = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["render", _sfc_render$5]]);
  var LibraryUploader_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$b = {
    name: "LibraryUploader",
    props: {
      noMargin: {
        type: Boolean,
        required: false,
        default: false
      }
    },
    setup() {
      return {};
    },
    data() {
      return {
        isInitial: true,
        isSaving: false,
        errorMessage: ""
      };
    },
    mounted() {
      let dropArea = this.$refs.formupload;
      dropArea.addEventListener("dragenter", this.highlightForm);
      dropArea.addEventListener("dragleave", this.dragOut);
      dropArea.addEventListener("dragover", this.highlightForm);
      dropArea.addEventListener("drop", this.dragDropped);
    },
    beforeUnmount() {
      let dropArea = this.$refs.formupload;
      dropArea.removeEventListener("dragenter", this.highlightForm);
      dropArea.removeEventListener("dragleave", this.dragOut);
      dropArea.removeEventListener("dragover", this.highlightForm);
      dropArea.removeEventListener("drop", this.dragDropped);
    },
    methods: {
      highlightForm() {
        this.isInitial = false;
      },
      dragOut() {
        this.isInitial = true;
      },
      dragDropped() {
        this.isInitial = true;
      },
      uploadFiles(fieldName, fileList) {
        const formData = new FormData();
        if (!fileList.length)
          return;
        Array.from(fileList).forEach((file) => {
          formData.append(fieldName, file, file.name);
        });
        this.saveFile(formData);
      },
      saveFile(formData) {
        const { getSource } = useLibrary();
        const localLibrary = getSource("local_library");
        if (!localLibrary) {
          console.warn(
            "Local library was not registered. It may be possible that a plugin is removing the default library."
          );
          return;
        }
        this.isSaving = true;
        this.errorMessage = "";
        localLibrary.importItem(formData).catch((error) => {
          console.error(error);
          if (typeof error.response.data === "string") {
            this.errorMessage = error.response.data;
          } else
            this.errorMessage = this.arrayBufferToString(error.response.data);
        }).finally(() => {
          this.isSaving = false;
          this.isInitial = true;
          this.$emit("file-uploaded", true);
        });
      },
      decode_utf8(s) {
        let obj = JSON.parse(s);
        return decodeURIComponent(escape(obj.message));
      },
      arrayBufferToString(buffer) {
        var s = String.fromCharCode.apply(null, new Uint8Array(buffer));
        return this.decode_utf8(s);
      }
    }
  };
  const _hoisted_1$9 = {
    id: "znpb-upload-form-library",
    enctype: "multipart/form-data",
    novalidate: ""
  };
  const _hoisted_2$8 = /* @__PURE__ */ Vue.createElementVNode("div", { class: "znpb-empty-list__border-top-bottom" }, null, -1);
  const _hoisted_3$7 = /* @__PURE__ */ Vue.createElementVNode("div", { class: "znpb-empty-list__border-left-right" }, null, -1);
  const _hoisted_4$5 = { class: "znpb-empty-list__content" };
  const _hoisted_5$3 = { class: "znpb-editor-library-upload__text" };
  const _hoisted_6$3 = { class: "" };
  const _hoisted_7$3 = {
    key: 1,
    class: "znpb-library-uploading-wrapper"
  };
  const _hoisted_8$3 = { class: "znpb-library-uploading-wrapper__text" };
  const _hoisted_9$2 = /* @__PURE__ */ Vue.createElementVNode("br", null, null, -1);
  const _hoisted_10$2 = ["disabled"];
  const _hoisted_11$1 = { key: 3 };
  function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Icon = Vue.resolveComponent("Icon");
    const _component_Loader = Vue.resolveComponent("Loader");
    return Vue.openBlock(), Vue.createElementBlock("form", _hoisted_1$9, [
      Vue.createElementVNode("div", {
        class: Vue.normalizeClass(["znpb-empty-list__container znpb-editor-library-upload", { "znpb-editor-library-upload--dragging": !$data.isInitial }])
      }, [
        _hoisted_2$8,
        _hoisted_3$7,
        Vue.createElementVNode("div", _hoisted_4$5, [
          $data.isInitial && !$data.isSaving ? (Vue.openBlock(), Vue.createElementBlock(Vue.Fragment, { key: 0 }, [
            Vue.createVNode(_component_Icon, { icon: "import-big-icon" }),
            Vue.createElementVNode("p", _hoisted_5$3, [
              Vue.createTextVNode(Vue.toDisplayString(_ctx.$translate("drag_drop")) + " ", 1),
              Vue.createElementVNode("span", _hoisted_6$3, Vue.toDisplayString(_ctx.$translate("browse")), 1),
              Vue.createTextVNode(" " + Vue.toDisplayString(_ctx.$translate("for_files")), 1)
            ])
          ], 64)) : Vue.createCommentVNode("", true),
          !$data.isInitial && !$data.isSaving ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_7$3, [
            Vue.createVNode(_component_Icon, {
              icon: "long-arrow-right",
              "bg-size": 68,
              "bg-color": "#06bee1",
              rounded: true,
              color: "#fff",
              size: 21
            }),
            Vue.createElementVNode("p", _hoisted_8$3, [
              Vue.createElementVNode("b", null, Vue.toDisplayString(_ctx.$translate("drop_files")), 1),
              _hoisted_9$2,
              Vue.createTextVNode(" " + Vue.toDisplayString(_ctx.$translate("to_upload")), 1)
            ])
          ])) : Vue.createCommentVNode("", true),
          Vue.createElementVNode("input", {
            ref: "formupload",
            type: "file",
            accept: "zip,application/octet-stream,application/zip,application/x-zip,application/x-zip-compressed",
            multiple: "",
            name: "file",
            disabled: $data.isSaving,
            class: "znpb-library-input-file",
            onChange: _cache[0] || (_cache[0] = ($event) => $options.uploadFiles($event.target.name, $event.target.files))
          }, null, 40, _hoisted_10$2),
          $data.isSaving ? (Vue.openBlock(), Vue.createBlock(_component_Loader, { key: 2 })) : Vue.createCommentVNode("", true),
          $data.errorMessage.length > 0 ? (Vue.openBlock(), Vue.createElementBlock("span", _hoisted_11$1, Vue.toDisplayString($data.errorMessage), 1)) : Vue.createCommentVNode("", true)
        ])
      ], 2)
    ]);
  }
  var LibraryUploader = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["render", _sfc_render$4]]);
  var PanelLibraryModal_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$a = {
    name: "LibraryModal",
    components: {
      LibraryPanel,
      LibraryUploader
    },
    provide() {
      return {
        Library: this
      };
    },
    setup() {
      const { addData, getData } = useLocalStorage();
      const UIStore = useUIStore();
      const { librarySources: librarySources2, getSource } = useLibrary();
      const activeLibraryTab = Vue.ref(getData("libraryActiveSource", "local_library"));
      const { editorData: editorData2 } = useEditorData();
      const isProActive = editorData2.value.plugin_info.is_pro_active;
      const isProInstalled = editorData2.value.plugin_info.is_pro_installed;
      const purchaseURL = Vue.ref(editorData2.value.urls.purchase_url);
      const previewOpen = Vue.ref(false);
      const activeItem = Vue.ref(null);
      const dashboardURL = `${editorData2.value.urls.zion_admin}#/pro-license`;
      function setActiveSource(source, save = true) {
        activeLibraryTab.value = source;
        if (save) {
          addData("libraryActiveSource", source);
        }
      }
      const activeLibraryConfig = Vue.computed(() => {
        return getSource(activeLibraryTab.value) || getSource("local_library");
      });
      Vue.watchEffect(() => {
        if (UIStore.isLibraryOpen) {
          activeLibraryConfig.value.getData();
        }
      });
      function onRefresh() {
        activeLibraryConfig.value.getData(false);
      }
      function activatePreview(item) {
        activeItem.value = item;
        previewOpen.value = true;
      }
      return {
        activeLibraryTab,
        previewOpen,
        activeItem,
        dashboardURL,
        librarySources: librarySources2,
        activeLibraryConfig,
        UIStore,
        editorData: editorData2,
        isProActive,
        isProInstalled,
        purchaseURL,
        setActiveSource,
        onRefresh,
        activatePreview
      };
    },
    data() {
      return {
        importActive: false,
        fullSize: false,
        insertItemLoading: false,
        templateUploaded: false
      };
    },
    computed: {
      computedTitle() {
        return this.previewOpen ? this.activeItem.post_title : this.$translate("import");
      }
    },
    mounted() {
      document.getElementById("znpb-editor-iframe").contentWindow.document.body.style.overflow = "hidden";
    },
    beforeUnmount() {
      document.getElementById("znpb-editor-iframe").contentWindow.document.body.style.overflow = null;
    },
    methods: {
      onTemplateUpload() {
        this.importActive = false;
        this.setActiveSource("local");
        this.templateUploaded = true;
      },
      insertLibraryItem(item) {
        this.insertItemLoading = true;
        this.insertItem(this.activeItem).then(() => {
          this.insertItemLoading = false;
        });
      },
      closeBody() {
        this.previewOpen = false;
        this.importActive = false;
      },
      insertItem(item) {
        return new Promise((resolve, reject) => {
          item.getBuilderData().then((response) => {
            const { template_data: templateData } = response.data;
            let compiledTemplateData = templateData.element_type ? [templateData] : templateData;
            const newElement = regenerateUIDsForContent(compiledTemplateData);
            window.zb.run("editor/elements/add-template", {
              templateContent: newElement
            });
            this.UIStore.toggleLibrary();
            resolve(true);
          }).catch((error) => {
            reject(error);
          });
        });
      }
    }
  };
  const _hoisted_1$8 = { class: "znpb-library-modal-header" };
  const _hoisted_2$7 = {
    key: 1,
    class: "znpb-library-modal-header-preview"
  };
  const _hoisted_3$6 = ["innerHTML"];
  const _hoisted_4$4 = ["onClick"];
  const _hoisted_5$2 = { class: "znpb-library-modal-header__actions" };
  const _hoisted_6$2 = ["href"];
  const _hoisted_7$2 = ["href"];
  const _hoisted_8$2 = { key: 0 };
  function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Icon = Vue.resolveComponent("Icon");
    const _component_Loader = Vue.resolveComponent("Loader");
    const _component_Button = Vue.resolveComponent("Button");
    const _component_LibraryUploader = Vue.resolveComponent("LibraryUploader");
    const _component_LibraryPanel = Vue.resolveComponent("LibraryPanel");
    const _component_Modal = Vue.resolveComponent("Modal");
    const _directive_znpb_tooltip = Vue.resolveDirective("znpb-tooltip");
    return $setup.UIStore.isLibraryOpen ? (Vue.openBlock(), Vue.createBlock(_component_Modal, {
      key: 0,
      fullscreen: $data.fullSize,
      "onUpdate:fullscreen": _cache[3] || (_cache[3] = ($event) => $data.fullSize = $event),
      show: true,
      "append-to": ".znpb-center-area",
      width: 1440,
      class: "znpb-library-modal",
      onCloseModal: $setup.UIStore.closeLibrary
    }, {
      header: Vue.withCtx(() => [
        Vue.createElementVNode("div", _hoisted_1$8, [
          $setup.previewOpen || $data.importActive ? (Vue.openBlock(), Vue.createElementBlock("span", {
            key: 0,
            class: "znpb-library-modal-header-preview__back",
            onClick: _cache[0] || (_cache[0] = Vue.withModifiers((...args) => $options.closeBody && $options.closeBody(...args), ["stop"]))
          }, [
            Vue.createVNode(_component_Icon, {
              icon: "long-arrow-right",
              rotate: "180"
            }),
            Vue.createTextVNode(" " + Vue.toDisplayString(_ctx.$translate("go_back")), 1)
          ])) : Vue.createCommentVNode("", true),
          $setup.previewOpen || $data.importActive ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_2$7, [
            Vue.createElementVNode("h2", {
              class: "znpb-library-modal-header-preview__title",
              innerHTML: $options.computedTitle
            }, null, 8, _hoisted_3$6)
          ])) : (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, { key: 2 }, Vue.renderList($setup.librarySources, (librarySource, sourceID) => {
            return Vue.openBlock(), Vue.createElementBlock("h2", {
              key: sourceID,
              class: Vue.normalizeClass(["znpb-library-modal-header__title", { "znpb-library-modal-header__title--active": $setup.activeLibraryTab === sourceID }]),
              onClick: ($event) => $setup.setActiveSource(sourceID)
            }, Vue.toDisplayString(librarySource.name), 11, _hoisted_4$4);
          }), 128)),
          Vue.createElementVNode("div", _hoisted_5$2, [
            $setup.previewOpen ? (Vue.openBlock(), Vue.createElementBlock(Vue.Fragment, { key: 0 }, [
              $setup.isProInstalled && !$setup.isProActive && $setup.activeItem.pro ? (Vue.openBlock(), Vue.createElementBlock("a", {
                key: 0,
                class: "znpb-button znpb-button--line",
                target: "_blank",
                href: $setup.dashboardURL
              }, Vue.toDisplayString(_ctx.$translate("activate_pro")), 9, _hoisted_6$2)) : !$setup.isProInstalled && $setup.activeItem.pro ? (Vue.openBlock(), Vue.createElementBlock("a", {
                key: 1,
                class: "znpb-button znpb-button--line znpb-button-buy-pro",
                href: $setup.purchaseURL,
                target: "_blank"
              }, Vue.toDisplayString(_ctx.$translate("buy_pro")), 9, _hoisted_7$2)) : Vue.withDirectives((Vue.openBlock(), Vue.createBlock(_component_Button, {
                key: 2,
                type: "secondary",
                class: "znpb-library-modal-header__insert-button",
                onClick: Vue.withModifiers($options.insertLibraryItem, ["stop"])
              }, {
                default: Vue.withCtx(() => [
                  !$data.insertItemLoading ? (Vue.openBlock(), Vue.createElementBlock("span", _hoisted_8$2, Vue.toDisplayString(_ctx.$translate("library_insert")), 1)) : (Vue.openBlock(), Vue.createBlock(_component_Loader, {
                    key: 1,
                    size: 13
                  }))
                ]),
                _: 1
              }, 8, ["onClick"])), [
                [_directive_znpb_tooltip, _ctx.$translate("library_insert_tooltip")]
              ])
            ], 64)) : (Vue.openBlock(), Vue.createElementBlock(Vue.Fragment, { key: 1 }, [
              Vue.createVNode(_component_Button, {
                type: "secondary",
                onClick: _cache[1] || (_cache[1] = ($event) => ($data.importActive = !$data.importActive, $data.templateUploaded = !$data.templateUploaded))
              }, {
                default: Vue.withCtx(() => [
                  Vue.createVNode(_component_Icon, { icon: "import" }),
                  Vue.createTextVNode(" " + Vue.toDisplayString(_ctx.$translate("import")), 1)
                ]),
                _: 1
              }),
              Vue.withDirectives(Vue.createVNode(_component_Icon, {
                icon: "refresh",
                size: 14,
                class: Vue.normalizeClass(["znpb-modal__header-button znpb-modal__header-button--library-refresh znpb-button znpb-button--line", { ["loading"]: $setup.activeLibraryConfig && $setup.activeLibraryConfig.loading }]),
                onClick: $setup.onRefresh
              }, null, 8, ["class", "onClick"]), [
                [_directive_znpb_tooltip, _ctx.$translate("refresh_tooltip")]
              ])
            ], 64)),
            Vue.createVNode(_component_Icon, {
              icon: $data.fullSize ? "shrink" : "maximize",
              class: "znpb-modal__header-button",
              size: 14,
              onClick: _cache[2] || (_cache[2] = Vue.withModifiers(($event) => $data.fullSize = !$data.fullSize, ["stop"]))
            }, null, 8, ["icon"]),
            Vue.createVNode(_component_Icon, {
              icon: "close",
              size: 14,
              class: "znpb-modal__header-button",
              onClick: $setup.UIStore.toggleLibrary
            }, null, 8, ["onClick"])
          ])
        ])
      ]),
      default: Vue.withCtx(() => [
        $data.importActive ? (Vue.openBlock(), Vue.createBlock(_component_LibraryUploader, {
          key: 0,
          onFileUploaded: $options.onTemplateUpload
        }, null, 8, ["onFileUploaded"])) : (Vue.openBlock(), Vue.createBlock(_component_LibraryPanel, {
          ref: "libraryContent",
          key: $setup.activeLibraryConfig.id,
          "preview-open": $setup.previewOpen,
          "library-config": $setup.activeLibraryConfig,
          onActivatePreview: $setup.activatePreview
        }, null, 8, ["preview-open", "library-config", "onActivatePreview"]))
      ]),
      _: 1
    }, 8, ["fullscreen", "onCloseModal"])) : Vue.createCommentVNode("", true);
  }
  var PanelLibraryModal = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["render", _sfc_render$3]]);
  var PostLock_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$7 = { class: "znpb-post-lock-modal" };
  const _hoisted_2$6 = { class: "znpb-post-lock-modal__avatar" };
  const _hoisted_3$5 = ["src"];
  const _hoisted_4$3 = { class: "znpb-post-lock-modal__content" };
  const _hoisted_5$1 = { class: "znpb-post-lock-modal__content-text" };
  const _hoisted_6$1 = {
    key: 0,
    class: "znpb-post-lock-modal__error-message"
  };
  const _hoisted_7$1 = { class: "znpb-post-lock-modal__content-buttons" };
  const _hoisted_8$1 = ["href"];
  const _hoisted_9$1 = ["href"];
  const _hoisted_10$1 = { href: "" };
  const _hoisted_11 = {
    key: 0,
    class: "znpb-post-lock-modal__loader-wrapper"
  };
  const _hoisted_12 = /* @__PURE__ */ Vue.createElementVNode("span", { class: "znpb-post-lock-modal__loader" }, null, -1);
  const _hoisted_13 = [
    _hoisted_12
  ];
  const _sfc_main$9 = /* @__PURE__ */ Vue.defineComponent({
    __name: "PostLock",
    setup(__props) {
      const UserStore = useUserStore();
      const showLoader = Vue.ref(false);
      const showError = Vue.ref(false);
      const pageId = window.ZnPbInitialData.page_id;
      const urls = window.ZnPbInitialData.urls;
      function lockPages() {
        showLoader.value = true;
        lockPage(pageId).then((result) => {
          if (result.status === 200) {
            UserStore.takeOverPost();
          } else if (result.status === 500) {
            showError.value = true;
            console.error(translate("post_could_not_lock"));
          }
        }).finally(() => {
          showLoader.value = false;
        });
      }
      return (_ctx, _cache) => {
        const _component_Button = Vue.resolveComponent("Button");
        const _component_Modal = Vue.resolveComponent("Modal");
        return Vue.unref(UserStore).isPostLocked ? (Vue.openBlock(), Vue.createBlock(_component_Modal, {
          key: 0,
          show: true,
          width: 570,
          "append-to": "body",
          "show-maximize": false,
          "show-close": false
        }, {
          default: Vue.withCtx(() => [
            Vue.createElementVNode("div", _hoisted_1$7, [
              Vue.createElementVNode("div", _hoisted_2$6, [
                Vue.createElementVNode("img", {
                  src: Vue.unref(UserStore).lockedUserInfo.avatar
                }, null, 8, _hoisted_3$5)
              ]),
              Vue.createElementVNode("div", _hoisted_4$3, [
                Vue.createElementVNode("div", _hoisted_5$1, [
                  showError.value ? (Vue.openBlock(), Vue.createElementBlock("p", _hoisted_6$1, Vue.toDisplayString(Vue.unref(translate)("post_could_not_lock")), 1)) : Vue.createCommentVNode("", true),
                  Vue.createElementVNode("p", null, Vue.toDisplayString(Vue.unref(UserStore).lockedUserInfo.message), 1)
                ]),
                Vue.createElementVNode("div", _hoisted_7$1, [
                  Vue.createVNode(_component_Button, { type: "gray" }, {
                    default: Vue.withCtx(() => [
                      Vue.createElementVNode("a", {
                        href: Vue.unref(urls).preview_url
                      }, Vue.toDisplayString(Vue.unref(translate)("post_preview")), 9, _hoisted_8$1)
                    ]),
                    _: 1
                  }),
                  Vue.createVNode(_component_Button, { type: "gray" }, {
                    default: Vue.withCtx(() => [
                      Vue.createElementVNode("a", {
                        href: Vue.unref(urls).all_pages_url
                      }, Vue.toDisplayString(Vue.unref(translate)("post_go_back")), 9, _hoisted_9$1)
                    ]),
                    _: 1
                  }),
                  Vue.createVNode(_component_Button, {
                    type: "gray",
                    onClick: Vue.withModifiers(lockPages, ["prevent"])
                  }, {
                    default: Vue.withCtx(() => [
                      Vue.createElementVNode("a", _hoisted_10$1, Vue.toDisplayString(Vue.unref(translate)("post_take_over")), 1)
                    ]),
                    _: 1
                  }, 8, ["onClick"])
                ])
              ]),
              showLoader.value ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_11, _hoisted_13)) : Vue.createCommentVNode("", true)
            ])
          ]),
          _: 1
        })) : Vue.createCommentVNode("", true);
      };
    }
  });
  var SaveElementModal_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$8 = {
    name: "SaveElementModal",
    setup() {
      const { activeSaveElement: activeSaveElement2, hideSaveElement } = useSaveTemplate();
      const contentStore = useContentStore();
      const formModel = Vue.ref({});
      const computedFormModel = Vue.computed({
        get() {
          return formModel.value;
        },
        set(newValue) {
          formModel.value = null !== newValue ? newValue : {};
        }
      });
      return {
        activeSaveElement: activeSaveElement2,
        hideSaveElement,
        formModel,
        computedFormModel,
        contentStore
      };
    },
    data() {
      return {
        loading: false,
        loadingMessage: false,
        errorMessage: ""
      };
    },
    computed: {
      optionsSchema() {
        return {
          title: {
            type: "text",
            title: this.$translate("choose_title"),
            description: this.$translate("save_title_desc")
          }
        };
      }
    },
    beforeUnmount() {
      this.loadingMessage = "";
      this.errorMessage = "";
    },
    methods: {
      saveElement() {
        const { getSource } = useLibrary();
        const { element, type } = this.activeSaveElement;
        const compiledElementData = type === "template" ? this.contentStore.getAreaContentAsJSON(window.ZnPbInitialData.page_id) : [element.toJSON()];
        const templateType = type === "template" ? "template" : "block";
        const localLibrary = getSource("local_library");
        if (!localLibrary) {
          console.warn(
            "Local library was not registered. It may be possible that a plugin is removing the default library."
          );
          return;
        }
        this.loading = true;
        this.loadingMessage = "";
        this.errorMessage = "";
        localLibrary.createItem({
          title: this.formModel.title,
          template_type: templateType,
          template_data: compiledElementData
        }).then((response) => {
          this.loadingMessage = this.$translate("template_was_added");
        }).catch((error) => {
          if (error.response !== void 0) {
            if (typeof error.response.data === "string") {
              this.errorMessage = error.response.data;
            } else
              this.errorMessage = this.arrayBufferToString(error.response.data);
          } else {
            console.error(error);
            this.errorMessage = error;
          }
        }).finally(() => {
          this.loading = false;
          this.formModel = {};
          setTimeout(() => {
            this.loadingMessage = false;
            this.errorMessage = false;
          }, 3500);
        });
      },
      downloadElement() {
        const { element, type } = this.activeSaveElement;
        const compiledElementData = type === "template" ? this.contentStore.getAreaContentAsJSON(window.ZnPbInitialData.page_id) : [element.toJSON()];
        const templateType = type === "template" ? "template" : "block";
        this.loading = true;
        this.loadingMessage = "";
        this.errorMessage = "";
        exportTemplate({
          title: this.formModel.title,
          template_type: templateType,
          template_data: compiledElementData
        }).then((response) => {
          const fileName = this.formModel.title && this.formModel.title.length > 0 ? this.formModel.title : "export";
          var blob = new Blob([response.data], { type: "application/zip" });
          FileSaver_min.exports.saveAs(blob, `${fileName}.zip`);
          this.loadingMessage = "";
          this.hideSaveElement();
        }).catch((error) => {
          if (typeof error.response.data === "string") {
            this.errorMessage = error.response.data;
          } else
            this.errorMessage = this.arrayBufferToString(error.response.data);
        }).finally(() => {
          this.loading = false;
          this.formModel = {};
        });
      },
      decode_utf8(s) {
        let obj = JSON.parse(s);
        return decodeURIComponent(escape(obj.message));
      },
      arrayBufferToString(buffer) {
        var s = String.fromCharCode.apply(null, new Uint8Array(buffer));
        return this.decode_utf8(s);
      }
    }
  };
  const _hoisted_1$6 = { class: "znpb-modal-save-element-wrapper" };
  const _hoisted_2$5 = { class: "znpb-modal-content-save-buttons" };
  const _hoisted_3$4 = ["innerHTML"];
  function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_OptionsForm = Vue.resolveComponent("OptionsForm");
    const _component_Button = Vue.resolveComponent("Button");
    const _component_Loader = Vue.resolveComponent("Loader");
    const _component_Modal = Vue.resolveComponent("Modal");
    return $setup.activeSaveElement.type ? (Vue.openBlock(), Vue.createBlock(_component_Modal, {
      key: 0,
      title: _ctx.$translate("save_to_library"),
      "append-to": "body",
      width: 560,
      "show-maximize": false,
      class: "znpb-modal-save-element",
      show: true,
      onCloseModal: $setup.hideSaveElement
    }, {
      default: Vue.withCtx(() => [
        Vue.createElementVNode("div", _hoisted_1$6, [
          Vue.createVNode(_component_OptionsForm, {
            modelValue: $setup.computedFormModel,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.computedFormModel = $event),
            schema: $options.optionsSchema
          }, null, 8, ["modelValue", "schema"]),
          Vue.createElementVNode("div", _hoisted_2$5, [
            Vue.createVNode(_component_Button, {
              class: "znpb-button--secondary",
              onClick: $options.saveElement
            }, {
              default: Vue.withCtx(() => [
                Vue.createElementVNode("span", null, Vue.toDisplayString(_ctx.$translate("save")), 1)
              ]),
              _: 1
            }, 8, ["onClick"]),
            Vue.createVNode(_component_Button, {
              class: "znpb-button--line",
              onClick: $options.downloadElement
            }, {
              default: Vue.withCtx(() => [
                Vue.createTextVNode(Vue.toDisplayString(_ctx.$translate("download")), 1)
              ]),
              _: 1
            }, 8, ["onClick"])
          ]),
          $data.loadingMessage || $data.errorMessage.length > 0 ? (Vue.openBlock(), Vue.createElementBlock("p", {
            key: 0,
            class: Vue.normalizeClass(["znpb-modal-save-element-wrapper__message", { "znpb-modal-save-element-wrapper__message--error": $data.errorMessage.length > 0 }]),
            innerHTML: $data.loadingMessage ? $data.loadingMessage : $data.errorMessage
          }, null, 10, _hoisted_3$4)) : Vue.createCommentVNode("", true),
          $data.loading ? (Vue.openBlock(), Vue.createBlock(_component_Loader, {
            key: 1,
            size: 16,
            class: "znpb-modal-save-element-wrapper__loading"
          })) : Vue.createCommentVNode("", true)
        ])
      ]),
      _: 1
    }, 8, ["title", "onCloseModal"])) : Vue.createCommentVNode("", true);
  }
  var SaveElementModal = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["render", _sfc_render$2]]);
  var AssetsRegeneration_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$5 = {
    key: 0,
    class: "znpb-assetsRegenerationWrapper"
  };
  const _sfc_main$7 = /* @__PURE__ */ Vue.defineComponent({
    __name: "AssetsRegeneration",
    setup(__props) {
      const AssetsStore = useAssetsStore();
      return (_ctx, _cache) => {
        return Vue.unref(AssetsStore).isLoading ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$5, [
          Vue.createTextVNode(Vue.toDisplayString(Vue.unref(translate)("regenerating_assets")) + " ", 1),
          Vue.unref(AssetsStore).filesCount > 0 ? (Vue.openBlock(), Vue.createElementBlock(Vue.Fragment, { key: 0 }, [
            Vue.createTextVNode(Vue.toDisplayString(Vue.unref(AssetsStore).currentIndex) + "/" + Vue.toDisplayString(Vue.unref(AssetsStore).filesCount), 1)
          ], 64)) : Vue.createCommentVNode("", true)
        ])) : Vue.createCommentVNode("", true);
      };
    }
  });
  const getLayoutConfigs = () => {
    return applyFilters("editor/addElementsPopup/layoutConfigs", {
      full: [
        {
          element_type: "zion_column"
        }
      ],
      "one-of-two": [
        {
          element_type: "zion_column",
          options: {
            column_size: {
              default: "6"
            }
          }
        },
        {
          element_type: "zion_column",
          options: {
            column_size: {
              default: "6"
            }
          }
        }
      ],
      "one-of-three": [
        {
          element_type: "zion_column",
          options: {
            column_size: {
              default: "4"
            }
          }
        },
        {
          element_type: "zion_column",
          options: {
            column_size: {
              default: "4"
            }
          }
        },
        {
          element_type: "zion_column",
          options: {
            column_size: {
              default: "4"
            }
          }
        }
      ],
      "one-of-four": [
        {
          element_type: "zion_column",
          options: {
            column_size: {
              default: "3"
            }
          }
        },
        {
          element_type: "zion_column",
          options: {
            column_size: {
              default: "3"
            }
          }
        },
        {
          element_type: "zion_column",
          options: {
            column_size: {
              default: "3"
            }
          }
        },
        {
          element_type: "zion_column",
          options: {
            column_size: {
              default: "3"
            }
          }
        }
      ],
      "one-of-five": [
        {
          element_type: "zion_column",
          options: {
            column_size: {
              default: "1of5"
            }
          }
        },
        {
          element_type: "zion_column",
          options: {
            column_size: {
              default: "1of5"
            }
          }
        },
        {
          element_type: "zion_column",
          options: {
            column_size: {
              default: "1of5"
            }
          }
        },
        {
          element_type: "zion_column",
          options: {
            column_size: {
              default: "1of5"
            }
          }
        },
        {
          element_type: "zion_column",
          options: {
            column_size: {
              default: "1of5"
            }
          }
        }
      ],
      "one-of-six": [
        {
          element_type: "zion_column",
          options: {
            column_size: {
              default: "2"
            }
          }
        },
        {
          element_type: "zion_column",
          options: {
            column_size: {
              default: "2"
            }
          }
        },
        {
          element_type: "zion_column",
          options: {
            column_size: {
              default: "2"
            }
          }
        },
        {
          element_type: "zion_column",
          options: {
            column_size: {
              default: "2"
            }
          }
        },
        {
          element_type: "zion_column",
          options: {
            column_size: {
              default: "2"
            }
          }
        },
        {
          element_type: "zion_column",
          options: {
            column_size: {
              default: "2"
            }
          }
        }
      ],
      "4-8": [
        {
          element_type: "zion_column",
          options: {
            column_size: {
              default: "4"
            }
          }
        },
        {
          element_type: "zion_column",
          options: {
            column_size: {
              default: "8"
            }
          }
        }
      ],
      "8-4": [
        {
          element_type: "zion_column",
          options: {
            column_size: {
              default: "8"
            }
          }
        },
        {
          element_type: "zion_column",
          options: {
            column_size: {
              default: "4"
            }
          }
        }
      ],
      "3-9": [
        {
          element_type: "zion_column",
          options: {
            column_size: {
              default: "3"
            }
          }
        },
        {
          element_type: "zion_column",
          options: {
            column_size: {
              default: "9"
            }
          }
        }
      ],
      "9-3": [
        {
          element_type: "zion_column",
          options: {
            column_size: {
              default: "9"
            }
          }
        },
        {
          element_type: "zion_column",
          options: {
            column_size: {
              default: "3"
            }
          }
        }
      ],
      "3-6-3": [
        {
          element_type: "zion_column",
          options: {
            column_size: {
              default: "3"
            }
          }
        },
        {
          element_type: "zion_column",
          options: {
            column_size: {
              default: "6"
            }
          }
        },
        {
          element_type: "zion_column",
          options: {
            column_size: {
              default: "3"
            }
          }
        }
      ],
      "3-3-6": [
        {
          element_type: "zion_column",
          options: {
            column_size: {
              default: "3"
            }
          }
        },
        {
          element_type: "zion_column",
          options: {
            column_size: {
              default: "3"
            }
          }
        },
        {
          element_type: "zion_column",
          options: {
            column_size: {
              default: "6"
            }
          }
        }
      ],
      "6-3-3": [
        {
          element_type: "zion_column",
          options: {
            column_size: {
              default: "6"
            }
          }
        },
        {
          element_type: "zion_column",
          options: {
            column_size: {
              default: "3"
            }
          }
        },
        {
          element_type: "zion_column",
          options: {
            column_size: {
              default: "3"
            }
          }
        }
      ],
      "6-3-3-3-3": [
        {
          element_type: "zion_column",
          options: {
            column_size: {
              default: "6"
            }
          }
        },
        {
          element_type: "zion_column",
          options: {
            column_size: {
              default: "3"
            }
          },
          content: [
            {
              element_type: "zion_column"
            },
            {
              element_type: "zion_column"
            }
          ]
        },
        {
          element_type: "zion_column",
          options: {
            column_size: {
              default: "3"
            }
          },
          content: [
            {
              element_type: "zion_column"
            },
            {
              element_type: "zion_column"
            }
          ]
        }
      ],
      "3-3-3-3-6": [
        {
          element_type: "zion_column",
          options: {
            column_size: {
              default: "3"
            }
          },
          content: [
            {
              element_type: "zion_column"
            },
            {
              element_type: "zion_column"
            }
          ]
        },
        {
          element_type: "zion_column",
          options: {
            column_size: {
              default: "3"
            }
          },
          content: [
            {
              element_type: "zion_column"
            },
            {
              element_type: "zion_column"
            }
          ]
        },
        {
          element_type: "zion_column",
          options: {
            column_size: {
              default: "6"
            }
          }
        }
      ],
      "3-3-6-3-3": [
        {
          element_type: "zion_column",
          options: {
            column_size: {
              default: "3"
            }
          },
          content: [
            {
              element_type: "zion_column"
            },
            {
              element_type: "zion_column"
            }
          ]
        },
        {
          element_type: "zion_column",
          options: {
            column_size: {
              default: "6"
            }
          }
        },
        {
          element_type: "zion_column",
          options: {
            column_size: {
              default: "3"
            }
          },
          content: [
            {
              element_type: "zion_column"
            },
            {
              element_type: "zion_column"
            }
          ]
        }
      ]
    });
  };
  var ElementListItem_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$4 = ["title"];
  const _hoisted_2$4 = { class: "znpb-element-box__element-name" };
  const _sfc_main$6 = /* @__PURE__ */ Vue.defineComponent({
    __name: "ElementListItem",
    props: {
      item: null
    },
    setup(__props) {
      const props = __props;
      const isActiveFavorite = Vue.computed(() => {
        const { getUserData } = useUserData();
        return getUserData("favorite_elements", []).includes(props.item.element_type);
      });
      function addToFavorites() {
        const { getUserData, updateUserData } = useUserData();
        const activeFavoritesClone = [...getUserData("favorite_elements", [])];
        if (activeFavoritesClone.includes(props.item.element_type)) {
          const favoriteIndex = activeFavoritesClone.indexOf(props.item.element_type);
          activeFavoritesClone.splice(favoriteIndex, 1);
        } else {
          activeFavoritesClone.push(props.item.element_type);
        }
        updateUserData({
          favorite_elements: activeFavoritesClone
        });
      }
      return (_ctx, _cache) => {
        const _component_Icon = Vue.resolveComponent("Icon");
        const _component_UIElementIcon = Vue.resolveComponent("UIElementIcon");
        return Vue.openBlock(), Vue.createElementBlock("li", {
          class: Vue.normalizeClass(["znpb-element-box", ["znpb-element-box--" + __props.item.element_type]]),
          title: __props.item.name
        }, [
          __props.item.label ? (Vue.openBlock(), Vue.createElementBlock("span", {
            key: 0,
            class: "znpb-element-box__label",
            style: Vue.normalizeStyle({ background: __props.item.label.color })
          }, Vue.toDisplayString(__props.item.label.text), 5)) : Vue.createCommentVNode("", true),
          Vue.createVNode(_component_Icon, {
            icon: "pin",
            class: Vue.normalizeClass(["znpb-element-box__favoriteIcon", {
              "znpb-element-box__favoriteIcon--active": Vue.unref(isActiveFavorite)
            }]),
            onClick: Vue.withModifiers(addToFavorites, ["stop"])
          }, null, 8, ["class", "onClick"]),
          Vue.createVNode(_component_UIElementIcon, {
            element: __props.item,
            class: "znpb-element-box__icon"
          }, null, 8, ["element"]),
          Vue.createElementVNode("span", _hoisted_2$4, Vue.toDisplayString(__props.item.name), 1)
        ], 10, _hoisted_1$4);
      };
    }
  });
  var ElementList_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1$3 = { class: "znpb-element-category-listWrapper" };
  const _hoisted_2$3 = {
    key: 0,
    class: "znpb-element-category-listTitle"
  };
  const _hoisted_3$3 = {
    key: 1,
    class: "znpb-element-category-list"
  };
  const _sfc_main$5 = /* @__PURE__ */ Vue.defineComponent({
    __name: "ElementList",
    props: {
      elements: null,
      element: null,
      category: null
    },
    emits: ["add-element"],
    setup(__props, { emit }) {
      return (_ctx, _cache) => {
        return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$3, [
          __props.elements.length ? (Vue.openBlock(), Vue.createElementBlock("h3", _hoisted_2$3, Vue.toDisplayString(__props.category), 1)) : Vue.createCommentVNode("", true),
          __props.elements.length ? (Vue.openBlock(), Vue.createElementBlock("ul", _hoisted_3$3, [
            (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList(__props.elements, (childElement) => {
              return Vue.openBlock(), Vue.createBlock(_sfc_main$6, {
                key: childElement.element_type,
                item: childElement,
                onClick: ($event) => emit("add-element", childElement)
              }, null, 8, ["item", "onClick"]);
            }), 128))
          ])) : Vue.createCommentVNode("", true)
        ]);
      };
    }
  });
  var ElementsTab_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$4 = {
    name: "ElementsTab",
    components: {
      ElementList: _sfc_main$5
    },
    props: {
      element: {
        type: Object,
        required: true
      },
      searchKeyword: {
        required: false,
        type: String,
        default: ""
      }
    },
    setup(props, { emit }) {
      const UIStore = useUIStore();
      const elementsDefinitionsStore = useElementDefinitionsStore();
      const { editorData: editorData2 } = useEditorData();
      const { getUserData } = useUserData();
      const categoriesWrapper = Vue.ref(false);
      const categoriesRefs = Vue.ref([]);
      const computedSearchKeyword = Vue.computed({
        get: () => {
          return props.searchKeyword;
        },
        set: (newValue) => {
          emit("update:search-keyword", newValue);
        }
      });
      const categoryValue = Vue.ref("all");
      const searchInputEl = Vue.ref(null);
      const elementCategories = Vue.computed(() => {
        const categoriesToReturn = [
          {
            id: "all",
            name: translate("all")
          }
        ];
        if (getUserData("favorite_elements", []).length > 0) {
          categoriesToReturn.push({
            id: "favorites",
            name: translate("favorites"),
            priority: 1
          });
        }
        const clonedCategories = [...elementsDefinitionsStore.categories];
        const sortedCategories = clonedCategories.sort((a, b) => {
          return a.priority < b.priority ? -1 : 1;
        });
        return categoriesToReturn.concat(sortedCategories);
      });
      const activeElements = Vue.computed(() => {
        let elements = elementsDefinitionsStore.getVisibleElements;
        const keyword = computedSearchKeyword.value;
        if (keyword.length > 0) {
          elements = elements.filter((element) => {
            return element.name.toLowerCase().indexOf(keyword.toLowerCase()) !== -1 || element.keywords.join().toLowerCase().indexOf(keyword.toLowerCase()) !== -1;
          });
        }
        return elements;
      });
      const dropdownOptions = Vue.computed(() => {
        const keyword = computedSearchKeyword.value;
        if (keyword.length === 0) {
          return elementCategories.value;
        } else {
          return elementCategories.value.filter((category) => {
            return category.id === "all" || activeElements.value.filter((element) => element.category.includes(category.id)).length > 0;
          });
        }
      });
      const categoriesWithElements = Vue.computed(() => {
        const clonedCategories = [...elementCategories.value];
        clonedCategories.shift();
        return clonedCategories.map((category) => {
          const elements = activeElements.value.filter((element) => {
            const elementCategories2 = Array.isArray(element.category) ? element.category : [element.category];
            if (category.id === "favorites") {
              return getUserData("favorite_elements", []).indexOf(element.element_type) >= 0;
            } else {
              return elementCategories2.includes(category.id);
            }
          });
          return {
            name: category.name,
            id: category.id,
            elements
          };
        });
      });
      const onAddElement = (element) => {
        const config = __spreadValues({
          element_type: element.element_type,
          version: element.version
        }, element.extra_data);
        window.zb.run("editor/elements/add", {
          element: config,
          parentUID: UIStore.activeAddElementPopup.element.uid,
          index: UIStore.activeAddElementPopup.index
        });
        UIStore.hideAddElementsPopup();
      };
      Vue.watch(activeElements, () => {
        Vue.nextTick(() => {
          categoriesWrapper.value.scrollTop = 0;
          categoryValue.value = "all";
        });
      });
      Vue.watch(categoryValue, (newValue) => {
        if (newValue === "all") {
          categoriesWrapper.value.scrollTop = 0;
        } else {
          if (typeof categoriesRefs.value[newValue] !== "undefined") {
            if (categoriesRefs.value[newValue].$el) {
              categoriesRefs.value[newValue].$el.scrollIntoView({
                behavior: "smooth",
                inline: "start",
                block: "nearest"
              });
            }
          }
        }
      });
      Vue.onMounted(() => {
        setTimeout(() => {
          searchInputEl.value.focus();
        }, 0);
      });
      Vue.onBeforeUnmount(() => {
        computedSearchKeyword.value = "";
      });
      return {
        elementCategories,
        dropdownOptions,
        categoriesRefs,
        computedSearchKeyword,
        categoryValue,
        searchInputEl,
        categoriesWrapper,
        categoriesWithElements,
        onAddElement,
        isRtl: editorData2.value.rtl,
        activeElements
      };
    }
  };
  const _hoisted_1$2 = { class: "znpb-tab__wrapper--columns-template-elements" };
  const _hoisted_2$2 = { class: "znpb-add-elements__filter" };
  const _hoisted_3$2 = {
    ref: "categoriesWrapper",
    class: "znpb-fancy-scrollbar znpb-wrapper-category"
  };
  const _hoisted_4$2 = {
    key: 1,
    style: { "text-align": "center" }
  };
  function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_InputSelect = Vue.resolveComponent("InputSelect");
    const _component_BaseInput = Vue.resolveComponent("BaseInput");
    const _component_ElementList = Vue.resolveComponent("ElementList");
    return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$2, [
      Vue.createElementVNode("div", _hoisted_2$2, [
        Vue.createVNode(_component_InputSelect, {
          modelValue: $setup.categoryValue,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.categoryValue = $event),
          class: "znpb-add-elements__filter-category",
          options: $setup.dropdownOptions,
          placeholder: $setup.dropdownOptions[0].name,
          placement: $setup.isRtl ? "bottom-end" : "bottom-start"
        }, null, 8, ["modelValue", "options", "placeholder", "placement"]),
        Vue.createVNode(_component_BaseInput, {
          ref: "searchInputEl",
          modelValue: $setup.computedSearchKeyword,
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $setup.computedSearchKeyword = $event),
          class: "znpb-columns-templates__search-wrapper znpb-add-elements__filter-search",
          placeholder: _ctx.$translate("search_elements"),
          clearable: true,
          icon: "search",
          autocomplete: "off"
        }, null, 8, ["modelValue", "placeholder"])
      ]),
      Vue.createElementVNode("div", _hoisted_3$2, [
        $setup.categoriesWithElements.length ? (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, { key: 0 }, Vue.renderList($setup.categoriesWithElements, (category) => {
          return Vue.openBlock(), Vue.createBlock(_component_ElementList, {
            key: category.id,
            ref_for: true,
            ref: (el) => {
              if (el)
                $setup.categoriesRefs[category.id] = el;
            },
            elements: category.elements,
            element: $props.element,
            category: category.name,
            onAddElement: $setup.onAddElement
          }, null, 8, ["elements", "element", "category", "onAddElement"]);
        }), 128)) : Vue.createCommentVNode("", true),
        !$setup.activeElements.length ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_4$2, Vue.toDisplayString(_ctx.$translate("no_elements_found")), 1)) : Vue.createCommentVNode("", true)
      ], 512)
    ]);
  }
  var ElementsTab = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$1]]);
  var ColumnTemplates_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$3 = {
    name: "ColumnTemplates",
    components: {
      ElementsTab
    },
    props: {
      element: {
        type: Object,
        required: true
      }
    },
    setup(props, { emit }) {
      const UIStore = useUIStore();
      const defaultTab = props.element.element_type === "zion_column" ? "elements" : "layouts";
      const active = Vue.ref(defaultTab);
      const { addEventListener, removeEventListener } = useWindows();
      const searchKeyword = Vue.ref("");
      const spanElements = {
        full: 1,
        "one-of-two": 2,
        "one-of-three": 3,
        "one-of-four": 4,
        "one-of-five": 5,
        "one-of-six": 6,
        "4-8": 2,
        "8-4": 2,
        "3-9": 2,
        "9-3": 2,
        "3-6-3": 3,
        "3-3-6": 3,
        "6-3-3": 3,
        "6-3-3-3-3": 5,
        "3-3-3-3-6": 5,
        "3-3-6-3-3": 5
      };
      const layouts = getLayoutConfigs();
      const getSpanNumber = (id) => {
        return spanElements[id];
      };
      const wrapColumn = (config) => {
        return [
          {
            element_type: "zion_column",
            content: config,
            options: {
              _styles: {
                wrapper: {
                  styles: {
                    default: {
                      default: {
                        "flex-direction": "row"
                      }
                    }
                  }
                }
              }
            }
          }
        ];
      };
      function getOrientation(element) {
        const elementsDefinitionsStore = useElementDefinitionsStore();
        let orientation = "horizontal";
        if (element.element_type === "contentRoot") {
          return "vertical";
        }
        const elementType = elementsDefinitionsStore.getElementDefinition(element);
        if (elementType) {
          orientation = elementType.content_orientation;
        }
        if (element.options.inner_content_layout) {
          orientation = element.options.inner_content_layout;
        }
        const mediaOrientation = get(element.options, "_styles.wrapper.styles.default.default.flex-direction");
        if (mediaOrientation) {
          orientation = mediaOrientation === "row" ? "horizontal" : "vertical";
        }
        return orientation;
      }
      const addElements = (config) => {
        const elementType = UIStore.activeAddElementPopup.element.element_type;
        if (elementType === "contentRoot") {
          config = [
            {
              element_type: "zion_section",
              content: config
            }
          ];
        } else {
          if (getOrientation(UIStore.activeAddElementPopup.element) === "vertical") {
            config = wrapColumn(config);
          }
        }
        window.zb.run("editor/elements/add-elements", {
          elements: config,
          elementUID: UIStore.activeAddElementPopup.element.uid,
          index: UIStore.activeAddElementPopup.index
        });
        emit("close");
      };
      const openLibrary = () => {
        UIStore.openLibrary(UIStore.activeAddElementPopup);
        emit("close");
      };
      function onKeyDown(event2) {
        if (!isEditable(event2.target)) {
          searchKeyword.value = searchKeyword.value + event2.key;
        }
        if (active.value !== "elements") {
          active.value = "elements";
        }
      }
      function onTabChange(tab) {
        if (tab === "library") {
          openLibrary();
        }
      }
      Vue.onMounted(() => addEventListener("keypress", onKeyDown));
      Vue.onUnmounted(() => removeEventListener("keypress", onKeyDown));
      return {
        layouts,
        active,
        spanElements,
        getSpanNumber,
        addElements,
        searchKeyword,
        openLibrary,
        onTabChange
      };
    }
  };
  const _hoisted_1$1 = { class: "znpb-columns-templates-wrapper" };
  const _hoisted_2$1 = { class: "znpb-columns-templates" };
  const _hoisted_3$1 = ["icon", "onClick"];
  const _hoisted_4$1 = /* @__PURE__ */ Vue.createElementVNode("span", null, null, -1);
  function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Tab = Vue.resolveComponent("Tab");
    const _component_ElementsTab = Vue.resolveComponent("ElementsTab");
    const _component_Tabs = Vue.resolveComponent("Tabs");
    return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1$1, [
      Vue.createVNode(_component_Tabs, {
        activeTab: $setup.active,
        "onUpdate:activeTab": _cache[1] || (_cache[1] = ($event) => $setup.active = $event),
        "title-position": "center",
        onChangedTab: $setup.onTabChange
      }, {
        default: Vue.withCtx(() => [
          Vue.createVNode(_component_Tab, {
            name: "Layouts",
            class: "znpb-tab__wrapper--columns-template"
          }, {
            default: Vue.withCtx(() => [
              Vue.createElementVNode("div", _hoisted_2$1, [
                (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList($setup.layouts, (columnConfig, columnId) => {
                  return Vue.openBlock(), Vue.createElementBlock("div", {
                    key: columnId,
                    icon: columnId,
                    class: Vue.normalizeClass(["znpb-columns-templates__icon znpb-columns-templates__icons--" + columnId]),
                    onClick: Vue.withModifiers(($event) => $setup.addElements(columnConfig), ["stop"])
                  }, [
                    (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList($setup.getSpanNumber(columnId), (span, i) => {
                      return Vue.openBlock(), Vue.createElementBlock("span", { key: i });
                    }), 128))
                  ], 10, _hoisted_3$1);
                }), 128))
              ])
            ]),
            _: 1
          }),
          Vue.createVNode(_component_Tab, { name: "Elements" }, {
            default: Vue.withCtx(() => [
              $setup.active === "elements" ? (Vue.openBlock(), Vue.createBlock(_component_ElementsTab, {
                key: 0,
                "search-keyword": $setup.searchKeyword,
                "onUpdate:search-keyword": _cache[0] || (_cache[0] = ($event) => $setup.searchKeyword = $event),
                element: $props.element
              }, null, 8, ["search-keyword", "element"])) : Vue.createCommentVNode("", true)
            ]),
            _: 1
          }),
          Vue.createVNode(_component_Tab, { name: "Library" }, {
            default: Vue.withCtx(() => [
              _hoisted_4$1
            ]),
            _: 1
          })
        ]),
        _: 1
      }, 8, ["activeTab", "onChangedTab"])
    ]);
  }
  var ColumnTemplates = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render]]);
  const _sfc_main$2 = /* @__PURE__ */ Vue.defineComponent({
    __name: "AddElementPopup",
    setup(__props) {
      const UIStore = useUIStore();
      Vue.watch(
        () => UIStore.activeAddElementPopup,
        (newValue) => {
          if (newValue) {
            window.addEventListener("scroll", UIStore.hideAddElementsPopup);
          } else {
            window.removeEventListener("scroll", UIStore.hideAddElementsPopup);
          }
        }
      );
      return (_ctx, _cache) => {
        const _component_Tooltip = Vue.resolveComponent("Tooltip");
        return Vue.unref(UIStore).activeAddElementPopup ? (Vue.openBlock(), Vue.createBlock(_component_Tooltip, {
          key: Vue.unref(UIStore).activeAddElementPopup.key,
          "tooltip-class": "hg-popper--big-arrows",
          placement: "auto",
          show: true,
          "append-to": "body",
          trigger: null,
          "close-on-outside-click": true,
          "close-on-escape": true,
          "popper-ref": Vue.unref(UIStore).activeAddElementPopup.selector,
          onHide: Vue.unref(UIStore).hideAddElementsPopup
        }, {
          content: Vue.withCtx(() => [
            Vue.createVNode(ColumnTemplates, {
              element: Vue.unref(UIStore).activeAddElementPopup.element,
              onClose: Vue.unref(UIStore).hideAddElementsPopup
            }, null, 8, ["element", "onClose"])
          ]),
          _: 1
        }, 8, ["popper-ref", "onHide"])) : Vue.createCommentVNode("", true);
      };
    }
  });
  var ElementMenu_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$1 = /* @__PURE__ */ Vue.defineComponent({
    __name: "ElementMenu",
    setup(__props) {
      const UIStore = useUIStore();
      const userStore = useUserStore();
      const { addEventListener, removeEventListener } = useWindows();
      const { getData } = useLocalStorage();
      const controlKey = Environment.isMac ? "\u2318" : "\u2303";
      const { copyElement, pasteElement, copiedElement: copiedElement2, pasteElementStyles, pasteElementClasses } = useElementActions();
      const elementActions = Vue.computed(() => {
        const element = UIStore.activeElementMenu.element;
        const contentStore = useContentStore();
        const isElementVisible = contentStore.getElementValue(element.uid, "options._isVisible", true);
        return [
          {
            title: `${translate("action_edit")} ${contentStore.getElementName(element)}`,
            icon: "edit",
            action: () => {
              UIStore.editElement(element);
            },
            cssClasses: "znpb-menu-item--separator-bottom"
          },
          {
            title: `${translate("duplicate_element")}`,
            icon: "copy",
            action: () => {
              element.duplicate();
            },
            append: `${controlKey}+D`,
            disabled: !userStore.permissions.only_content
          },
          {
            title: `${translate("copy_element")}`,
            icon: "copy",
            action: () => {
              copyElement(element);
            },
            append: `${controlKey}+C`,
            disabled: !userStore.permissions.only_content
          },
          {
            title: `${translate("cut_element")}`,
            icon: "close",
            action: () => {
              copyElement(element, "cut");
            },
            append: `${controlKey}+X`,
            disabled: !userStore.permissions.only_content
          },
          {
            title: `${translate("paste_element")}`,
            icon: "paste",
            action: () => {
              pasteElement(element);
            },
            append: `${controlKey}+V`,
            show: hasCopiedElement.value,
            disabled: !userStore.permissions.only_content
          },
          {
            title: translate("paste_element_styles"),
            icon: "drop",
            action: () => {
              pasteElementStyles(element);
            },
            append: `${controlKey}+\u21E7+V`,
            show: hasCopiedElementStyles.value,
            disabled: !userStore.permissions.only_content
          },
          {
            title: translate("paste_classes"),
            icon: "braces",
            action: () => {
              pasteElementClasses(element);
            },
            show: hasCopiedElementClasses.value,
            disabled: !userStore.permissions.only_content
          },
          {
            title: translate("save_element"),
            icon: "check",
            action: () => {
              saveElement(element);
            },
            disabled: !userStore.permissions.only_content
          },
          {
            title: isElementVisible ? translate("visible_element") : translate("show_element"),
            icon: "eye",
            action: () => {
              element.isVisible = !isElementVisible;
            },
            append: `${controlKey}+H`,
            cssClasses: "znpb-menu-item--separator-bottom",
            disabled: !userStore.permissions.only_content
          },
          {
            title: translate("wrap_with_container"),
            icon: "eye",
            action: () => {
              element.wrapIn();
            },
            append: `${controlKey}+H`,
            cssClasses: "znpb-menu-item--separator-bottom",
            disabled: !userStore.permissions.only_content
          },
          {
            title: translate("discard_element_styles"),
            icon: "drop",
            action: () => {
              discardElementStyles(element);
            },
            show: element && Object.keys(get(element.options, "_styles", {})).length > 0,
            disabled: !userStore.permissions.only_content
          },
          {
            title: translate("delete_element"),
            icon: "delete",
            action: () => element.delete(),
            append: `\u2326`,
            disabled: !userStore.permissions.only_content
          }
        ];
      });
      Vue.watch(UIStore.activeElementMenu, (newValue) => {
        if (newValue) {
          addEventListener("scroll", UIStore.hideElementMenu);
        } else {
          removeEventListener("scroll", UIStore.hideElementMenu);
        }
      });
      function discardElementStyles(element) {
        window.zb.run("editor/elements/discard-element-styles", {
          element
        });
      }
      function saveElement(element) {
        const { showSaveElement } = useSaveTemplate();
        showSaveElement(element, "block");
      }
      const hasCopiedElement = Vue.computed(() => {
        return !!(copiedElement2.value.element || getData("copiedElement"));
      });
      const hasCopiedElementClasses = Vue.computed(() => {
        return !!getData("copiedElementClasses");
      });
      const hasCopiedElementStyles = Vue.computed(() => {
        return !!getData("copiedElementStyles");
      });
      return (_ctx, _cache) => {
        const _component_Menu = Vue.resolveComponent("Menu");
        const _component_Tooltip = Vue.resolveComponent("Tooltip");
        return Vue.openBlock(), Vue.createBlock(_component_Tooltip, {
          key: Vue.unref(UIStore).activeElementMenu.rand,
          "tooltip-class": "hg-popper--big-arrows znpb-rightClickMenu__Tooltip",
          placement: "auto",
          show: true,
          "append-to": "body",
          trigger: "click",
          "close-on-outside-click": true,
          "close-on-escape": true,
          "popper-ref": Vue.unref(UIStore).activeElementMenu.selector,
          onHide: Vue.unref(UIStore).hideElementMenu
        }, {
          content: Vue.withCtx(() => [
            Vue.createVNode(_component_Menu, {
              actions: Vue.unref(elementActions),
              onAction: Vue.unref(UIStore).hideElementMenu
            }, null, 8, ["actions", "onAction"])
          ]),
          _: 1
        }, 8, ["popper-ref", "onHide"]);
      };
    }
  });
  var EditorApp_vue_vue_type_style_index_0_lang = "";
  const _hoisted_1 = {
    key: 0,
    class: "znpb-editor-layout__preview-breakpoints"
  };
  const _hoisted_2 = ["onClick"];
  const _hoisted_3 = /* @__PURE__ */ Vue.createElementVNode("div", { class: "znpb-main-wrapper--mainBarPlaceholderInner" }, null, -1);
  const _hoisted_4 = [
    _hoisted_3
  ];
  const _hoisted_5 = { class: "znpb-center-area" };
  const _hoisted_6 = /* @__PURE__ */ Vue.createElementVNode("div", { class: "znpb-panel-placeholder" }, null, -1);
  const _hoisted_7 = [
    _hoisted_6
  ];
  const _hoisted_8 = {
    key: 0,
    class: "znpb-loading-wrapper-gif"
  };
  const _hoisted_9 = ["src"];
  const _hoisted_10 = { class: "znpb-loading-wrapper-gif__text" };
  const _sfc_main = /* @__PURE__ */ Vue.defineComponent({
    __name: "EditorApp",
    setup(__props) {
      const devicesVisible = Vue.ref(false);
      const UIStore = useUIStore();
      const { notifications } = storeToRefs(useNotificationsStore());
      const { activeResponsiveDeviceInfo: activeResponsiveDeviceInfo2, responsiveDevices: responsiveDevices2, setActiveResponsiveDeviceId, activeResponsiveDeviceId: activeResponsiveDeviceId2 } = useResponsiveDevices();
      const { applyShortcuts } = useKeyBindings();
      const { editorData: editorData2 } = useEditorData();
      const panelComponentsMap = {
        "panel-element-options": _sfc_main$g,
        "panel-global-settings": PanelGlobalSettings,
        "preview-iframe": PreviewIframe,
        "panel-history": _sfc_main$w,
        "panel-tree": _sfc_main$y
      };
      const cssClasses = useCSSClassesStore();
      cssClasses.setCSSClasses(window.ZnPbInitialData.css_classes);
      const pageSettings = usePageSettingsStore();
      pageSettings.settings = window.ZnPbInitialData.page_settings.values;
      const mainBarDraggingPlaceholderStyles = Vue.computed(() => {
        return {
          transform: `translate3d(${UIStore.mainBarDraggingPlaceholder.left - 22}px, ${UIStore.mainBarDraggingPlaceholder.top - 22}px,0)`
        };
      });
      const historyStore = useHistoryStore();
      const { saveAutosave } = useSavePage();
      let canAutosave = true;
      Vue.watch(
        () => historyStore.activeHistoryIndex,
        (newValue) => {
          if (canAutosave && newValue > 0) {
            saveAutosave();
            canAutosave = false;
            setTimeout(() => {
              canAutosave = true;
            }, window.ZnPbInitialData.autosaveInterval * 1e3);
          }
        }
      );
      Vue.provide("builderOptions", useBuilderOptionsStore);
      Vue.provide("serverRequester", serverRequest);
      Vue.provide("masks", editorData2.value.masks);
      Vue.provide("plugin_info", editorData2.value.plugin_info);
      const { add } = useNotificationsStore();
      add({
        message: translate("autosave_notice"),
        type: "info",
        delayClose: 5e3
      });
      const showEditorButtonStyle = Vue.computed(() => {
        let buttonStyle;
        buttonStyle = {
          left: "30px",
          top: "30px"
        };
        return buttonStyle;
      });
      Vue.onMounted(() => {
        document.addEventListener("keydown", applyShortcuts);
      });
      Vue.onBeforeUnmount(() => {
        document.removeEventListener("keydown", applyShortcuts);
      });
      function activateDevice(device) {
        setActiveResponsiveDeviceId(device.id);
        setTimeout(() => {
        }, 50);
      }
      function showPanels() {
        UIStore.setPreviewMode(false);
      }
      return (_ctx, _cache) => {
        const _component_Icon = Vue.resolveComponent("Icon");
        const _component_Tooltip = Vue.resolveComponent("Tooltip");
        const _component_Notice = Vue.resolveComponent("Notice");
        return Vue.openBlock(), Vue.createElementBlock("div", {
          id: "znpb-main-wrapper",
          class: Vue.normalizeClass(["znpb-main-wrapper", {
            [`znpb-responsiveDevice--${Vue.unref(activeResponsiveDeviceId2)}`]: Vue.unref(activeResponsiveDeviceId2)
          }])
        }, [
          Vue.createVNode(Vue.Transition, { name: "slide-from-left" }, {
            default: Vue.withCtx(() => [
              Vue.withDirectives(Vue.createElementVNode("div", {
                style: Vue.normalizeStyle(Vue.unref(showEditorButtonStyle)),
                class: "znpb-editor-layout__preview-buttons"
              }, [
                Vue.createElementVNode("div", {
                  class: "znpb-editor-layout__preview-button",
                  onClick: showPanels
                }, [
                  Vue.createVNode(_component_Icon, { icon: "layout" })
                ]),
                Vue.createElementVNode("div", {
                  class: "znpb-editor-layout__preview-button",
                  onClick: _cache[0] || (_cache[0] = ($event) => devicesVisible.value = !devicesVisible.value)
                }, [
                  Vue.createVNode(_component_Icon, {
                    icon: Vue.unref(activeResponsiveDeviceInfo2).icon
                  }, null, 8, ["icon"])
                ]),
                devicesVisible.value ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1, [
                  Vue.createVNode(_component_Tooltip, {
                    show: devicesVisible.value,
                    "show-arrows": false,
                    "append-to": "element",
                    trigger: null,
                    placement: "bottom",
                    "close-on-outside-click": true
                  }, {
                    content: Vue.withCtx(() => [
                      (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList(Vue.unref(responsiveDevices2), (device, index2) => {
                        return Vue.openBlock(), Vue.createElementBlock("div", {
                          key: index2,
                          ref_for: true,
                          ref: "dropdown",
                          class: Vue.normalizeClass(["znpb-options-devices-buttons znpb-has-responsive-options__icon-button", {
                            "znpb-has-responsive-options__icon-button--active": Vue.unref(activeResponsiveDeviceId2) === device.id
                          }]),
                          onClick: ($event) => activateDevice(device)
                        }, [
                          Vue.createVNode(_component_Icon, {
                            icon: device.icon
                          }, null, 8, ["icon"])
                        ], 10, _hoisted_2);
                      }), 128))
                    ]),
                    _: 1
                  }, 8, ["show"])
                ])) : Vue.createCommentVNode("", true)
              ], 4), [
                [Vue.vShow, Vue.unref(UIStore).isPreviewMode]
              ])
            ]),
            _: 1
          }),
          Vue.createElementVNode("div", {
            class: Vue.normalizeClass(["znpb-panels-wrapper", {
              [`znpb-editorHeaderPosition--${Vue.unref(UIStore).mainBar.position}`]: Vue.unref(UIStore).mainBar.position
            }])
          }, [
            Vue.unref(UIStore).mainBar.isDragging ? (Vue.openBlock(), Vue.createElementBlock("div", {
              key: 0,
              class: Vue.normalizeClass(["znpb-main-wrapper--mainBarPlaceholder", {
                [`znpb-main-wrapper--mainBarPlaceholder--${Vue.unref(UIStore).mainBar.draggingPosition}`]: Vue.unref(UIStore).mainBar.draggingPosition
              }])
            }, _hoisted_4, 2)) : Vue.createCommentVNode("", true),
            Vue.createVNode(MainPanel),
            Vue.createElementVNode("div", _hoisted_5, [
              Vue.unref(UIStore).panelPlaceholder.visibility ? (Vue.openBlock(), Vue.createElementBlock("div", {
                key: 0,
                id: "znpb-panel-placeholder",
                style: Vue.normalizeStyle({ left: Vue.unref(UIStore).panelPlaceholder.left + "px" })
              }, _hoisted_7, 4)) : Vue.createCommentVNode("", true),
              (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList(Vue.unref(UIStore).openPanels, (panel) => {
                return Vue.withDirectives((Vue.openBlock(), Vue.createBlock(Vue.resolveDynamicComponent(panelComponentsMap[panel.id]), {
                  key: panel.id,
                  panel
                }, null, 8, ["panel"])), [
                  [Vue.vShow, !Vue.unref(UIStore).isPreviewMode || panel.id === "preview-iframe"]
                ]);
              }), 128))
            ])
          ], 2),
          Vue.unref(UIStore).isPreviewLoading ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_8, [
            Vue.createElementVNode("img", {
              src: Vue.unref(editorData2).urls.loader
            }, null, 8, _hoisted_9),
            Vue.createElementVNode("div", _hoisted_10, Vue.toDisplayString(Vue.unref(translate)("generating_preview")), 1)
          ])) : Vue.createCommentVNode("", true),
          Vue.createVNode(Vue.unref(_sfc_main$2)),
          Vue.unref(UIStore).activeElementMenu ? (Vue.openBlock(), Vue.createBlock(Vue.unref(_sfc_main$1), { key: 1 })) : Vue.createCommentVNode("", true),
          Vue.createVNode(SaveElementModal),
          Vue.createVNode(_sfc_main$9),
          Vue.createVNode(PanelLibraryModal),
          Vue.createVNode(_sfc_main$7),
          (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList(Vue.unref(notifications), (error) => {
            return Vue.openBlock(), Vue.createBlock(_component_Notice, {
              key: error.message,
              error,
              onCloseNotice: ($event) => error.remove()
            }, null, 8, ["error", "onCloseNotice"]);
          }), 128)),
          Vue.unref(UIStore).mainBar.isDragging ? (Vue.openBlock(), Vue.createElementBlock("div", {
            key: 2,
            class: "znpb-editor-header__helper",
            style: Vue.normalizeStyle(Vue.unref(mainBarDraggingPlaceholderStyles))
          }, [
            Vue.createVNode(_component_Icon, {
              icon: "more",
              rotate: "90"
            })
          ], 4)) : Vue.createCommentVNode("", true)
        ], 2);
      };
    }
  });
  class CommandManager {
    constructor() {
      __publicField(this, "commands", []);
    }
    registerCommand(commandId, commandClass) {
      this.commands.push({
        id: commandId,
        callback: (commandArgs) => {
          return new commandClass(commandArgs).runCommand();
        }
      });
    }
    getCommand(commandId) {
      const command = this.commands.find((command2) => command2.id === commandId);
      if (!command) {
        console.warn(`Command ${commandId} not found`);
        return false;
      }
      return command;
    }
    runCommand(commandId, commandArgs) {
      const command = this.getCommand(commandId);
      if (command) {
        return command.callback.call(command, commandArgs);
      } else {
        console.warn(`Command with id ${commandId} not found`);
      }
      return null;
    }
  }
  class BaseCommand {
    constructor(data2) {
      __publicField(this, "data", {});
      this.data = data2;
    }
    runCommand() {
      this.beforeCommand();
      const result = this.doCommand();
      this.afterCommand(result);
      return result;
    }
    undoCommand() {
      console.warn("undoCommand needs to be implemented by the child class");
    }
    doCommand() {
      console.warn("doCommand needs to be implemented by the child class");
    }
    beforeCommand() {
    }
    afterCommand(result) {
    }
  }
  class HistoryCommand extends BaseCommand {
    constructor(data2) {
      super(data2);
    }
    getHistory() {
      return useHistoryStore();
    }
    getActionName(action) {
      const actions = {
        added: translate("added"),
        deleted: translate("deleted"),
        renamed: translate("renamed"),
        show: translate("show"),
        hide: translate("hide"),
        duplicate: translate("duplicate"),
        wrapped_with_container: translate("wrapped_with_container"),
        copied: translate("copied"),
        moved: translate("moved"),
        pasteStyles: translate("paste-styles"),
        pasteCSSClasses: translate("paste-css-classes"),
        discardStyles: translate("discard-styles")
      };
      return actions[action] || "Invalid action";
    }
  }
  const _AddElement = class extends HistoryCommand {
    doCommand() {
      const contentStore = useContentStore();
      const { element, parentUID, index: index2 } = this.data;
      const newElement = contentStore.addElement(element, parentUID, index2);
      if (newElement) {
        const historyManager = this.getHistory();
        historyManager.addHistoryItem({
          undo: _AddElement.undo,
          redo: _AddElement.redo,
          data: {
            elementModel: newElement.toJSON(),
            parentUID,
            index: index2
          },
          title: newElement.name,
          action: this.getActionName("added")
        });
        return newElement.uid;
      }
      return null;
    }
    static undo(historyItem) {
      const { elementModel } = historyItem.data || {};
      if (elementModel) {
        const contentStore = useContentStore();
        contentStore.deleteElement(elementModel.uid);
      }
    }
    static redo(historyItem) {
      const { data: data2 = {} } = historyItem;
      const { elementModel, parentUID, index: index2 } = data2;
      const contentStore = useContentStore();
      contentStore.addElement(elementModel, parentUID, index2);
    }
  };
  let AddElement = _AddElement;
  __publicField(AddElement, "commandID", "editor/elements/add");
  const _DeleteElement = class extends HistoryCommand {
    doCommand() {
      const { elementUID } = this.data;
      const contentStore = useContentStore();
      const deletedElement = contentStore.getElement(elementUID);
      if (deletedElement) {
        const historyManager = this.getHistory();
        historyManager.addHistoryItem({
          undo: _DeleteElement.undo,
          redo: _DeleteElement.redo,
          data: {
            elementModel: deletedElement.toJSON(),
            parentUID: deletedElement.parentUID,
            index: deletedElement.indexInParent
          },
          title: deletedElement.name,
          action: this.getActionName("deleted")
        });
        contentStore.deleteElement(elementUID);
      }
    }
    static undo(historyItem) {
      const { data: data2 = {} } = historyItem;
      const { elementModel, parentUID, index: index2 } = data2;
      const contentStore = useContentStore();
      contentStore.addElement(elementModel, parentUID, index2);
    }
    static redo(historyItem) {
      const { data: data2 } = historyItem;
      if (data2.elementModel) {
        const contentStore = useContentStore();
        contentStore.deleteElement(data2.elementModel.uid);
      }
    }
  };
  let DeleteElement = _DeleteElement;
  __publicField(DeleteElement, "commandID", "editor/elements/delete");
  var lodash = { exports: {} };
  /**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   */
  (function(module2, exports2) {
    (function() {
      var undefined$1;
      var VERSION2 = "4.17.21";
      var LARGE_ARRAY_SIZE2 = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT2 = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE2 = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG2 = 1, CLONE_FLAT_FLAG2 = 2, CLONE_SYMBOLS_FLAG2 = 4;
      var COMPARE_PARTIAL_FLAG2 = 1, COMPARE_UNORDERED_FLAG2 = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT2 = 800, HOT_SPAN2 = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY2 = 1 / 0, MAX_SAFE_INTEGER2 = 9007199254740991, MAX_INTEGER2 = 17976931348623157e292, NAN2 = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag2 = "[object Arguments]", arrayTag2 = "[object Array]", asyncTag2 = "[object AsyncFunction]", boolTag2 = "[object Boolean]", dateTag2 = "[object Date]", domExcTag = "[object DOMException]", errorTag2 = "[object Error]", funcTag2 = "[object Function]", genTag2 = "[object GeneratorFunction]", mapTag2 = "[object Map]", numberTag2 = "[object Number]", nullTag2 = "[object Null]", objectTag2 = "[object Object]", promiseTag2 = "[object Promise]", proxyTag2 = "[object Proxy]", regexpTag2 = "[object RegExp]", setTag2 = "[object Set]", stringTag2 = "[object String]", symbolTag2 = "[object Symbol]", undefinedTag2 = "[object Undefined]", weakMapTag2 = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag2 = "[object ArrayBuffer]", dataViewTag2 = "[object DataView]", float32Tag2 = "[object Float32Array]", float64Tag2 = "[object Float64Array]", int8Tag2 = "[object Int8Array]", int16Tag2 = "[object Int16Array]", int32Tag2 = "[object Int32Array]", uint8Tag2 = "[object Uint8Array]", uint8ClampedTag2 = "[object Uint8ClampedArray]", uint16Tag2 = "[object Uint16Array]", uint32Tag2 = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml2 = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml2 = RegExp(reUnescapedHtml2.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp2 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp2 = /^\w*$/, rePropName2 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar2.source);
      var reTrimStart2 = /^\s+/;
      var reWhitespace2 = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord2 = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar2 = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags2 = /\w*$/;
      var reIsBadHex2 = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary2 = /^0b[01]+$/i;
      var reIsHostCtor2 = /^\[object .+?Constructor\]$/;
      var reIsOctal2 = /^0o[0-7]+$/i;
      var reIsUint2 = /^(?:0|[1-9]\d*)$/;
      var reLatin2 = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange2 = "\\ud800-\\udfff", rsComboMarksRange2 = "\\u0300-\\u036f", reComboHalfMarksRange2 = "\\ufe20-\\ufe2f", rsComboSymbolsRange2 = "\\u20d0-\\u20ff", rsComboRange2 = rsComboMarksRange2 + reComboHalfMarksRange2 + rsComboSymbolsRange2, rsDingbatRange2 = "\\u2700-\\u27bf", rsLowerRange2 = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange2 = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange2 = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange2 = "\\u2000-\\u206f", rsSpaceRange2 = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange2 = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange2 = "\\ufe0e\\ufe0f", rsBreakRange2 = rsMathOpRange2 + rsNonCharRange2 + rsPunctuationRange2 + rsSpaceRange2;
      var rsApos2 = "['\u2019]", rsAstral2 = "[" + rsAstralRange2 + "]", rsBreak2 = "[" + rsBreakRange2 + "]", rsCombo2 = "[" + rsComboRange2 + "]", rsDigits2 = "\\d+", rsDingbat2 = "[" + rsDingbatRange2 + "]", rsLower2 = "[" + rsLowerRange2 + "]", rsMisc2 = "[^" + rsAstralRange2 + rsBreakRange2 + rsDigits2 + rsDingbatRange2 + rsLowerRange2 + rsUpperRange2 + "]", rsFitz2 = "\\ud83c[\\udffb-\\udfff]", rsModifier2 = "(?:" + rsCombo2 + "|" + rsFitz2 + ")", rsNonAstral2 = "[^" + rsAstralRange2 + "]", rsRegional2 = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair2 = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper2 = "[" + rsUpperRange2 + "]", rsZWJ2 = "\\u200d";
      var rsMiscLower2 = "(?:" + rsLower2 + "|" + rsMisc2 + ")", rsMiscUpper2 = "(?:" + rsUpper2 + "|" + rsMisc2 + ")", rsOptContrLower2 = "(?:" + rsApos2 + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper2 = "(?:" + rsApos2 + "(?:D|LL|M|RE|S|T|VE))?", reOptMod2 = rsModifier2 + "?", rsOptVar2 = "[" + rsVarRange2 + "]?", rsOptJoin2 = "(?:" + rsZWJ2 + "(?:" + [rsNonAstral2, rsRegional2, rsSurrPair2].join("|") + ")" + rsOptVar2 + reOptMod2 + ")*", rsOrdLower2 = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper2 = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq2 = rsOptVar2 + reOptMod2 + rsOptJoin2, rsEmoji2 = "(?:" + [rsDingbat2, rsRegional2, rsSurrPair2].join("|") + ")" + rsSeq2, rsSymbol2 = "(?:" + [rsNonAstral2 + rsCombo2 + "?", rsCombo2, rsRegional2, rsSurrPair2, rsAstral2].join("|") + ")";
      var reApos2 = RegExp(rsApos2, "g");
      var reComboMark2 = RegExp(rsCombo2, "g");
      var reUnicode2 = RegExp(rsFitz2 + "(?=" + rsFitz2 + ")|" + rsSymbol2 + rsSeq2, "g");
      var reUnicodeWord2 = RegExp([
        rsUpper2 + "?" + rsLower2 + "+" + rsOptContrLower2 + "(?=" + [rsBreak2, rsUpper2, "$"].join("|") + ")",
        rsMiscUpper2 + "+" + rsOptContrUpper2 + "(?=" + [rsBreak2, rsUpper2 + rsMiscLower2, "$"].join("|") + ")",
        rsUpper2 + "?" + rsMiscLower2 + "+" + rsOptContrLower2,
        rsUpper2 + "+" + rsOptContrUpper2,
        rsOrdUpper2,
        rsOrdLower2,
        rsDigits2,
        rsEmoji2
      ].join("|"), "g");
      var reHasUnicode2 = RegExp("[" + rsZWJ2 + rsAstralRange2 + rsComboRange2 + rsVarRange2 + "]");
      var reHasUnicodeWord2 = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags2 = {};
      typedArrayTags2[float32Tag2] = typedArrayTags2[float64Tag2] = typedArrayTags2[int8Tag2] = typedArrayTags2[int16Tag2] = typedArrayTags2[int32Tag2] = typedArrayTags2[uint8Tag2] = typedArrayTags2[uint8ClampedTag2] = typedArrayTags2[uint16Tag2] = typedArrayTags2[uint32Tag2] = true;
      typedArrayTags2[argsTag2] = typedArrayTags2[arrayTag2] = typedArrayTags2[arrayBufferTag2] = typedArrayTags2[boolTag2] = typedArrayTags2[dataViewTag2] = typedArrayTags2[dateTag2] = typedArrayTags2[errorTag2] = typedArrayTags2[funcTag2] = typedArrayTags2[mapTag2] = typedArrayTags2[numberTag2] = typedArrayTags2[objectTag2] = typedArrayTags2[regexpTag2] = typedArrayTags2[setTag2] = typedArrayTags2[stringTag2] = typedArrayTags2[weakMapTag2] = false;
      var cloneableTags2 = {};
      cloneableTags2[argsTag2] = cloneableTags2[arrayTag2] = cloneableTags2[arrayBufferTag2] = cloneableTags2[dataViewTag2] = cloneableTags2[boolTag2] = cloneableTags2[dateTag2] = cloneableTags2[float32Tag2] = cloneableTags2[float64Tag2] = cloneableTags2[int8Tag2] = cloneableTags2[int16Tag2] = cloneableTags2[int32Tag2] = cloneableTags2[mapTag2] = cloneableTags2[numberTag2] = cloneableTags2[objectTag2] = cloneableTags2[regexpTag2] = cloneableTags2[setTag2] = cloneableTags2[stringTag2] = cloneableTags2[symbolTag2] = cloneableTags2[uint8Tag2] = cloneableTags2[uint8ClampedTag2] = cloneableTags2[uint16Tag2] = cloneableTags2[uint32Tag2] = true;
      cloneableTags2[errorTag2] = cloneableTags2[funcTag2] = cloneableTags2[weakMapTag2] = false;
      var deburredLetters2 = {
        "\xC0": "A",
        "\xC1": "A",
        "\xC2": "A",
        "\xC3": "A",
        "\xC4": "A",
        "\xC5": "A",
        "\xE0": "a",
        "\xE1": "a",
        "\xE2": "a",
        "\xE3": "a",
        "\xE4": "a",
        "\xE5": "a",
        "\xC7": "C",
        "\xE7": "c",
        "\xD0": "D",
        "\xF0": "d",
        "\xC8": "E",
        "\xC9": "E",
        "\xCA": "E",
        "\xCB": "E",
        "\xE8": "e",
        "\xE9": "e",
        "\xEA": "e",
        "\xEB": "e",
        "\xCC": "I",
        "\xCD": "I",
        "\xCE": "I",
        "\xCF": "I",
        "\xEC": "i",
        "\xED": "i",
        "\xEE": "i",
        "\xEF": "i",
        "\xD1": "N",
        "\xF1": "n",
        "\xD2": "O",
        "\xD3": "O",
        "\xD4": "O",
        "\xD5": "O",
        "\xD6": "O",
        "\xD8": "O",
        "\xF2": "o",
        "\xF3": "o",
        "\xF4": "o",
        "\xF5": "o",
        "\xF6": "o",
        "\xF8": "o",
        "\xD9": "U",
        "\xDA": "U",
        "\xDB": "U",
        "\xDC": "U",
        "\xF9": "u",
        "\xFA": "u",
        "\xFB": "u",
        "\xFC": "u",
        "\xDD": "Y",
        "\xFD": "y",
        "\xFF": "y",
        "\xC6": "Ae",
        "\xE6": "ae",
        "\xDE": "Th",
        "\xFE": "th",
        "\xDF": "ss",
        "\u0100": "A",
        "\u0102": "A",
        "\u0104": "A",
        "\u0101": "a",
        "\u0103": "a",
        "\u0105": "a",
        "\u0106": "C",
        "\u0108": "C",
        "\u010A": "C",
        "\u010C": "C",
        "\u0107": "c",
        "\u0109": "c",
        "\u010B": "c",
        "\u010D": "c",
        "\u010E": "D",
        "\u0110": "D",
        "\u010F": "d",
        "\u0111": "d",
        "\u0112": "E",
        "\u0114": "E",
        "\u0116": "E",
        "\u0118": "E",
        "\u011A": "E",
        "\u0113": "e",
        "\u0115": "e",
        "\u0117": "e",
        "\u0119": "e",
        "\u011B": "e",
        "\u011C": "G",
        "\u011E": "G",
        "\u0120": "G",
        "\u0122": "G",
        "\u011D": "g",
        "\u011F": "g",
        "\u0121": "g",
        "\u0123": "g",
        "\u0124": "H",
        "\u0126": "H",
        "\u0125": "h",
        "\u0127": "h",
        "\u0128": "I",
        "\u012A": "I",
        "\u012C": "I",
        "\u012E": "I",
        "\u0130": "I",
        "\u0129": "i",
        "\u012B": "i",
        "\u012D": "i",
        "\u012F": "i",
        "\u0131": "i",
        "\u0134": "J",
        "\u0135": "j",
        "\u0136": "K",
        "\u0137": "k",
        "\u0138": "k",
        "\u0139": "L",
        "\u013B": "L",
        "\u013D": "L",
        "\u013F": "L",
        "\u0141": "L",
        "\u013A": "l",
        "\u013C": "l",
        "\u013E": "l",
        "\u0140": "l",
        "\u0142": "l",
        "\u0143": "N",
        "\u0145": "N",
        "\u0147": "N",
        "\u014A": "N",
        "\u0144": "n",
        "\u0146": "n",
        "\u0148": "n",
        "\u014B": "n",
        "\u014C": "O",
        "\u014E": "O",
        "\u0150": "O",
        "\u014D": "o",
        "\u014F": "o",
        "\u0151": "o",
        "\u0154": "R",
        "\u0156": "R",
        "\u0158": "R",
        "\u0155": "r",
        "\u0157": "r",
        "\u0159": "r",
        "\u015A": "S",
        "\u015C": "S",
        "\u015E": "S",
        "\u0160": "S",
        "\u015B": "s",
        "\u015D": "s",
        "\u015F": "s",
        "\u0161": "s",
        "\u0162": "T",
        "\u0164": "T",
        "\u0166": "T",
        "\u0163": "t",
        "\u0165": "t",
        "\u0167": "t",
        "\u0168": "U",
        "\u016A": "U",
        "\u016C": "U",
        "\u016E": "U",
        "\u0170": "U",
        "\u0172": "U",
        "\u0169": "u",
        "\u016B": "u",
        "\u016D": "u",
        "\u016F": "u",
        "\u0171": "u",
        "\u0173": "u",
        "\u0174": "W",
        "\u0175": "w",
        "\u0176": "Y",
        "\u0177": "y",
        "\u0178": "Y",
        "\u0179": "Z",
        "\u017B": "Z",
        "\u017D": "Z",
        "\u017A": "z",
        "\u017C": "z",
        "\u017E": "z",
        "\u0132": "IJ",
        "\u0133": "ij",
        "\u0152": "Oe",
        "\u0153": "oe",
        "\u0149": "'n",
        "\u017F": "s"
      };
      var htmlEscapes2 = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt2 = parseInt;
      var freeGlobal2 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
      var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
      var root2 = freeGlobal2 || freeSelf2 || Function("return this")();
      var freeExports2 = exports2 && !exports2.nodeType && exports2;
      var freeModule2 = freeExports2 && true && module2 && !module2.nodeType && module2;
      var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
      var freeProcess2 = moduleExports2 && freeGlobal2.process;
      var nodeUtil2 = function() {
        try {
          var types = freeModule2 && freeModule2.require && freeModule2.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess2 && freeProcess2.binding && freeProcess2.binding("util");
        } catch (e) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil2 && nodeUtil2.isArrayBuffer, nodeIsDate = nodeUtil2 && nodeUtil2.isDate, nodeIsMap2 = nodeUtil2 && nodeUtil2.isMap, nodeIsRegExp = nodeUtil2 && nodeUtil2.isRegExp, nodeIsSet2 = nodeUtil2 && nodeUtil2.isSet, nodeIsTypedArray2 = nodeUtil2 && nodeUtil2.isTypedArray;
      function apply2(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index2 = -1, length = array == null ? 0 : array.length;
        while (++index2 < length) {
          var value = array[index2];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      function arrayEach2(array, iteratee) {
        var index2 = -1, length = array == null ? 0 : array.length;
        while (++index2 < length) {
          if (iteratee(array[index2], index2, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEachRight(array, iteratee) {
        var length = array == null ? 0 : array.length;
        while (length--) {
          if (iteratee(array[length], length, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEvery(array, predicate) {
        var index2 = -1, length = array == null ? 0 : array.length;
        while (++index2 < length) {
          if (!predicate(array[index2], index2, array)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter2(array, predicate) {
        var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index2 < length) {
          var value = array[index2];
          if (predicate(value, index2, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes2(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf2(array, value, 0) > -1;
      }
      function arrayIncludesWith2(array, value, comparator) {
        var index2 = -1, length = array == null ? 0 : array.length;
        while (++index2 < length) {
          if (comparator(value, array[index2])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap2(array, iteratee) {
        var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index2 < length) {
          result[index2] = iteratee(array[index2], index2, array);
        }
        return result;
      }
      function arrayPush2(array, values) {
        var index2 = -1, length = values.length, offset2 = array.length;
        while (++index2 < length) {
          array[offset2 + index2] = values[index2];
        }
        return array;
      }
      function arrayReduce2(array, iteratee, accumulator, initAccum) {
        var index2 = -1, length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[++index2];
        }
        while (++index2 < length) {
          accumulator = iteratee(accumulator, array[index2], index2, array);
        }
        return accumulator;
      }
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
      }
      function arraySome2(array, predicate) {
        var index2 = -1, length = array == null ? 0 : array.length;
        while (++index2 < length) {
          if (predicate(array[index2], index2, array)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty2("length");
      function asciiToArray2(string) {
        return string.split("");
      }
      function asciiWords2(string) {
        return string.match(reAsciiWord2) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex2(array, predicate, fromIndex, fromRight) {
        var length = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index2-- : ++index2 < length) {
          if (predicate(array[index2], index2, array)) {
            return index2;
          }
        }
        return -1;
      }
      function baseIndexOf2(array, value, fromIndex) {
        return value === value ? strictIndexOf2(array, value, fromIndex) : baseFindIndex2(array, baseIsNaN2, fromIndex);
      }
      function baseIndexOfWith2(array, value, fromIndex, comparator) {
        var index2 = fromIndex - 1, length = array.length;
        while (++index2 < length) {
          if (comparator(array[index2], value)) {
            return index2;
          }
        }
        return -1;
      }
      function baseIsNaN2(value) {
        return value !== value;
      }
      function baseMean(array, iteratee) {
        var length = array == null ? 0 : array.length;
        return length ? baseSum(array, iteratee) / length : NAN2;
      }
      function baseProperty2(key) {
        return function(object) {
          return object == null ? undefined$1 : object[key];
        };
      }
      function basePropertyOf2(object) {
        return function(key) {
          return object == null ? undefined$1 : object[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index2, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index2, collection2);
        });
        return accumulator;
      }
      function baseSortBy2(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }
      function baseSum(array, iteratee) {
        var result, index2 = -1, length = array.length;
        while (++index2 < length) {
          var current = iteratee(array[index2]);
          if (current !== undefined$1) {
            result = result === undefined$1 ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes2(n, iteratee) {
        var index2 = -1, result = Array(n);
        while (++index2 < n) {
          result[index2] = iteratee(index2);
        }
        return result;
      }
      function baseToPairs(object, props) {
        return arrayMap2(props, function(key) {
          return [key, object[key]];
        });
      }
      function baseTrim2(string) {
        return string ? string.slice(0, trimmedEndIndex2(string) + 1).replace(reTrimStart2, "") : string;
      }
      function baseUnary2(func) {
        return function(value) {
          return func(value);
        };
      }
      function baseValues(object, props) {
        return arrayMap2(props, function(key) {
          return object[key];
        });
      }
      function cacheHas2(cache2, key) {
        return cache2.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index2 = -1, length = strSymbols.length;
        while (++index2 < length && baseIndexOf2(chrSymbols, strSymbols[index2], 0) > -1) {
        }
        return index2;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index2 = strSymbols.length;
        while (index2-- && baseIndexOf2(chrSymbols, strSymbols[index2], 0) > -1) {
        }
        return index2;
      }
      function countHolders(array, placeholder) {
        var length = array.length, result = 0;
        while (length--) {
          if (array[length] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter2 = basePropertyOf2(deburredLetters2);
      var escapeHtmlChar2 = basePropertyOf2(htmlEscapes2);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue2(object, key) {
        return object == null ? undefined$1 : object[key];
      }
      function hasUnicode2(string) {
        return reHasUnicode2.test(string);
      }
      function hasUnicodeWord2(string) {
        return reHasUnicodeWord2.test(string);
      }
      function iteratorToArray(iterator) {
        var data2, result = [];
        while (!(data2 = iterator.next()).done) {
          result.push(data2.value);
        }
        return result;
      }
      function mapToArray2(map) {
        var index2 = -1, result = Array(map.size);
        map.forEach(function(value, key) {
          result[++index2] = [key, value];
        });
        return result;
      }
      function overArg2(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      function replaceHolders(array, placeholder) {
        var index2 = -1, length = array.length, resIndex = 0, result = [];
        while (++index2 < length) {
          var value = array[index2];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index2] = PLACEHOLDER;
            result[resIndex++] = index2;
          }
        }
        return result;
      }
      function setToArray2(set2) {
        var index2 = -1, result = Array(set2.size);
        set2.forEach(function(value) {
          result[++index2] = value;
        });
        return result;
      }
      function setToPairs(set2) {
        var index2 = -1, result = Array(set2.size);
        set2.forEach(function(value) {
          result[++index2] = [value, value];
        });
        return result;
      }
      function strictIndexOf2(array, value, fromIndex) {
        var index2 = fromIndex - 1, length = array.length;
        while (++index2 < length) {
          if (array[index2] === value) {
            return index2;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array, value, fromIndex) {
        var index2 = fromIndex + 1;
        while (index2--) {
          if (array[index2] === value) {
            return index2;
          }
        }
        return index2;
      }
      function stringSize(string) {
        return hasUnicode2(string) ? unicodeSize(string) : asciiSize(string);
      }
      function stringToArray2(string) {
        return hasUnicode2(string) ? unicodeToArray2(string) : asciiToArray2(string);
      }
      function trimmedEndIndex2(string) {
        var index2 = string.length;
        while (index2-- && reWhitespace2.test(string.charAt(index2))) {
        }
        return index2;
      }
      var unescapeHtmlChar = basePropertyOf2(htmlUnescapes);
      function unicodeSize(string) {
        var result = reUnicode2.lastIndex = 0;
        while (reUnicode2.test(string)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray2(string) {
        return string.match(reUnicode2) || [];
      }
      function unicodeWords2(string) {
        return string.match(reUnicodeWord2) || [];
      }
      var runInContext = function runInContext2(context) {
        context = context == null ? root2 : _.defaults(root2.Object(), context, _.pick(root2, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto2 = Array2.prototype, funcProto2 = Function2.prototype, objectProto2 = Object2.prototype;
        var coreJsData2 = context["__core-js_shared__"];
        var funcToString2 = funcProto2.toString;
        var hasOwnProperty2 = objectProto2.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey2 = function() {
          var uid = /[^.]+$/.exec(coreJsData2 && coreJsData2.keys && coreJsData2.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var nativeObjectToString2 = objectProto2.toString;
        var objectCtorString2 = funcToString2.call(Object2);
        var oldDash = root2._;
        var reIsNative2 = RegExp2(
          "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer2 = moduleExports2 ? context.Buffer : undefined$1, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe2 = Buffer2 ? Buffer2.allocUnsafe : undefined$1, getPrototype2 = overArg2(Object2.getPrototypeOf, Object2), objectCreate2 = Object2.create, propertyIsEnumerable2 = objectProto2.propertyIsEnumerable, splice2 = arrayProto2.splice, spreadableSymbol2 = Symbol2 ? Symbol2.isConcatSpreadable : undefined$1, symIterator = Symbol2 ? Symbol2.iterator : undefined$1, symToStringTag2 = Symbol2 ? Symbol2.toStringTag : undefined$1;
        var defineProperty2 = function() {
          try {
            var func = getNative2(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e) {
          }
        }();
        var ctxClearTimeout = context.clearTimeout !== root2.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root2.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root2.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols2 = Object2.getOwnPropertySymbols, nativeIsBuffer2 = Buffer2 ? Buffer2.isBuffer : undefined$1, nativeIsFinite = context.isFinite, nativeJoin = arrayProto2.join, nativeKeys2 = overArg2(Object2.keys, Object2), nativeMax2 = Math2.max, nativeMin2 = Math2.min, nativeNow2 = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto2.reverse;
        var DataView2 = getNative2(context, "DataView"), Map2 = getNative2(context, "Map"), Promise2 = getNative2(context, "Promise"), Set2 = getNative2(context, "Set"), WeakMap2 = getNative2(context, "WeakMap"), nativeCreate2 = getNative2(Object2, "create");
        var metaMap = WeakMap2 && new WeakMap2();
        var realNames = {};
        var dataViewCtorString2 = toSource2(DataView2), mapCtorString2 = toSource2(Map2), promiseCtorString2 = toSource2(Promise2), setCtorString2 = toSource2(Set2), weakMapCtorString2 = toSource2(WeakMap2);
        var symbolProto2 = Symbol2 ? Symbol2.prototype : undefined$1, symbolValueOf2 = symbolProto2 ? symbolProto2.valueOf : undefined$1, symbolToString2 = symbolProto2 ? symbolProto2.toString : undefined$1;
        function lodash2(value) {
          if (isObjectLike2(value) && !isArray2(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty2.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate2 = function() {
          function object() {
          }
          return function(proto) {
            if (!isObject2(proto)) {
              return {};
            }
            if (objectCreate2) {
              return objectCreate2(proto);
            }
            object.prototype = proto;
            var result2 = new object();
            object.prototype = undefined$1;
            return result2;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined$1;
        }
        lodash2.templateSettings = {
          "escape": reEscape,
          "evaluate": reEvaluate,
          "interpolate": reInterpolate,
          "variable": "",
          "imports": {
            "_": lodash2
          }
        };
        lodash2.prototype = baseLodash.prototype;
        lodash2.prototype.constructor = lodash2;
        LodashWrapper.prototype = baseCreate2(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray2(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray2(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray2(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray2(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start2 = view.start, end2 = view.end, length = end2 - start2, index2 = isRight ? end2 : start2 - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin2(length, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length && takeCount == length) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length-- && resIndex < takeCount) {
              index2 += dir;
              var iterIndex = -1, value = array[index2];
              while (++iterIndex < iterLength) {
                var data2 = iteratees[iterIndex], iteratee2 = data2.iteratee, type = data2.type, computed = iteratee2(value);
                if (type == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate2(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash2(entries) {
          var index2 = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index2 < length) {
            var entry = entries[index2];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear2() {
          this.__data__ = nativeCreate2 ? nativeCreate2(null) : {};
          this.size = 0;
        }
        function hashDelete2(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet2(key) {
          var data2 = this.__data__;
          if (nativeCreate2) {
            var result2 = data2[key];
            return result2 === HASH_UNDEFINED2 ? undefined$1 : result2;
          }
          return hasOwnProperty2.call(data2, key) ? data2[key] : undefined$1;
        }
        function hashHas2(key) {
          var data2 = this.__data__;
          return nativeCreate2 ? data2[key] !== undefined$1 : hasOwnProperty2.call(data2, key);
        }
        function hashSet2(key, value) {
          var data2 = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data2[key] = nativeCreate2 && value === undefined$1 ? HASH_UNDEFINED2 : value;
          return this;
        }
        Hash2.prototype.clear = hashClear2;
        Hash2.prototype["delete"] = hashDelete2;
        Hash2.prototype.get = hashGet2;
        Hash2.prototype.has = hashHas2;
        Hash2.prototype.set = hashSet2;
        function ListCache2(entries) {
          var index2 = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index2 < length) {
            var entry = entries[index2];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear2() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete2(key) {
          var data2 = this.__data__, index2 = assocIndexOf2(data2, key);
          if (index2 < 0) {
            return false;
          }
          var lastIndex = data2.length - 1;
          if (index2 == lastIndex) {
            data2.pop();
          } else {
            splice2.call(data2, index2, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet2(key) {
          var data2 = this.__data__, index2 = assocIndexOf2(data2, key);
          return index2 < 0 ? undefined$1 : data2[index2][1];
        }
        function listCacheHas2(key) {
          return assocIndexOf2(this.__data__, key) > -1;
        }
        function listCacheSet2(key, value) {
          var data2 = this.__data__, index2 = assocIndexOf2(data2, key);
          if (index2 < 0) {
            ++this.size;
            data2.push([key, value]);
          } else {
            data2[index2][1] = value;
          }
          return this;
        }
        ListCache2.prototype.clear = listCacheClear2;
        ListCache2.prototype["delete"] = listCacheDelete2;
        ListCache2.prototype.get = listCacheGet2;
        ListCache2.prototype.has = listCacheHas2;
        ListCache2.prototype.set = listCacheSet2;
        function MapCache2(entries) {
          var index2 = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index2 < length) {
            var entry = entries[index2];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear2() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash2(),
            "map": new (Map2 || ListCache2)(),
            "string": new Hash2()
          };
        }
        function mapCacheDelete2(key) {
          var result2 = getMapData2(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet2(key) {
          return getMapData2(this, key).get(key);
        }
        function mapCacheHas2(key) {
          return getMapData2(this, key).has(key);
        }
        function mapCacheSet2(key, value) {
          var data2 = getMapData2(this, key), size2 = data2.size;
          data2.set(key, value);
          this.size += data2.size == size2 ? 0 : 1;
          return this;
        }
        MapCache2.prototype.clear = mapCacheClear2;
        MapCache2.prototype["delete"] = mapCacheDelete2;
        MapCache2.prototype.get = mapCacheGet2;
        MapCache2.prototype.has = mapCacheHas2;
        MapCache2.prototype.set = mapCacheSet2;
        function SetCache2(values2) {
          var index2 = -1, length = values2 == null ? 0 : values2.length;
          this.__data__ = new MapCache2();
          while (++index2 < length) {
            this.add(values2[index2]);
          }
        }
        function setCacheAdd2(value) {
          this.__data__.set(value, HASH_UNDEFINED2);
          return this;
        }
        function setCacheHas2(value) {
          return this.__data__.has(value);
        }
        SetCache2.prototype.add = SetCache2.prototype.push = setCacheAdd2;
        SetCache2.prototype.has = setCacheHas2;
        function Stack2(entries) {
          var data2 = this.__data__ = new ListCache2(entries);
          this.size = data2.size;
        }
        function stackClear2() {
          this.__data__ = new ListCache2();
          this.size = 0;
        }
        function stackDelete2(key) {
          var data2 = this.__data__, result2 = data2["delete"](key);
          this.size = data2.size;
          return result2;
        }
        function stackGet2(key) {
          return this.__data__.get(key);
        }
        function stackHas2(key) {
          return this.__data__.has(key);
        }
        function stackSet2(key, value) {
          var data2 = this.__data__;
          if (data2 instanceof ListCache2) {
            var pairs = data2.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE2 - 1) {
              pairs.push([key, value]);
              this.size = ++data2.size;
              return this;
            }
            data2 = this.__data__ = new MapCache2(pairs);
          }
          data2.set(key, value);
          this.size = data2.size;
          return this;
        }
        Stack2.prototype.clear = stackClear2;
        Stack2.prototype["delete"] = stackDelete2;
        Stack2.prototype.get = stackGet2;
        Stack2.prototype.has = stackHas2;
        Stack2.prototype.set = stackSet2;
        function arrayLikeKeys2(value, inherited) {
          var isArr = isArray2(value), isArg = !isArr && isArguments2(value), isBuff = !isArr && !isArg && isBuffer2(value), isType = !isArr && !isArg && !isBuff && isTypedArray2(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes2(value.length, String2) : [], length = result2.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex2(key, length)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array) {
          var length = array.length;
          return length ? array[baseRandom(0, length - 1)] : undefined$1;
        }
        function arraySampleSize(array, n) {
          return shuffleSelf(copyArray2(array), baseClamp2(n, 0, array.length));
        }
        function arrayShuffle(array) {
          return shuffleSelf(copyArray2(array));
        }
        function assignMergeValue2(object, key, value) {
          if (value !== undefined$1 && !eq2(object[key], value) || value === undefined$1 && !(key in object)) {
            baseAssignValue2(object, key, value);
          }
        }
        function assignValue2(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty2.call(object, key) && eq2(objValue, value)) || value === undefined$1 && !(key in object)) {
            baseAssignValue2(object, key, value);
          }
        }
        function assocIndexOf2(array, key) {
          var length = array.length;
          while (length--) {
            if (eq2(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach2(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign2(object, source) {
          return object && copyObject2(source, keys2(source), object);
        }
        function baseAssignIn2(object, source) {
          return object && copyObject2(source, keysIn2(source), object);
        }
        function baseAssignValue2(object, key, value) {
          if (key == "__proto__" && defineProperty2) {
            defineProperty2(object, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object[key] = value;
          }
        }
        function baseAt(object, paths) {
          var index2 = -1, length = paths.length, result2 = Array2(length), skip = object == null;
          while (++index2 < length) {
            result2[index2] = skip ? undefined$1 : get2(object, paths[index2]);
          }
          return result2;
        }
        function baseClamp2(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined$1) {
              number = number <= upper ? number : upper;
            }
            if (lower !== undefined$1) {
              number = number >= lower ? number : lower;
            }
          }
          return number;
        }
        function baseClone2(value, bitmask, customizer, key, object, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG2, isFlat = bitmask & CLONE_FLAT_FLAG2, isFull = bitmask & CLONE_SYMBOLS_FLAG2;
          if (customizer) {
            result2 = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result2 !== undefined$1) {
            return result2;
          }
          if (!isObject2(value)) {
            return value;
          }
          var isArr = isArray2(value);
          if (isArr) {
            result2 = initCloneArray2(value);
            if (!isDeep) {
              return copyArray2(value, result2);
            }
          } else {
            var tag = getTag2(value), isFunc = tag == funcTag2 || tag == genTag2;
            if (isBuffer2(value)) {
              return cloneBuffer2(value, isDeep);
            }
            if (tag == objectTag2 || tag == argsTag2 || isFunc && !object) {
              result2 = isFlat || isFunc ? {} : initCloneObject2(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn2(value, baseAssignIn2(result2, value)) : copySymbols2(value, baseAssign2(result2, value));
              }
            } else {
              if (!cloneableTags2[tag]) {
                return object ? value : {};
              }
              result2 = initCloneByTag2(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack2());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet2(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone2(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap2(value)) {
            value.forEach(function(subValue, key2) {
              result2.set(key2, baseClone2(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn2 : getAllKeys2 : isFlat ? keysIn2 : keys2;
          var props = isArr ? undefined$1 : keysFunc(value);
          arrayEach2(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue2(result2, key2, baseClone2(subValue, bitmask, customizer, key2, value, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys2(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }
        function baseConformsTo(object, source, props) {
          var length = props.length;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (length--) {
            var key = props[length], predicate = source[key], value = object[key];
            if (value === undefined$1 && !(key in object) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT2);
          }
          return setTimeout2(function() {
            func.apply(undefined$1, args);
          }, wait);
        }
        function baseDifference(array, values2, iteratee2, comparator) {
          var index2 = -1, includes2 = arrayIncludes2, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
          if (!length) {
            return result2;
          }
          if (iteratee2) {
            values2 = arrayMap2(values2, baseUnary2(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith2;
            isCommon = false;
          } else if (values2.length >= LARGE_ARRAY_SIZE2) {
            includes2 = cacheHas2;
            isCommon = false;
            values2 = new SetCache2(values2);
          }
          outer:
            while (++index2 < length) {
              var value = array[index2], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values2[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value);
              } else if (!includes2(values2, computed, comparator)) {
                result2.push(value);
              }
            }
          return result2;
        }
        var baseEach2 = createBaseEach2(baseForOwn2);
        var baseEachRight = createBaseEach2(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach2(collection, function(value, index2, collection2) {
            result2 = !!predicate(value, index2, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array, iteratee2, comparator) {
          var index2 = -1, length = array.length;
          while (++index2 < length) {
            var value = array[index2], current = iteratee2(value);
            if (current != null && (computed === undefined$1 ? current === current && !isSymbol2(current) : comparator(current, computed))) {
              var computed = current, result2 = value;
            }
          }
          return result2;
        }
        function baseFill(array, value, start2, end2) {
          var length = array.length;
          start2 = toInteger2(start2);
          if (start2 < 0) {
            start2 = -start2 > length ? 0 : length + start2;
          }
          end2 = end2 === undefined$1 || end2 > length ? length : toInteger2(end2);
          if (end2 < 0) {
            end2 += length;
          }
          end2 = start2 > end2 ? 0 : toLength(end2);
          while (start2 < end2) {
            array[start2++] = value;
          }
          return array;
        }
        function baseFilter2(collection, predicate) {
          var result2 = [];
          baseEach2(collection, function(value, index2, collection2) {
            if (predicate(value, index2, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        function baseFlatten2(array, depth, predicate, isStrict, result2) {
          var index2 = -1, length = array.length;
          predicate || (predicate = isFlattenable2);
          result2 || (result2 = []);
          while (++index2 < length) {
            var value = array[index2];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten2(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush2(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        var baseFor2 = createBaseFor2();
        var baseForRight = createBaseFor2(true);
        function baseForOwn2(object, iteratee2) {
          return object && baseFor2(object, iteratee2, keys2);
        }
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys2);
        }
        function baseFunctions(object, props) {
          return arrayFilter2(props, function(key) {
            return isFunction2(object[key]);
          });
        }
        function baseGet2(object, path) {
          path = castPath2(path, object);
          var index2 = 0, length = path.length;
          while (object != null && index2 < length) {
            object = object[toKey2(path[index2++])];
          }
          return index2 && index2 == length ? object : undefined$1;
        }
        function baseGetAllKeys2(object, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object);
          return isArray2(object) ? result2 : arrayPush2(result2, symbolsFunc(object));
        }
        function baseGetTag2(value) {
          if (value == null) {
            return value === undefined$1 ? undefinedTag2 : nullTag2;
          }
          return symToStringTag2 && symToStringTag2 in Object2(value) ? getRawTag2(value) : objectToString2(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object, key) {
          return object != null && hasOwnProperty2.call(object, key);
        }
        function baseHasIn2(object, key) {
          return object != null && key in Object2(object);
        }
        function baseInRange(number, start2, end2) {
          return number >= nativeMin2(start2, end2) && number < nativeMax2(start2, end2);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith2 : arrayIncludes2, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee2) {
              array = arrayMap2(array, baseUnary2(iteratee2));
            }
            maxLength = nativeMin2(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache2(othIndex && array) : undefined$1;
          }
          array = arrays[0];
          var index2 = -1, seen2 = caches[0];
          outer:
            while (++index2 < length && result2.length < maxLength) {
              var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen2 ? cacheHas2(seen2, computed) : includes2(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache2 = caches[othIndex];
                  if (!(cache2 ? cacheHas2(cache2, computed) : includes2(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen2) {
                  seen2.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseInverter(object, setter, iteratee2, accumulator) {
          baseForOwn2(object, function(value, key, object2) {
            setter(accumulator, iteratee2(value), key, object2);
          });
          return accumulator;
        }
        function baseInvoke(object, path, args) {
          path = castPath2(path, object);
          object = parent2(object, path);
          var func = object == null ? object : object[toKey2(last2(path))];
          return func == null ? undefined$1 : apply2(func, object, args);
        }
        function baseIsArguments2(value) {
          return isObjectLike2(value) && baseGetTag2(value) == argsTag2;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike2(value) && baseGetTag2(value) == arrayBufferTag2;
        }
        function baseIsDate(value) {
          return isObjectLike2(value) && baseGetTag2(value) == dateTag2;
        }
        function baseIsEqual2(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike2(value) && !isObjectLike2(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep2(value, other, bitmask, customizer, baseIsEqual2, stack);
        }
        function baseIsEqualDeep2(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag2 : getTag2(object), othTag = othIsArr ? arrayTag2 : getTag2(other);
          objTag = objTag == argsTag2 ? objectTag2 : objTag;
          othTag = othTag == argsTag2 ? objectTag2 : othTag;
          var objIsObj = objTag == objectTag2, othIsObj = othTag == objectTag2, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer2(object)) {
            if (!isBuffer2(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack2());
            return objIsArr || isTypedArray2(object) ? equalArrays2(object, other, bitmask, customizer, equalFunc, stack) : equalByTag2(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG2)) {
            var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack2());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack2());
          return equalObjects2(object, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap2(value) {
          return isObjectLike2(value) && getTag2(value) == mapTag2;
        }
        function baseIsMatch2(object, source, matchData, customizer) {
          var index2 = matchData.length, length = index2, noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (index2--) {
            var data2 = matchData[index2];
            if (noCustomizer && data2[2] ? data2[1] !== object[data2[0]] : !(data2[0] in object)) {
              return false;
            }
          }
          while (++index2 < length) {
            data2 = matchData[index2];
            var key = data2[0], objValue = object[key], srcValue = data2[1];
            if (noCustomizer && data2[2]) {
              if (objValue === undefined$1 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack2();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result2 === undefined$1 ? baseIsEqual2(srcValue, objValue, COMPARE_PARTIAL_FLAG2 | COMPARE_UNORDERED_FLAG2, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative2(value) {
          if (!isObject2(value) || isMasked2(value)) {
            return false;
          }
          var pattern = isFunction2(value) ? reIsNative2 : reIsHostCtor2;
          return pattern.test(toSource2(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike2(value) && baseGetTag2(value) == regexpTag2;
        }
        function baseIsSet2(value) {
          return isObjectLike2(value) && getTag2(value) == setTag2;
        }
        function baseIsTypedArray2(value) {
          return isObjectLike2(value) && isLength2(value.length) && !!typedArrayTags2[baseGetTag2(value)];
        }
        function baseIteratee2(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity2;
          }
          if (typeof value == "object") {
            return isArray2(value) ? baseMatchesProperty2(value[0], value[1]) : baseMatches2(value);
          }
          return property2(value);
        }
        function baseKeys2(object) {
          if (!isPrototype2(object)) {
            return nativeKeys2(object);
          }
          var result2 = [];
          for (var key in Object2(object)) {
            if (hasOwnProperty2.call(object, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn2(object) {
          if (!isObject2(object)) {
            return nativeKeysIn2(object);
          }
          var isProto = isPrototype2(object), result2 = [];
          for (var key in object) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap2(collection, iteratee2) {
          var index2 = -1, result2 = isArrayLike2(collection) ? Array2(collection.length) : [];
          baseEach2(collection, function(value, key, collection2) {
            result2[++index2] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        function baseMatches2(source) {
          var matchData = getMatchData2(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable2(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch2(object, source, matchData);
          };
        }
        function baseMatchesProperty2(path, srcValue) {
          if (isKey2(path) && isStrictComparable2(srcValue)) {
            return matchesStrictComparable2(toKey2(path), srcValue);
          }
          return function(object) {
            var objValue = get2(object, path);
            return objValue === undefined$1 && objValue === srcValue ? hasIn2(object, path) : baseIsEqual2(srcValue, objValue, COMPARE_PARTIAL_FLAG2 | COMPARE_UNORDERED_FLAG2);
          };
        }
        function baseMerge2(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor2(source, function(srcValue, key) {
            stack || (stack = new Stack2());
            if (isObject2(srcValue)) {
              baseMergeDeep2(object, source, key, srcIndex, baseMerge2, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet2(object, key), srcValue, key + "", object, source, stack) : undefined$1;
              if (newValue === undefined$1) {
                newValue = srcValue;
              }
              assignMergeValue2(object, key, newValue);
            }
          }, keysIn2);
        }
        function baseMergeDeep2(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet2(object, key), srcValue = safeGet2(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue2(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined$1;
          var isCommon = newValue === undefined$1;
          if (isCommon) {
            var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer2(srcValue), isTyped = !isArr && !isBuff && isTypedArray2(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray2(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject2(objValue)) {
                newValue = copyArray2(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer2(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray2(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject2(srcValue) || isArguments2(srcValue)) {
              newValue = objValue;
              if (isArguments2(objValue)) {
                newValue = toPlainObject2(objValue);
              } else if (!isObject2(objValue) || isFunction2(objValue)) {
                newValue = initCloneObject2(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue2(object, key, newValue);
        }
        function baseNth(array, n) {
          var length = array.length;
          if (!length) {
            return;
          }
          n += n < 0 ? length : 0;
          return isIndex2(n, length) ? array[n] : undefined$1;
        }
        function baseOrderBy2(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap2(iteratees, function(iteratee2) {
              if (isArray2(iteratee2)) {
                return function(value) {
                  return baseGet2(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity2];
          }
          var index2 = -1;
          iteratees = arrayMap2(iteratees, baseUnary2(getIteratee()));
          var result2 = baseMap2(collection, function(value, key, collection2) {
            var criteria = arrayMap2(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { "criteria": criteria, "index": ++index2, "value": value };
          });
          return baseSortBy2(result2, function(object, other) {
            return compareMultiple2(object, other, orders);
          });
        }
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path) {
            return hasIn2(object, path);
          });
        }
        function basePickBy(object, paths, predicate) {
          var index2 = -1, length = paths.length, result2 = {};
          while (++index2 < length) {
            var path = paths[index2], value = baseGet2(object, path);
            if (predicate(value, path)) {
              baseSet2(result2, castPath2(path, object), value);
            }
          }
          return result2;
        }
        function basePropertyDeep2(path) {
          return function(object) {
            return baseGet2(object, path);
          };
        }
        function basePullAll2(array, values2, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith2 : baseIndexOf2, index2 = -1, length = values2.length, seen2 = array;
          if (array === values2) {
            values2 = copyArray2(values2);
          }
          if (iteratee2) {
            seen2 = arrayMap2(array, baseUnary2(iteratee2));
          }
          while (++index2 < length) {
            var fromIndex = 0, value = values2[index2], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf2(seen2, computed, fromIndex, comparator)) > -1) {
              if (seen2 !== array) {
                splice2.call(seen2, fromIndex, 1);
              }
              splice2.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0, lastIndex = length - 1;
          while (length--) {
            var index2 = indexes[length];
            if (length == lastIndex || index2 !== previous) {
              var previous = index2;
              if (isIndex2(index2)) {
                splice2.call(array, index2, 1);
              } else {
                baseUnset2(array, index2);
              }
            }
          }
          return array;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start2, end2, step, fromRight) {
          var index2 = -1, length = nativeMax2(nativeCeil((end2 - start2) / (step || 1)), 0), result2 = Array2(length);
          while (length--) {
            result2[fromRight ? length : ++index2] = start2;
            start2 += step;
          }
          return result2;
        }
        function baseRepeat(string, n) {
          var result2 = "";
          if (!string || n < 1 || n > MAX_SAFE_INTEGER2) {
            return result2;
          }
          do {
            if (n % 2) {
              result2 += string;
            }
            n = nativeFloor(n / 2);
            if (n) {
              string += string;
            }
          } while (n);
          return result2;
        }
        function baseRest2(func, start2) {
          return setToString2(overRest2(func, start2, identity2), func + "");
        }
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        function baseSampleSize(collection, n) {
          var array = values(collection);
          return shuffleSelf(array, baseClamp2(n, 0, array.length));
        }
        function baseSet2(object, path, value, customizer) {
          if (!isObject2(object)) {
            return object;
          }
          path = castPath2(path, object);
          var index2 = -1, length = path.length, lastIndex = length - 1, nested = object;
          while (nested != null && ++index2 < length) {
            var key = toKey2(path[index2]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object;
            }
            if (index2 != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined$1;
              if (newValue === undefined$1) {
                newValue = isObject2(objValue) ? objValue : isIndex2(path[index2 + 1]) ? [] : {};
              }
            }
            assignValue2(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }
        var baseSetData = !metaMap ? identity2 : function(func, data2) {
          metaMap.set(func, data2);
          return func;
        };
        var baseSetToString2 = !defineProperty2 ? identity2 : function(func, string) {
          return defineProperty2(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant2(string),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        function baseSlice2(array, start2, end2) {
          var index2 = -1, length = array.length;
          if (start2 < 0) {
            start2 = -start2 > length ? 0 : length + start2;
          }
          end2 = end2 > length ? length : end2;
          if (end2 < 0) {
            end2 += length;
          }
          length = start2 > end2 ? 0 : end2 - start2 >>> 0;
          start2 >>>= 0;
          var result2 = Array2(length);
          while (++index2 < length) {
            result2[index2] = array[index2 + start2];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach2(collection, function(value, index2, collection2) {
            result2 = predicate(value, index2, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array, value, retHighest) {
          var low = 0, high = array == null ? low : array.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array[mid];
              if (computed !== null && !isSymbol2(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity2, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee2, retHighest) {
          var low = 0, high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol2(value), valIsUndefined = value === undefined$1;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined$1, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol2(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin2(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array, iteratee2) {
          var index2 = -1, length = array.length, resIndex = 0, result2 = [];
          while (++index2 < length) {
            var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
            if (!index2 || !eq2(computed, seen2)) {
              var seen2 = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol2(value)) {
            return NAN2;
          }
          return +value;
        }
        function baseToString2(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray2(value)) {
            return arrayMap2(value, baseToString2) + "";
          }
          if (isSymbol2(value)) {
            return symbolToString2 ? symbolToString2.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY2 ? "-0" : result2;
        }
        function baseUniq2(array, iteratee2, comparator) {
          var index2 = -1, includes2 = arrayIncludes2, length = array.length, isCommon = true, result2 = [], seen2 = result2;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith2;
          } else if (length >= LARGE_ARRAY_SIZE2) {
            var set3 = iteratee2 ? null : createSet2(array);
            if (set3) {
              return setToArray2(set3);
            }
            isCommon = false;
            includes2 = cacheHas2;
            seen2 = new SetCache2();
          } else {
            seen2 = iteratee2 ? [] : result2;
          }
          outer:
            while (++index2 < length) {
              var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen2.length;
                while (seenIndex--) {
                  if (seen2[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen2.push(computed);
                }
                result2.push(value);
              } else if (!includes2(seen2, computed, comparator)) {
                if (seen2 !== result2) {
                  seen2.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseUnset2(object, path) {
          path = castPath2(path, object);
          object = parent2(object, path);
          return object == null || delete object[toKey2(last2(path))];
        }
        function baseUpdate2(object, path, updater, customizer) {
          return baseSet2(object, path, updater(baseGet2(object, path)), customizer);
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length, index2 = fromRight ? length : -1;
          while ((fromRight ? index2-- : ++index2 < length) && predicate(array[index2], index2, array)) {
          }
          return isDrop ? baseSlice2(array, fromRight ? 0 : index2, fromRight ? index2 + 1 : length) : baseSlice2(array, fromRight ? index2 + 1 : 0, fromRight ? length : index2);
        }
        function baseWrapperValue(value, actions) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce2(actions, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush2([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq2(arrays[0]) : [];
          }
          var index2 = -1, result2 = Array2(length);
          while (++index2 < length) {
            var array = arrays[index2], othIndex = -1;
            while (++othIndex < length) {
              if (othIndex != index2) {
                result2[index2] = baseDifference(result2[index2] || array, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq2(baseFlatten2(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values2, assignFunc) {
          var index2 = -1, length = props.length, valsLength = values2.length, result2 = {};
          while (++index2 < length) {
            var value = index2 < valsLength ? values2[index2] : undefined$1;
            assignFunc(result2, props[index2], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject2(value) ? value : [];
        }
        function castFunction2(value) {
          return typeof value == "function" ? value : identity2;
        }
        function castPath2(value, object) {
          if (isArray2(value)) {
            return value;
          }
          return isKey2(value, object) ? [value] : stringToPath2(toString2(value));
        }
        var castRest = baseRest2;
        function castSlice2(array, start2, end2) {
          var length = array.length;
          end2 = end2 === undefined$1 ? length : end2;
          return !start2 && end2 >= length ? array : baseSlice2(array, start2, end2);
        }
        var clearTimeout2 = ctxClearTimeout || function(id) {
          return root2.clearTimeout(id);
        };
        function cloneBuffer2(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length = buffer.length, result2 = allocUnsafe2 ? allocUnsafe2(length) : new buffer.constructor(length);
          buffer.copy(result2);
          return result2;
        }
        function cloneArrayBuffer2(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
          return result2;
        }
        function cloneDataView2(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer2(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp2(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags2.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        function cloneSymbol2(symbol) {
          return symbolValueOf2 ? Object2(symbolValueOf2.call(symbol)) : {};
        }
        function cloneTypedArray2(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer2(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending2(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined$1, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol2(value);
            var othIsDefined = other !== undefined$1, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol2(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple2(object, other, orders) {
          var index2 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
          while (++index2 < length) {
            var result2 = compareAscending2(objCriteria[index2], othCriteria[index2]);
            if (result2) {
              if (index2 >= ordersLength) {
                return result2;
              }
              var order2 = orders[index2];
              return result2 * (order2 == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax2(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax2(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset2 = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset2 + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset2 + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray2(source, array) {
          var index2 = -1, length = source.length;
          array || (array = Array2(length));
          while (++index2 < length) {
            array[index2] = source[index2];
          }
          return array;
        }
        function copyObject2(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index2 = -1, length = props.length;
          while (++index2 < length) {
            var key = props[index2];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined$1;
            if (newValue === undefined$1) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue2(object, key, newValue);
            } else {
              assignValue2(object, key, newValue);
            }
          }
          return object;
        }
        function copySymbols2(source, object) {
          return copyObject2(source, getSymbols2(source), object);
        }
        function copySymbolsIn2(source, object) {
          return copyObject2(source, getSymbolsIn2(source), object);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray2(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner2(assigner) {
          return baseRest2(function(object, sources) {
            var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined$1, guard = length > 2 ? sources[2] : undefined$1;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined$1;
            if (guard && isIterateeCall2(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined$1 : customizer;
              length = 1;
            }
            object = Object2(object);
            while (++index2 < length) {
              var source = sources[index2];
              if (source) {
                assigner(object, source, index2, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach2(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike2(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length = collection.length, index2 = fromRight ? length : -1, iterable = Object2(collection);
            while (fromRight ? index2-- : ++index2 < length) {
              if (iteratee2(iterable[index2], index2, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor2(fromRight) {
          return function(object, iteratee2, keysFunc) {
            var index2 = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index2];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst2(methodName) {
          return function(string) {
            string = toString2(string);
            var strSymbols = hasUnicode2(string) ? stringToArray2(string) : undefined$1;
            var chr = strSymbols ? strSymbols[0] : string.charAt(0);
            var trailing = strSymbols ? castSlice2(strSymbols, 1).join("") : string.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder2(callback) {
          return function(string) {
            return arrayReduce2(words2(deburr2(string).replace(reApos2, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate2(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject2(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index2 = length, placeholder = getHolder(wrapper);
            while (index2--) {
              args[index2] = arguments[index2];
            }
            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length -= holders.length;
            if (length < arity) {
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                undefined$1,
                args,
                holders,
                undefined$1,
                undefined$1,
                arity - length
              );
            }
            var fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
            return apply2(fn, this, args);
          }
          return wrapper;
        }
        function createFind2(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike2(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys2(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index2 = findIndexFunc(collection, predicate, fromIndex);
            return index2 > -1 ? iterable[iteratee2 ? collection[index2] : index2] : undefined$1;
          };
        }
        function createFlow(fromRight) {
          return flatRest2(function(funcs) {
            var length = funcs.length, index2 = length, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index2--) {
              var func = funcs[index2];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT2);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index2 = wrapper ? index2 : length;
            while (++index2 < length) {
              func = funcs[index2];
              var funcName = getFuncName(func), data2 = funcName == "wrapper" ? getData(func) : undefined$1;
              if (data2 && isLaziable(data2[0]) && data2[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data2[4].length && data2[9] == 1) {
                wrapper = wrapper[getFuncName(data2[0])].apply(wrapper, data2[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray2(value)) {
                return wrapper.plant(value).value();
              }
              var index3 = 0, result2 = length ? funcs[index3].apply(this, args) : value;
              while (++index3 < length) {
                result2 = funcs[index3].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined$1 : createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index2 = length;
            while (index2--) {
              args[index2] = arguments[index2];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length
              );
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length) {
              args.length = ary2;
            }
            if (this && this !== root2 && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined$1 && other === undefined$1) {
              return defaultValue;
            }
            if (value !== undefined$1) {
              result2 = value;
            }
            if (other !== undefined$1) {
              if (result2 === undefined$1) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString2(value);
                other = baseToString2(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest2(function(iteratees) {
            iteratees = arrayMap2(iteratees, baseUnary2(getIteratee()));
            return baseRest2(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply2(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length, chars) {
          chars = chars === undefined$1 ? " " : baseToString2(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode2(chars) ? castSlice2(stringToArray2(result2), 0, length).join("") : result2.slice(0, length);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply2(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start2, end2, step) {
            if (step && typeof step != "number" && isIterateeCall2(start2, end2, step)) {
              end2 = step = undefined$1;
            }
            start2 = toFinite2(start2);
            if (end2 === undefined$1) {
              end2 = start2;
              start2 = 0;
            } else {
              end2 = toFinite2(end2);
            }
            step = step === undefined$1 ? start2 < end2 ? 1 : -1 : toFinite2(step);
            return baseRange(start2, end2, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber2(value);
              other = toNumber2(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined$1, newHoldersRight = isCurry ? undefined$1 : holders, newPartials = isCurry ? partials : undefined$1, newPartialsRight = isCurry ? undefined$1 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined$1, newData);
          if (isLaziable(func)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number, precision) {
            number = toNumber2(number);
            precision = precision == null ? 0 : nativeMin2(toInteger2(precision), 292);
            if (precision && nativeIsFinite(number)) {
              var pair = (toString2(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString2(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number);
          };
        }
        var createSet2 = !(Set2 && 1 / setToArray2(new Set2([, -0]))[1] == INFINITY2) ? noop2 : function(values2) {
          return new Set2(values2);
        };
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag2(object);
            if (tag == mapTag2) {
              return mapToArray2(object);
            }
            if (tag == setTag2) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT2);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined$1;
          }
          ary2 = ary2 === undefined$1 ? ary2 : nativeMax2(toInteger2(ary2), 0);
          arity = arity === undefined$1 ? arity : toInteger2(arity);
          length -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined$1;
          }
          var data2 = isBindKey ? undefined$1 : getData(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data2) {
            mergeData(newData, data2);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined$1 ? isBindKey ? 0 : func.length : nativeMax2(newData[9] - length, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined$1, newData);
          }
          var setter = data2 ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined$1 || eq2(objValue, objectProto2[key]) && !hasOwnProperty2.call(object, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject2(objValue) && isObject2(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge2(objValue, srcValue, undefined$1, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone2(value) {
          return isPlainObject2(value) ? undefined$1 : value;
        }
        function equalArrays2(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG2, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index2 = -1, result2 = true, seen2 = bitmask & COMPARE_UNORDERED_FLAG2 ? new SetCache2() : undefined$1;
          stack.set(array, other);
          stack.set(other, array);
          while (++index2 < arrLength) {
            var arrValue = array[index2], othValue = other[index2];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
            }
            if (compared !== undefined$1) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen2) {
              if (!arraySome2(other, function(othValue2, othIndex) {
                if (!cacheHas2(seen2, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen2.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array);
          stack["delete"](other);
          return result2;
        }
        function equalByTag2(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag2:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag2:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag2:
            case dateTag2:
            case numberTag2:
              return eq2(+object, +other);
            case errorTag2:
              return object.name == other.name && object.message == other.message;
            case regexpTag2:
            case stringTag2:
              return object == other + "";
            case mapTag2:
              var convert = mapToArray2;
            case setTag2:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG2;
              convert || (convert = setToArray2);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG2;
              stack.set(object, other);
              var result2 = equalArrays2(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object);
              return result2;
            case symbolTag2:
              if (symbolValueOf2) {
                return symbolValueOf2.call(object) == symbolValueOf2.call(other);
              }
          }
          return false;
        }
        function equalObjects2(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG2, objProps = getAllKeys2(object), objLength = objProps.length, othProps = getAllKeys2(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index2 = objLength;
          while (index2--) {
            var key = objProps[index2];
            if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result2 = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index2 < objLength) {
            key = objProps[index2];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === undefined$1 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result2;
        }
        function flatRest2(func) {
          return setToString2(overRest2(func, undefined$1, flatten2), func + "");
        }
        function getAllKeys2(object) {
          return baseGetAllKeys2(object, keys2, getSymbols2);
        }
        function getAllKeysIn2(object) {
          return baseGetAllKeys2(object, keysIn2, getSymbolsIn2);
        }
        var getData = !metaMap ? noop2 : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty2.call(realNames, result2) ? array.length : 0;
          while (length--) {
            var data2 = array[length], otherFunc = data2.func;
            if (otherFunc == null || otherFunc == func) {
              return data2.name;
            }
          }
          return result2;
        }
        function getHolder(func) {
          var object = hasOwnProperty2.call(lodash2, "placeholder") ? lodash2 : func;
          return object.placeholder;
        }
        function getIteratee() {
          var result2 = lodash2.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee2 : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData2(map2, key) {
          var data2 = map2.__data__;
          return isKeyable2(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
        }
        function getMatchData2(object) {
          var result2 = keys2(object), length = result2.length;
          while (length--) {
            var key = result2[length], value = object[key];
            result2[length] = [key, value, isStrictComparable2(value)];
          }
          return result2;
        }
        function getNative2(object, key) {
          var value = getValue2(object, key);
          return baseIsNative2(value) ? value : undefined$1;
        }
        function getRawTag2(value) {
          var isOwn = hasOwnProperty2.call(value, symToStringTag2), tag = value[symToStringTag2];
          try {
            value[symToStringTag2] = undefined$1;
            var unmasked = true;
          } catch (e) {
          }
          var result2 = nativeObjectToString2.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag2] = tag;
            } else {
              delete value[symToStringTag2];
            }
          }
          return result2;
        }
        var getSymbols2 = !nativeGetSymbols2 ? stubArray2 : function(object) {
          if (object == null) {
            return [];
          }
          object = Object2(object);
          return arrayFilter2(nativeGetSymbols2(object), function(symbol) {
            return propertyIsEnumerable2.call(object, symbol);
          });
        };
        var getSymbolsIn2 = !nativeGetSymbols2 ? stubArray2 : function(object) {
          var result2 = [];
          while (object) {
            arrayPush2(result2, getSymbols2(object));
            object = getPrototype2(object);
          }
          return result2;
        };
        var getTag2 = baseGetTag2;
        if (DataView2 && getTag2(new DataView2(new ArrayBuffer(1))) != dataViewTag2 || Map2 && getTag2(new Map2()) != mapTag2 || Promise2 && getTag2(Promise2.resolve()) != promiseTag2 || Set2 && getTag2(new Set2()) != setTag2 || WeakMap2 && getTag2(new WeakMap2()) != weakMapTag2) {
          getTag2 = function(value) {
            var result2 = baseGetTag2(value), Ctor = result2 == objectTag2 ? value.constructor : undefined$1, ctorString = Ctor ? toSource2(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString2:
                  return dataViewTag2;
                case mapCtorString2:
                  return mapTag2;
                case promiseCtorString2:
                  return promiseTag2;
                case setCtorString2:
                  return setTag2;
                case weakMapCtorString2:
                  return weakMapTag2;
              }
            }
            return result2;
          };
        }
        function getView(start2, end2, transforms) {
          var index2 = -1, length = transforms.length;
          while (++index2 < length) {
            var data2 = transforms[index2], size2 = data2.size;
            switch (data2.type) {
              case "drop":
                start2 += size2;
                break;
              case "dropRight":
                end2 -= size2;
                break;
              case "take":
                end2 = nativeMin2(end2, start2 + size2);
                break;
              case "takeRight":
                start2 = nativeMax2(start2, end2 - size2);
                break;
            }
          }
          return { "start": start2, "end": end2 };
        }
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }
        function hasPath2(object, path, hasFunc) {
          path = castPath2(path, object);
          var index2 = -1, length = path.length, result2 = false;
          while (++index2 < length) {
            var key = toKey2(path[index2]);
            if (!(result2 = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result2 || ++index2 != length) {
            return result2;
          }
          length = object == null ? 0 : object.length;
          return !!length && isLength2(length) && isIndex2(key, length) && (isArray2(object) || isArguments2(object));
        }
        function initCloneArray2(array) {
          var length = array.length, result2 = new array.constructor(length);
          if (length && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
            result2.index = array.index;
            result2.input = array.input;
          }
          return result2;
        }
        function initCloneObject2(object) {
          return typeof object.constructor == "function" && !isPrototype2(object) ? baseCreate2(getPrototype2(object)) : {};
        }
        function initCloneByTag2(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag2:
              return cloneArrayBuffer2(object);
            case boolTag2:
            case dateTag2:
              return new Ctor(+object);
            case dataViewTag2:
              return cloneDataView2(object, isDeep);
            case float32Tag2:
            case float64Tag2:
            case int8Tag2:
            case int16Tag2:
            case int32Tag2:
            case uint8Tag2:
            case uint8ClampedTag2:
            case uint16Tag2:
            case uint32Tag2:
              return cloneTypedArray2(object, isDeep);
            case mapTag2:
              return new Ctor();
            case numberTag2:
            case stringTag2:
              return new Ctor(object);
            case regexpTag2:
              return cloneRegExp2(object);
            case setTag2:
              return new Ctor();
            case symbolTag2:
              return cloneSymbol2(object);
          }
        }
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable2(value) {
          return isArray2(value) || isArguments2(value) || !!(spreadableSymbol2 && value && value[spreadableSymbol2]);
        }
        function isIndex2(value, length) {
          var type = typeof value;
          length = length == null ? MAX_SAFE_INTEGER2 : length;
          return !!length && (type == "number" || type != "symbol" && reIsUint2.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        function isIterateeCall2(value, index2, object) {
          if (!isObject2(object)) {
            return false;
          }
          var type = typeof index2;
          if (type == "number" ? isArrayLike2(object) && isIndex2(index2, object.length) : type == "string" && index2 in object) {
            return eq2(object[index2], value);
          }
          return false;
        }
        function isKey2(value, object) {
          if (isArray2(value)) {
            return false;
          }
          var type = typeof value;
          if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol2(value)) {
            return true;
          }
          return reIsPlainProp2.test(value) || !reIsDeepProp2.test(value) || object != null && value in Object2(object);
        }
        function isKeyable2(value) {
          var type = typeof value;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash2[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data2 = getData(other);
          return !!data2 && func === data2[0];
        }
        function isMasked2(func) {
          return !!maskSrcKey2 && maskSrcKey2 in func;
        }
        var isMaskable = coreJsData2 ? isFunction2 : stubFalse2;
        function isPrototype2(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto2;
          return value === proto;
        }
        function isStrictComparable2(value) {
          return value === value && !isObject2(value);
        }
        function matchesStrictComparable2(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined$1 || key in Object2(object));
          };
        }
        function memoizeCapped2(func) {
          var result2 = memoize2(func, function(key) {
            if (cache2.size === MAX_MEMOIZE_SIZE2) {
              cache2.clear();
            }
            return key;
          });
          var cache2 = result2.cache;
          return result2;
        }
        function mergeData(data2, source) {
          var bitmask = data2[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data2[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data2;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data2[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data2[3];
            data2[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data2[4] = partials ? replaceHolders(data2[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data2[5];
            data2[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data2[6] = partials ? replaceHolders(data2[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data2[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data2[8] = data2[8] == null ? source[8] : nativeMin2(data2[8], source[8]);
          }
          if (data2[9] == null) {
            data2[9] = source[9];
          }
          data2[0] = source[0];
          data2[1] = newBitmask;
          return data2;
        }
        function nativeKeysIn2(object) {
          var result2 = [];
          if (object != null) {
            for (var key in Object2(object)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString2(value) {
          return nativeObjectToString2.call(value);
        }
        function overRest2(func, start2, transform2) {
          start2 = nativeMax2(start2 === undefined$1 ? func.length - 1 : start2, 0);
          return function() {
            var args = arguments, index2 = -1, length = nativeMax2(args.length - start2, 0), array = Array2(length);
            while (++index2 < length) {
              array[index2] = args[start2 + index2];
            }
            index2 = -1;
            var otherArgs = Array2(start2 + 1);
            while (++index2 < start2) {
              otherArgs[index2] = args[index2];
            }
            otherArgs[start2] = transform2(array);
            return apply2(func, this, otherArgs);
          };
        }
        function parent2(object, path) {
          return path.length < 2 ? object : baseGet2(object, baseSlice2(path, 0, -1));
        }
        function reorder(array, indexes) {
          var arrLength = array.length, length = nativeMin2(indexes.length, arrLength), oldArray = copyArray2(array);
          while (length--) {
            var index2 = indexes[length];
            array[length] = isIndex2(index2, arrLength) ? oldArray[index2] : undefined$1;
          }
          return array;
        }
        function safeGet2(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object[key];
        }
        var setData = shortOut2(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func, wait) {
          return root2.setTimeout(func, wait);
        };
        var setToString2 = shortOut2(baseSetToString2);
        function setWrapToString(wrapper, reference2, bitmask) {
          var source = reference2 + "";
          return setToString2(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut2(func) {
          var count = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow2(), remaining = HOT_SPAN2 - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT2) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined$1, arguments);
          };
        }
        function shuffleSelf(array, size2) {
          var index2 = -1, length = array.length, lastIndex = length - 1;
          size2 = size2 === undefined$1 ? length : size2;
          while (++index2 < size2) {
            var rand = baseRandom(index2, lastIndex), value = array[rand];
            array[rand] = array[index2];
            array[index2] = value;
          }
          array.length = size2;
          return array;
        }
        var stringToPath2 = memoizeCapped2(function(string) {
          var result2 = [];
          if (string.charCodeAt(0) === 46) {
            result2.push("");
          }
          string.replace(rePropName2, function(match, number, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar2, "$1") : number || match);
          });
          return result2;
        });
        function toKey2(value) {
          if (typeof value == "string" || isSymbol2(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY2 ? "-0" : result2;
        }
        function toSource2(func) {
          if (func != null) {
            try {
              return funcToString2.call(func);
            } catch (e) {
            }
            try {
              return func + "";
            } catch (e) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach2(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes2(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray2(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        function chunk(array, size2, guard) {
          if (guard ? isIterateeCall2(array, size2, guard) : size2 === undefined$1) {
            size2 = 1;
          } else {
            size2 = nativeMax2(toInteger2(size2), 0);
          }
          var length = array == null ? 0 : array.length;
          if (!length || size2 < 1) {
            return [];
          }
          var index2 = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
          while (index2 < length) {
            result2[resIndex++] = baseSlice2(array, index2, index2 += size2);
          }
          return result2;
        }
        function compact(array) {
          var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
          while (++index2 < length) {
            var value = array[index2];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        function concat() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array2(length - 1), array = arguments[0], index2 = length;
          while (index2--) {
            args[index2 - 1] = arguments[index2];
          }
          return arrayPush2(isArray2(array) ? copyArray2(array) : [array], baseFlatten2(args, 1));
        }
        var difference = baseRest2(function(array, values2) {
          return isArrayLikeObject2(array) ? baseDifference(array, baseFlatten2(values2, 1, isArrayLikeObject2, true)) : [];
        });
        var differenceBy = baseRest2(function(array, values2) {
          var iteratee2 = last2(values2);
          if (isArrayLikeObject2(iteratee2)) {
            iteratee2 = undefined$1;
          }
          return isArrayLikeObject2(array) ? baseDifference(array, baseFlatten2(values2, 1, isArrayLikeObject2, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest2(function(array, values2) {
          var comparator = last2(values2);
          if (isArrayLikeObject2(comparator)) {
            comparator = undefined$1;
          }
          return isArrayLikeObject2(array) ? baseDifference(array, baseFlatten2(values2, 1, isArrayLikeObject2, true), undefined$1, comparator) : [];
        });
        function drop(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined$1 ? 1 : toInteger2(n);
          return baseSlice2(array, n < 0 ? 0 : n, length);
        }
        function dropRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined$1 ? 1 : toInteger2(n);
          n = length - n;
          return baseSlice2(array, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }
        function fill(array, value, start2, end2) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (start2 && typeof start2 != "number" && isIterateeCall2(array, value, start2)) {
            start2 = 0;
            end2 = length;
          }
          return baseFill(array, value, start2, end2);
        }
        function findIndex2(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index2 = fromIndex == null ? 0 : toInteger2(fromIndex);
          if (index2 < 0) {
            index2 = nativeMax2(length + index2, 0);
          }
          return baseFindIndex2(array, getIteratee(predicate, 3), index2);
        }
        function findLastIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index2 = length - 1;
          if (fromIndex !== undefined$1) {
            index2 = toInteger2(fromIndex);
            index2 = fromIndex < 0 ? nativeMax2(length + index2, 0) : nativeMin2(index2, length - 1);
          }
          return baseFindIndex2(array, getIteratee(predicate, 3), index2, true);
        }
        function flatten2(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten2(array, 1) : [];
        }
        function flattenDeep(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten2(array, INFINITY2) : [];
        }
        function flattenDepth(array, depth) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined$1 ? 1 : toInteger2(depth);
          return baseFlatten2(array, depth);
        }
        function fromPairs(pairs) {
          var index2 = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
          while (++index2 < length) {
            var pair = pairs[index2];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head(array) {
          return array && array.length ? array[0] : undefined$1;
        }
        function indexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index2 = fromIndex == null ? 0 : toInteger2(fromIndex);
          if (index2 < 0) {
            index2 = nativeMax2(length + index2, 0);
          }
          return baseIndexOf2(array, value, index2);
        }
        function initial(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice2(array, 0, -1) : [];
        }
        var intersection = baseRest2(function(arrays) {
          var mapped = arrayMap2(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest2(function(arrays) {
          var iteratee2 = last2(arrays), mapped = arrayMap2(arrays, castArrayLikeObject);
          if (iteratee2 === last2(mapped)) {
            iteratee2 = undefined$1;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest2(function(arrays) {
          var comparator = last2(arrays), mapped = arrayMap2(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined$1;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined$1, comparator) : [];
        });
        function join(array, separator) {
          return array == null ? "" : nativeJoin.call(array, separator);
        }
        function last2(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined$1;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index2 = length;
          if (fromIndex !== undefined$1) {
            index2 = toInteger2(fromIndex);
            index2 = index2 < 0 ? nativeMax2(length + index2, 0) : nativeMin2(index2, length - 1);
          }
          return value === value ? strictLastIndexOf(array, value, index2) : baseFindIndex2(array, baseIsNaN2, index2, true);
        }
        function nth(array, n) {
          return array && array.length ? baseNth(array, toInteger2(n)) : undefined$1;
        }
        var pull2 = baseRest2(pullAll2);
        function pullAll2(array, values2) {
          return array && array.length && values2 && values2.length ? basePullAll2(array, values2) : array;
        }
        function pullAllBy(array, values2, iteratee2) {
          return array && array.length && values2 && values2.length ? basePullAll2(array, values2, getIteratee(iteratee2, 2)) : array;
        }
        function pullAllWith(array, values2, comparator) {
          return array && array.length && values2 && values2.length ? basePullAll2(array, values2, undefined$1, comparator) : array;
        }
        var pullAt = flatRest2(function(array, indexes) {
          var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
          basePullAt(array, arrayMap2(indexes, function(index2) {
            return isIndex2(index2, length) ? +index2 : index2;
          }).sort(compareAscending2));
          return result2;
        });
        function remove(array, predicate) {
          var result2 = [];
          if (!(array && array.length)) {
            return result2;
          }
          var index2 = -1, indexes = [], length = array.length;
          predicate = getIteratee(predicate, 3);
          while (++index2 < length) {
            var value = array[index2];
            if (predicate(value, index2, array)) {
              result2.push(value);
              indexes.push(index2);
            }
          }
          basePullAt(array, indexes);
          return result2;
        }
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }
        function slice(array, start2, end2) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (end2 && typeof end2 != "number" && isIterateeCall2(array, start2, end2)) {
            start2 = 0;
            end2 = length;
          } else {
            start2 = start2 == null ? 0 : toInteger2(start2);
            end2 = end2 === undefined$1 ? length : toInteger2(end2);
          }
          return baseSlice2(array, start2, end2);
        }
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }
        function sortedIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index2 = baseSortedIndex(array, value);
            if (index2 < length && eq2(array[index2], value)) {
              return index2;
            }
          }
          return -1;
        }
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }
        function sortedLastIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index2 = baseSortedIndex(array, value, true) - 1;
            if (eq2(array[index2], value)) {
              return index2;
            }
          }
          return -1;
        }
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee2) {
          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice2(array, 1, length) : [];
        }
        function take(array, n, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n = guard || n === undefined$1 ? 1 : toInteger2(n);
          return baseSlice2(array, 0, n < 0 ? 0 : n);
        }
        function takeRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined$1 ? 1 : toInteger2(n);
          n = length - n;
          return baseSlice2(array, n < 0 ? 0 : n, length);
        }
        function takeRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        var union = baseRest2(function(arrays) {
          return baseUniq2(baseFlatten2(arrays, 1, isArrayLikeObject2, true));
        });
        var unionBy2 = baseRest2(function(arrays) {
          var iteratee2 = last2(arrays);
          if (isArrayLikeObject2(iteratee2)) {
            iteratee2 = undefined$1;
          }
          return baseUniq2(baseFlatten2(arrays, 1, isArrayLikeObject2, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest2(function(arrays) {
          var comparator = last2(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined$1;
          return baseUniq2(baseFlatten2(arrays, 1, isArrayLikeObject2, true), undefined$1, comparator);
        });
        function uniq2(array) {
          return array && array.length ? baseUniq2(array) : [];
        }
        function uniqBy(array, iteratee2) {
          return array && array.length ? baseUniq2(array, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined$1;
          return array && array.length ? baseUniq2(array, undefined$1, comparator) : [];
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length = 0;
          array = arrayFilter2(array, function(group) {
            if (isArrayLikeObject2(group)) {
              length = nativeMax2(group.length, length);
              return true;
            }
          });
          return baseTimes2(length, function(index2) {
            return arrayMap2(array, baseProperty2(index2));
          });
        }
        function unzipWith(array, iteratee2) {
          if (!(array && array.length)) {
            return [];
          }
          var result2 = unzip(array);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap2(result2, function(group) {
            return apply2(iteratee2, undefined$1, group);
          });
        }
        var without = baseRest2(function(array, values2) {
          return isArrayLikeObject2(array) ? baseDifference(array, values2) : [];
        });
        var xor = baseRest2(function(arrays) {
          return baseXor(arrayFilter2(arrays, isArrayLikeObject2));
        });
        var xorBy = baseRest2(function(arrays) {
          var iteratee2 = last2(arrays);
          if (isArrayLikeObject2(iteratee2)) {
            iteratee2 = undefined$1;
          }
          return baseXor(arrayFilter2(arrays, isArrayLikeObject2), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest2(function(arrays) {
          var comparator = last2(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined$1;
          return baseXor(arrayFilter2(arrays, isArrayLikeObject2), undefined$1, comparator);
        });
        var zip = baseRest2(unzip);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue2);
        }
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet2);
        }
        var zipWith = baseRest2(function(arrays) {
          var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined$1;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined$1;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash2(value);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest2(function(paths) {
          var length = paths.length, start2 = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
            return baseAt(object, paths);
          };
          if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex2(start2)) {
            return this.thru(interceptor);
          }
          value = value.slice(start2, +start2 + (length ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined$1
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length && !array.length) {
              array.push(undefined$1);
            }
            return array;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined$1) {
            this.__values__ = toArray2(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined$1 : this.__values__[this.__index__++];
          return { "done": done, "value": value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result2, parent3 = this;
          while (parent3 instanceof baseLodash) {
            var clone2 = wrapperClone(parent3);
            clone2.__index__ = 0;
            clone2.__values__ = undefined$1;
            if (result2) {
              previous.__wrapped__ = clone2;
            } else {
              result2 = clone2;
            }
            var previous = clone2;
            parent3 = parent3.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse],
              "thisArg": undefined$1
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty2.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue2(result2, key, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func = isArray2(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall2(collection, predicate, guard)) {
            predicate = undefined$1;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter2(collection, predicate) {
          var func = isArray2(collection) ? arrayFilter2 : baseFilter2;
          return func(collection, getIteratee(predicate, 3));
        }
        var find2 = createFind2(findIndex2);
        var findLast = createFind2(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten2(map(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten2(map(collection, iteratee2), INFINITY2);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined$1 ? 1 : toInteger2(depth);
          return baseFlatten2(map(collection, iteratee2), depth);
        }
        function forEach2(collection, iteratee2) {
          var func = isArray2(collection) ? arrayEach2 : baseEach2;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray2(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty2.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue2(result2, key, [value]);
          }
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike2(collection) ? collection : values(collection);
          fromIndex = fromIndex && !guard ? toInteger2(fromIndex) : 0;
          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax2(length + fromIndex, 0);
          }
          return isString2(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf2(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest2(function(collection, path, args) {
          var index2 = -1, isFunc = typeof path == "function", result2 = isArrayLike2(collection) ? Array2(collection.length) : [];
          baseEach2(collection, function(value) {
            result2[++index2] = isFunc ? apply2(path, value, args) : baseInvoke(value, path, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value, key) {
          baseAssignValue2(result2, key, value);
        });
        function map(collection, iteratee2) {
          var func = isArray2(collection) ? arrayMap2 : baseMap2;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy2(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray2(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined$1 : orders;
          if (!isArray2(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy2(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result2, value, key) {
          result2[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce(collection, iteratee2, accumulator) {
          var func = isArray2(collection) ? arrayReduce2 : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach2);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray2(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func = isArray2(collection) ? arrayFilter2 : baseFilter2;
          return func(collection, negate(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func = isArray2(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n, guard) {
          if (guard ? isIterateeCall2(collection, n, guard) : n === undefined$1) {
            n = 1;
          } else {
            n = toInteger2(n);
          }
          var func = isArray2(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n);
        }
        function shuffle(collection) {
          var func = isArray2(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike2(collection)) {
            return isString2(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag2(collection);
          if (tag == mapTag2 || tag == setTag2) {
            return collection.size;
          }
          return baseKeys2(collection).length;
        }
        function some(collection, predicate, guard) {
          var func = isArray2(collection) ? arraySome2 : baseSome;
          if (guard && isIterateeCall2(collection, predicate, guard)) {
            predicate = undefined$1;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest2(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall2(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall2(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy2(collection, baseFlatten2(iteratees, 1), []);
        });
        var now2 = ctxNow || function() {
          return root2.Date.now();
        };
        function after(n, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT2);
          }
          n = toInteger2(n);
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n, guard) {
          n = guard ? undefined$1 : n;
          n = func && n == null ? func.length : n;
          return createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n);
        }
        function before(n, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT2);
          }
          n = toInteger2(n);
          return function() {
            if (--n > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined$1;
            }
            return result2;
          };
        }
        var bind2 = baseRest2(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind2));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest2(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined$1 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined$1 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce2(func, wait, options2) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT2);
          }
          wait = toNumber2(wait) || 0;
          if (isObject2(options2)) {
            leading = !!options2.leading;
            maxing = "maxWait" in options2;
            maxWait = maxing ? nativeMax2(toNumber2(options2.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options2 ? !!options2.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined$1;
            lastInvokeTime = time;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin2(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined$1 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now2();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined$1;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined$1;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined$1) {
              clearTimeout2(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined$1;
          }
          function flush() {
            return timerId === undefined$1 ? result2 : trailingEdge(now2());
          }
          function debounced() {
            var time = now2(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined$1) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout2(timerId);
                timerId = setTimeout2(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined$1) {
              timerId = setTimeout2(timerExpired, wait);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var defer = baseRest2(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest2(function(func, wait, args) {
          return baseDelay(func, toNumber2(wait) || 0, args);
        });
        function flip2(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize2(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT2);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
            if (cache2.has(key)) {
              return cache2.get(key);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache2.set(key, result2) || cache2;
            return result2;
          };
          memoized.cache = new (memoize2.Cache || MapCache2)();
          return memoized;
        }
        memoize2.Cache = MapCache2;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT2);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray2(transforms[0]) ? arrayMap2(transforms[0], baseUnary2(getIteratee())) : arrayMap2(baseFlatten2(transforms, 1), baseUnary2(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest2(function(args) {
            var index2 = -1, length = nativeMin2(args.length, funcsLength);
            while (++index2 < length) {
              args[index2] = transforms[index2].call(this, args[index2]);
            }
            return apply2(func, this, args);
          });
        });
        var partial = baseRest2(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
        });
        var partialRight = baseRest2(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
        });
        var rearg = flatRest2(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
        });
        function rest(func, start2) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT2);
          }
          start2 = start2 === undefined$1 ? start2 : toInteger2(start2);
          return baseRest2(func, start2);
        }
        function spread2(func, start2) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT2);
          }
          start2 = start2 == null ? 0 : nativeMax2(toInteger2(start2), 0);
          return baseRest2(function(args) {
            var array = args[start2], otherArgs = castSlice2(args, 0, start2);
            if (array) {
              arrayPush2(otherArgs, array);
            }
            return apply2(func, this, otherArgs);
          });
        }
        function throttle(func, wait, options2) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT2);
          }
          if (isObject2(options2)) {
            leading = "leading" in options2 ? !!options2.leading : leading;
            trailing = "trailing" in options2 ? !!options2.trailing : trailing;
          }
          return debounce2(func, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap(value, wrapper) {
          return partial(castFunction2(wrapper), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray2(value) ? value : [value];
        }
        function clone(value) {
          return baseClone2(value, CLONE_SYMBOLS_FLAG2);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          return baseClone2(value, CLONE_SYMBOLS_FLAG2, customizer);
        }
        function cloneDeep2(value) {
          return baseClone2(value, CLONE_DEEP_FLAG2 | CLONE_SYMBOLS_FLAG2);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          return baseClone2(value, CLONE_DEEP_FLAG2 | CLONE_SYMBOLS_FLAG2, customizer);
        }
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys2(source));
        }
        function eq2(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments2 = baseIsArguments2(function() {
          return arguments;
        }()) ? baseIsArguments2 : function(value) {
          return isObjectLike2(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable2.call(value, "callee");
        };
        var isArray2 = Array2.isArray;
        var isArrayBuffer2 = nodeIsArrayBuffer ? baseUnary2(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike2(value) {
          return value != null && isLength2(value.length) && !isFunction2(value);
        }
        function isArrayLikeObject2(value) {
          return isObjectLike2(value) && isArrayLike2(value);
        }
        function isBoolean(value) {
          return value === true || value === false || isObjectLike2(value) && baseGetTag2(value) == boolTag2;
        }
        var isBuffer2 = nativeIsBuffer2 || stubFalse2;
        var isDate2 = nodeIsDate ? baseUnary2(nodeIsDate) : baseIsDate;
        function isElement2(value) {
          return isObjectLike2(value) && value.nodeType === 1 && !isPlainObject2(value);
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike2(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer2(value) || isTypedArray2(value) || isArguments2(value))) {
            return !value.length;
          }
          var tag = getTag2(value);
          if (tag == mapTag2 || tag == setTag2) {
            return !value.size;
          }
          if (isPrototype2(value)) {
            return !baseKeys2(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty2.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual2(value, other) {
          return baseIsEqual2(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          var result2 = customizer ? customizer(value, other) : undefined$1;
          return result2 === undefined$1 ? baseIsEqual2(value, other, undefined$1, customizer) : !!result2;
        }
        function isError(value) {
          if (!isObjectLike2(value)) {
            return false;
          }
          var tag = baseGetTag2(value);
          return tag == errorTag2 || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject2(value);
        }
        function isFinite(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction2(value) {
          if (!isObject2(value)) {
            return false;
          }
          var tag = baseGetTag2(value);
          return tag == funcTag2 || tag == genTag2 || tag == asyncTag2 || tag == proxyTag2;
        }
        function isInteger(value) {
          return typeof value == "number" && value == toInteger2(value);
        }
        function isLength2(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
        }
        function isObject2(value) {
          var type = typeof value;
          return value != null && (type == "object" || type == "function");
        }
        function isObjectLike2(value) {
          return value != null && typeof value == "object";
        }
        var isMap2 = nodeIsMap2 ? baseUnary2(nodeIsMap2) : baseIsMap2;
        function isMatch(object, source) {
          return object === source || baseIsMatch2(object, source, getMatchData2(source));
        }
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          return baseIsMatch2(object, source, getMatchData2(source), customizer);
        }
        function isNaN2(value) {
          return isNumber2(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative2(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber2(value) {
          return typeof value == "number" || isObjectLike2(value) && baseGetTag2(value) == numberTag2;
        }
        function isPlainObject2(value) {
          if (!isObjectLike2(value) || baseGetTag2(value) != objectTag2) {
            return false;
          }
          var proto = getPrototype2(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString2.call(Ctor) == objectCtorString2;
        }
        var isRegExp = nodeIsRegExp ? baseUnary2(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER2 && value <= MAX_SAFE_INTEGER2;
        }
        var isSet2 = nodeIsSet2 ? baseUnary2(nodeIsSet2) : baseIsSet2;
        function isString2(value) {
          return typeof value == "string" || !isArray2(value) && isObjectLike2(value) && baseGetTag2(value) == stringTag2;
        }
        function isSymbol2(value) {
          return typeof value == "symbol" || isObjectLike2(value) && baseGetTag2(value) == symbolTag2;
        }
        var isTypedArray2 = nodeIsTypedArray2 ? baseUnary2(nodeIsTypedArray2) : baseIsTypedArray2;
        function isUndefined2(value) {
          return value === undefined$1;
        }
        function isWeakMap(value) {
          return isObjectLike2(value) && getTag2(value) == weakMapTag2;
        }
        function isWeakSet(value) {
          return isObjectLike2(value) && baseGetTag2(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray2(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike2(value)) {
            return isString2(value) ? stringToArray2(value) : copyArray2(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag2(value), func = tag == mapTag2 ? mapToArray2 : tag == setTag2 ? setToArray2 : values;
          return func(value);
        }
        function toFinite2(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber2(value);
          if (value === INFINITY2 || value === -INFINITY2) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER2;
          }
          return value === value ? value : 0;
        }
        function toInteger2(value) {
          var result2 = toFinite2(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp2(toInteger2(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber2(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol2(value)) {
            return NAN2;
          }
          if (isObject2(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject2(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim2(value);
          var isBinary = reIsBinary2.test(value);
          return isBinary || reIsOctal2.test(value) ? freeParseInt2(value.slice(2), isBinary ? 2 : 8) : reIsBadHex2.test(value) ? NAN2 : +value;
        }
        function toPlainObject2(value) {
          return copyObject2(value, keysIn2(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp2(toInteger2(value), -MAX_SAFE_INTEGER2, MAX_SAFE_INTEGER2) : value === 0 ? value : 0;
        }
        function toString2(value) {
          return value == null ? "" : baseToString2(value);
        }
        var assign2 = createAssigner2(function(object, source) {
          if (isPrototype2(source) || isArrayLike2(source)) {
            copyObject2(source, keys2(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty2.call(source, key)) {
              assignValue2(object, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner2(function(object, source) {
          copyObject2(source, keysIn2(source), object);
        });
        var assignInWith = createAssigner2(function(object, source, srcIndex, customizer) {
          copyObject2(source, keysIn2(source), object, customizer);
        });
        var assignWith = createAssigner2(function(object, source, srcIndex, customizer) {
          copyObject2(source, keys2(source), object, customizer);
        });
        var at = flatRest2(baseAt);
        function create(prototype2, properties) {
          var result2 = baseCreate2(prototype2);
          return properties == null ? result2 : baseAssign2(result2, properties);
        }
        var defaults2 = baseRest2(function(object, sources) {
          object = Object2(object);
          var index2 = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined$1;
          if (guard && isIterateeCall2(sources[0], sources[1], guard)) {
            length = 1;
          }
          while (++index2 < length) {
            var source = sources[index2];
            var props = keysIn2(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];
              if (value === undefined$1 || eq2(value, objectProto2[key]) && !hasOwnProperty2.call(object, key)) {
                object[key] = source[key];
              }
            }
          }
          return object;
        });
        var defaultsDeep = baseRest2(function(args) {
          args.push(undefined$1, customDefaultsMerge);
          return apply2(mergeWith2, undefined$1, args);
        });
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn2);
        }
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object, iteratee2) {
          return object == null ? object : baseFor2(object, getIteratee(iteratee2, 3), keysIn2);
        }
        function forInRight(object, iteratee2) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn2);
        }
        function forOwn(object, iteratee2) {
          return object && baseForOwn2(object, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys2(object));
        }
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn2(object));
        }
        function get2(object, path, defaultValue) {
          var result2 = object == null ? undefined$1 : baseGet2(object, path);
          return result2 === undefined$1 ? defaultValue : result2;
        }
        function has(object, path) {
          return object != null && hasPath2(object, path, baseHas);
        }
        function hasIn2(object, path) {
          return object != null && hasPath2(object, path, baseHasIn2);
        }
        var invert = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString2.call(value);
          }
          result2[value] = key;
        }, constant2(identity2));
        var invertBy = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString2.call(value);
          }
          if (hasOwnProperty2.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest2(baseInvoke);
        function keys2(object) {
          return isArrayLike2(object) ? arrayLikeKeys2(object) : baseKeys2(object);
        }
        function keysIn2(object) {
          return isArrayLike2(object) ? arrayLikeKeys2(object, true) : baseKeysIn2(object);
        }
        function mapKeys(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn2(object, function(value, key, object2) {
            baseAssignValue2(result2, iteratee2(value, key, object2), value);
          });
          return result2;
        }
        function mapValues(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn2(object, function(value, key, object2) {
            baseAssignValue2(result2, key, iteratee2(value, key, object2));
          });
          return result2;
        }
        var merge2 = createAssigner2(function(object, source, srcIndex) {
          baseMerge2(object, source, srcIndex);
        });
        var mergeWith2 = createAssigner2(function(object, source, srcIndex, customizer) {
          baseMerge2(object, source, srcIndex, customizer);
        });
        var omit2 = flatRest2(function(object, paths) {
          var result2 = {};
          if (object == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap2(paths, function(path) {
            path = castPath2(path, object);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject2(object, getAllKeysIn2(object), result2);
          if (isDeep) {
            result2 = baseClone2(result2, CLONE_DEEP_FLAG2 | CLONE_FLAT_FLAG2 | CLONE_SYMBOLS_FLAG2, customOmitClone2);
          }
          var length = paths.length;
          while (length--) {
            baseUnset2(result2, paths[length]);
          }
          return result2;
        });
        function omitBy(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)));
        }
        var pick = flatRest2(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap2(getAllKeysIn2(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value, path) {
            return predicate(value, path[0]);
          });
        }
        function result(object, path, defaultValue) {
          path = castPath2(path, object);
          var index2 = -1, length = path.length;
          if (!length) {
            length = 1;
            object = undefined$1;
          }
          while (++index2 < length) {
            var value = object == null ? undefined$1 : object[toKey2(path[index2])];
            if (value === undefined$1) {
              index2 = length;
              value = defaultValue;
            }
            object = isFunction2(value) ? value.call(object) : value;
          }
          return object;
        }
        function set2(object, path, value) {
          return object == null ? object : baseSet2(object, path, value);
        }
        function setWith(object, path, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          return object == null ? object : baseSet2(object, path, value, customizer);
        }
        var toPairs = createToPairs(keys2);
        var toPairsIn = createToPairs(keysIn2);
        function transform(object, iteratee2, accumulator) {
          var isArr = isArray2(object), isArrLike = isArr || isBuffer2(object) || isTypedArray2(object);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject2(object)) {
              accumulator = isFunction2(Ctor) ? baseCreate2(getPrototype2(object)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach2 : baseForOwn2)(object, function(value, index2, object2) {
            return iteratee2(accumulator, value, index2, object2);
          });
          return accumulator;
        }
        function unset2(object, path) {
          return object == null ? true : baseUnset2(object, path);
        }
        function update2(object, path, updater) {
          return object == null ? object : baseUpdate2(object, path, castFunction2(updater));
        }
        function updateWith(object, path, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          return object == null ? object : baseUpdate2(object, path, castFunction2(updater), customizer);
        }
        function values(object) {
          return object == null ? [] : baseValues(object, keys2(object));
        }
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn2(object));
        }
        function clamp2(number, lower, upper) {
          if (upper === undefined$1) {
            upper = lower;
            lower = undefined$1;
          }
          if (upper !== undefined$1) {
            upper = toNumber2(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined$1) {
            lower = toNumber2(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp2(toNumber2(number), lower, upper);
        }
        function inRange(number, start2, end2) {
          start2 = toFinite2(start2);
          if (end2 === undefined$1) {
            end2 = start2;
            start2 = 0;
          } else {
            end2 = toFinite2(end2);
          }
          number = toNumber2(number);
          return baseInRange(number, start2, end2);
        }
        function random(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall2(lower, upper, floating)) {
            upper = floating = undefined$1;
          }
          if (floating === undefined$1) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined$1;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined$1;
            }
          }
          if (lower === undefined$1 && upper === undefined$1) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite2(lower);
            if (upper === undefined$1) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite2(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin2(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase2 = createCompounder2(function(result2, word, index2) {
          word = word.toLowerCase();
          return result2 + (index2 ? capitalize2(word) : word);
        });
        function capitalize2(string) {
          return upperFirst2(toString2(string).toLowerCase());
        }
        function deburr2(string) {
          string = toString2(string);
          return string && string.replace(reLatin2, deburrLetter2).replace(reComboMark2, "");
        }
        function endsWith2(string, target, position) {
          string = toString2(string);
          target = baseToString2(target);
          var length = string.length;
          position = position === undefined$1 ? length : baseClamp2(toInteger2(position), 0, length);
          var end2 = position;
          position -= target.length;
          return position >= 0 && string.slice(position, end2) == target;
        }
        function escape2(string) {
          string = toString2(string);
          return string && reHasUnescapedHtml2.test(string) ? string.replace(reUnescapedHtml2, escapeHtmlChar2) : string;
        }
        function escapeRegExp(string) {
          string = toString2(string);
          return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar2, "\\$&") : string;
        }
        var kebabCase2 = createCompounder2(function(result2, word, index2) {
          return result2 + (index2 ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder2(function(result2, word, index2) {
          return result2 + (index2 ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst2("toLowerCase");
        function pad(string, length, chars) {
          string = toString2(string);
          length = toInteger2(length);
          var strLength = length ? stringSize(string) : 0;
          if (!length || strLength >= length) {
            return string;
          }
          var mid = (length - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string, length, chars) {
          string = toString2(string);
          length = toInteger2(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
        }
        function padStart(string, length, chars) {
          string = toString2(string);
          length = toInteger2(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
        }
        function parseInt2(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString2(string).replace(reTrimStart2, ""), radix || 0);
        }
        function repeat(string, n, guard) {
          if (guard ? isIterateeCall2(string, n, guard) : n === undefined$1) {
            n = 1;
          } else {
            n = toInteger2(n);
          }
          return baseRepeat(toString2(string), n);
        }
        function replace() {
          var args = arguments, string = toString2(args[0]);
          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder2(function(result2, word, index2) {
          return result2 + (index2 ? "_" : "") + word.toLowerCase();
        });
        function split(string, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall2(string, separator, limit)) {
            separator = limit = undefined$1;
          }
          limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString2(string);
          if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
            separator = baseToString2(separator);
            if (!separator && hasUnicode2(string)) {
              return castSlice2(stringToArray2(string), 0, limit);
            }
          }
          return string.split(separator, limit);
        }
        var startCase2 = createCompounder2(function(result2, word, index2) {
          return result2 + (index2 ? " " : "") + upperFirst2(word);
        });
        function startsWith(string, target, position) {
          string = toString2(string);
          position = position == null ? 0 : baseClamp2(toInteger2(position), 0, string.length);
          target = baseToString2(target);
          return string.slice(position, position + target.length) == target;
        }
        function template(string, options2, guard) {
          var settings = lodash2.templateSettings;
          if (guard && isIterateeCall2(string, options2, guard)) {
            options2 = undefined$1;
          }
          string = toString2(string);
          options2 = assignInWith({}, options2, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options2.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys2(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index2 = 0, interpolate = options2.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2(
            (options2.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options2.evaluate || reNoMatch).source + "|$",
            "g"
          );
          var sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options2, "sourceURL") ? (options2.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset2) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index2, offset2).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index2 = offset2 + match.length;
            return match;
          });
          source += "';\n";
          var variable = hasOwnProperty2.call(options2, "variable") && options2.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined$1, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value) {
          return toString2(value).toLowerCase();
        }
        function toUpper(value) {
          return toString2(value).toUpperCase();
        }
        function trim2(string, chars, guard) {
          string = toString2(string);
          if (string && (guard || chars === undefined$1)) {
            return baseTrim2(string);
          }
          if (!string || !(chars = baseToString2(chars))) {
            return string;
          }
          var strSymbols = stringToArray2(string), chrSymbols = stringToArray2(chars), start2 = charsStartIndex(strSymbols, chrSymbols), end2 = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice2(strSymbols, start2, end2).join("");
        }
        function trimEnd(string, chars, guard) {
          string = toString2(string);
          if (string && (guard || chars === undefined$1)) {
            return string.slice(0, trimmedEndIndex2(string) + 1);
          }
          if (!string || !(chars = baseToString2(chars))) {
            return string;
          }
          var strSymbols = stringToArray2(string), end2 = charsEndIndex(strSymbols, stringToArray2(chars)) + 1;
          return castSlice2(strSymbols, 0, end2).join("");
        }
        function trimStart(string, chars, guard) {
          string = toString2(string);
          if (string && (guard || chars === undefined$1)) {
            return string.replace(reTrimStart2, "");
          }
          if (!string || !(chars = baseToString2(chars))) {
            return string;
          }
          var strSymbols = stringToArray2(string), start2 = charsStartIndex(strSymbols, stringToArray2(chars));
          return castSlice2(strSymbols, start2).join("");
        }
        function truncate(string, options2) {
          var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject2(options2)) {
            var separator = "separator" in options2 ? options2.separator : separator;
            length = "length" in options2 ? toInteger2(options2.length) : length;
            omission = "omission" in options2 ? baseToString2(options2.omission) : omission;
          }
          string = toString2(string);
          var strLength = string.length;
          if (hasUnicode2(string)) {
            var strSymbols = stringToArray2(string);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string;
          }
          var end2 = length - stringSize(omission);
          if (end2 < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice2(strSymbols, 0, end2).join("") : string.slice(0, end2);
          if (separator === undefined$1) {
            return result2 + omission;
          }
          if (strSymbols) {
            end2 += result2.length - end2;
          }
          if (isRegExp(separator)) {
            if (string.slice(end2).search(separator)) {
              var match, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString2(reFlags2.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match = separator.exec(substring)) {
                var newEnd = match.index;
              }
              result2 = result2.slice(0, newEnd === undefined$1 ? end2 : newEnd);
            }
          } else if (string.indexOf(baseToString2(separator), end2) != end2) {
            var index2 = result2.lastIndexOf(separator);
            if (index2 > -1) {
              result2 = result2.slice(0, index2);
            }
          }
          return result2 + omission;
        }
        function unescape2(string) {
          string = toString2(string);
          return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        var upperCase = createCompounder2(function(result2, word, index2) {
          return result2 + (index2 ? " " : "") + word.toUpperCase();
        });
        var upperFirst2 = createCaseFirst2("toUpperCase");
        function words2(string, pattern, guard) {
          string = toString2(string);
          pattern = guard ? undefined$1 : pattern;
          if (pattern === undefined$1) {
            return hasUnicodeWord2(string) ? unicodeWords2(string) : asciiWords2(string);
          }
          return string.match(pattern) || [];
        }
        var attempt = baseRest2(function(func, args) {
          try {
            return apply2(func, undefined$1, args);
          } catch (e) {
            return isError(e) ? e : new Error2(e);
          }
        });
        var bindAll = flatRest2(function(object, methodNames) {
          arrayEach2(methodNames, function(key) {
            key = toKey2(key);
            baseAssignValue2(object, key, bind2(object[key], object));
          });
          return object;
        });
        function cond(pairs) {
          var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length ? [] : arrayMap2(pairs, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT2);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest2(function(args) {
            var index2 = -1;
            while (++index2 < length) {
              var pair = pairs[index2];
              if (apply2(pair[0], this, args)) {
                return apply2(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone2(source, CLONE_DEEP_FLAG2));
        }
        function constant2(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity2(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee2(typeof func == "function" ? func : baseClone2(func, CLONE_DEEP_FLAG2));
        }
        function matches2(source) {
          return baseMatches2(baseClone2(source, CLONE_DEEP_FLAG2));
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty2(path, baseClone2(srcValue, CLONE_DEEP_FLAG2));
        }
        var method = baseRest2(function(path, args) {
          return function(object) {
            return baseInvoke(object, path, args);
          };
        });
        var methodOf = baseRest2(function(object, args) {
          return function(path) {
            return baseInvoke(object, path, args);
          };
        });
        function mixin(object, source, options2) {
          var props = keys2(source), methodNames = baseFunctions(source, props);
          if (options2 == null && !(isObject2(source) && (methodNames.length || !props.length))) {
            options2 = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys2(source));
          }
          var chain2 = !(isObject2(options2) && "chain" in options2) || !!options2.chain, isFunc = isFunction2(object);
          arrayEach2(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray2(this.__actions__);
                  actions.push({ "func": func, "args": arguments, "thisArg": object });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object, arrayPush2([this.value()], arguments));
              };
            }
          });
          return object;
        }
        function noConflict() {
          if (root2._ === this) {
            root2._ = oldDash;
          }
          return this;
        }
        function noop2() {
        }
        function nthArg(n) {
          n = toInteger2(n);
          return baseRest2(function(args) {
            return baseNth(args, n);
          });
        }
        var over = createOver(arrayMap2);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome2);
        function property2(path) {
          return isKey2(path) ? baseProperty2(toKey2(path)) : basePropertyDeep2(path);
        }
        function propertyOf(object) {
          return function(path) {
            return object == null ? undefined$1 : baseGet2(object, path);
          };
        }
        var range2 = createRange();
        var rangeRight = createRange(true);
        function stubArray2() {
          return [];
        }
        function stubFalse2() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n, iteratee2) {
          n = toInteger2(n);
          if (n < 1 || n > MAX_SAFE_INTEGER2) {
            return [];
          }
          var index2 = MAX_ARRAY_LENGTH, length = nativeMin2(n, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes2(length, iteratee2);
          while (++index2 < n) {
            iteratee2(index2);
          }
          return result2;
        }
        function toPath(value) {
          if (isArray2(value)) {
            return arrayMap2(value, toKey2);
          }
          return isSymbol2(value) ? [value] : copyArray2(stringToPath2(toString2(value)));
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return toString2(prefix) + id;
        }
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound("floor");
        function max2(array) {
          return array && array.length ? baseExtremum(array, identity2, baseGt) : undefined$1;
        }
        function maxBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined$1;
        }
        function mean(array) {
          return baseMean(array, identity2);
        }
        function meanBy(array, iteratee2) {
          return baseMean(array, getIteratee(iteratee2, 2));
        }
        function min2(array) {
          return array && array.length ? baseExtremum(array, identity2, baseLt) : undefined$1;
        }
        function minBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined$1;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round2 = createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array) {
          return array && array.length ? baseSum(array, identity2) : 0;
        }
        function sumBy(array, iteratee2) {
          return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
        }
        lodash2.after = after;
        lodash2.ary = ary;
        lodash2.assign = assign2;
        lodash2.assignIn = assignIn;
        lodash2.assignInWith = assignInWith;
        lodash2.assignWith = assignWith;
        lodash2.at = at;
        lodash2.before = before;
        lodash2.bind = bind2;
        lodash2.bindAll = bindAll;
        lodash2.bindKey = bindKey;
        lodash2.castArray = castArray;
        lodash2.chain = chain;
        lodash2.chunk = chunk;
        lodash2.compact = compact;
        lodash2.concat = concat;
        lodash2.cond = cond;
        lodash2.conforms = conforms;
        lodash2.constant = constant2;
        lodash2.countBy = countBy;
        lodash2.create = create;
        lodash2.curry = curry;
        lodash2.curryRight = curryRight;
        lodash2.debounce = debounce2;
        lodash2.defaults = defaults2;
        lodash2.defaultsDeep = defaultsDeep;
        lodash2.defer = defer;
        lodash2.delay = delay;
        lodash2.difference = difference;
        lodash2.differenceBy = differenceBy;
        lodash2.differenceWith = differenceWith;
        lodash2.drop = drop;
        lodash2.dropRight = dropRight;
        lodash2.dropRightWhile = dropRightWhile;
        lodash2.dropWhile = dropWhile;
        lodash2.fill = fill;
        lodash2.filter = filter2;
        lodash2.flatMap = flatMap;
        lodash2.flatMapDeep = flatMapDeep;
        lodash2.flatMapDepth = flatMapDepth;
        lodash2.flatten = flatten2;
        lodash2.flattenDeep = flattenDeep;
        lodash2.flattenDepth = flattenDepth;
        lodash2.flip = flip2;
        lodash2.flow = flow;
        lodash2.flowRight = flowRight;
        lodash2.fromPairs = fromPairs;
        lodash2.functions = functions;
        lodash2.functionsIn = functionsIn;
        lodash2.groupBy = groupBy;
        lodash2.initial = initial;
        lodash2.intersection = intersection;
        lodash2.intersectionBy = intersectionBy;
        lodash2.intersectionWith = intersectionWith;
        lodash2.invert = invert;
        lodash2.invertBy = invertBy;
        lodash2.invokeMap = invokeMap;
        lodash2.iteratee = iteratee;
        lodash2.keyBy = keyBy;
        lodash2.keys = keys2;
        lodash2.keysIn = keysIn2;
        lodash2.map = map;
        lodash2.mapKeys = mapKeys;
        lodash2.mapValues = mapValues;
        lodash2.matches = matches2;
        lodash2.matchesProperty = matchesProperty;
        lodash2.memoize = memoize2;
        lodash2.merge = merge2;
        lodash2.mergeWith = mergeWith2;
        lodash2.method = method;
        lodash2.methodOf = methodOf;
        lodash2.mixin = mixin;
        lodash2.negate = negate;
        lodash2.nthArg = nthArg;
        lodash2.omit = omit2;
        lodash2.omitBy = omitBy;
        lodash2.once = once;
        lodash2.orderBy = orderBy2;
        lodash2.over = over;
        lodash2.overArgs = overArgs;
        lodash2.overEvery = overEvery;
        lodash2.overSome = overSome;
        lodash2.partial = partial;
        lodash2.partialRight = partialRight;
        lodash2.partition = partition;
        lodash2.pick = pick;
        lodash2.pickBy = pickBy;
        lodash2.property = property2;
        lodash2.propertyOf = propertyOf;
        lodash2.pull = pull2;
        lodash2.pullAll = pullAll2;
        lodash2.pullAllBy = pullAllBy;
        lodash2.pullAllWith = pullAllWith;
        lodash2.pullAt = pullAt;
        lodash2.range = range2;
        lodash2.rangeRight = rangeRight;
        lodash2.rearg = rearg;
        lodash2.reject = reject;
        lodash2.remove = remove;
        lodash2.rest = rest;
        lodash2.reverse = reverse;
        lodash2.sampleSize = sampleSize;
        lodash2.set = set2;
        lodash2.setWith = setWith;
        lodash2.shuffle = shuffle;
        lodash2.slice = slice;
        lodash2.sortBy = sortBy;
        lodash2.sortedUniq = sortedUniq;
        lodash2.sortedUniqBy = sortedUniqBy;
        lodash2.split = split;
        lodash2.spread = spread2;
        lodash2.tail = tail;
        lodash2.take = take;
        lodash2.takeRight = takeRight;
        lodash2.takeRightWhile = takeRightWhile;
        lodash2.takeWhile = takeWhile;
        lodash2.tap = tap;
        lodash2.throttle = throttle;
        lodash2.thru = thru;
        lodash2.toArray = toArray2;
        lodash2.toPairs = toPairs;
        lodash2.toPairsIn = toPairsIn;
        lodash2.toPath = toPath;
        lodash2.toPlainObject = toPlainObject2;
        lodash2.transform = transform;
        lodash2.unary = unary;
        lodash2.union = union;
        lodash2.unionBy = unionBy2;
        lodash2.unionWith = unionWith;
        lodash2.uniq = uniq2;
        lodash2.uniqBy = uniqBy;
        lodash2.uniqWith = uniqWith;
        lodash2.unset = unset2;
        lodash2.unzip = unzip;
        lodash2.unzipWith = unzipWith;
        lodash2.update = update2;
        lodash2.updateWith = updateWith;
        lodash2.values = values;
        lodash2.valuesIn = valuesIn;
        lodash2.without = without;
        lodash2.words = words2;
        lodash2.wrap = wrap;
        lodash2.xor = xor;
        lodash2.xorBy = xorBy;
        lodash2.xorWith = xorWith;
        lodash2.zip = zip;
        lodash2.zipObject = zipObject;
        lodash2.zipObjectDeep = zipObjectDeep;
        lodash2.zipWith = zipWith;
        lodash2.entries = toPairs;
        lodash2.entriesIn = toPairsIn;
        lodash2.extend = assignIn;
        lodash2.extendWith = assignInWith;
        mixin(lodash2, lodash2);
        lodash2.add = add;
        lodash2.attempt = attempt;
        lodash2.camelCase = camelCase2;
        lodash2.capitalize = capitalize2;
        lodash2.ceil = ceil;
        lodash2.clamp = clamp2;
        lodash2.clone = clone;
        lodash2.cloneDeep = cloneDeep2;
        lodash2.cloneDeepWith = cloneDeepWith;
        lodash2.cloneWith = cloneWith;
        lodash2.conformsTo = conformsTo;
        lodash2.deburr = deburr2;
        lodash2.defaultTo = defaultTo;
        lodash2.divide = divide;
        lodash2.endsWith = endsWith2;
        lodash2.eq = eq2;
        lodash2.escape = escape2;
        lodash2.escapeRegExp = escapeRegExp;
        lodash2.every = every;
        lodash2.find = find2;
        lodash2.findIndex = findIndex2;
        lodash2.findKey = findKey;
        lodash2.findLast = findLast;
        lodash2.findLastIndex = findLastIndex;
        lodash2.findLastKey = findLastKey;
        lodash2.floor = floor;
        lodash2.forEach = forEach2;
        lodash2.forEachRight = forEachRight;
        lodash2.forIn = forIn;
        lodash2.forInRight = forInRight;
        lodash2.forOwn = forOwn;
        lodash2.forOwnRight = forOwnRight;
        lodash2.get = get2;
        lodash2.gt = gt;
        lodash2.gte = gte;
        lodash2.has = has;
        lodash2.hasIn = hasIn2;
        lodash2.head = head;
        lodash2.identity = identity2;
        lodash2.includes = includes;
        lodash2.indexOf = indexOf;
        lodash2.inRange = inRange;
        lodash2.invoke = invoke;
        lodash2.isArguments = isArguments2;
        lodash2.isArray = isArray2;
        lodash2.isArrayBuffer = isArrayBuffer2;
        lodash2.isArrayLike = isArrayLike2;
        lodash2.isArrayLikeObject = isArrayLikeObject2;
        lodash2.isBoolean = isBoolean;
        lodash2.isBuffer = isBuffer2;
        lodash2.isDate = isDate2;
        lodash2.isElement = isElement2;
        lodash2.isEmpty = isEmpty;
        lodash2.isEqual = isEqual2;
        lodash2.isEqualWith = isEqualWith;
        lodash2.isError = isError;
        lodash2.isFinite = isFinite;
        lodash2.isFunction = isFunction2;
        lodash2.isInteger = isInteger;
        lodash2.isLength = isLength2;
        lodash2.isMap = isMap2;
        lodash2.isMatch = isMatch;
        lodash2.isMatchWith = isMatchWith;
        lodash2.isNaN = isNaN2;
        lodash2.isNative = isNative;
        lodash2.isNil = isNil;
        lodash2.isNull = isNull;
        lodash2.isNumber = isNumber2;
        lodash2.isObject = isObject2;
        lodash2.isObjectLike = isObjectLike2;
        lodash2.isPlainObject = isPlainObject2;
        lodash2.isRegExp = isRegExp;
        lodash2.isSafeInteger = isSafeInteger;
        lodash2.isSet = isSet2;
        lodash2.isString = isString2;
        lodash2.isSymbol = isSymbol2;
        lodash2.isTypedArray = isTypedArray2;
        lodash2.isUndefined = isUndefined2;
        lodash2.isWeakMap = isWeakMap;
        lodash2.isWeakSet = isWeakSet;
        lodash2.join = join;
        lodash2.kebabCase = kebabCase2;
        lodash2.last = last2;
        lodash2.lastIndexOf = lastIndexOf;
        lodash2.lowerCase = lowerCase;
        lodash2.lowerFirst = lowerFirst;
        lodash2.lt = lt;
        lodash2.lte = lte;
        lodash2.max = max2;
        lodash2.maxBy = maxBy;
        lodash2.mean = mean;
        lodash2.meanBy = meanBy;
        lodash2.min = min2;
        lodash2.minBy = minBy;
        lodash2.stubArray = stubArray2;
        lodash2.stubFalse = stubFalse2;
        lodash2.stubObject = stubObject;
        lodash2.stubString = stubString;
        lodash2.stubTrue = stubTrue;
        lodash2.multiply = multiply;
        lodash2.nth = nth;
        lodash2.noConflict = noConflict;
        lodash2.noop = noop2;
        lodash2.now = now2;
        lodash2.pad = pad;
        lodash2.padEnd = padEnd;
        lodash2.padStart = padStart;
        lodash2.parseInt = parseInt2;
        lodash2.random = random;
        lodash2.reduce = reduce;
        lodash2.reduceRight = reduceRight;
        lodash2.repeat = repeat;
        lodash2.replace = replace;
        lodash2.result = result;
        lodash2.round = round2;
        lodash2.runInContext = runInContext2;
        lodash2.sample = sample;
        lodash2.size = size;
        lodash2.snakeCase = snakeCase;
        lodash2.some = some;
        lodash2.sortedIndex = sortedIndex;
        lodash2.sortedIndexBy = sortedIndexBy;
        lodash2.sortedIndexOf = sortedIndexOf;
        lodash2.sortedLastIndex = sortedLastIndex;
        lodash2.sortedLastIndexBy = sortedLastIndexBy;
        lodash2.sortedLastIndexOf = sortedLastIndexOf;
        lodash2.startCase = startCase2;
        lodash2.startsWith = startsWith;
        lodash2.subtract = subtract;
        lodash2.sum = sum;
        lodash2.sumBy = sumBy;
        lodash2.template = template;
        lodash2.times = times;
        lodash2.toFinite = toFinite2;
        lodash2.toInteger = toInteger2;
        lodash2.toLength = toLength;
        lodash2.toLower = toLower;
        lodash2.toNumber = toNumber2;
        lodash2.toSafeInteger = toSafeInteger;
        lodash2.toString = toString2;
        lodash2.toUpper = toUpper;
        lodash2.trim = trim2;
        lodash2.trimEnd = trimEnd;
        lodash2.trimStart = trimStart;
        lodash2.truncate = truncate;
        lodash2.unescape = unescape2;
        lodash2.uniqueId = uniqueId;
        lodash2.upperCase = upperCase;
        lodash2.upperFirst = upperFirst2;
        lodash2.each = forEach2;
        lodash2.eachRight = forEachRight;
        lodash2.first = head;
        mixin(lodash2, function() {
          var source = {};
          baseForOwn2(lodash2, function(func, methodName) {
            if (!hasOwnProperty2.call(lodash2.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }(), { "chain": false });
        lodash2.VERSION = VERSION2;
        arrayEach2(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash2[methodName].placeholder = lodash2;
        });
        arrayEach2(["drop", "take"], function(methodName, index2) {
          LazyWrapper.prototype[methodName] = function(n) {
            n = n === undefined$1 ? 1 : nativeMax2(toInteger2(n), 0);
            var result2 = this.__filtered__ && !index2 ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin2(n, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin2(n, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });
        arrayEach2(["filter", "map", "takeWhile"], function(methodName, index2) {
          var type = index2 + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach2(["head", "last"], function(methodName, index2) {
          var takeName = "take" + (index2 ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach2(["initial", "tail"], function(methodName, index2) {
          var dropName = "drop" + (index2 ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity2);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest2(function(path, args) {
          if (typeof path == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start2, end2) {
          start2 = toInteger2(start2);
          var result2 = this;
          if (result2.__filtered__ && (start2 > 0 || end2 < 0)) {
            return new LazyWrapper(result2);
          }
          if (start2 < 0) {
            result2 = result2.takeRight(-start2);
          } else if (start2) {
            result2 = result2.drop(start2);
          }
          if (end2 !== undefined$1) {
            end2 = toInteger2(end2);
            result2 = end2 < 0 ? result2.dropRight(-end2) : result2.take(end2 - start2);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn2(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash2[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash2.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray2(value);
            var interceptor = function(value2) {
              var result3 = lodashFunc.apply(lodash2, arrayPush2([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined$1 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach2(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto2[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash2.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray2(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray2(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn2(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash2[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty2.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined$1
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash2.prototype.at = wrapperAt;
        lodash2.prototype.chain = wrapperChain;
        lodash2.prototype.commit = wrapperCommit;
        lodash2.prototype.next = wrapperNext;
        lodash2.prototype.plant = wrapperPlant;
        lodash2.prototype.reverse = wrapperReverse;
        lodash2.prototype.toJSON = lodash2.prototype.valueOf = lodash2.prototype.value = wrapperValue;
        lodash2.prototype.first = lodash2.prototype.head;
        if (symIterator) {
          lodash2.prototype[symIterator] = wrapperToIterator;
        }
        return lodash2;
      };
      var _ = runInContext();
      if (freeModule2) {
        (freeModule2.exports = _)._ = _;
        freeExports2._ = _;
      } else {
        root2._ = _;
      }
    }).call(commonjsGlobal);
  })(lodash, lodash.exports);
  let items = [];
  class DebouncedHistoryCommand extends HistoryCommand {
    constructor(data2) {
      super(data2);
      if (this.constructor.debounce === null) {
        this.constructor.debounce = lodash.exports.debounce((fn, ...args) => {
          fn(...args);
        }, 800);
      }
    }
    addToHistory(historyItem) {
      items.push(historyItem);
      this.constructor.debounce(this.getHistoryItem, historyItem);
    }
    getHistoryItem(historyItem) {
      const historyStore = useHistoryStore();
      historyItem.initialChange = items[0].data;
      historyStore.addHistoryItem(historyItem);
      items = [];
    }
  }
  __publicField(DebouncedHistoryCommand, "debounce", null);
  const _RenameElement = class extends DebouncedHistoryCommand {
    doCommand() {
      const { elementUID, newName } = this.data;
      const contentStore = useContentStore();
      const element = contentStore.getElement(elementUID);
      if (element) {
        const oldName = element.name;
        element.setName(newName);
        this.addToHistory({
          undo: _RenameElement.undo,
          redo: _RenameElement.redo,
          data: {
            elementUID,
            oldName,
            newName
          },
          title: element.name,
          action: this.getActionName("renamed")
        });
      }
    }
    static undo(historyItem) {
      const { data: data2 = {}, initialChange = {} } = historyItem;
      const { elementUID } = data2;
      const { oldName } = initialChange;
      const contentStore = useContentStore();
      const element = contentStore.getElement(elementUID);
      if (element) {
        element.setName(oldName);
      }
    }
    static redo(historyItem) {
      const { data: data2 = {} } = historyItem;
      const { elementUID, newName } = data2;
      const contentStore = useContentStore();
      const element = contentStore.getElement(elementUID);
      if (element) {
        element.setName(newName);
      }
    }
  };
  let RenameElement = _RenameElement;
  __publicField(RenameElement, "commandID", "editor/elements/rename");
  const _RemoveAllElements = class extends HistoryCommand {
    doCommand() {
      const contentStore = useContentStore();
      const { areaID } = this.data;
      const areaElement = contentStore.getElement(areaID);
      let areaModel = {};
      if (areaElement) {
        areaModel = areaElement == null ? void 0 : areaElement.toJSON();
        contentStore.clearAreaContent(areaID);
        const historyManager = this.getHistory();
        historyManager.addHistoryItem({
          undo: _RemoveAllElements.undo,
          redo: _RemoveAllElements.redo,
          data: {
            areaID,
            areaModel
          },
          title: translate("page_cleared")
        });
      }
    }
    static undo(historyItem) {
      const { areaID, areaModel } = historyItem.data || {};
      const contentStore = useContentStore();
      contentStore.registerArea(
        {
          name: areaID,
          id: areaID
        },
        areaModel.content
      );
    }
    static redo(historyItem) {
      const { areaID, areaModel } = historyItem.data || {};
      const contentStore = useContentStore();
      contentStore.clearAreaContent(areaID);
    }
  };
  let RemoveAllElements = _RemoveAllElements;
  __publicField(RemoveAllElements, "commandID", "editor/elements/remove_all");
  const _SetElementVisibility = class extends HistoryCommand {
    doCommand() {
      const { elementUID, isVisible } = this.data;
      const contentStore = useContentStore();
      const element = contentStore.getElement(elementUID);
      if (element) {
        element.setVisibility(isVisible);
        const historyManager = this.getHistory();
        historyManager.addHistoryItem({
          undo: _SetElementVisibility.undo,
          redo: _SetElementVisibility.redo,
          data: {
            elementUID,
            isVisible
          },
          title: element.name,
          action: isVisible ? this.getActionName("show") : this.getActionName("hide")
        });
      }
    }
    static undo(historyItem) {
      const { elementUID, isVisible } = historyItem.data || {};
      const contentStore = useContentStore();
      const element = contentStore.getElement(elementUID);
      if (element) {
        element.setVisibility(!isVisible);
      }
    }
    static redo(historyItem) {
      const { elementUID, isVisible } = historyItem.data || {};
      const contentStore = useContentStore();
      const element = contentStore.getElement(elementUID);
      if (element) {
        element.setVisibility(isVisible);
      }
    }
  };
  let SetElementVisibility = _SetElementVisibility;
  __publicField(SetElementVisibility, "commandID", "editor/elements/set_visibility");
  const _duplicateElement = class extends HistoryCommand {
    doCommand() {
      const contentStore = useContentStore();
      const { element } = this.data;
      const newElement = contentStore.duplicateElement(element);
      if (newElement) {
        const historyManager = this.getHistory();
        historyManager.addHistoryItem({
          undo: _duplicateElement.undo,
          redo: _duplicateElement.redo,
          data: {
            elementModel: newElement.toJSON(),
            elementUID: element.uid
          },
          title: element.name,
          action: this.getActionName("duplicate")
        });
        return newElement.uid;
      }
      return null;
    }
    static undo(historyItem) {
      const { elementModel } = historyItem.data;
      if (elementModel) {
        const contentStore = useContentStore();
        contentStore.deleteElement(elementModel.uid);
      }
    }
    static redo(historyItem) {
      const { elementUID, elementModel } = historyItem.data;
      const contentStore = useContentStore();
      const element = contentStore.getElement(elementUID);
      if (element) {
        const elementIndex = element.indexInParent;
        contentStore.addElement(elementModel, element.parentUID, elementIndex + 1);
      }
    }
  };
  let duplicateElement = _duplicateElement;
  __publicField(duplicateElement, "commandID", "editor/elements/duplicate");
  const _WrapElement = class extends HistoryCommand {
    doCommand() {
      const { element, wrapperType } = this.data;
      const contentStore = useContentStore();
      const parent2 = element.parent;
      const newElement = contentStore.registerElement(
        {
          element_type: wrapperType
        },
        parent2.uid
      );
      const elementModel = newElement.toJSON();
      newElement.addChild(element);
      parent2.replaceChild(element, newElement);
      if (newElement) {
        const historyManager = this.getHistory();
        historyManager.addHistoryItem({
          undo: _WrapElement.undo,
          redo: _WrapElement.redo,
          data: {
            elementModel,
            wrappedElementUID: element.uid
          },
          title: newElement.name,
          action: this.getActionName("wrapped_with_container")
        });
        return newElement.uid;
      }
      return null;
    }
    static undo(historyItem) {
      const { elementModel, wrappedElementUID } = historyItem.data;
      const contentStore = useContentStore();
      const element = contentStore.getElement(elementModel.uid);
      const wrappedElement = contentStore.getElement(wrappedElementUID);
      if (element && element.parent && wrappedElement) {
        element.parent.replaceChild(element, wrappedElement);
        contentStore.deleteElement(element.uid);
      }
    }
    static redo(historyItem) {
      const { elementModel, wrappedElementUID } = historyItem.data;
      const contentStore = useContentStore();
      const element = contentStore.getElement(wrappedElementUID);
      const parent2 = element == null ? void 0 : element.parent;
      if (element && parent2) {
        const newElement = contentStore.registerElement(elementModel, parent2.uid);
        newElement.addChild(element);
        parent2.replaceChild(element, newElement);
      }
    }
  };
  let WrapElement = _WrapElement;
  __publicField(WrapElement, "commandID", "editor/elements/wrap_element");
  const _CopyElement = class extends HistoryCommand {
    doCommand() {
      const { parent: parent2, copiedElement: copiedElement2, index: index2 } = this.data;
      const newElement = parent2.addChild(regenerateUIDs(copiedElement2), index2);
      if (newElement) {
        const historyManager = this.getHistory();
        historyManager.addHistoryItem({
          undo: _CopyElement.undo,
          redo: _CopyElement.redo,
          data: {
            elementModel: newElement.toJSON(),
            parentUID: parent2.uid,
            index: index2
          },
          title: newElement.name,
          action: this.getActionName("copied")
        });
        return newElement.uid;
      }
      return null;
    }
    static undo(historyItem) {
      const { elementModel } = historyItem.data || {};
      if (elementModel) {
        const contentStore = useContentStore();
        contentStore.deleteElement(elementModel.uid);
      }
    }
    static redo(historyItem) {
      const { elementModel, parentUID, index: index2 } = historyItem.data || {};
      const contentStore = useContentStore();
      contentStore.addElement(elementModel, parentUID, index2);
    }
  };
  let CopyElement = _CopyElement;
  __publicField(CopyElement, "commandID", "editor/elements/copy");
  const _MoveElement = class extends HistoryCommand {
    doCommand() {
      const { element, newParent, index: index2 } = this.data;
      const oldParentUID = element.parentUID;
      const oldIndex = element.indexInParent;
      element.move(newParent, index2);
      const historyManager = this.getHistory();
      historyManager.addHistoryItem({
        undo: _MoveElement.undo,
        redo: _MoveElement.redo,
        data: {
          elementUID: element.uid,
          oldParentUID,
          newParentUID: newParent.uid,
          newIndex: index2,
          oldIndex
        },
        title: element.name,
        action: this.getActionName("moved")
      });
    }
    static undo(historyItem) {
      const { elementUID, oldParentUID, oldIndex } = historyItem.data || {};
      const contentStore = useContentStore();
      const movedElement = contentStore.getElement(elementUID);
      const oldParent = contentStore.getElement(oldParentUID);
      if (movedElement && oldParent) {
        movedElement.move(oldParent, oldIndex);
      }
    }
    static redo(historyItem) {
      const { elementUID, newParentUID, newIndex } = historyItem.data || {};
      const contentStore = useContentStore();
      const movedElement = contentStore.getElement(elementUID);
      const oldParent = contentStore.getElement(newParentUID);
      if (movedElement && oldParent) {
        movedElement.move(oldParent, newIndex);
      }
    }
  };
  let MoveElement = _MoveElement;
  __publicField(MoveElement, "commandID", "editor/elements/move");
  const _PasteElementStyles = class extends HistoryCommand {
    doCommand() {
      const { element, styles } = this.data;
      const oldStyles = JSON.parse(
        JSON.stringify({
          styles: element.options._styles || {},
          custom_css: get(element, "options._advanced_options._custom_css", "")
        })
      );
      if (styles.styles) {
        if (!element.options._styles) {
          element.options._styles = {};
        }
        const elementStyleConfig = element.elementDefinition.style_elements || {};
        const stylesToAdd = {};
        Object.keys(elementStyleConfig).forEach((styleSelector) => {
          if (typeof styles.styles[styleSelector] !== void 0) {
            stylesToAdd[styleSelector] = styles.styles[styleSelector];
          }
        });
        merge$1(element.options._styles || {}, stylesToAdd);
      }
      if (styles.custom_css.length) {
        const existingStyles = get(element, "options._advanced_options._custom_css", "");
        set(element, "options._advanced_options._custom_css", existingStyles + styles.custom_css);
      }
      const historyManager = this.getHistory();
      historyManager.addHistoryItem({
        undo: _PasteElementStyles.undo,
        redo: _PasteElementStyles.redo,
        data: {
          elementUID: element.uid,
          oldStyles,
          newStyles: styles
        },
        title: element.name,
        action: this.getActionName("pasteStyles")
      });
    }
    static undo(historyItem) {
      var _a3, _b;
      const { elementUID, oldStyles } = historyItem.data || {};
      const contentStore = useContentStore();
      const element = contentStore.getElement(elementUID);
      if (element) {
        element.options._styles = JSON.parse(JSON.stringify(oldStyles.styles));
        if (((_b = (_a3 = element.options) == null ? void 0 : _a3._advanced_options) == null ? void 0 : _b._custom_css) && oldStyles.custom_css.length) {
          element.options._advanced_options._custom_css = oldStyles.custom_css;
        }
      }
    }
    static redo(historyItem) {
      const { elementUID, newStyles } = historyItem.data || {};
      const contentStore = useContentStore();
      const element = contentStore.getElement(elementUID);
      if (element) {
        if (newStyles.styles) {
          if (!element.options._styles) {
            element.options._styles = {};
          }
          const elementStyleConfig = element.elementDefinition.style_elements || {};
          const stylesToAdd = {};
          Object.keys(elementStyleConfig).forEach((styleSelector) => {
            if (typeof newStyles.styles[styleSelector] !== void 0) {
              stylesToAdd[styleSelector] = newStyles.styles[styleSelector];
            }
          });
          merge$1(element.options._styles || {}, stylesToAdd);
        }
        if (newStyles.custom_css.length) {
          const existingStyles = get(element, "options._advanced_options._custom_css", "");
          set(element, "options._advanced_options._custom_css", existingStyles + newStyles.custom_css);
        }
      }
    }
  };
  let PasteElementStyles = _PasteElementStyles;
  __publicField(PasteElementStyles, "commandID", "editor/elements/paste-styles");
  const _PasteElementClasses = class extends HistoryCommand {
    doCommand() {
      const { element, classes } = this.data;
      const oldCSSClasses = [...get(element.options, "_styles.wrapper.classes", [])];
      merge$1(element.options, {
        _styles: {
          wrapper: {
            classes
          }
        }
      });
      const historyManager = this.getHistory();
      historyManager.addHistoryItem({
        undo: _PasteElementClasses.undo,
        redo: _PasteElementClasses.redo,
        data: {
          elementUID: element.uid,
          oldCSSClasses,
          newCSSClasses: classes
        },
        title: element.name,
        action: this.getActionName("pasteCSSClasses")
      });
    }
    static undo(historyItem) {
      const { elementUID, oldCSSClasses } = historyItem.data || {};
      const contentStore = useContentStore();
      const element = contentStore.getElement(elementUID);
      if (element) {
        set(element.options, "_styles.wrapper.classes", [...oldCSSClasses]);
      }
    }
    static redo(historyItem) {
      const { elementUID, newCSSClasses } = historyItem.data || {};
      const contentStore = useContentStore();
      const element = contentStore.getElement(elementUID);
      if (element) {
        merge$1(element.options, {
          _styles: {
            wrapper: {
              classes: [...newCSSClasses]
            }
          }
        });
      }
    }
  };
  let PasteElementClasses = _PasteElementClasses;
  __publicField(PasteElementClasses, "commandID", "editor/elements/paste-css-classes");
  const _DiscardElementStyles = class extends HistoryCommand {
    doCommand() {
      const { element } = this.data;
      const oldStyles = JSON.parse(JSON.stringify(element.options._styles || {}));
      delete element.options._styles;
      const historyManager = this.getHistory();
      historyManager.addHistoryItem({
        undo: _DiscardElementStyles.undo,
        redo: _DiscardElementStyles.redo,
        data: {
          elementUID: element.uid,
          oldStyles
        },
        title: element.name,
        action: this.getActionName("discardStyles")
      });
    }
    static undo(historyItem) {
      const { elementUID, oldStyles } = historyItem.data || {};
      const contentStore = useContentStore();
      const element = contentStore.getElement(elementUID);
      if (element) {
        element.options._styles = JSON.parse(JSON.stringify(oldStyles));
      }
    }
    static redo(historyItem) {
      const { elementUID } = historyItem.data || {};
      const contentStore = useContentStore();
      const element = contentStore.getElement(elementUID);
      if (element) {
        delete element.options._styles;
      }
    }
  };
  let DiscardElementStyles = _DiscardElementStyles;
  __publicField(DiscardElementStyles, "commandID", "editor/elements/discard-element-styles");
  const _AddTemplate = class extends HistoryCommand {
    doCommand() {
      const { templateContent } = this.data;
      const UIStore = useUIStore();
      const contentStore = useContentStore();
      const rootElement = contentStore.contentRootElement;
      const { element = rootElement, index: index2 = -1 } = UIStore.libraryInsertConfig;
      const addedElements = element.addChildren(templateContent, index2);
      if (addedElements.length) {
        this.getHistory().addHistoryItem({
          undo: _AddTemplate.undo,
          redo: _AddTemplate.redo,
          data: {
            templateContent,
            elementUID: element.uid,
            index: index2,
            addedElementsUIDs: addedElements.map((el) => el.uid)
          },
          title: translate("template"),
          action: translate("added")
        });
      }
    }
    static undo(historyItem) {
      const { addedElementsUIDs = [] } = historyItem.data || {};
      if (addedElementsUIDs.length) {
        const contentStore = useContentStore();
        addedElementsUIDs.forEach((elementUID) => {
          contentStore.deleteElement(elementUID);
        });
      }
    }
    static redo(historyItem) {
      const { templateContent, elementUID, index: index2 } = historyItem.data || {};
      const contentStore = useContentStore();
      const element = contentStore.getElement(elementUID);
      element.addChildren(templateContent, index2);
    }
  };
  let AddTemplate = _AddTemplate;
  __publicField(AddTemplate, "commandID", "editor/elements/add-template");
  const _AddElements = class extends HistoryCommand {
    doCommand() {
      const { elements, elementUID, index: index2 } = this.data;
      const contentStore = useContentStore();
      const element = contentStore.getElement(elementUID);
      const elementsForInsert = regenerateUIDsForContent(elements);
      if (!element) {
        console.log(`Element with id ${elementUID} not found. Cannot add elements`);
        return;
      }
      const addedElements = element.addChildren(elements, index2);
      if (addedElements.length) {
        this.getHistory().addHistoryItem({
          undo: _AddElements.undo,
          redo: _AddElements.redo,
          data: {
            elements: elementsForInsert,
            elementUID,
            index: index2,
            addedElementsUIDs: addedElements.map((el) => el.uid)
          },
          title: translate("layout"),
          action: translate("added")
        });
      }
    }
    static undo(historyItem) {
      const { addedElementsUIDs = [] } = historyItem.data || {};
      if (addedElementsUIDs.length) {
        const contentStore = useContentStore();
        addedElementsUIDs.forEach((elementUID) => {
          contentStore.deleteElement(elementUID);
        });
      }
    }
    static redo(historyItem) {
      const { elements, elementUID, index: index2 } = historyItem.data || {};
      const contentStore = useContentStore();
      const element = contentStore.getElement(elementUID);
      element.addChildren(elements, index2);
    }
  };
  let AddElements = _AddElements;
  __publicField(AddElements, "commandID", "editor/elements/add-elements");
  const _UpdateElementOptions = class extends DebouncedHistoryCommand {
    doCommand() {
      const {
        elementUID,
        newValues,
        path = null
      } = this.data;
      const contentStore = useContentStore();
      const element = contentStore.getElement(elementUID);
      if (element) {
        const oldValues = JSON.parse(JSON.stringify(element.options));
        element.updateOptionValue(path, newValues);
        this.addToHistory({
          undo: _UpdateElementOptions.undo,
          redo: _UpdateElementOptions.redo,
          data: {
            elementUID,
            newValues: JSON.parse(JSON.stringify(element.options)),
            oldValues,
            path
          },
          title: element.name,
          action: translate("edited")
        });
      }
    }
    static undo(historyItem) {
      const { data: data2 = {}, initialChange = {} } = historyItem;
      const { elementUID } = data2;
      const { oldValues } = initialChange;
      const contentStore = useContentStore();
      const element = contentStore.getElement(elementUID);
      if (element) {
        element.updateOptionValue(null, oldValues);
      }
    }
    static redo(historyItem) {
      const { elementUID, newValues } = historyItem.data || {};
      const contentStore = useContentStore();
      const element = contentStore.getElement(elementUID);
      if (element) {
        element.updateOptionValue(null, newValues);
      }
    }
  };
  let UpdateElementOptions = _UpdateElementOptions;
  __publicField(UpdateElementOptions, "commandID", "editor/elements/update-element-options");
  var commands = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    AddElement,
    DeleteElement,
    RenameElement,
    RemoveAllElements,
    SetElementVisibility,
    duplicateElement,
    WrapElement,
    CopyElement,
    MoveElement,
    PasteElementStyles,
    PasteElementClasses,
    DiscardElementStyles,
    AddTemplate,
    AddElements,
    UpdateElementOptions
  }, Symbol.toStringTag, { value: "Module" }));
  class HistoryManager {
    constructor() {
      __publicField(this, "state", Vue.ref([]));
      Object.keys(commands).forEach((importId) => {
        const classObject = commands[importId];
        if (classObject.commandID) {
          window.zb.commandsManager.registerCommand(classObject.commandID, classObject);
        }
      });
    }
    addTransaction(transaction) {
      this.state.value.push(transaction);
    }
    undo() {
    }
    redo() {
    }
  }
  const commandsManager = new CommandManager();
  window.zb.commandsManager = commandsManager;
  const history = new HistoryManager();
  const { registerSchema } = useOptionsSchemas();
  registerSchema("pageSettingsSchema", window.ZnPbInitialData.page_settings.schema);
  registerEditorOptions();
  const appInstance = Vue__namespace.createApp(_sfc_main);
  appInstance.use(install$1, window.ZnI18NStrings);
  appInstance.use(install);
  appInstance.use(createPinia());
  const { addSources } = useLibrary();
  addSources(window.ZnPbInitialData.template_sources);
  errorInterceptor(useNotificationsStore());
  appInstance.component("EmptySortablePlaceholder", _sfc_main$16);
  appInstance.component("AddElementIcon", _sfc_main$17);
  appInstance.component("UIElementIcon", UIElementIcon);
  appInstance.component("SortableHelper", SortableHelper);
  appInstance.component("SortablePlaceholder", SortablePlaceholder);
  appInstance.component("SortableContent", _sfc_main$I);
  appInstance.component("RenderValue", RenderValue);
  appInstance.component("ElementIcon", _sfc_main$12);
  appInstance.component("InlineEditor", InlineEditor);
  appInstance.component("ElementWrapper", ElementWrapper);
  appInstance.component("Element", _sfc_main$J);
  appInstance.config.globalProperties.$zb = {
    appInstance,
    urls: window.ZnPbInitialData.urls
  };
  appInstance.provide("$zb", appInstance.config.globalProperties.$zb);
  new HeartBeat();
  window.addEventListener("load", function() {
    const evt = new CustomEvent("zionbuilder/editor/ready");
    window.dispatchEvent(evt);
    appInstance.mount("#znpb-app");
  });
  const elementDefinitionsStore = useElementDefinitionsStore();
  window.zb = window.zb || {};
  window.zb.editor = Object.assign(
    {},
    { appInstance, registerElementComponent: elementDefinitionsStore.registerElementComponent },
    API,
    COMPOSABLES,
    units,
    UTILS,
    STORE,
    COMMON_COMPOSABLES
  );
  window.zb.vue = Vue__namespace;
  window.zb.utils = COMMONUTILS;
  window.zb.commandsManager = commandsManager;
  window.zb.components = COMMON;
  window.zb.run = function(commandName, commandArgs) {
    return commandsManager.runCommand(commandName, commandArgs);
  };
  window.zb.history = history;
})(zb.vue);
